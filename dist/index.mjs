import adaptic$1, { setTokenProvider, getApolloClient } from '@adaptic/backend-legacy';
import { format, sub, set, add, startOfDay, endOfDay, isBefore, differenceInMilliseconds } from 'date-fns';
import { formatInTimeZone, toZonedTime, fromZonedTime } from 'date-fns-tz';
import ms from 'ms';
import require$$0$3, { EventEmitter } from 'events';
import require$$2 from 'https';
import require$$1 from 'http';
import require$$3 from 'net';
import require$$4 from 'tls';
import require$$5 from 'crypto';
import require$$0$2 from 'stream';
import require$$7 from 'url';
import require$$0$1 from 'zlib';
import { clearLine, cursorTo } from 'readline';
import * as fs from 'fs';
import fs__default from 'fs';
import * as path from 'path';
import path__default from 'path';
import require$$4$1 from 'assert';
import require$$1$1 from 'tty';
import require$$1$2 from 'util';
import require$$0$4 from 'os';
import require$$0$5 from 'buffer';

// Keep track of a single instance of Apollo client
let apolloClientInstance = null;
// Track if auth has been configured
let authConfigured = false;
/**
 * Configure the Apollo client authentication with a dynamic token provider.
 * This should be called once during app initialization before making any
 * @adaptic/backend-legacy API calls.
 *
 * The token provider function will be called for each GraphQL request,
 * allowing for dynamic token retrieval (e.g., from session storage, SecretsManager, etc.)
 *
 * @param provider - Function that returns the auth token (sync or async)
 *
 * @example
 * // Configure with an environment variable
 * configureAuth(() => process.env.GRAPHQL_API_KEY || '');
 *
 * @example
 * // Configure with NextAuth session token (async)
 * configureAuth(async () => {
 *   const session = await auth();
 *   return session?.accessToken || '';
 * });
 *
 * @example
 * // Configure with SecretsManager
 * configureAuth(() => {
 *   const secrets = getSecretsManager();
 *   return secrets.getGraphQLConfig().apiKey || '';
 * });
 */
const configureAuth = (provider) => {
    if (authConfigured) {
        console.warn('[adaptic] Auth provider already configured. Calling configureAuth again will reset the client.');
    }
    setTokenProvider(provider);
    authConfigured = true;
    // Reset the cached client so it picks up the new auth on next request
    if (apolloClientInstance) {
        apolloClientInstance = null;
        console.log('[adaptic] Apollo client reset due to auth configuration change');
    }
};
/**
 * Check if Apollo auth has been configured.
 */
const isAuthConfigured = () => {
    return authConfigured;
};
/**
 * Returns a shared Apollo client instance with connection pooling.
 * This should be used for all @adaptic/backend-legacy operations.
 *
 * @returns {Promise<ApolloClientType>} The shared Apollo client instance.
 */
const getSharedApolloClient = async () => {
    if (!apolloClientInstance) {
        try {
            // Initialize the client once and reuse it across requests
            apolloClientInstance = await getApolloClient();
        }
        catch (error) {
            console.error('Error initializing shared Apollo client:', error);
            throw error;
        }
    }
    return apolloClientInstance;
};
/**
 * Fetches the asset overview for a given symbol from the Adaptic backend.
 *
 * @param {string} symbol - The symbol of the asset to fetch.
 * @returns {Promise<AssetOverviewResponse>} - A promise that resolves to the asset overview response.
 */
const fetchAssetOverview = async (symbol) => {
    if (!symbol) {
        return {
            asset: null,
            error: 'Symbol is required',
            success: false,
        };
    }
    try {
        const encodedSymbol = encodeURIComponent(symbol.trim().toUpperCase());
        const res = await fetch(`https://adaptic.ai/api/asset/overview?symbol=${encodedSymbol}`);
        if (!res.ok) {
            const errorData = (await res.json());
            console.error(`Failed to fetch asset data for ${symbol}:`, errorData);
            return {
                asset: null,
                error: errorData.error || `Failed to fetch asset data for ${symbol}`,
                success: false,
            };
        }
        const data = (await res.json());
        if (!data.asset || !data.asset.id) {
            console.error(`Invalid asset data received for ${symbol}:`, data);
            return {
                asset: null,
                error: `Invalid asset data received for ${symbol}`,
                success: false,
            };
        }
        const cleanedAsset = Object.entries(data.asset).reduce((acc, [key, value]) => {
            if (value !== null && value !== '' && value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return {
            asset: {
                ...cleanedAsset,
                symbol: cleanedAsset.symbol || symbol,
            },
            error: null,
            success: true,
        };
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        console.error(`Error fetching asset data for ${symbol}:`, errorMessage);
        return {
            asset: null,
            error: errorMessage,
            success: false,
        };
    }
};

// Utility function for debug logging
// Define the possible log types as a const array for better type inference
/**
 * Debug logging utility that respects environment debug flags.
 * Logs messages to the console based on the specified log level.
 *
 * @param message - The message to log.
 * @param data - Optional data to log alongside the message. This can be any type of data.
 * @param type - Log level. One of: 'info' | 'warn' | 'error' | 'debug' | 'trace'. Defaults to 'info'.
 *
 * @example
 * logIfDebug("User login failed", { userId: 123 }, "error");
 * logIfDebug("Cache miss", undefined, "warn");
 * logIfDebug("Processing request", { requestId: "abc" }, "debug");
 */
const logIfDebug = (message, data, type = 'info') => {
    const debugMode = process.env.LUMIC_DEBUG === 'true' || process.env.lumic_debug === 'true' || false;
    if (!debugMode)
        return;
    const prefix = `[DEBUG][${type.toUpperCase()}]`;
    const formattedData = data !== undefined ? JSON.stringify(data, null, 2) : '';
    switch (type) {
        case 'error':
            console.error(prefix, message, formattedData);
            break;
        case 'warn':
            console.warn(prefix, message, formattedData);
            break;
        case 'debug':
            console.debug(prefix, message, formattedData);
            break;
        case 'trace':
            console.trace(prefix, message, formattedData);
            break;
        case 'info':
        default:
            console.info(prefix, message, formattedData);
    }
};
/**
 * Masks the middle part of an API key, returning only the first 2 and last 2 characters.
 * If the API key is very short (<= 4 characters), it will be returned as is.
 *
 * @param keyValue - The API key to mask.
 * @returns The masked API key.
 *
 * @example
 * maskApiKey("12341239856677"); // Returns "12****77"
 */
function maskApiKey(keyValue) {
    if (keyValue.length <= 4) {
        return keyValue;
    }
    const firstTwo = keyValue.slice(0, 2);
    const lastTwo = keyValue.slice(-2);
    return `${firstTwo}****${lastTwo}`;
}
/**
 * Hides (masks) the value of any query parameter that is "apiKey" (case-insensitive),
 * replacing the middle part with **** and keeping only the first 2 and last 2 characters.
 *
 * @param url - The URL containing the query parameters.
 * @returns The URL with the masked API key.
 *
 * @example
 * hideApiKeyFromurl("https://xxx.com/s/23/fdsa/?apiKey=12341239856677");
 * // Returns "https://xxx.com/s/23/fdsa/?apiKey=12****77"
 */
function hideApiKeyFromurl(url) {
    try {
        const parsedUrl = new URL(url);
        // We iterate over all search params and look for one named 'apikey' (case-insensitive)
        for (const [key, value] of parsedUrl.searchParams.entries()) {
            if (key.toLowerCase() === 'apikey') {
                const masked = maskApiKey(value);
                parsedUrl.searchParams.set(key, masked);
            }
        }
        return parsedUrl.toString();
    }
    catch {
        // If we can't parse it as a valid URL, just return the original string
        return url;
    }
}
/**
 * Extracts meaningful error information from various error types.
 * @param error - The error to analyze.
 * @param response - Optional response object for HTTP errors.
 * @returns Structured error details.
 */
function extractErrorDetails(error, response) {
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
        return { type: 'NETWORK_ERROR', reason: 'Network connectivity issue', status: null };
    }
    if (error.message.includes('HTTP error: 429')) {
        const match = error.message.match(/RATE_LIMIT: 429:(\d+)/);
        const retryAfter = match ? parseInt(match[1]) : undefined;
        return { type: 'RATE_LIMIT', reason: 'Rate limit exceeded', status: 429, retryAfter };
    }
    if (error.message.includes('HTTP error: 401') || error.message.includes('AUTH_ERROR: 401')) {
        return { type: 'AUTH_ERROR', reason: 'Authentication failed - invalid API key', status: 401 };
    }
    if (error.message.includes('HTTP error: 403') || error.message.includes('AUTH_ERROR: 403')) {
        return { type: 'AUTH_ERROR', reason: 'Access forbidden - insufficient permissions', status: 403 };
    }
    if (error.message.includes('SERVER_ERROR:')) {
        const status = parseInt(error.message.split('SERVER_ERROR: ')[1]) || 500;
        return { type: 'SERVER_ERROR', reason: `Server error (${status})`, status };
    }
    if (error.message.includes('CLIENT_ERROR:')) {
        const status = parseInt(error.message.split('CLIENT_ERROR: ')[1]) || 400;
        return { type: 'CLIENT_ERROR', reason: `Client error (${status})`, status };
    }
    return { type: 'UNKNOWN', reason: error.message || 'Unknown error', status: null };
}
/**
 * Fetches a resource with intelligent retry logic for handling transient errors.
 * Features enhanced error logging, rate limit detection, and adaptive backoff.
 *
 * @param url - The URL to fetch.
 * @param options - Optional fetch options.
 * @param retries - The number of retry attempts. Defaults to 3.
 * @param initialBackoff - The initial backoff time in milliseconds. Defaults to 1000.
 * @returns A promise that resolves to the response.
 *
 * @throws Will throw an error if the fetch fails after the specified number of retries.
 */
async function fetchWithRetry(url, options = {}, retries = 3, initialBackoff = 1000) {
    let backoff = initialBackoff;
    for (let attempt = 1; attempt <= retries; attempt++) {
        try {
            const response = await fetch(url, options);
            if (!response.ok) {
                // Enhanced HTTP error handling with specific error types
                if (response.status === 429) {
                    // Check for Retry-After header
                    const retryAfter = response.headers.get('Retry-After');
                    const retryDelay = retryAfter ? parseInt(retryAfter) * 1000 : null;
                    throw new Error(`RATE_LIMIT: ${response.status}${retryDelay ? `:${retryDelay}` : ''}`);
                }
                if ([500, 502, 503, 504].includes(response.status)) {
                    throw new Error(`SERVER_ERROR: ${response.status}`);
                }
                if ([401, 403].includes(response.status)) {
                    throw new Error(`AUTH_ERROR: ${response.status}`);
                }
                if (response.status >= 400 && response.status < 500) {
                    // Don't retry most 4xx client errors
                    throw new Error(`CLIENT_ERROR: ${response.status}`);
                }
                throw new Error(`HTTP_ERROR: ${response.status}`);
            }
            return response;
        }
        catch (error) {
            if (attempt === retries) {
                throw error;
            }
            // Extract meaningful error information
            const errorDetails = extractErrorDetails(error);
            let adaptiveBackoff = backoff;
            // Adaptive backoff based on error type
            if (errorDetails.type === 'RATE_LIMIT') {
                // Use Retry-After header if available, otherwise use minimum 5s for rate limits
                if (errorDetails.retryAfter) {
                    adaptiveBackoff = errorDetails.retryAfter;
                }
                else {
                    adaptiveBackoff = Math.max(backoff, 5000);
                }
            }
            else if (errorDetails.type === 'AUTH_ERROR') {
                // Don't retry auth errors - fail fast
                console.error(`Authentication error for ${hideApiKeyFromurl(url)}: ${errorDetails.reason}`, {
                    attemptNumber: attempt,
                    errorType: errorDetails.type,
                    httpStatus: errorDetails.status,
                    url: hideApiKeyFromurl(url),
                    source: 'fetchWithRetry',
                    timestamp: new Date().toISOString()
                });
                throw error;
            }
            else if (errorDetails.type === 'CLIENT_ERROR') {
                // Don't retry client errors (except 429 which is handled above)
                console.error(`Client error for ${hideApiKeyFromurl(url)}: ${errorDetails.reason}`, {
                    attemptNumber: attempt,
                    errorType: errorDetails.type,
                    httpStatus: errorDetails.status,
                    url: hideApiKeyFromurl(url),
                    source: 'fetchWithRetry',
                    timestamp: new Date().toISOString()
                });
                throw error;
            }
            // Enhanced error logging with structured data
            console.warn(`Fetch attempt ${attempt} of ${retries} for ${hideApiKeyFromurl(url)} failed: ${errorDetails.reason}. Retrying in ${adaptiveBackoff}ms...`, {
                attemptNumber: attempt,
                totalRetries: retries,
                errorType: errorDetails.type,
                httpStatus: errorDetails.status,
                retryDelay: adaptiveBackoff,
                url: hideApiKeyFromurl(url),
                source: 'fetchWithRetry',
                timestamp: new Date().toISOString()
            });
            await new Promise((resolve) => setTimeout(resolve, adaptiveBackoff));
            backoff = Math.min(backoff * 2, 30000); // Cap at 30 seconds
        }
    }
    throw new Error('Failed to fetch after multiple attempts');
}
/**
 * Validates a Polygon.io API key by making a test request.
 * @param apiKey - The API key to validate.
 * @returns Promise that resolves to true if valid, false otherwise.
 */
async function validatePolygonApiKey(apiKey) {
    try {
        const response = await fetch(`https://api.polygon.io/v1/meta/symbols?apikey=${apiKey}&limit=1`);
        if (response.status === 401) {
            throw new Error('Invalid or expired Polygon.io API key');
        }
        if (response.status === 403) {
            throw new Error('Polygon.io API key lacks required permissions');
        }
        return response.ok;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        console.error('Polygon.io API key validation failed:', errorMessage);
        return false;
    }
}

// alpaca.ts
// functions related to Alpaca accounts
/**
 * Round a price to the nearest 2 decimal places for Alpaca, or 4 decimal places for prices less than $1
 * @param price - The price to round
 * @returns The rounded price
 */
const roundPriceForAlpaca$5 = (price) => {
    return price >= 1
        ? Math.round(price * 100) / 100
        : Math.round(price * 10000) / 10000;
};
async function validateAuth(auth) {
    if (auth.adapticAccountId) {
        // Get shared Apollo client for connection pooling
        const client = await getSharedApolloClient();
        const alpacaAccount = (await adaptic$1.alpacaAccount.get({
            id: auth.adapticAccountId,
        }, client));
        if (!alpacaAccount || !alpacaAccount.APIKey || !alpacaAccount.APISecret) {
            throw new Error('Alpaca account not found or incomplete');
        }
        return {
            APIKey: alpacaAccount.APIKey,
            APISecret: alpacaAccount.APISecret,
            type: alpacaAccount.type,
        };
    }
    else if (auth.alpacaApiKey && auth.alpacaApiSecret) {
        const accountType = auth.type || 'PAPER'; // Default to live if type is not provided
        return {
            APIKey: auth.alpacaApiKey,
            APISecret: auth.alpacaApiSecret,
            type: accountType,
        };
    }
    throw new Error('Either adapticAccountId or both alpacaApiKey and alpacaApiSecret must be provided');
}
/**
 * Creates a new order in Alpaca.
 * @param {AlpacaAuth} auth - The authentication details for Alpaca.
 * @param {CreateOrderParams} params - The parameters for creating the order.
 * @returns {Promise<Order>} The created order.
 */
// Orders API functions
async function createOrder$1(auth, params) {
    try {
        const { APIKey, APISecret, type } = await validateAuth(auth);
        const apiBaseUrl = type === 'PAPER' ? 'https://paper-api.alpaca.markets' : 'https://api.alpaca.markets';
        const response = await fetch(`${apiBaseUrl}/v2/orders`, {
            method: 'POST',
            headers: {
                'APCA-API-KEY-ID': APIKey,
                'APCA-API-SECRET-KEY': APISecret,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(params),
        });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to create order: ${response.status} ${response.statusText} ${errorText}`);
        }
        return (await response.json());
    }
    catch (error) {
        console.error('Error in createOrder:', error);
        throw error;
    }
}
/**
 * Retrieves a list of orders from Alpaca.
 * @param {AlpacaAuth} auth - The authentication details for Alpaca.
 * @param {GetOrdersParams} [params={}] - The parameters for fetching orders.
 * @returns {Promise<AlpacaOrder[]>} The list of orders.
 */
async function getOrders$1(auth, params = {}) {
    try {
        const { APIKey, APISecret, type } = await validateAuth(auth);
        const apiBaseUrl = type === 'PAPER' ? 'https://paper-api.alpaca.markets' : 'https://api.alpaca.markets';
        const allOrders = [];
        let currentUntil = params.until ? params.until : new Date().toISOString();
        const CHUNK_SIZE = 500;
        while (true) {
            const queryParams = new URLSearchParams();
            if (params.status)
                queryParams.append('status', params.status);
            queryParams.append('limit', CHUNK_SIZE.toString());
            if (params.after)
                queryParams.append('after', params.after);
            queryParams.append('until', currentUntil);
            if (params.direction)
                queryParams.append('direction', params.direction);
            if (params.nested)
                queryParams.append('nested', params.nested.toString());
            if (params.symbols)
                queryParams.append('symbols', params.symbols.join(','));
            if (params.side)
                queryParams.append('side', params.side);
            const response = await fetch(`${apiBaseUrl}/v2/orders?${queryParams}`, {
                method: 'GET',
                headers: {
                    'APCA-API-KEY-ID': APIKey,
                    'APCA-API-SECRET-KEY': APISecret,
                },
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Failed to get orders: ${response.status} ${response.statusText} ${errorText}`);
            }
            const orders = (await response.json());
            allOrders.push(...orders);
            if (orders.length < CHUNK_SIZE)
                break;
            const lastOrder = orders[orders.length - 1];
            if (!lastOrder.submitted_at)
                break;
            currentUntil = lastOrder.submitted_at;
            await new Promise((resolve) => setTimeout(resolve, 300));
        }
        return allOrders;
    }
    catch (error) {
        console.error('Error in getOrders:', error);
        throw error;
    }
}
/**
 * Cancels all orders in Alpaca.
 * @param {AlpacaAuth} auth - The authentication details for Alpaca.
 * @returns {Promise<{ id: string; status: number }[]>} The list of canceled orders with their statuses.
 */
async function cancelAllOrders$1(auth) {
    try {
        const { APIKey, APISecret, type } = await validateAuth(auth);
        const apiBaseUrl = type === 'PAPER' ? 'https://paper-api.alpaca.markets' : 'https://api.alpaca.markets';
        const response = await fetch(`${apiBaseUrl}/v2/orders`, {
            method: 'DELETE',
            headers: {
                'APCA-API-KEY-ID': APIKey,
                'APCA-API-SECRET-KEY': APISecret,
            },
        });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to cancel orders: ${response.status} ${response.statusText} ${errorText}`);
        }
        return (await response.json());
    }
    catch (error) {
        console.error('Error in cancelAllOrders:', error);
        throw error;
    }
}
/**
 * Retrieves a specific order from Alpaca.
 * @param {AlpacaAuth} auth - The authentication details for Alpaca.
 * @param {string} orderId - The ID of the order to retrieve.
 * @param {boolean} [nested] - Whether to include nested details.
 * @returns {Promise<Order>} The requested order.
 */
async function getOrder$1(auth, orderId, nested) {
    try {
        const { APIKey, APISecret, type } = await validateAuth(auth);
        const apiBaseUrl = type === 'PAPER' ? 'https://paper-api.alpaca.markets' : 'https://api.alpaca.markets';
        const queryParams = new URLSearchParams();
        if (nested)
            queryParams.append('nested', 'true');
        const response = await fetch(`${apiBaseUrl}/v2/orders/${orderId}?${queryParams}`, {
            method: 'GET',
            headers: {
                'APCA-API-KEY-ID': APIKey,
                'APCA-API-SECRET-KEY': APISecret,
            },
        });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to get order: ${response.status} ${response.statusText} ${errorText}`);
        }
        return (await response.json());
    }
    catch (error) {
        console.error('Error in getOrder:', error);
        throw error;
    }
}
/**
 * Replaces an existing order in Alpaca.
 * @param {AlpacaAuth} auth - The authentication details for Alpaca.
 * @param {string} orderId - The ID of the order to replace.
 * @param {ReplaceOrderParams} params - The parameters for replacing the order.
 * @returns {Promise<Order>} The updated order.
 */
async function replaceOrder$1(auth, orderId, params) {
    try {
        const { APIKey, APISecret, type } = await validateAuth(auth);
        const apiBaseUrl = type === 'PAPER' ? 'https://paper-api.alpaca.markets' : 'https://api.alpaca.markets';
        const response = await fetch(`${apiBaseUrl}/v2/orders/${orderId}`, {
            method: 'PATCH',
            headers: {
                'APCA-API-KEY-ID': APIKey,
                'APCA-API-SECRET-KEY': APISecret,
                'Content-Type': 'application/json',
                accept: 'application/json',
            },
            body: JSON.stringify(params),
        });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to replace order: ${response.status} ${response.statusText} ${errorText}`);
        }
        return (await response.json());
    }
    catch (error) {
        console.error('Error in replaceOrder:', error);
        throw error;
    }
}
/**
 * Cancels a specific order in Alpaca.
 * @param {AlpacaAuth} auth - The authentication details for Alpaca.
 * @param {string} orderId - The ID of the order to cancel.
 * @returns {Promise<{ success: boolean; message?: string }>} - Success status and optional message if order not found.
 */
async function cancelOrder$1(auth, orderId) {
    try {
        const { APIKey, APISecret, type } = await validateAuth(auth);
        const apiBaseUrl = type === 'PAPER' ? 'https://paper-api.alpaca.markets' : 'https://api.alpaca.markets';
        const response = await fetch(`${apiBaseUrl}/v2/orders/${orderId}`, {
            method: 'DELETE',
            headers: {
                'APCA-API-KEY-ID': APIKey,
                'APCA-API-SECRET-KEY': APISecret,
            },
        });
        if (!response.ok) {
            const errorText = await response.text();
            // Special handling for 404 errors
            if (response.status === 404) {
                return { success: false, message: `Order not found: ${orderId}` };
            }
            else {
                throw new Error(`Failed to cancel order: ${response.status} ${response.statusText} ${errorText}`);
            }
        }
        return { success: true };
    }
    catch (error) {
        console.error('Error in cancelOrder:', error);
        throw error;
    }
}
/**
 * Fetches news articles from Alpaca API for specified symbols.
 * @param {string} symbols - The symbols to fetch news for (comma-separated for multiple symbols, e.g. "AAPL,MSFT,GOOG")
 * @param {Object} params - Optional parameters for fetching news
 * @param {AlpacaAuth} params.auth - Optional Alpaca authentication details
 * @param {Date | string} params.start - Start date for fetching news (default is last 24 hours)
 * @param {Date | string} params.end - End date for fetching news (default is now)
 * @param {number} params.limit - Maximum number of articles to return (default is 10)
 * @param {'asc' | 'desc'} params.sort - Sorting order (default is descending)
 * @param {string} params.page_token - Token for pagination
 * @param {boolean} params.include_content - Whether to include content in the news articles (default is true)
 * @returns {Promise<{ news: SimpleNews[]; nextPageToken?: string }>} The fetched news articles.
 */
async function fetchNews$1(symbols, params) {
    // Initialize params with defaults if not provided
    const defaultParams = {
        start: new Date(Date.now() - 24 * 60 * 60 * 1000), // Default to last 24 hours
        end: new Date(),
        limit: 10,
        sort: 'desc',
        page_token: null,
        include_content: true,
    };
    const mergedParams = { ...defaultParams, ...params };
    // Handle authentication
    let APIKey;
    let APISecret;
    if (mergedParams.auth) {
        // Try to authenticate with provided auth object
        if (mergedParams.auth.alpacaApiKey && mergedParams.auth.alpacaApiSecret) {
            APIKey = mergedParams.auth.alpacaApiKey;
            APISecret = mergedParams.auth.alpacaApiSecret;
        }
        else if (mergedParams.auth.adapticAccountId) {
            // Get shared Apollo client for connection pooling
            const client = await getSharedApolloClient();
            const alpacaAccount = (await adaptic$1.alpacaAccount.get({
                id: mergedParams.auth.adapticAccountId,
            }, client));
            if (!alpacaAccount || !alpacaAccount.APIKey || !alpacaAccount.APISecret) {
                throw new Error('Alpaca account not found or incomplete');
            }
            APIKey = alpacaAccount.APIKey;
            APISecret = alpacaAccount.APISecret;
        }
    }
    else {
        // Try to authenticate with environment variables
        APIKey = process.env.ALPACA_API_KEY;
        APISecret = process.env.ALPACA_SECRET_KEY;
    }
    // Throw error if no valid authentication is found
    if (!APIKey || !APISecret) {
        throw new Error('No valid Alpaca authentication found. Please provide either auth object or set ALPACA_API_KEY and ALPACA_API_SECRET environment variables.');
    }
    try {
        let newsArticles = [];
        let pageToken = mergedParams.page_token;
        let hasMorePages = true;
        while (hasMorePages) {
            // Prepare query parameters
            const queryParams = new URLSearchParams({
                ...(mergedParams.start && { start: new Date(mergedParams.start).toISOString() }),
                ...(mergedParams.end && { end: new Date(mergedParams.end).toISOString() }),
                ...(symbols && { symbols: symbols }),
                ...(mergedParams.limit && { limit: mergedParams.limit.toString() }),
                ...(mergedParams.sort && { sort: mergedParams.sort }),
                ...(mergedParams.include_content !== undefined ? { include_content: mergedParams.include_content.toString() } : {}),
                ...(pageToken && { page_token: pageToken }),
            });
            const url = `https://data.alpaca.markets/v1beta1/news?${queryParams}`;
            logIfDebug(`Fetching news from: ${url}`);
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'APCA-API-KEY-ID': APIKey,
                    'APCA-API-SECRET-KEY': APISecret,
                    'accept': 'application/json',
                },
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Alpaca API error (${response.status}): ${errorText}`);
            }
            const data = (await response.json());
            // Transform to SimpleNews format
            const transformedNews = data.news.map((article) => ({
                symbols: article.symbols,
                title: article.headline,
                summary: cleanContent(article.summary),
                content: article.content ? cleanContent(article.content) : undefined,
                url: article.url,
                source: article.source,
                author: article.author,
                date: article.created_at,
                updatedDate: article.updated_at || article.created_at,
                sentiment: 0, // Default sentiment since it's not provided by the API
            }));
            newsArticles = newsArticles.concat(transformedNews);
            pageToken = data.next_page_token || null;
            hasMorePages = !!pageToken;
            logIfDebug(`Received ${data.news.length} news articles. More pages: ${hasMorePages}`);
        }
        // Trim results to respect the limit parameter based on sort order
        if (mergedParams.limit && newsArticles.length > mergedParams.limit) {
            // For ascending order, keep the most recent (last) articles
            // For descending order, keep the earliest (first) articles
            // This is because in ascending order, newer articles are at the end
            // In descending order, newer articles are at the beginning
            if (mergedParams.sort === 'asc') {
                newsArticles = newsArticles.slice(-mergedParams.limit);
            }
            else {
                newsArticles = newsArticles.slice(0, mergedParams.limit);
            }
        }
        // If sort is "asc" and limit is specified, return only the most recent articles
        if (mergedParams.sort === 'asc' && mergedParams.limit) {
            newsArticles = newsArticles.slice(-mergedParams.limit);
        }
        return {
            news: newsArticles,
            nextPageToken: pageToken || undefined,
        };
    }
    catch (error) {
        console.error('Error in fetchNews:', error);
        throw error;
    }
}
// Fetches account details from Alpaca API.
/**
 * Fetches account details from Alpaca API.
 * @param {FetchAccountDetailsProps} props - The properties for fetching account details.
 * @returns {Promise<AlpacaAccountDetails>} The account details.
 */
async function fetchAccountDetails({ accountId, client, alpacaAccount, auth }) {
    let alpacaAccountObj = alpacaAccount ? alpacaAccount : null;
    if (!alpacaAccountObj && auth) {
        const validatedAuth = await validateAuth(auth);
        alpacaAccountObj = {
            APIKey: validatedAuth.APIKey,
            APISecret: validatedAuth.APISecret,
            type: validatedAuth.type,
        };
    }
    if (!alpacaAccountObj) {
        try {
            // Use provided client or get the shared client
            const apolloClient = client || await getSharedApolloClient();
            alpacaAccountObj = (await adaptic$1.alpacaAccount.get({
                id: accountId,
            }, apolloClient));
        }
        catch (error) {
            console.error('[fetchAccountDetails] Error fetching Alpaca account:', error);
            throw error;
        }
    }
    if (!alpacaAccountObj || !alpacaAccountObj.APIKey || !alpacaAccountObj.APISecret) {
        throw new Error('[fetchAccountDetails] Alpaca account not found or incomplete');
    }
    const { APIKey, APISecret, type } = alpacaAccountObj;
    // Set the API URL based on the user's current mode ('PAPER' or 'LIVE')
    const apiUrl = type === 'PAPER' ? 'https://paper-api.alpaca.markets/v2/account' : 'https://api.alpaca.markets/v2/account';
    // Make GET request to Alpaca Markets API to fetch account details
    try {
        const response = await fetch(apiUrl, {
            method: 'GET',
            headers: {
                'APCA-API-KEY-ID': APIKey,
                'APCA-API-SECRET-KEY': APISecret,
                'Content-Type': 'application/json',
            },
        });
        if (!response.ok) {
            throw new Error(`Failed to fetch account details: ${response.statusText}`);
        }
        const data = await response.json();
        return data;
    }
    catch (error) {
        console.error('Error in fetchAccountDetails:', error);
        throw error;
    }
}
/**
 * Fetches portfolio history for one Alpaca account.
 * @param {FetchPortfolioHistoryProps} props - The properties for fetching portfolio history.
 * @returns {Promise<PortfolioHistoryResponse>} The portfolio history.
 */
/** Fetches portfolio history for one Alpaca account, as stored in Adaptic backend
*/
async function fetchPortfolioHistory({ params, accountId, client, alpacaAccount }) {
    let alpacaAccountObj = alpacaAccount ? alpacaAccount : null;
    if (!alpacaAccountObj) {
        try {
            // Use provided client or get the shared client
            const apolloClient = client || await getSharedApolloClient();
            alpacaAccountObj = (await adaptic$1.alpacaAccount.get({
                id: accountId,
            }, apolloClient));
        }
        catch (error) {
            console.error('[fetchPortfolioHistory] Error fetching Alpaca account:', error);
            throw error;
        }
    }
    if (!alpacaAccountObj || !alpacaAccountObj.APIKey || !alpacaAccountObj.APISecret) {
        throw new Error('[fetchPortfolioHistory] Alpaca account not found or incomplete');
    }
    const { APIKey, APISecret, type } = alpacaAccountObj;
    // Set the API base URL
    const apiBaseUrl = type === 'PAPER' ? 'https://paper-api.alpaca.markets' : 'https://api.alpaca.markets';
    const apiUrl = `${apiBaseUrl}/v2/account/portfolio/history`;
    // Ensure that only two of 'start', 'end', and 'period' are specified
    const { start, end, period } = params;
    // Validate date formats
    if (start) {
        params.start = new Date(start).toISOString();
        // delete period if start is specified
        if (period) {
            delete params.period;
        }
    }
    if (end) {
        params.end = new Date(end).toISOString();
    }
    if (period === 'YTD') {
        params.period = '1A';
    }
    // Remove undefined parameters
    Object.keys(params).forEach((key) => params[key] === undefined && delete params[key]);
    // Construct query string from params
    const queryString = new URLSearchParams(params).toString();
    const fullUrl = `${apiUrl}?${queryString}`;
    try {
        // Make GET request to Alpaca Markets API to fetch portfolio history
        const response = await fetch(fullUrl, {
            method: 'GET',
            headers: {
                'APCA-API-KEY-ID': APIKey,
                'APCA-API-SECRET-KEY': APISecret,
                'Content-Type': 'application/json',
            },
        });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to fetch portfolio history: ${response.status} ${response.statusText} ${errorText}`);
        }
        const data = await response.json();
        return data;
    }
    catch (error) {
        console.error('[fetchPortfolioHistory] Error fetching portfolio history call to Alpaca:', error);
        throw error;
    }
}
/**
 * Fetches all positions for an Alpaca trading account.
 * @param {AlpacaAuth} auth - The authentication details for Alpaca.
 * @returns {Promise<AlpacaPosition[]>} The list of positions.
 */
async function fetchAllPositions(auth) {
    try {
        const { APIKey, APISecret, type } = await validateAuth(auth);
        // Set the API base URL
        const apiBaseUrl = type === 'PAPER' ? 'https://paper-api.alpaca.markets' : 'https://api.alpaca.markets';
        const apiUrl = `${apiBaseUrl}/v2/positions`;
        // Make GET request to Alpaca Markets API to fetch positions
        const response = await fetch(apiUrl, {
            method: 'GET',
            headers: {
                'APCA-API-KEY-ID': APIKey,
                'APCA-API-SECRET-KEY': APISecret,
                'Content-Type': 'application/json',
            },
        });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to fetch positions: ${response.status} ${response.statusText} ${errorText}`);
        }
        return (await response.json());
    }
    catch (error) {
        console.error('Error in fetchAllPositions:', error);
        throw error;
    }
}
/**
 * Fetches a specific position for an Alpaca account.
 * @param {AlpacaAuth} auth - The authentication details for Alpaca.
 * @param {string} symbolOrAssetId - The symbol or asset ID to fetch the position for.
 * @returns {Promise<{ position: AlpacaPosition | null; message?: string }>} The position details or null with message if not found.
 */
async function fetchPosition(auth, symbolOrAssetId) {
    try {
        const { APIKey, APISecret, type } = await validateAuth(auth);
        const apiBaseUrl = type === 'PAPER' ? 'https://paper-api.alpaca.markets' : 'https://api.alpaca.markets';
        const response = await fetch(`${apiBaseUrl}/v2/positions/${symbolOrAssetId}`, {
            method: 'GET',
            headers: {
                'APCA-API-KEY-ID': APIKey,
                'APCA-API-SECRET-KEY': APISecret,
                'Content-Type': 'application/json',
            },
        });
        if (!response.ok) {
            const errorText = await response.text();
            // Special handling for 404 errors
            if (response.status === 404) {
                return { position: null, message: `Position does not exist: ${symbolOrAssetId}` };
            }
            else {
                throw new Error(`Failed to fetch position: ${response.status} ${response.statusText} ${errorText}`);
            }
        }
        const position = (await response.json());
        return { position };
    }
    catch (error) {
        console.error('Error in fetchPosition:', error);
        throw error;
    }
}
/**
 * Closes a specific position in Alpaca.
 * @param {AlpacaAuth} auth - The authentication details for Alpaca.
 * @param {string} symbolOrAssetId - The symbol or asset ID of the position to close.
 * @param {Object} [params] - Optional parameters for closing the position.
 * @param {number} [params.qty] - Quantity of shares to close (up to 9 decimal places).
 * @param {number} [params.percentage] - Percentage of position to close (0-100, up to 9 decimal places).
 * @param {boolean} [params.useLimitOrder] - Whether to use a limit order to close the position.
 * @param {boolean} [params.cancelOrders] - Whether to cancel open orders for the symbol before closing.
 * @param {number} [params.slippagePercent1] - Slippage percentage for limit orders (default: 0.1).
 * @param {boolean} [params.extendedHours] - Whether to enable extended hours trading (default: false).
 * @returns {Promise<AlpacaOrder>} The order created to close the position.
 */
async function closePosition$1(auth, symbolOrAssetId, params) {
    try {
        const { APIKey, APISecret, type } = await validateAuth(auth);
        const apiBaseUrl = type === 'PAPER' ? 'https://paper-api.alpaca.markets' : 'https://api.alpaca.markets';
        // Default parameters
        const useLimitOrder = params?.useLimitOrder ?? false;
        const cancelOrders = params?.cancelOrders ?? true;
        const slippagePercent1 = params?.slippagePercent1 ?? 0.1;
        const extendedHours = params?.extendedHours ?? false;
        // Cancel open orders for this symbol if requested
        if (cancelOrders) {
            console.log(`Canceling open orders for ${symbolOrAssetId} before closing position`, {
                account: auth.adapticAccountId || 'direct',
                symbol: symbolOrAssetId
            });
            // Get all open orders
            const openOrders = await getOrders$1(auth, { status: 'open', symbols: [symbolOrAssetId] });
            // Cancel each order for this symbol
            for (const order of openOrders) {
                if (order.symbol === symbolOrAssetId) {
                    await cancelOrder$1(auth, order.id);
                }
            }
        }
        if (useLimitOrder) {
            // Fetch position details to get quantity and side
            const { position } = await fetchPosition(auth, symbolOrAssetId);
            if (!position) {
                throw new Error(`Position not found for ${symbolOrAssetId}`);
            }
            // Construct global Alpaca Auth
            const alpacaAuth = {
                type: 'LIVE',
                alpacaApiKey: process.env.ALPACA_API_KEY,
                alpacaApiSecret: process.env.ALPACA_SECRET_KEY,
            };
            // Get latest quote for the symbol
            const quotesResponse = await getLatestQuotes$1(alpacaAuth, { symbols: [symbolOrAssetId] });
            const quote = quotesResponse.quotes[symbolOrAssetId];
            if (!quote) {
                throw new Error(`No quote available for ${symbolOrAssetId}`);
            }
            // Calculate quantity to close
            let qty = Math.abs(parseFloat(position.qty));
            if (params?.qty !== undefined) {
                qty = params.qty;
            }
            else if (params?.percentage !== undefined) {
                qty = Math.abs(parseFloat(position.qty)) * (params.percentage / 100);
            }
            const side = position.side === 'long' ? 'sell' : 'buy';
            const positionIntent = side === 'sell' ? 'sell_to_close' : 'buy_to_close';
            // Get the current price from the quote
            const currentPrice = side === 'sell' ? quote.bp : quote.ap; // Use bid for sells, ask for buys
            if (!currentPrice) {
                throw new Error(`No valid price available for ${symbolOrAssetId}`);
            }
            // Apply slippage
            const limitSlippage = slippagePercent1 / 100;
            const limitPrice = side === 'sell'
                ? roundPriceForAlpaca$5(currentPrice * (1 - limitSlippage)) // Sell slightly lower
                : roundPriceForAlpaca$5(currentPrice * (1 + limitSlippage)); // Buy slightly higher
            console.log(`Creating limit order to close ${symbolOrAssetId} position: ${side} ${qty} shares at ${limitPrice.toFixed(2)}`, {
                account: auth.adapticAccountId || 'direct',
                symbol: symbolOrAssetId
            });
            // Create limit order
            return await createLimitOrder(auth, {
                symbol: symbolOrAssetId,
                qty,
                side,
                limitPrice,
                position_intent: positionIntent,
                extended_hours: extendedHours
            });
        }
        else {
            // Use the standard position closing API
            // Construct query parameters if provided
            const queryParams = new URLSearchParams();
            if (params?.qty !== undefined) {
                queryParams.append('qty', params.qty.toString());
            }
            if (params?.percentage !== undefined) {
                queryParams.append('percentage', params.percentage.toString());
            }
            const queryString = queryParams.toString();
            const url = `${apiBaseUrl}/v2/positions/${encodeURIComponent(symbolOrAssetId)}${queryString ? `?${queryString}` : ''}`;
            const response = await fetch(url, {
                method: 'DELETE',
                headers: {
                    'APCA-API-KEY-ID': APIKey,
                    'APCA-API-SECRET-KEY': APISecret,
                },
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Failed to close position: ${response.status} ${response.statusText} ${errorText}`);
            }
            return (await response.json());
        }
    }
    catch (error) {
        console.error('Error in closePosition:', error);
        throw error;
    }
}
async function makeRequest(auth, params) {
    const { endpoint, method, body, queryString, apiBaseUrl } = params;
    try {
        const apiBaseUrlInner = apiBaseUrl ? apiBaseUrl : auth.type === 'PAPER' ? 'https://paper-api.alpaca.markets' : 'https://api.alpaca.markets';
        const { APIKey, APISecret } = await validateAuth(auth);
        if (!APIKey || !APISecret) {
            throw new Error('No valid Alpaca authentication found. Please provide either auth object or set ALPACA_API_KEY and ALPACA_API_SECRET environment variables.');
        }
        // Construct the full URL
        const url = `${apiBaseUrlInner}${endpoint}${queryString || ''}`;
        console.log(`Making ${method} request to ${endpoint}${queryString || ''}`, {
            account: auth.adapticAccountId || 'direct',
            source: 'AlpacaAPI'
        });
        // Prepare fetch options
        const fetchOptions = {
            method,
            headers: {
                'APCA-API-KEY-ID': APIKey,
                'APCA-API-SECRET-KEY': APISecret,
            },
        };
        // Only add Content-Type and body for non-GET/HEAD requests that have a body
        if (body && method !== 'GET' && method !== 'HEAD') {
            fetchOptions.headers = {
                ...fetchOptions.headers,
                'Content-Type': 'application/json',
            };
            fetchOptions.body = JSON.stringify(body);
        }
        const response = await fetch(url, fetchOptions);
        // Handle 207 Multi-Status responses (used by closeAll positions)
        if (response.status === 207 || response.ok) {
            return await response.json();
        }
        // Handle errors
        const errorText = await response.text();
        console.error(`Alpaca API error (${response.status}): ${errorText}`, {
            account: auth.adapticAccountId || 'direct',
            source: 'AlpacaAPI',
            type: 'error'
        });
        throw new Error(`Alpaca API error (${response.status}): ${errorText}`);
    }
    catch (err) {
        const error = err;
        console.error(`Error in makeRequest: ${error.message}`, {
            source: 'AlpacaAPI',
            type: 'error'
        });
        throw error;
    }
}
/**
 * Create a limit order
 * @param symbol (string) - the symbol of the order
 * @param qty (number) - the quantity of the order
 * @param side (string) - the side of the order
 * @param limitPrice (number) - the limit price of the order
 * @param position_intent (string) - the position intent of the order
 * @param extended_hours (boolean) - whether the order is in extended hours
 * @param client_order_id (string) - the client order id of the order
 */
async function createLimitOrder(auth, params = {
    symbol: '',
    qty: 0,
    side: 'buy',
    limitPrice: 0,
    position_intent: 'buy_to_open',
    extended_hours: false,
    client_order_id: undefined
}) {
    const { symbol, qty, side, limitPrice, position_intent, extended_hours, client_order_id } = params;
    console.log(`Creating limit order for ${symbol}: ${side} ${qty} shares at ${limitPrice.toFixed(2)} (${position_intent})`, {
        account: auth.adapticAccountId || 'direct',
        symbol
    });
    const body = {
        symbol,
        qty: Math.abs(qty),
        side,
        position_intent,
        type: 'limit',
        limit_price: limitPrice.toString(),
        time_in_force: 'day',
        order_class: 'simple',
        extended_hours,
    };
    if (client_order_id !== undefined) {
        body.client_order_id = client_order_id;
    }
    return makeRequest(auth, {
        endpoint: '/v2/orders',
        method: 'POST',
        body,
    });
}
/**
 * Closes all positions in Alpaca.
 * @param {AlpacaAuth} auth - The authentication details for Alpaca.
 * @param {Object} [params] - Optional parameters for closing all positions.
 * @param {boolean} [params.cancelOrders] - If true, cancels all open orders before closing positions.
 * @param {boolean} [params.useLimitOrders] - If true, uses limit orders to close positions.
 * @returns {Promise<Array<{ symbol: string; status: number; body?: Order }>>} The status of each position closure attempt.
 */
async function closeAllPositions$1(auth, params = { cancel_orders: true, useLimitOrders: false, slippagePercent1: 0.1 }) {
    const { cancel_orders, useLimitOrders, slippagePercent1 = 0.1 } = params;
    console.log(`Closing all positions${useLimitOrders ? ' using limit orders' : ''}${cancel_orders ? ' and canceling open orders' : ''}`, {
        account: auth.adapticAccountId || 'direct'
    });
    if (useLimitOrders) {
        // Get all positions
        const positions = await fetchAllPositions(auth);
        if (positions.length === 0) {
            console.log('No positions to close', {
                account: auth.adapticAccountId || 'direct'
            });
            return [];
        }
        console.log(`Found ${positions.length} positions to close`, {
            account: auth.adapticAccountId || 'direct'
        });
        // Construct global Alpaca Auth
        const alpacaAuth = {
            type: 'LIVE',
            alpacaApiKey: process.env.ALPACA_API_KEY,
            alpacaApiSecret: process.env.ALPACA_SECRET_KEY,
        };
        // Get latest quotes for all positions
        const symbols = positions.map(position => position.symbol);
        const quotesResponse = await getLatestQuotes$1(alpacaAuth, { symbols });
        const lengthOfQuotes = Object.keys(quotesResponse.quotes).length;
        if (lengthOfQuotes === 0) {
            console.error('No quotes available for positions, received 0 quotes', {
                account: auth.adapticAccountId || 'direct',
                type: 'error'
            });
            return [];
        }
        if (lengthOfQuotes !== positions.length) {
            console.warn(`Received ${lengthOfQuotes} quotes for ${positions.length} positions, expected ${positions.length} quotes`, {
                account: auth.adapticAccountId || 'direct',
                type: 'warn'
            });
            return [];
        }
        // Create limit orders to close each position
        for (const position of positions) {
            const quote = quotesResponse.quotes[position.symbol];
            if (!quote) {
                console.warn(`No quote available for ${position.symbol}, skipping limit order`, {
                    account: auth.adapticAccountId || 'direct',
                    symbol: position.symbol,
                    type: 'warn'
                });
                continue;
            }
            const qty = Math.abs(parseFloat(position.qty));
            const side = position.side === 'long' ? 'sell' : 'buy';
            const positionIntent = side === 'sell' ? 'sell_to_close' : 'buy_to_close';
            // Get the current price from the quote
            const currentPrice = side === 'sell' ? quote.bp : quote.ap; // Use bid for sells, ask for buys
            if (!currentPrice) {
                console.warn(`No valid price available for ${position.symbol}, skipping limit order`, {
                    account: auth.adapticAccountId || 'direct',
                    symbol: position.symbol,
                    type: 'warn'
                });
                continue;
            }
            // Apply slippage from config
            const limitSlippage = slippagePercent1 / 100;
            const limitPrice = side === 'sell'
                ? roundPriceForAlpaca$5(currentPrice * (1 - limitSlippage)) // Sell slightly lower
                : roundPriceForAlpaca$5(currentPrice * (1 + limitSlippage)); // Buy slightly higher
            console.log(`Creating limit order to close ${position.symbol} position: ${side} ${qty} shares at ${limitPrice.toFixed(2)}`, {
                account: auth.adapticAccountId || 'direct',
                symbol: position.symbol
            });
            await createLimitOrder(auth, {
                symbol: position.symbol,
                qty,
                side,
                limitPrice,
                position_intent: positionIntent,
                extended_hours: false // Set to false or true based on your requirement
            });
        }
    }
    else {
        const response = await makeRequest(auth, {
            endpoint: '/v2/positions', method: 'DELETE', queryString: cancel_orders ? '?cancel_orders=true' : ''
        });
        return response;
    }
}
/**
 * Close all positions using limit orders during extended hours trading
 * @param cancelOrders Whether to cancel related orders (default: true)
 * @returns Promise that resolves when all positions are closed
 */
/**
 * Closes all positions in Alpaca using limit orders during extended hours trading.
 * @param {AlpacaAuth} auth - The authentication details for Alpaca.
 * @param {Object} [params] - Optional parameters for closing all positions.
 * @param {boolean} [params.cancelOrders] - If true, cancels all open orders before closing positions.
 * @returns {Promise<Array<{ symbol: string; status: number; body?: Order }>>} The status of each position closure attempt.
 */
async function closeAllPositionsAfterHours$1(auth, params = { cancel_orders: true, slippagePercent1: 0.1 }) {
    console.log('Closing all positions using limit orders during extended hours trading', {
        account: auth.adapticAccountId || 'direct'
    });
    const { cancel_orders, slippagePercent1 = 0.1 } = params;
    // Get all positions
    const positions = await fetchAllPositions(auth);
    if (positions.length === 0) {
        console.log('No positions to close', {
            account: auth.adapticAccountId || 'direct'
        });
        return;
    }
    console.log(`Found ${positions.length} positions to close`, {
        account: auth.adapticAccountId || 'direct'
    });
    if (cancel_orders) {
        await cancelAllOrders$1(auth);
        console.log('Cancelled all open orders', {
            account: auth.adapticAccountId || 'direct'
        });
    }
    // Construct global Alpaca Auth
    const alpacaAuth = {
        type: 'LIVE',
        alpacaApiKey: process.env.ALPACA_API_KEY,
        alpacaApiSecret: process.env.ALPACA_SECRET_KEY,
    };
    // Get latest quotes for all positions
    const symbols = positions.map(position => position.symbol);
    const quotesResponse = await getLatestQuotes$1(alpacaAuth, { symbols });
    // Create limit orders to close each position
    for (const position of positions) {
        const quote = quotesResponse.quotes[position.symbol];
        if (!quote) {
            console.warn(`No quote available for ${position.symbol}, skipping limit order`, {
                account: auth.adapticAccountId || 'direct',
                symbol: position.symbol,
                type: 'warn'
            });
            continue;
        }
        const qty = Math.abs(parseFloat(position.qty));
        const side = position.side === 'long' ? 'sell' : 'buy';
        const positionIntent = side === 'sell' ? 'sell_to_close' : 'buy_to_close';
        // Get the current price from the quote
        const currentPrice = side === 'sell' ? quote.bp : quote.ap; // Use bid for sells, ask for buys
        if (!currentPrice) {
            console.warn(`No valid price available for ${position.symbol}, skipping limit order`, {
                account: auth.adapticAccountId || 'direct',
                symbol: position.symbol,
                type: 'warn'
            });
            continue;
        }
        // Apply slippage from config
        const limitSlippage = slippagePercent1 / 100;
        const limitPrice = side === 'sell'
            ? roundPriceForAlpaca$5(currentPrice * (1 - limitSlippage)) // Sell slightly lower
            : roundPriceForAlpaca$5(currentPrice * (1 + limitSlippage)); // Buy slightly higher
        console.log(`Creating extended hours limit order to close ${position.symbol} position: ${side} ${qty} shares at ${limitPrice.toFixed(2)}`, {
            account: auth.adapticAccountId || 'direct',
            symbol: position.symbol
        });
        await createLimitOrder(auth, {
            symbol: position.symbol,
            qty,
            side,
            limitPrice,
            position_intent: positionIntent,
            extended_hours: true // Enable extended hours trading
        });
    }
    console.log(`All positions closed: ${positions.map(p => p.symbol).join(', ')}`, {
        account: auth.adapticAccountId || 'direct'
    });
}
/**
  * Get the most recent quotes for requested symbols
  * @param symbols Array of stock symbols to query
  * @param feed Optional data source (sip/iex/delayed_sip)
  * @param currency Optional currency in ISO 4217 format
  * @returns Latest quote data for each symbol
  * @throws Error if request fails or rate limit exceeded
  */
async function getLatestQuotes$1(auth, params) {
    const DEFAULT_CURRENCY = 'USD';
    const DEFAULT_FEED = 'sip';
    const { symbols, feed, currency } = params;
    // Return empty response if symbols array is empty to avoid API error
    if (!symbols || symbols.length === 0) {
        console.warn('No symbols provided to getLatestQuotes, returning empty response', {
            type: 'warn'
        });
        return {
            quotes: {},
            currency: currency || DEFAULT_CURRENCY
        };
    }
    // For GET requests, we should use query parameters instead of body
    const queryParams = new URLSearchParams();
    queryParams.append('symbols', symbols.join(','));
    queryParams.append('feed', feed || DEFAULT_FEED);
    queryParams.append('currency', currency || DEFAULT_CURRENCY);
    return makeRequest(auth, {
        endpoint: '/v2/stocks/quotes/latest',
        method: 'GET',
        queryString: `?${queryParams.toString()}`,
        apiBaseUrl: 'https://data.alpaca.markets'
    });
}
/**
 * Retrieves the configuration for a specific Alpaca account.
 * @param {types.AlpacaAccount} account - The Alpaca account to retrieve the configuration for.
 * @returns {Promise<AccountConfiguration>} The account configuration.
 */
async function getConfiguration(account) {
    try {
        if (!account) {
            throw new Error(`Account is missing.`);
        }
        const { APIKey, APISecret } = account;
        if (!APIKey || !APISecret) {
            throw new Error('User APIKey or APISecret is missing.');
        }
        const apiUrl = account.type === 'PAPER' ? 'https://paper-api.alpaca.markets/v2' : 'https://api.alpaca.markets/v2';
        // Get shared Apollo client for connection pooling
        const client = await getSharedApolloClient();
        // Parallel requests:
        const [alpacaResponse, freshAlpacaAccount] = await Promise.all([
            fetch(`${apiUrl}/account/configurations`, {
                method: 'GET',
                headers: {
                    'APCA-API-KEY-ID': APIKey,
                    'APCA-API-SECRET-KEY': APISecret,
                    accept: 'application/json',
                },
            }),
            // Re-fetch this account from @adaptic/backend-legacy to get DB-level fields
            adaptic$1.alpacaAccount.get({ id: account.id }, client),
        ]);
        if (!alpacaResponse.ok) {
            throw new Error(`Failed to fetch account configuration: ${alpacaResponse.statusText}`);
        }
        if (!freshAlpacaAccount) {
            throw new Error('Failed to get Alpaca Account from @adaptic/backend-legacy.');
        }
        const dataFromAlpaca = (await alpacaResponse.json());
        // Fetch allocation data with expanded asset types and defaults
        // Type assertion to handle fields that may not exist in backend-legacy yet
        const accountWithAllocation = freshAlpacaAccount;
        const allocationData = accountWithAllocation.allocation || {
            stocks: 70,
            options: 0,
            futures: 0,
            etfs: 10,
            forex: 0,
            crypto: 20
        };
        // Merge DB fields onto the returned object
        // (These are not part of Alpaca's config, but are stored in our DB)
        const combinedConfig = {
            ...dataFromAlpaca,
            marketOpen: freshAlpacaAccount.marketOpen,
            realTime: freshAlpacaAccount.realTime,
            tradeAllocationPct: freshAlpacaAccount.tradeAllocationPct,
            minPercentageChange: freshAlpacaAccount.minPercentageChange,
            volumeThreshold: freshAlpacaAccount.volumeThreshold,
            // New fields
            cryptoTradingEnabled: freshAlpacaAccount.cryptoTradingEnabled ?? false,
            cryptoTradingPairs: freshAlpacaAccount.cryptoTradingPairs ?? [],
            cryptoTradeAllocationPct: freshAlpacaAccount.cryptoTradeAllocationPct ?? 5.0,
            autoAllocation: accountWithAllocation.autoAllocation ?? false,
            allocation: allocationData,
            enablePortfolioTrailingStop: freshAlpacaAccount.enablePortfolioTrailingStop,
            portfolioTrailPercent: freshAlpacaAccount.portfolioTrailPercent,
            portfolioProfitThresholdPercent: freshAlpacaAccount.portfolioProfitThresholdPercent,
            reducedPortfolioTrailPercent: freshAlpacaAccount.reducedPortfolioTrailPercent,
            // Position Trailing Stop Service Fields
            defaultTrailingStopPercentage100: freshAlpacaAccount.defaultTrailingStopPercentage100 ?? 4.0,
            firstTrailReductionThreshold100: freshAlpacaAccount.firstTrailReductionThreshold100 ?? 2.0,
            secondTrailReductionThreshold100: freshAlpacaAccount.secondTrailReductionThreshold100 ?? 5.0,
            firstReducedTrailPercentage100: freshAlpacaAccount.firstReducedTrailPercentage100 ?? 1.0,
            secondReducedTrailPercentage100: freshAlpacaAccount.secondReducedTrailPercentage100 ?? 0.5,
            minimumPriceChangePercent100: freshAlpacaAccount.minimumPriceChangePercent100 ?? 0.5,
        };
        return combinedConfig;
    }
    catch (error) {
        console.error('Error in getConfiguration:', error);
        throw error;
    }
}
/**
 * Updates the configuration for a specific Alpaca account.
 * @param {types.User} user - The user making the update.
 * @param {types.AlpacaAccount} account - The Alpaca account to update.
 * @param {AccountConfiguration} updatedConfig - The updated configuration.
 * @returns {Promise<AccountConfiguration>} The updated account configuration.
 */
async function updateConfiguration(user, account, updatedConfig) {
    try {
        if (!account) {
            throw new Error(`Account is missing.`);
        }
        const { APIKey, APISecret } = account;
        if (!APIKey || !APISecret) {
            throw new Error('User APIKey or APISecret is missing.');
        }
        const apiUrl = account.type === 'PAPER' ? 'https://paper-api.alpaca.markets/v2' : 'https://api.alpaca.markets/v2';
        // Prepare the config object for Alpaca by removing DB-only fields
        const configForAlpaca = { ...updatedConfig };
        // Remove DB-only fields from Alpaca API request
        delete configForAlpaca.marketOpen;
        delete configForAlpaca.realTime;
        delete configForAlpaca.tradeAllocationPct;
        delete configForAlpaca.minPercentageChange;
        delete configForAlpaca.volumeThreshold;
        // Remove new fields from Alpaca API request
        delete configForAlpaca.cryptoTradingEnabled;
        delete configForAlpaca.cryptoTradingPairs;
        delete configForAlpaca.cryptoTradeAllocationPct;
        delete configForAlpaca.autoAllocation;
        delete configForAlpaca.allocation;
        delete configForAlpaca.enablePortfolioTrailingStop;
        delete configForAlpaca.portfolioTrailPercent;
        delete configForAlpaca.portfolioProfitThresholdPercent;
        delete configForAlpaca.reducedPortfolioTrailPercent;
        // Remove Position Trailing Stop Service fields from Alpaca API request
        delete configForAlpaca.defaultTrailingStopPercentage100;
        delete configForAlpaca.firstTrailReductionThreshold100;
        delete configForAlpaca.secondTrailReductionThreshold100;
        delete configForAlpaca.firstReducedTrailPercentage100;
        delete configForAlpaca.secondReducedTrailPercentage100;
        delete configForAlpaca.minimumPriceChangePercent100;
        // Make a PATCH request to Alpaca to update their side
        const alpacaUpdatePromise = fetch(`${apiUrl}/account/configurations`, {
            method: 'PATCH',
            headers: {
                'APCA-API-KEY-ID': APIKey,
                'APCA-API-SECRET-KEY': APISecret,
                'Content-Type': 'application/json',
                accept: 'application/json',
            },
            body: JSON.stringify(configForAlpaca),
        });
        // Get shared Apollo client for connection pooling
        const client = await getSharedApolloClient();
        // Check if we need to update allocation
        let allocUpdatePromise = Promise.resolve(null);
        if (updatedConfig.allocation) {
            // Validate allocation percentages sum to 100%
            const totalAllocation = (updatedConfig.allocation.stocks ?? 0) +
                (updatedConfig.allocation.options ?? 0) +
                (updatedConfig.allocation.futures ?? 0) +
                (updatedConfig.allocation.etfs ?? 0) +
                (updatedConfig.allocation.forex ?? 0) +
                (updatedConfig.allocation.crypto ?? 0);
            if (Math.abs(totalAllocation - 100) > 0.01) {
                throw new Error(`Allocation percentages must sum to 100%. Current total: ${totalAllocation}%`);
            }
            // If account already has an allocation, update it, otherwise create one
            if (account.allocation) {
                allocUpdatePromise = adaptic$1.allocation.update({
                    id: account.allocation.id,
                    alpacaAccount: {
                        id: account.id,
                    },
                    alpacaAccountId: account.id,
                    stocks: updatedConfig.allocation.stocks ?? 0,
                    options: updatedConfig.allocation.options ?? 0,
                    futures: updatedConfig.allocation.futures ?? 0,
                    etfs: updatedConfig.allocation.etfs ?? 0,
                    forex: updatedConfig.allocation.forex ?? 0,
                    crypto: updatedConfig.allocation.crypto ?? 0,
                }, client);
            }
            else {
                allocUpdatePromise = adaptic$1.allocation.create({
                    stocks: updatedConfig.allocation.stocks ?? 0,
                    options: updatedConfig.allocation.options ?? 0,
                    futures: updatedConfig.allocation.futures ?? 0,
                    etfs: updatedConfig.allocation.etfs ?? 0,
                    forex: updatedConfig.allocation.forex ?? 0,
                    crypto: updatedConfig.allocation.crypto ?? 0,
                    alpacaAccount: {
                        id: account.id,
                    },
                    alpacaAccountId: account.id
                }, client);
            }
        }
        // Meanwhile, update the DB-based fields in @adaptic/backend-legacy
        // Use type assertion for fields that may not exist in backend-legacy yet
        const adapticUpdatePromise = adaptic$1.alpacaAccount.update({
            id: account.id,
            user: {
                id: user.id,
                name: user?.name,
            },
            configuration: updatedConfig,
            marketOpen: updatedConfig.marketOpen,
            realTime: updatedConfig.realTime,
            tradeAllocationPct: updatedConfig.tradeAllocationPct,
            minPercentageChange: updatedConfig.minPercentageChange,
            volumeThreshold: updatedConfig.volumeThreshold,
            // New fields
            cryptoTradingEnabled: updatedConfig.cryptoTradingEnabled,
            cryptoTradingPairs: updatedConfig.cryptoTradingPairs,
            cryptoTradeAllocationPct: updatedConfig.cryptoTradeAllocationPct,
            autoAllocation: updatedConfig.autoAllocation,
            enablePortfolioTrailingStop: updatedConfig.enablePortfolioTrailingStop,
            portfolioTrailPercent: updatedConfig.portfolioTrailPercent,
            portfolioProfitThresholdPercent: updatedConfig.portfolioProfitThresholdPercent,
            reducedPortfolioTrailPercent: updatedConfig.reducedPortfolioTrailPercent,
            // Position Trailing Stop Service fields
            defaultTrailingStopPercentage100: updatedConfig.defaultTrailingStopPercentage100,
            firstTrailReductionThreshold100: updatedConfig.firstTrailReductionThreshold100,
            secondTrailReductionThreshold100: updatedConfig.secondTrailReductionThreshold100,
            firstReducedTrailPercentage100: updatedConfig.firstReducedTrailPercentage100,
            secondReducedTrailPercentage100: updatedConfig.secondReducedTrailPercentage100,
            minimumPriceChangePercent100: updatedConfig.minimumPriceChangePercent100,
        }, client);
        const [alpacaResponse, updatedAlpacaAccount, updatedAllocation] = await Promise.all([
            alpacaUpdatePromise,
            adapticUpdatePromise,
            allocUpdatePromise
        ]);
        console.log('=== PROMISE.ALL RESULTS ===');
        console.log('updatedAllocation from Promise.all:', updatedAllocation);
        console.log('updatedAllocation fields:', {
            stocks: updatedAllocation?.stocks,
            options: updatedAllocation?.options,
            futures: updatedAllocation?.futures,
            etfs: updatedAllocation?.etfs,
            forex: updatedAllocation?.forex,
            crypto: updatedAllocation?.crypto,
        });
        if (!alpacaResponse.ok) {
            console.error('Failed to update account configuration at Alpaca:', alpacaResponse.statusText);
            throw new Error(`Failed to update account config at Alpaca: ${alpacaResponse.statusText}`);
        }
        const alpacaData = (await alpacaResponse.json());
        if (!updatedAlpacaAccount) {
            throw new Error('Failed to update Alpaca Account in @adaptic/backend-legacy.');
        }
        // Merge final data from Alpaca + local DB fields
        // Type assertion for fields that may not exist in backend-legacy yet
        const updatedAccountWithAllocation = updatedAlpacaAccount;
        // FIX: Use the validated input allocation instead of mutation response
        // The mutation response may return stale/cached data, but we already validated
        // and sent the correct values to the database, so use updatedConfig.allocation
        const selectedAllocation = updatedConfig.allocation || updatedAllocation || updatedAccountWithAllocation.allocation;
        console.log('=== ALLOCATION DEBUG (will be removed after fix verified) ===');
        console.log('Using updatedConfig.allocation (validated input):', updatedConfig.allocation);
        console.log('Ignoring potentially stale updatedAllocation:', updatedAllocation);
        console.log('Final allocation:', selectedAllocation);
        const finalConfig = {
            ...alpacaData,
            marketOpen: updatedAlpacaAccount.marketOpen,
            realTime: updatedAlpacaAccount.realTime,
            tradeAllocationPct: updatedAlpacaAccount.tradeAllocationPct,
            minPercentageChange: updatedAlpacaAccount.minPercentageChange,
            volumeThreshold: updatedAlpacaAccount.volumeThreshold,
            // New fields
            cryptoTradingEnabled: updatedAlpacaAccount.cryptoTradingEnabled,
            cryptoTradingPairs: updatedAlpacaAccount.cryptoTradingPairs,
            cryptoTradeAllocationPct: updatedAlpacaAccount.cryptoTradeAllocationPct,
            autoAllocation: updatedAccountWithAllocation.autoAllocation,
            allocation: selectedAllocation,
            enablePortfolioTrailingStop: updatedAlpacaAccount.enablePortfolioTrailingStop,
            portfolioTrailPercent: updatedAlpacaAccount.portfolioTrailPercent,
            portfolioProfitThresholdPercent: updatedAlpacaAccount.portfolioProfitThresholdPercent,
            reducedPortfolioTrailPercent: updatedAlpacaAccount.reducedPortfolioTrailPercent,
            // Position Trailing Stop Service fields
            defaultTrailingStopPercentage100: updatedAlpacaAccount.defaultTrailingStopPercentage100,
            firstTrailReductionThreshold100: updatedAlpacaAccount.firstTrailReductionThreshold100,
            secondTrailReductionThreshold100: updatedAlpacaAccount.secondTrailReductionThreshold100,
            firstReducedTrailPercentage100: updatedAlpacaAccount.firstReducedTrailPercentage100,
            secondReducedTrailPercentage100: updatedAlpacaAccount.secondReducedTrailPercentage100,
            minimumPriceChangePercent100: updatedAlpacaAccount.minimumPriceChangePercent100,
        };
        return finalConfig;
    }
    catch (error) {
        console.error('Error in updateConfiguration:', error);
        throw error;
    }
}
function cleanContent(htmlContent) {
    // Remove <script> and <style> tags and their content
    let result = htmlContent.replace(/<(script|style)[^>]*>[\s\S]*?<\/\1>/gi, '');
    // Remove remaining HTML tags
    result = result.replace(/<[^>]+>/g, '');
    // Remove unnecessary '+' characters
    result = result.replace(/\+\s*/g, ' ');
    // Replace named entities with plain text equivalents
    result = result.split('&nbsp;').join(' ')
        .split('&amp;').join('&')
        .split('&#8217;').join("'")
        .split('&#8216;').join("'")
        .split('&#8220;').join('"')
        .split('&#8221;').join('"')
        .split('&#39;').join("'");
    // Decode hexadecimal numeric entities (e.g., &#x1f92f;)
    result = result.replace(/&#x([\da-fA-F]+);/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));
    // Decode decimal numeric entities (e.g., &#8220; if not already replaced)
    result = result.replace(/&#(\d+);/g, (_, dec) => String.fromCharCode(parseInt(dec, 10)));
    // Normalize whitespace and trim
    result = result.replace(/\s+/g, ' ').trim();
    return result;
}
/**
 * Retrieves an asset from Alpaca by symbol or asset ID.
 * @param {AlpacaAuth} auth - The authentication details for Alpaca.
 * @param {string} symbolOrAssetId - The symbol or asset ID to retrieve.
 * @returns {Promise<Asset>} The requested asset.
 */
async function getAsset(auth, symbolOrAssetId) {
    try {
        const { APIKey, APISecret, type } = await validateAuth(auth);
        const apiBaseUrl = type === 'PAPER' ? 'https://paper-api.alpaca.markets' : 'https://api.alpaca.markets';
        // Use encodeURIComponent to handle special characters in symbols (e.g., BTC/USDT)
        const encodedSymbolOrAssetId = encodeURIComponent(symbolOrAssetId);
        const response = await fetch(`${apiBaseUrl}/v2/assets/${encodedSymbolOrAssetId}`, {
            method: 'GET',
            headers: {
                'APCA-API-KEY-ID': APIKey,
                'APCA-API-SECRET-KEY': APISecret,
                'Content-Type': 'application/json',
            },
        });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to get asset: ${response.status} ${response.statusText} ${errorText}`);
        }
        return (await response.json());
    }
    catch (error) {
        console.error('Error in getAsset:', error);
        throw error;
    }
}

// market-hours.ts
const marketHolidays = {
    2024: {
        'New Year\'s Day': { date: '2024-01-01' },
        'Martin Luther King, Jr. Day': { date: '2024-01-15' },
        'Washington\'s Birthday': { date: '2024-02-19' },
        'Good Friday': { date: '2024-03-29' },
        'Memorial Day': { date: '2024-05-27' },
        'Juneteenth National Independence Day': { date: '2024-06-19' },
        'Independence Day': { date: '2024-07-04' },
        'Labor Day': { date: '2024-09-02' },
        'Thanksgiving Day': { date: '2024-11-28' },
        'Christmas Day': { date: '2024-12-25' }
    },
    2025: {
        'New Year\'s Day': { date: '2025-01-01' },
        'Jimmy Carter Memorial Day': { date: '2025-01-09' },
        'Martin Luther King, Jr. Day': { date: '2025-01-20' },
        'Washington\'s Birthday': { date: '2025-02-17' },
        'Good Friday': { date: '2025-04-18' },
        'Memorial Day': { date: '2025-05-26' },
        'Juneteenth National Independence Day': { date: '2025-06-19' },
        'Independence Day': { date: '2025-07-04' },
        'Labor Day': { date: '2025-09-01' },
        'Thanksgiving Day': { date: '2025-11-27' },
        'Christmas Day': { date: '2025-12-25' }
    },
    2026: {
        'New Year\'s Day': { date: '2026-01-01' },
        'Martin Luther King, Jr. Day': { date: '2026-01-19' },
        'Washington\'s Birthday': { date: '2026-02-16' },
        'Good Friday': { date: '2026-04-03' },
        'Memorial Day': { date: '2026-05-25' },
        'Juneteenth National Independence Day': { date: '2026-06-19' },
        'Independence Day': { date: '2026-07-03' },
        'Labor Day': { date: '2026-09-07' },
        'Thanksgiving Day': { date: '2026-11-26' },
        'Christmas Day': { date: '2026-12-25' }
    }
};
const marketEarlyCloses = {
    2024: {
        '2024-07-03': {
            date: '2024-07-03',
            time: '13:00',
            optionsTime: '13:15',
            notes: 'Market closes early on Wednesday, July 3, 2024 at 1:00 p.m. (1:15 p.m. for eligible options). NYSE American Equities, NYSE Arca Equities, NYSE Chicago, and NYSE National late trading sessions will close at 5:00 p.m. Eastern Time.'
        },
        '2024-11-29': {
            date: '2024-11-29',
            time: '13:00',
            optionsTime: '13:15',
            notes: 'Market closes early on Friday, November 29, 2024 at 1:00 p.m. (1:15 p.m. for eligible options). NYSE American Equities, NYSE Arca Equities, NYSE Chicago, and NYSE National late trading sessions will close at 5:00 p.m. Eastern Time.'
        },
        '2024-12-24': {
            date: '2024-12-24',
            time: '13:00',
            optionsTime: '13:15',
            notes: 'Market closes early on Tuesday, December 24, 2024 at 1:00 p.m. (1:15 p.m. for eligible options). NYSE American Equities, NYSE Arca Equities, NYSE Chicago, and NYSE National late trading sessions will close at 5:00 p.m. Eastern Time.'
        }
    },
    2025: {
        '2025-07-03': {
            date: '2025-07-03',
            time: '13:00',
            optionsTime: '13:15',
            notes: 'Market closes early on Thursday, July 3, 2025 at 1:00 p.m. (1:15 p.m. for eligible options). NYSE American Equities, NYSE Arca Equities, NYSE Chicago, and NYSE National late trading sessions will close at 5:00 p.m. Eastern Time.'
        },
        '2025-11-28': {
            date: '2025-11-28',
            time: '13:00',
            optionsTime: '13:15',
            notes: 'Market closes early on Friday, November 28, 2025 at 1:00 p.m. (1:15 p.m. for eligible options). NYSE American Equities, NYSE Arca Equities, NYSE Chicago, and NYSE National late trading sessions will close at 5:00 p.m. Eastern Time.'
        },
        '2025-12-24': {
            date: '2025-12-24',
            time: '13:00',
            optionsTime: '13:15',
            notes: 'Market closes early on Wednesday, December 24, 2025 at 1:00 p.m. (1:15 p.m. for eligible options). NYSE American Equities, NYSE Arca Equities, NYSE Chicago, and NYSE National late trading sessions will close at 5:00 p.m. Eastern Time.'
        }
    },
    2026: {
        '2026-07-02': {
            date: '2026-07-02',
            time: '13:00',
            optionsTime: '13:15',
            notes: 'Independence Day observed, market closes early at 1:00 p.m. (1:15 p.m. for eligible options). NYSE American Equities, NYSE Arca Equities, NYSE Chicago, and NYSE National late trading sessions will close at 5:00 p.m. Eastern Time.'
        },
        '2026-11-27': {
            date: '2026-11-27',
            time: '13:00',
            optionsTime: '13:15',
            notes: 'Market closes early on Friday, November 27, 2026 at 1:00 p.m. (1:15 p.m. for eligible options). NYSE American Equities, NYSE Arca Equities, NYSE Chicago, and NYSE National late trading sessions will close at 5:00 p.m. Eastern Time.'
        },
        '2026-12-24': {
            date: '2026-12-24',
            time: '13:00',
            optionsTime: '13:15',
            notes: 'Market closes early on Thursday, December 24, 2026 at 1:00 p.m. (1:15 p.m. for eligible options). NYSE American Equities, NYSE Arca Equities, NYSE Chicago, and NYSE National late trading sessions will close at 5:00 p.m. Eastern Time.'
        }
    }
};

// market-time.ts
/**
 * Market times for NYSE
 * Regular market hours are 9:30am-4:00pm
 * Early market hours are 9:30am-10:00am (first 30 minutes)
 * Extended market hours are 4:00am to 9:30am and 4:00pm-8:00pm
 * On days before some holidays, the market closes early at 1:00pm
 * Early extended market hours are 1:00pm-5:00pm on early close days
 */
const MARKET_TIMES = {
    TIMEZONE: 'America/New_York',
    PRE: { START: { HOUR: 4, MINUTE: 0, MINUTES: 240 }, END: { HOUR: 9, MINUTE: 30, MINUTES: 570 } },
    EARLY_MORNING: { START: { HOUR: 9, MINUTE: 30, MINUTES: 570 }, END: { HOUR: 10, MINUTE: 0, MINUTES: 600 } }, // early market trading
    EARLY_CLOSE_BEFORE_HOLIDAY: { START: { HOUR: 9, MINUTE: 30, MINUTES: 570 }, END: { HOUR: 13, MINUTE: 0, MINUTES: 780 } }, // early market trading end
    EARLY_EXTENDED_BEFORE_HOLIDAY: { START: { HOUR: 13, MINUTE: 0, MINUTES: 780 }, END: { HOUR: 17, MINUTE: 0, MINUTES: 1020 } }, // extended hours trading on early close days
    REGULAR: { START: { HOUR: 9, MINUTE: 30, MINUTES: 570 }, END: { HOUR: 16, MINUTE: 0, MINUTES: 960 } },
    EXTENDED: { START: { HOUR: 4, MINUTE: 0, MINUTES: 240 }, END: { HOUR: 20, MINUTE: 0, MINUTES: 1200 } },
};
/**
 * Utility class for handling market time-related operations
 */
class MarketTimeUtil {
    timezone;
    intradayReporting;
    /**
     * Creates a new MarketTimeUtil instance
     * @param {string} [timezone='America/New_York'] - The timezone to use for market time calculations
     * @param {IntradayReporting} [intradayReporting='market_hours'] - The intraday reporting mode
     */
    constructor(timezone = MARKET_TIMES.TIMEZONE, intradayReporting = 'market_hours') {
        this.validateTimezone(timezone);
        this.timezone = timezone;
        this.intradayReporting = intradayReporting;
    }
    /**
     * Validates the provided timezone
     * @private
     * @param {string} timezone - The timezone to validate
     * @throws {Error} If the timezone is invalid
     */
    validateTimezone(timezone) {
        try {
            Intl.DateTimeFormat(undefined, { timeZone: timezone });
        }
        catch (error) {
            throw new Error(`Invalid timezone: ${timezone}`);
        }
    }
    formatDate(date, outputFormat = 'iso') {
        switch (outputFormat) {
            case 'unix-seconds':
                return Math.floor(date.getTime() / 1000);
            case 'unix-ms':
                return date.getTime();
            case 'iso':
            default:
                // return with timezone offset
                return formatInTimeZone(date, this.timezone, "yyyy-MM-dd'T'HH:mm:ssXXX");
        }
    }
    isWeekend(date) {
        const day = date.getDay();
        return day === 0 || day === 6;
    }
    isHoliday(date) {
        const formattedDate = format(date, 'yyyy-MM-dd');
        const yearHolidays = marketHolidays[date.getFullYear()];
        for (const holiday in yearHolidays) {
            if (yearHolidays[holiday].date === formattedDate) {
                return true;
            }
        }
        return false;
    }
    isEarlyCloseDay(date) {
        const formattedDate = format(date, 'yyyy-MM-dd');
        const yearEarlyCloses = marketEarlyCloses[date.getFullYear()];
        return yearEarlyCloses && yearEarlyCloses[formattedDate] !== undefined;
    }
    /**
     * Get the early close time for a given date
     * @param date - The date to get the early close time for
     * @returns The early close time in minutes from midnight, or null if there is no early close
     */
    getEarlyCloseTime(date) {
        const formattedDate = format(date, 'yyyy-MM-dd');
        const yearEarlyCloses = marketEarlyCloses[date.getFullYear()];
        if (yearEarlyCloses && yearEarlyCloses[formattedDate]) {
            const [hours, minutes] = yearEarlyCloses[formattedDate].time.split(':').map(Number);
            return hours * 60 + minutes;
        }
        return null;
    }
    /**
     * Check if a given date is a market day
     * @param date - The date to check
     * @returns true if the date is a market day, false otherwise
     */
    isMarketDay(date) {
        const isWeekendDay = this.isWeekend(date);
        const isHolidayDay = this.isHoliday(date);
        const returner = !isWeekendDay && !isHolidayDay;
        return returner;
    }
    /**
     * Check if a given date is within market hours
     * @param date - The date to check
     * @returns true if the date is within market hours, false otherwise
     */
    isWithinMarketHours(date) {
        // Check for holidays first
        if (this.isHoliday(date)) {
            return false;
        }
        const timeInMinutes = date.getHours() * 60 + date.getMinutes();
        // Check for early closure
        if (this.isEarlyCloseDay(date)) {
            const earlyCloseMinutes = this.getEarlyCloseTime(date);
            if (earlyCloseMinutes !== null && timeInMinutes > earlyCloseMinutes) {
                return false;
            }
        }
        // Regular market hours logic
        let returner;
        switch (this.intradayReporting) {
            case 'extended_hours': {
                const extendedStartMinutes = MARKET_TIMES.EXTENDED.START.HOUR * 60 + MARKET_TIMES.EXTENDED.START.MINUTE;
                const extendedEndMinutes = MARKET_TIMES.EXTENDED.END.HOUR * 60 + MARKET_TIMES.EXTENDED.END.MINUTE;
                // Comprehensive handling of times crossing midnight
                const adjustedDate = timeInMinutes < extendedStartMinutes ? sub(date, { days: 1 }) : date;
                const adjustedTimeInMinutes = adjustedDate.getHours() * 60 + adjustedDate.getMinutes();
                returner = adjustedTimeInMinutes >= extendedStartMinutes && adjustedTimeInMinutes <= extendedEndMinutes;
                break;
            }
            case 'continuous':
                returner = true;
                break;
            default: {
                // market_hours
                const regularStartMinutes = MARKET_TIMES.REGULAR.START.HOUR * 60 + MARKET_TIMES.REGULAR.START.MINUTE;
                const regularEndMinutes = MARKET_TIMES.REGULAR.END.HOUR * 60 + MARKET_TIMES.REGULAR.END.MINUTE;
                returner = timeInMinutes >= regularStartMinutes && timeInMinutes <= regularEndMinutes;
                break;
            }
        }
        return returner;
    }
    /**
     * Check if a given date is before market hours
     * @param date - The date to check
     * @returns true if the date is before market hours, false otherwise
     */
    isBeforeMarketHours(date) {
        const timeInMinutes = date.getHours() * 60 + date.getMinutes();
        const startMinutes = this.intradayReporting === 'extended_hours'
            ? MARKET_TIMES.EXTENDED.START.HOUR * 60 + MARKET_TIMES.EXTENDED.START.MINUTE
            : MARKET_TIMES.REGULAR.START.HOUR * 60 + MARKET_TIMES.REGULAR.START.MINUTE;
        return timeInMinutes < startMinutes;
    }
    /**
     * Get the last trading date, i.e. the last date that was a market day
     * @param currentDate - The current date
     * @returns The last trading date
     */
    getLastTradingDate(currentDate = new Date()) {
        const nowET = toZonedTime(currentDate, this.timezone);
        const isMarketDayToday = this.isMarketDay(nowET);
        const currentMinutes = nowET.getHours() * 60 + nowET.getMinutes();
        const marketOpenMinutes = MARKET_TIMES.REGULAR.START.HOUR * 60 + MARKET_TIMES.REGULAR.START.MINUTE;
        if (isMarketDayToday && currentMinutes >= marketOpenMinutes) {
            // After market open on a market day, return today
            return nowET;
        }
        else {
            // Before market open, or not a market day, return previous trading day
            let lastTradingDate = sub(nowET, { days: 1 });
            while (!this.isMarketDay(lastTradingDate)) {
                lastTradingDate = sub(lastTradingDate, { days: 1 });
            }
            return lastTradingDate;
        }
    }
    getLastMarketDay(date) {
        let currentDate = sub(date, { days: 1 });
        while (!this.isMarketDay(currentDate)) {
            currentDate = sub(currentDate, { days: 1 });
        }
        return currentDate;
    }
    getLastFullTradingDate(currentDate = new Date()) {
        const nowET = toZonedTime(currentDate, this.timezone);
        // If today is a market day and we're after extended hours close
        // then return today since it's a completed trading day
        if (this.isMarketDay(nowET)) {
            const timeInMinutes = nowET.getHours() * 60 + nowET.getMinutes();
            const extendedEndMinutes = MARKET_TIMES.EXTENDED.END.HOUR * 60 + MARKET_TIMES.EXTENDED.END.MINUTE;
            // Check if we're after market close (including extended hours)
            if (timeInMinutes >= extendedEndMinutes) {
                // Set to midnight ET while preserving the date
                return fromZonedTime(set(nowET, { hours: 0, minutes: 0, seconds: 0, milliseconds: 0 }), this.timezone);
            }
        }
        // In all other cases (during trading hours, before market open, holidays, weekends),
        // we want the last completed trading day
        let lastFullDate = this.getLastMarketDay(nowET);
        // Set to midnight ET while preserving the date
        return fromZonedTime(set(lastFullDate, { hours: 0, minutes: 0, seconds: 0, milliseconds: 0 }), this.timezone);
    }
    /**
     * Gets the next market day from a reference date
     * @param {Object} [options] - Options object
     * @param {Date} [options.referenceDate] - The reference date (defaults to current date)
     * @returns {Object} The next market day information
     * @property {Date} date - The date object (start of day in NY time)
     * @property {string} yyyymmdd - The date in YYYY-MM-DD format
     * @property {string} dateISOString - Full ISO date string
     */
    getNextMarketDay(date) {
        let currentDate = add(date, { days: 1 });
        while (!this.isMarketDay(currentDate)) {
            currentDate = add(currentDate, { days: 1 });
        }
        return currentDate;
    }
    getDayBoundaries(date) {
        let start;
        let end;
        switch (this.intradayReporting) {
            case 'extended_hours': {
                start = set(date, {
                    hours: MARKET_TIMES.EXTENDED.START.HOUR,
                    minutes: MARKET_TIMES.EXTENDED.START.MINUTE,
                    seconds: 0,
                    milliseconds: 0,
                });
                end = set(date, {
                    hours: MARKET_TIMES.EXTENDED.END.HOUR,
                    minutes: MARKET_TIMES.EXTENDED.END.MINUTE,
                    seconds: 59,
                    milliseconds: 999,
                });
                break;
            }
            case 'continuous': {
                start = startOfDay(date);
                end = endOfDay(date);
                break;
            }
            default: {
                // market_hours
                start = set(date, {
                    hours: MARKET_TIMES.REGULAR.START.HOUR,
                    minutes: MARKET_TIMES.REGULAR.START.MINUTE,
                    seconds: 0,
                    milliseconds: 0,
                });
                // Check for early close
                if (this.isEarlyCloseDay(date)) {
                    const earlyCloseMinutes = this.getEarlyCloseTime(date);
                    if (earlyCloseMinutes !== null) {
                        const earlyCloseHours = Math.floor(earlyCloseMinutes / 60);
                        const earlyCloseMinutesRemainder = earlyCloseMinutes % 60;
                        end = set(date, {
                            hours: earlyCloseHours,
                            minutes: earlyCloseMinutesRemainder,
                            seconds: 59,
                            milliseconds: 999,
                        });
                        break;
                    }
                }
                end = set(date, {
                    hours: MARKET_TIMES.REGULAR.END.HOUR,
                    minutes: MARKET_TIMES.REGULAR.END.MINUTE,
                    seconds: 59,
                    milliseconds: 999,
                });
                break;
            }
        }
        return { start, end };
    }
    calculatePeriodStartDate(endDate, period) {
        let startDate;
        switch (period) {
            case 'YTD':
                startDate = set(endDate, { month: 0, date: 1 });
                break;
            case '1D':
                startDate = this.getLastMarketDay(endDate);
                break;
            case '3D':
                startDate = sub(endDate, { days: 3 });
                break;
            case '1W':
                startDate = sub(endDate, { weeks: 1 });
                break;
            case '2W':
                startDate = sub(endDate, { weeks: 2 });
                break;
            case '1M':
                startDate = sub(endDate, { months: 1 });
                break;
            case '3M':
                startDate = sub(endDate, { months: 3 });
                break;
            case '6M':
                startDate = sub(endDate, { months: 6 });
                break;
            case '1Y':
                startDate = sub(endDate, { years: 1 });
                break;
            default:
                throw new Error(`Invalid period: ${period}`);
        }
        while (!this.isMarketDay(startDate)) {
            startDate = this.getNextMarketDay(startDate);
        }
        return startDate;
    }
    getMarketTimePeriod({ period, end = new Date(), intraday_reporting, outputFormat = 'iso', }) {
        if (!period) {
            throw new Error('Period is required');
        }
        if (intraday_reporting) {
            this.intradayReporting = intraday_reporting;
        }
        // Convert end date to specified timezone
        const zonedEndDate = toZonedTime(end, this.timezone);
        let startDate;
        let endDate;
        const isCurrentMarketDay = this.isMarketDay(zonedEndDate);
        const isWithinHours = this.isWithinMarketHours(zonedEndDate);
        const isBeforeHours = this.isBeforeMarketHours(zonedEndDate);
        // First determine the end date based on current market conditions
        if (isCurrentMarketDay) {
            if (isBeforeHours) {
                // Case 1: Market day before open hours - use previous full trading day
                const lastMarketDay = this.getLastMarketDay(zonedEndDate);
                const { end: dayEnd } = this.getDayBoundaries(lastMarketDay);
                endDate = dayEnd;
            }
            else if (isWithinHours) {
                // Case 2: Market day during hours - use current time
                endDate = zonedEndDate;
            }
            else {
                // Case 3: Market day after close - use today's close
                const { end: dayEnd } = this.getDayBoundaries(zonedEndDate);
                endDate = dayEnd;
            }
        }
        else {
            // Case 4: Not a market day - use previous market day's close
            const lastMarketDay = this.getLastMarketDay(zonedEndDate);
            const { end: dayEnd } = this.getDayBoundaries(lastMarketDay);
            endDate = dayEnd;
        }
        // Now calculate the start date based on the period
        const periodStartDate = this.calculatePeriodStartDate(endDate, period);
        const { start: dayStart } = this.getDayBoundaries(periodStartDate);
        startDate = dayStart;
        // Convert boundaries back to UTC for final output
        const utcStart = fromZonedTime(startDate, this.timezone);
        const utcEnd = fromZonedTime(endDate, this.timezone);
        // Ensure start is not after end
        if (isBefore(utcEnd, utcStart)) {
            throw new Error('Start date cannot be after end date');
        }
        return {
            start: this.formatDate(utcStart, outputFormat),
            end: this.formatDate(utcEnd, outputFormat),
        };
    }
    getMarketOpenClose(options = {}) {
        const { date = new Date() } = options;
        const zonedDate = toZonedTime(date, this.timezone);
        // Check if market is closed for the day
        if (this.isWeekend(zonedDate) || this.isHoliday(zonedDate)) {
            return {
                marketOpen: false,
                open: null,
                close: null,
                openExt: null,
                closeExt: null,
            };
        }
        const dayStart = startOfDay(zonedDate);
        const regularOpenTime = MARKET_TIMES.REGULAR.START;
        let regularCloseTime = MARKET_TIMES.REGULAR.END;
        const extendedOpenTime = MARKET_TIMES.EXTENDED.START;
        let extendedCloseTime = MARKET_TIMES.EXTENDED.END;
        // Check for early close
        const isEarlyClose = this.isEarlyCloseDay(zonedDate);
        if (isEarlyClose) {
            const earlyCloseMinutes = this.getEarlyCloseTime(zonedDate);
            if (earlyCloseMinutes !== null) {
                // For regular hours, use the early close time
                regularCloseTime = {
                    HOUR: Math.floor(earlyCloseMinutes / 60),
                    MINUTE: earlyCloseMinutes % 60,
                    MINUTES: earlyCloseMinutes,
                };
                // For extended hours on early close days, close at 5:00 PM
                extendedCloseTime = {
                    HOUR: 17,
                    MINUTE: 0,
                    MINUTES: 1020,
                };
            }
        }
        const open = fromZonedTime(set(dayStart, { hours: regularOpenTime.HOUR, minutes: regularOpenTime.MINUTE }), this.timezone);
        const close = fromZonedTime(set(dayStart, { hours: regularCloseTime.HOUR, minutes: regularCloseTime.MINUTE }), this.timezone);
        const openExt = fromZonedTime(set(dayStart, { hours: extendedOpenTime.HOUR, minutes: extendedOpenTime.MINUTE }), this.timezone);
        const closeExt = fromZonedTime(set(dayStart, { hours: extendedCloseTime.HOUR, minutes: extendedCloseTime.MINUTE }), this.timezone);
        return {
            marketOpen: true,
            open,
            close,
            openExt,
            closeExt,
        };
    }
}
/**
 * Creates a new MarketTimeUtil instance
 * @param {string} [timezone] - The timezone to use for market time calculations
 * @param {IntradayReporting} [intraday_reporting] - The intraday reporting mode
 * @returns {MarketTimeUtil} A new MarketTimeUtil instance
 */
function createMarketTimeUtil(timezone, intraday_reporting) {
    return new MarketTimeUtil(timezone, intraday_reporting);
}
/**
 * Gets start and end timestamps for a given market time period
 * @param {MarketTimeParams} [params] - The market time parameters
 * @returns {PeriodDates} The start and end timestamps
 */
function getStartAndEndTimestamps(params = {}) {
    const util = createMarketTimeUtil(params.timezone, params.intraday_reporting);
    const effectiveParams = {
        ...params,
        end: params.referenceDate || params.end || new Date(),
    };
    return util.getMarketTimePeriod(effectiveParams);
}
/**
 * Gets the market open/close times for a given date
 * @param {Object} [options] - Options object
 * @param {Date} [options.date] - The date to check (defaults to current date)
 * @returns {MarketOpenCloseResult} The market open/close times
 */
function getMarketOpenClose(options = {}) {
    const marketTimeUtil = new MarketTimeUtil();
    return marketTimeUtil.getMarketOpenClose(options);
}
/**
 * Gets the start and end dates for a given market time period
 * @param {MarketTimeParams} [params] - The market time parameters
 * @returns {Object} The start and end dates
 * @property {Date} start - The start date
 * @property {Date} end - The end date
 */
function getStartAndEndDates(params = {}) {
    const util = createMarketTimeUtil(params.timezone, params.intraday_reporting);
    const effectiveParams = {
        ...params,
        end: params.referenceDate || params.end || new Date(),
    };
    const { start, end } = util.getMarketTimePeriod(effectiveParams);
    // Ensure the returned values are Dates
    return {
        start: new Date(start),
        end: new Date(end),
    };
}
/**
 * Gets the last trading date in YYYY-MM-DD format
 * @returns {string} The last trading date in YYYY-MM-DD format
 */
function getLastTradingDateYYYYMMDD() {
    const util = new MarketTimeUtil();
    const lastTradingDate = util.getLastTradingDate();
    return format(lastTradingDate, 'yyyy-MM-dd');
}
/**
 * Gets the last full trading date
 * @param {Date} [currentDate] - The current date (defaults to now)
 * @returns {Object} The last full trading date
 * @property {Date} date - The date object
 * @property {string} YYYYMMDD - The date in YYYY-MM-DD format
 */
function getLastFullTradingDate(currentDate = new Date()) {
    const util = new MarketTimeUtil();
    const date = util.getLastFullTradingDate(currentDate);
    // Format the date in NY timezone to ensure consistency
    return {
        date,
        YYYYMMDD: formatInTimeZone(date, MARKET_TIMES.TIMEZONE, 'yyyy-MM-dd'),
    };
}
/**
 * Gets the next market day from a reference date
 * @param {Object} [options] - Options object
 * @param {Date} [options.referenceDate] - The reference date (defaults to current date)
 * @returns {Object} The next market day information
 * @property {Date} date - The date object (start of day in NY time)
 * @property {string} yyyymmdd - The date in YYYY-MM-DD format
 * @property {string} dateISOString - Full ISO date string
 */
function getNextMarketDay({ referenceDate } = {}) {
    const util = new MarketTimeUtil();
    const startDate = referenceDate || new Date();
    const nextDate = util.getNextMarketDay(startDate);
    // Convert to start of day in NY time
    const startOfDayNY = startOfDay(toZonedTime(nextDate, MARKET_TIMES.TIMEZONE));
    const dateInET = fromZonedTime(startOfDayNY, MARKET_TIMES.TIMEZONE);
    return {
        date: dateInET,
        yyyymmdd: formatInTimeZone(dateInET, MARKET_TIMES.TIMEZONE, 'yyyy-MM-dd'),
        dateISOString: dateInET.toISOString()
    };
}
/**
 * Gets the current time in Eastern Time
 * @returns {Date} The current time in Eastern Time
 */
const currentTimeET = () => {
    return toZonedTime(new Date(), MARKET_TIMES.TIMEZONE);
};
/**
 * Gets a date in New York timezone, rezoned using date-fns-tz
 * @param {number|string|Date} time - The time to convert
 * @returns {Date} The date in New York timezone
 */
function getDateInNY(time) {
    let date;
    if (typeof time === 'number' || typeof time === 'string' || time instanceof Date) {
        // Assuming Unix timestamp in epoch milliseconds, string date, or Date object
        date = new Date(time);
    }
    else {
        // Assuming object with year, month, and day
        date = new Date(time.year, time.month - 1, time.day);
    }
    return toZonedTime(date, 'America/New_York');
}
/**
 * Gets the trading date in YYYY-MM-DD format for New York timezone, for grouping of data
 * @param {string|number|Date} time - The time to convert (string, unix timestamp in ms, or Date object)
 * @returns {string} The trading date in YYYY-MM-DD format
 */
function getTradingDate(time) {
    let date;
    if (typeof time === 'number') {
        // Assuming Unix timestamp in milliseconds
        date = new Date(time);
    }
    else if (typeof time === 'string') {
        date = new Date(time);
    }
    else {
        date = time;
    }
    // Convert to NY timezone and format as YYYY-MM-DD
    return formatInTimeZone(date, MARKET_TIMES.TIMEZONE, 'yyyy-MM-dd');
}
/**
 * Returns the New York timezone offset based on whether daylight savings is active
 * @param dateString - The date string to check
 * @returns "-04:00" during daylight savings (EDT) or "-05:00" during standard time (EST)
 */
const getNYTimeZone = (date) => {
    if (!date) {
        date = new Date();
    }
    const dtf = new Intl.DateTimeFormat('en-US', {
        timeZone: 'America/New_York',
        timeZoneName: 'shortOffset',
    });
    const parts = dtf.formatToParts(date);
    const tz = parts.find((p) => p.type === 'timeZoneName')?.value;
    // tz will be "GMT-5" or "GMT-4"
    if (!tz) {
        throw new Error('Could not determine New York offset');
    }
    // extract the -4 or -5 from the string
    const shortOffset = tz.replace('GMT', '');
    // return the correct offset
    if (shortOffset === '-4') {
        console.log(`New York is on EDT; using -04:00. Full date: ${date.toLocaleString('en-US', {
            timeZone: 'America/New_York',
        })}, time zone part: ${tz}`);
        return '-04:00';
    }
    else if (shortOffset === '-5') {
        console.log(`New York is on EST; using -05:00. Full date: ${date.toLocaleString('en-US', {
            timeZone: 'America/New_York',
        })}, time zone part: ${tz}`);
        return '-05:00';
    }
    else {
        throw new Error('Could not determine New York offset');
    }
};
/**
 * Gets the current market status
 * @param {Object} [options] - Options object
 * @param {Date} [options.date] - The date to check (defaults to current date)
 * @returns {MarketStatus} The current market status
 */
function getMarketStatus(options = {}) {
    const util = new MarketTimeUtil();
    const now = options.date || new Date();
    const nyTime = toZonedTime(now, MARKET_TIMES.TIMEZONE);
    const isEarlyCloseDay = util.isEarlyCloseDay(nyTime);
    const timeInMinutes = nyTime.getHours() * 60 + nyTime.getMinutes();
    const extendedStartMinutes = MARKET_TIMES.EXTENDED.START.MINUTES;
    const marketStartMinutes = MARKET_TIMES.REGULAR.START.MINUTES;
    MARKET_TIMES.EARLY_MORNING.END.MINUTES;
    const marketRegularCloseMinutes = isEarlyCloseDay
        ? MARKET_TIMES.EARLY_CLOSE_BEFORE_HOLIDAY.END.MINUTES
        : MARKET_TIMES.REGULAR.END.MINUTES;
    const extendedEndMinutes = isEarlyCloseDay
        ? MARKET_TIMES.EARLY_EXTENDED_BEFORE_HOLIDAY.END.MINUTES
        : MARKET_TIMES.EXTENDED.END.MINUTES;
    let status;
    let nextStatus;
    let nextStatusTime;
    let marketPeriod;
    const nextMarketDay = util.getNextMarketDay(nyTime);
    // Determine current status and market period
    if (!util.isMarketDay(nyTime)) {
        // Not a market day! market is closed
        marketPeriod = 'closed';
        status = 'closed';
        nextStatus = 'extended hours';
        // Find next market day and set to extended hours start time
        nextStatusTime = set(nextMarketDay, {
            hours: MARKET_TIMES.EXTENDED.START.HOUR,
            minutes: MARKET_TIMES.EXTENDED.START.MINUTE,
        });
    } // check if the market isn't in extended hours yet
    else if (timeInMinutes >= 0 && timeInMinutes < extendedStartMinutes) {
        marketPeriod = 'closed';
        status = 'closed';
        nextStatus = 'extended hours';
        nextStatusTime = set(nyTime, {
            hours: MARKET_TIMES.EXTENDED.START.HOUR,
            minutes: MARKET_TIMES.EXTENDED.START.MINUTE,
        });
        // check if we're in pre-market hours
    }
    else if (timeInMinutes >= extendedStartMinutes && timeInMinutes < marketStartMinutes) {
        marketPeriod = 'preMarket';
        status = 'extended hours';
        nextStatus = 'open';
        nextStatusTime = set(nyTime, {
            hours: MARKET_TIMES.REGULAR.START.HOUR,
            minutes: MARKET_TIMES.REGULAR.START.MINUTE,
        });
        // check if market is open
    }
    else if (timeInMinutes >= marketStartMinutes && timeInMinutes < marketRegularCloseMinutes) {
        status = 'open';
        nextStatus = 'extended hours';
        // market is open, but just check the marketPeriod - could be earlyMarket or regularMarket
        marketPeriod = timeInMinutes < MARKET_TIMES.EARLY_MORNING.END.MINUTES ? 'earlyMarket' : 'regularMarket';
        nextStatusTime = isEarlyCloseDay
            ? set(nyTime, {
                hours: MARKET_TIMES.EARLY_CLOSE_BEFORE_HOLIDAY.END.HOUR,
                minutes: MARKET_TIMES.EARLY_CLOSE_BEFORE_HOLIDAY.END.MINUTE,
            })
            : set(nyTime, {
                hours: MARKET_TIMES.REGULAR.END.HOUR,
                minutes: MARKET_TIMES.REGULAR.END.MINUTE,
            });
        // check if it's after-market extended hours
    }
    else if (timeInMinutes >= marketRegularCloseMinutes && timeInMinutes < extendedEndMinutes) {
        status = 'extended hours';
        nextStatus = 'closed';
        marketPeriod = 'afterMarket';
        nextStatusTime = isEarlyCloseDay
            ? set(nyTime, {
                hours: MARKET_TIMES.EARLY_EXTENDED_BEFORE_HOLIDAY.END.HOUR,
                minutes: MARKET_TIMES.EARLY_EXTENDED_BEFORE_HOLIDAY.END.MINUTE,
            })
            : set(nyTime, {
                hours: MARKET_TIMES.EXTENDED.END.HOUR,
                minutes: MARKET_TIMES.EXTENDED.END.MINUTE,
            });
        // otherwise, the market is closed
    }
    else {
        status = 'closed';
        nextStatus = 'extended hours';
        marketPeriod = 'closed';
        nextStatusTime = set(nextMarketDay, {
            hours: MARKET_TIMES.EXTENDED.START.HOUR,
            minutes: MARKET_TIMES.EXTENDED.START.MINUTE,
        });
    }
    const dateFormat = 'MMMM dd, yyyy, HH:mm:ss a';
    return {
        time: now,
        timeString: format(nyTime, dateFormat),
        status,
        nextStatus,
        marketPeriod,
        nextStatusTime: fromZonedTime(nextStatusTime, MARKET_TIMES.TIMEZONE),
        nextStatusTimeDifference: differenceInMilliseconds(nextStatusTime, nyTime),
        nextStatusTimeString: format(nextStatusTime, dateFormat),
    };
}

// performance-metrics.ts
/**
 * Calculates the total return year-to-date (YTD) for a given portfolio history.
 * @param portfolioHistory - The portfolio history data containing equity values.
 * @returns A promise that resolves to a string representing the total return YTD in percentage format.
 */
async function calculateTotalReturnYTD(portfolioHistory) {
    const equity = portfolioHistory.equity; // array of equity values
    if (!equity || !Array.isArray(equity) || equity.length < 2) {
        console.warn('Not enough data to calculate total return.');
        return 'N/A';
    }
    let startEquity = equity[0];
    const endEquity = equity[equity.length - 1];
    // Validate startEquity and endEquity
    if (typeof startEquity !== 'number' || isNaN(startEquity)) {
        console.warn('Invalid start equity value.');
        return 'N/A';
    }
    // if startEquity is 0 or less, fetch the first non-zero value in the array
    if (startEquity <= 0) {
        for (let i = 1; i < equity.length; i++) {
            if (equity[i] > 0) {
                startEquity = equity[i];
                break;
            }
        }
    }
    if (typeof endEquity !== 'number' || isNaN(endEquity)) {
        console.warn('Invalid end equity value.');
    }
    // Calculate total return
    const totalReturn = ((endEquity - startEquity) / startEquity) * 100;
    return `${totalReturn.toFixed(2)}%`;
}
/**
 * Calculates the expense ratio for a given Alpaca account.
 * @param accountId - The ID of the Alpaca account.
 * @param client - The Apollo client instance.
 * @param alpacaAccount - The Alpaca account object.
 * @returns A promise that resolves to a string representing the expense ratio in percentage format.
 */
async function calculateExpenseRatio$1({ accountId, client, alpacaAccount }) {
    if (!accountId && !alpacaAccount && !client) {
        console.warn('Missing account ID or client to calculate expense ratio.');
        return 'N/A';
    }
    let alpacaAccountId = accountId || (alpacaAccount && alpacaAccount.id) || '';
    let accountDetails;
    if (!alpacaAccountId) {
        console.warn('Invalid account ID.');
        return 'N/A';
    }
    if (alpacaAccount) {
        // Use Alpaca account object to get accountDetails
        accountDetails = await fetchAccountDetails({ alpacaAccount: alpacaAccount });
        if (!accountDetails) {
            console.warn('Failed to fetch account details inside calculateExpenseRatio.');
            return 'N/A';
        }
    }
    else {
        // Fetch account details using account ID and client
        accountDetails = await fetchAccountDetails({ accountId, client });
        if (!accountDetails) {
            console.warn('Failed to fetch account details inside calculateExpenseRatio.');
            return 'N/A';
        }
    }
    // Validate equity
    if (!accountDetails.equity || isNaN(parseFloat(accountDetails.equity))) {
        console.warn('Invalid equity value.');
        return 'N/A';
    }
    const equity = parseFloat(accountDetails.equity);
    // Fetch portfolio expenses from your system (Assuming you have this data)
    const expenses = await getPortfolioExpensesFromYourSystem();
    // Calculate expense ratio
    const expenseRatio = (expenses / equity) * 100;
    return `${expenseRatio.toFixed(2)}%`;
}
// Mock function to represent fetching expenses from your system
async function getPortfolioExpensesFromYourSystem(accountId) {
    // Implement this function based on your data storage
    return 0; // Placeholder
}
/**
 * Calculates the liquidity ratio for a given Alpaca account.
 * @param accountId - The ID of the Alpaca account.
 * @param client - The Apollo client instance.
 * @param alpacaAccount - The Alpaca account object.
 * @returns A promise that resolves to a string representing the liquidity ratio in the format "1:ratio".
 */
async function calculateLiquidityRatio({ accountId, client, alpacaAccount }) {
    if (!accountId && !alpacaAccount && !client) {
        console.warn('Missing account ID or client to calculateLiquidityRatio.');
        return 'N/A';
    }
    let alpacaAccountId = accountId || (alpacaAccount && alpacaAccount.id) || '';
    let accountDetails;
    if (!alpacaAccountId) {
        console.warn('Invalid account ID.');
        return 'N/A';
    }
    if (alpacaAccount) {
        // Use Alpaca account object to get accountDetails
        accountDetails = await fetchAccountDetails({ alpacaAccount: alpacaAccount });
        if (!accountDetails) {
            console.warn('Failed to fetch account details inside calculateLiquidityRatio.');
            return 'N/A';
        }
    }
    else {
        // Fetch account details using account ID and client
        accountDetails = await fetchAccountDetails({ accountId, client });
        if (!accountDetails) {
            console.warn('Failed to fetch account details.');
            return 'N/A';
        }
    }
    const cashBalance = parseFloat(accountDetails.cash);
    const equity = parseFloat(accountDetails.equity);
    const totalPositionsValue = equity - cashBalance;
    if (isNaN(cashBalance)) {
        console.warn('Invalid cash balance.');
        return 'N/A';
    }
    if (isNaN(equity)) {
        console.warn('Invalid equity value.');
        return 'N/A';
    }
    // Calculate total portfolio value
    const totalPortfolioValue = cashBalance + totalPositionsValue;
    if (totalPortfolioValue <= 0) {
        console.warn('Total portfolio value is zero or negative.');
        return 'N/A';
    }
    // Calculate liquidity ratio as Total Portfolio Value to Cash Balance
    const ratio = totalPortfolioValue / cashBalance;
    // Ensure the ratio is a finite number
    if (!isFinite(ratio)) {
        console.warn('Liquidity ratio calculation resulted in a non-finite number.');
        return 'N/A';
    }
    return `1:${ratio.toFixed(2)}`;
}
/**
 * Calculates the risk-adjusted return for a given portfolio history.
 * @param portfolioHistory - The portfolio history data containing profit/loss percentages.
 * @returns A promise that resolves to a string representing the risk-adjusted return.
 */
async function calculateRiskAdjustedReturn$1(portfolioHistory) {
    const returns = portfolioHistory.profit_loss_pct; // Array of percentage returns in decimal form
    // Validate the returns array
    if (!returns || !Array.isArray(returns) || returns.length < 2) {
        console.warn('No returns data available.');
        return 'N/A';
    }
    // Filter out invalid returns
    const validReturns = returns.filter((ret) => typeof ret === 'number' && !isNaN(ret));
    if (validReturns.length < 2) {
        console.warn('Not enough valid returns data to calculate risk-adjusted return.');
        return 'N/A';
    }
    // Calculate average daily return
    const avgDailyReturn = validReturns.reduce((sum, ret) => sum + ret, 0) / validReturns.length;
    // Calculate standard deviation of daily returns
    const mean = avgDailyReturn;
    const squaredDiffs = validReturns.map((ret) => Math.pow(ret - mean, 2));
    const variance = squaredDiffs.reduce((sum, diff) => sum + diff, 0) / (validReturns.length - 1);
    const stdDevDaily = Math.sqrt(variance);
    // Annualize average return and standard deviation
    const tradingDaysPerYear = 252;
    const avgAnnualReturn = avgDailyReturn * tradingDaysPerYear;
    const stdDevAnnual = stdDevDaily * Math.sqrt(tradingDaysPerYear);
    // Check for zero or non-finite standard deviation
    if (!isFinite(stdDevAnnual) || stdDevAnnual === 0) {
        console.warn('Standard deviation is zero or non-finite, cannot calculate Sharpe ratio.');
        return 'N/A';
    }
    // Assume a risk-free rate, e.g., 2%
    const riskFreeRate = 0.02; // Annual risk-free rate (2%)
    // Calculate Sharpe Ratio
    const sharpeRatio = (avgAnnualReturn - riskFreeRate) / stdDevAnnual;
    if (!isFinite(sharpeRatio)) {
        console.warn('Sharpe ratio calculation resulted in a non-finite number.');
        return 'N/A';
    }
    // Return the Sharpe Ratio formatted to two decimal places
    return `${sharpeRatio.toFixed(2)}`;
}
/**
 * Retrieves the dividend yield for the portfolio.
 * @returns A promise that resolves to a string representing the dividend yield.
 */
async function getDividendYield() {
    return "N/A";
}
/**
 * Cleans the portfolio equity data by replacing NaN and Infinity values with the last valid value.
 * @param equity - Array of portfolio equity values.
 * @returns Cleaned equity array.
 */
function interpolatePortfolioEquity(equity) {
    const cleanedEquity = [];
    let lastValid = 0;
    for (let i = 0; i < equity.length; i++) {
        if (isFinite(equity[i])) {
            cleanedEquity.push(equity[i]);
            lastValid = equity[i];
        }
        else {
            console.warn(`Invalid equity value at index ${i}: ${equity[i]}. Replacing with last valid value: ${lastValid}`);
            cleanedEquity.push(lastValid);
        }
    }
    return cleanedEquity;
}
/**
 * Calculates the alpha, beta, and annualized Alpha of the portfolio compared to a benchmark.
 * @param portfolioHistory - The portfolio history data.
 * @param benchmarkBars - The historical price data of the benchmark.
 * @returns An object containing alpha, beta, and annualized alpha.
 */
async function calculateAlphaAndBeta$1(portfolioHistory, benchmarkBars) {
    if (!portfolioHistory || !benchmarkBars || benchmarkBars.length < 2) {
        console.warn('Insufficient portfolio or benchmark data.', {
            portfolioHistory,
            benchmarkBars,
        });
        return {
            alpha: 'N/A',
            alphaAnnualized: 'N/A',
            beta: 'N/A',
        };
    }
    let portfolioEquity = portfolioHistory.equity;
    let portfolioTimestamps = portfolioHistory.timestamp;
    if (!portfolioEquity ||
        !Array.isArray(portfolioEquity) ||
        portfolioEquity.length < 2 ||
        !portfolioTimestamps ||
        !Array.isArray(portfolioTimestamps) ||
        portfolioTimestamps.length !== portfolioEquity.length) {
        console.warn('Invalid or insufficient portfolio equity data.', {
            portfolioEquity,
            portfolioTimestamps,
        });
        return {
            alpha: 'N/A',
            alphaAnnualized: 'N/A',
            beta: 'N/A',
        };
    }
    // **Trim initial zero equity values**
    const firstNonZeroIndex = portfolioEquity.findIndex((equity) => equity !== 0);
    if (firstNonZeroIndex === -1) {
        console.warn('Portfolio equity contains only zeros.');
        return {
            alpha: 'N/A',
            alphaAnnualized: 'N/A',
            beta: 'N/A',
        };
    }
    portfolioEquity = portfolioEquity.slice(firstNonZeroIndex);
    portfolioTimestamps = portfolioTimestamps.slice(firstNonZeroIndex);
    // **Convert portfolio timestamps from ISO strings to Unix milliseconds**
    portfolioTimestamps = portfolioTimestamps.map((timestamp) => timestamp * 1000);
    // **Normalize portfolio timestamps to midnight UTC**
    portfolioTimestamps = portfolioTimestamps.map((timestamp) => getMidnightTimestamp(timestamp));
    // **Clean the portfolio equity data**
    const cleanedPortfolioEquity = interpolatePortfolioEquity(portfolioEquity);
    // **Calculate portfolio returns with Unix millisecond timestamps**
    const portfolioReturnsWithDates = calculateDailyReturnsWithTimestamps(cleanedPortfolioEquity, portfolioTimestamps);
    // **Process benchmark data**
    const benchmarkPrices = benchmarkBars.map((bar) => bar.c);
    let benchmarkTimestamps = benchmarkBars.map((bar) => bar.t);
    if (!benchmarkPrices ||
        !Array.isArray(benchmarkPrices) ||
        benchmarkPrices.length < 2 ||
        !benchmarkTimestamps ||
        !Array.isArray(benchmarkTimestamps) ||
        benchmarkTimestamps.length !== benchmarkPrices.length) {
        console.warn('Invalid or insufficient benchmark data.', {
            benchmarkPrices,
            benchmarkTimestamps,
        });
        return {
            alpha: 'N/A',
            alphaAnnualized: 'N/A',
            beta: 'N/A',
        };
    }
    // **Convert benchmark timestamps from Unix seconds to Unix milliseconds**
    benchmarkTimestamps = benchmarkTimestamps.map((timestamp) => timestamp * 1000);
    // **Normalize benchmark timestamps to midnight UTC**
    benchmarkTimestamps = benchmarkTimestamps.map((timestamp) => getMidnightTimestamp(timestamp));
    // **Calculate benchmark returns with Unix millisecond timestamps**
    const benchmarkReturnsWithDates = calculateDailyReturnsWithTimestamps(benchmarkPrices, benchmarkTimestamps);
    // **Align returns by timestamp and ensure returns are finite**
    const portfolioReturnsMap = new Map();
    portfolioReturnsWithDates.forEach(({ timestamp, return: ret }) => {
        if (isFinite(ret)) {
            portfolioReturnsMap.set(timestamp, ret);
        }
        else {
            console.warn(`Non-finite portfolio return on ${new Date(timestamp).toISOString()}: ${ret}. Skipping.`);
        }
    });
    const benchmarkReturnsMap = new Map();
    benchmarkReturnsWithDates.forEach(({ timestamp, return: ret }) => {
        if (isFinite(ret)) {
            benchmarkReturnsMap.set(timestamp, ret);
        }
        else {
            console.warn(`Non-finite benchmark return on ${new Date(timestamp).toISOString()}: ${ret}. Skipping.`);
        }
    });
    // **Find common timestamps**
    const commonTimestamps = [...portfolioReturnsMap.keys()].filter((timestamp) => benchmarkReturnsMap.has(timestamp));
    if (commonTimestamps.length < 2) {
        console.warn('Not enough overlapping data to calculate alpha.');
        return {
            alpha: 'N/A',
            alphaAnnualized: 'N/A',
            beta: 'N/A',
        };
    }
    // **Align returns**
    const alignedPortfolioReturns = [];
    const alignedBenchmarkReturns = [];
    for (const timestamp of commonTimestamps) {
        const portfolioRet = portfolioReturnsMap.get(timestamp);
        const benchmarkRet = benchmarkReturnsMap.get(timestamp);
        if (isFinite(portfolioRet) && isFinite(benchmarkRet)) {
            alignedPortfolioReturns.push(portfolioRet);
            alignedBenchmarkReturns.push(benchmarkRet);
        }
        else {
            console.warn(`Non-finite returns on ${new Date(timestamp).toISOString()}. Skipping.`);
        }
    }
    const n = alignedPortfolioReturns.length;
    if (n === 0) {
        console.warn('No valid aligned returns to calculate alpha.');
        return {
            alpha: 'N/A',
            alphaAnnualized: 'N/A',
            beta: 'N/A',
        };
    }
    // **Calculate average returns**
    const portfolioAvgReturn = alignedPortfolioReturns.reduce((sum, ret) => sum + ret, 0) / n;
    const benchmarkAvgReturn = alignedBenchmarkReturns.reduce((sum, ret) => sum + ret, 0) / n;
    // **Calculate beta**
    const beta = calculateBetaFromReturns$1(alignedPortfolioReturns, alignedBenchmarkReturns);
    if (!isFinite(beta.beta)) {
        console.warn('Beta calculation resulted in a non-finite value.');
        return {
            alpha: 'N/A',
            alphaAnnualized: 'N/A',
            beta: 'N/A',
        };
    }
    // **Calculate alpha**
    const riskFreeRateAnnual = 0.02; // 2%
    const tradingDaysPerYear = 252;
    const riskFreeRateDaily = riskFreeRateAnnual / tradingDaysPerYear;
    const alpha = portfolioAvgReturn - (riskFreeRateDaily + beta.beta * (benchmarkAvgReturn - riskFreeRateDaily));
    const alphaAnnualized = alpha * tradingDaysPerYear;
    if (!isFinite(alphaAnnualized)) {
        console.warn('Alpha calculation resulted in a non-finite value.');
        return {
            alpha: 'N/A',
            alphaAnnualized: 'N/A',
            beta: 'N/A',
        };
    }
    return {
        alpha: `${(alpha * 100).toFixed(2)}`,
        alphaAnnualized: `${(alphaAnnualized * 100).toFixed(2)}`,
        beta: `${(beta.beta * 100).toFixed(2)}`,
    };
}
// **Helper function to calculate daily returns with Unix millisecond timestamps**
function calculateDailyReturnsWithTimestamps(values, timestamps) {
    const returnsWithTimestamps = [];
    for (let i = 1; i < values.length; i++) {
        const prevValue = values[i - 1];
        const currValue = values[i];
        const currTimestamp = timestamps[i];
        if (!isFinite(prevValue) || prevValue === 0) {
            // Avoid division by zero or invalid returns
            continue;
        }
        const ret = (currValue - prevValue) / prevValue;
        returnsWithTimestamps.push({ timestamp: currTimestamp, return: ret });
    }
    return returnsWithTimestamps;
}
// **Helper function to normalize timestamps to midnight UTC**
function getMidnightTimestamp(timestamp) {
    const date = new Date(timestamp);
    date.setUTCHours(0, 0, 0, 0);
    return date.getTime();
}
/**
 * Calculates the Maximum Drawdown (MDD) and related metrics from an array of equity values.
 *
 * @param equity - An array of equity values (must contain at least one positive number)
 * @param options - Configuration options for the calculation
 * @returns Object containing drawdown metrics
 * @throws Will throw an error if the input is invalid
 */
function calculateDrawdownMetrics(equity, options = {}) {
    // Default options
    const decimals = options.decimals ?? 2;
    const minimumDrawdown = options.minimumDrawdown ?? 0;
    // Input validation
    if (!Array.isArray(equity) || equity.length === 0) {
        throw new TypeError('Equity data must be a non-empty array of numbers.');
    }
    // Pre-validate all equity values at once
    const validEquity = equity.map((value, index) => {
        if (typeof value !== 'number' || isNaN(value)) {
            console.warn(`Invalid equity value at index ${index}: ${value}. Using 0 instead.`);
            return 0;
        }
        return value;
    });
    // Single-pass algorithm for efficiency
    let maxDrawdown = 0;
    let maxPeakIndex = 0;
    let maxTroughIndex = 0;
    let peakIndex = 0;
    let peakValue = validEquity[0];
    let currentPeakValue = validEquity[0];
    let recoveryIndex;
    // Main loop - O(n) complexity
    for (let i = 1; i < validEquity.length; i++) {
        const currentValue = validEquity[i];
        // Update peak if we have a new high
        if (currentValue >= peakValue) {
            peakValue = currentValue;
            peakIndex = i;
        }
        else {
            // Calculate drawdown from peak
            const drawdown = peakValue <= 0 ? 0 : (peakValue - currentValue) / peakValue;
            // Update max drawdown if current drawdown is greater
            if (drawdown > maxDrawdown) {
                maxDrawdown = drawdown;
                maxPeakIndex = peakIndex;
                maxTroughIndex = i;
                recoveryIndex = undefined;
            }
            // Check for recovery from max drawdown
            if (!recoveryIndex && maxDrawdown > 0 && currentValue >= validEquity[maxPeakIndex]) {
                recoveryIndex = i;
            }
        }
        // Track current peak for current drawdown calculation
        if (currentValue >= currentPeakValue) {
            currentPeakValue = currentValue;
        }
    }
    // Calculate current drawdown
    const lastValue = validEquity[validEquity.length - 1];
    const currentDrawdown = currentPeakValue <= 0 ? 0 : (currentPeakValue - lastValue) / currentPeakValue;
    // Helper for percentage formatting
    const formatPercentage = (value) => {
        const percentage = value * 100;
        return `${parseFloat(percentage.toFixed(decimals))}%`;
    };
    // If no drawdown meets minimum threshold, return default values
    if (maxDrawdown < minimumDrawdown) {
        return {
            maxDrawdownPercentage: '0%',
            maxDrawdownValue: 0,
            peakValue: validEquity[0],
            troughValue: validEquity[0],
            peakIndex: 0,
            troughIndex: 0,
            drawdownPeriod: 0,
            recoveryIndex: undefined,
            recoveryPeriod: undefined,
            currentDrawdownPercentage: formatPercentage(currentDrawdown >= minimumDrawdown ? currentDrawdown : 0),
        };
    }
    // Calculate periods
    const drawdownPeriod = maxTroughIndex - maxPeakIndex;
    const recoveryPeriod = recoveryIndex !== undefined ? recoveryIndex - maxTroughIndex : undefined;
    return {
        maxDrawdownPercentage: formatPercentage(maxDrawdown),
        maxDrawdownValue: validEquity[maxPeakIndex] - validEquity[maxTroughIndex],
        peakValue: validEquity[maxPeakIndex],
        troughValue: validEquity[maxTroughIndex],
        peakIndex: maxPeakIndex,
        troughIndex: maxTroughIndex,
        drawdownPeriod,
        recoveryIndex,
        recoveryPeriod,
        currentDrawdownPercentage: formatPercentage(currentDrawdown >= minimumDrawdown ? currentDrawdown : 0),
    };
}
/**
 * Simplified version that returns only the maximum drawdown percentage
 * For backward compatibility
 * @param equity - An array of equity values.
 * @param decimals - Number of decimal places for the percentage value.
 * @returns The maximum drawdown percentage as a string.
 */
function calculateMaxDrawdown$1(equity, decimals = 2) {
    const result = calculateDrawdownMetrics(equity, { decimals });
    return result.maxDrawdownPercentage;
}
/**
 * Calculates daily log returns for an array of prices.
 * Log returns are preferred for statistical properties.
 * @param prices - Array of prices.
 * @returns Array of daily log returns.
 */
function calculateDailyReturns$1(prices) {
    const returns = [];
    for (let i = 1; i < prices.length; i++) {
        const previous = prices[i - 1];
        const current = prices[i];
        if (!isFinite(previous) || !isFinite(current) || previous <= 0) {
            continue; // Skip invalid returns
        }
        const logReturn = Math.log(current / previous);
        returns.push(logReturn);
    }
    return returns;
}
/**
 * Aligns portfolio and benchmark returns based on matching dates.
 * @param portfolioHistory - The portfolio history data.
 * @param benchmarkBars - The historical price data of the benchmark.
 * @returns An object containing aligned returns arrays.
 */
function alignReturnsByDate(portfolioHistory, benchmarkBars) {
    const portfolioEquity = portfolioHistory.equity;
    let portfolioTimestamps = portfolioHistory.timestamp;
    const benchmarkPrices = benchmarkBars.map((bar) => bar.c);
    let benchmarkTimestamps = benchmarkBars.map((bar) => bar.t);
    // **Convert portfolio timestamps from ISO strings to Unix milliseconds**
    portfolioTimestamps = portfolioTimestamps.map((timestamp) => timestamp * 1000);
    // **Normalize portfolio timestamps to midnight UTC**
    portfolioTimestamps = portfolioTimestamps.map((timestamp) => getMidnightTimestamp(timestamp));
    // **Convert benchmark timestamps from Unix seconds to Unix milliseconds**
    benchmarkTimestamps = benchmarkTimestamps.map((timestamp) => timestamp * 1000);
    // **Normalize benchmark timestamps to midnight UTC**
    benchmarkTimestamps = benchmarkTimestamps.map((timestamp) => getMidnightTimestamp(timestamp));
    // Calculate log daily returns
    const portfolioReturns = calculateDailyReturns$1(portfolioEquity);
    const benchmarkReturns = calculateDailyReturns$1(benchmarkPrices);
    // Create maps of timestamp to return
    const portfolioReturnsMap = new Map();
    for (let i = 1; i < portfolioTimestamps.length; i++) {
        const timestamp = portfolioTimestamps[i];
        const ret = portfolioReturns[i - 1];
        if (isFinite(ret)) {
            portfolioReturnsMap.set(timestamp, ret);
        }
    }
    const benchmarkReturnsMap = new Map();
    for (let i = 1; i < benchmarkTimestamps.length; i++) {
        const timestamp = benchmarkTimestamps[i];
        const ret = benchmarkReturns[i - 1];
        if (isFinite(ret)) {
            benchmarkReturnsMap.set(timestamp, ret);
        }
    }
    // Find common timestamps
    const commonTimestamps = [...portfolioReturnsMap.keys()].filter((timestamp) => benchmarkReturnsMap.has(timestamp));
    if (commonTimestamps.length === 0) {
        console.warn('No common dates found between portfolio and benchmark.');
        return {
            alignedPortfolioReturns: [],
            alignedBenchmarkReturns: [],
        };
    }
    // Extract aligned returns
    const alignedPortfolioReturns = [];
    const alignedBenchmarkReturns = [];
    for (const timestamp of commonTimestamps) {
        const portfolioRet = portfolioReturnsMap.get(timestamp);
        const benchmarkRet = benchmarkReturnsMap.get(timestamp);
        alignedPortfolioReturns.push(portfolioRet);
        alignedBenchmarkReturns.push(benchmarkRet);
    }
    return { alignedPortfolioReturns, alignedBenchmarkReturns };
}
/**
 * Calculates the beta of the portfolio compared to a benchmark.
 * @param portfolioReturns - Array of portfolio returns.
 * @param benchmarkReturns - Array of benchmark returns.
 * @returns An object containing beta and intermediate calculations.
 */
function calculateBetaFromReturns$1(portfolioReturns, benchmarkReturns) {
    const n = portfolioReturns.length;
    if (n === 0) {
        console.warn('No returns to calculate beta.');
        return {
            beta: 0,
            covariance: 0,
            variance: 0,
            averagePortfolioReturn: 0,
            averageBenchmarkReturn: 0,
        };
    }
    // Calculate average returns
    const averagePortfolioReturn = portfolioReturns.reduce((sum, ret) => sum + ret, 0) / n;
    const averageBenchmarkReturn = benchmarkReturns.reduce((sum, ret) => sum + ret, 0) / n;
    // Calculate covariance and variance
    let covariance = 0;
    let variance = 0;
    for (let i = 0; i < n; i++) {
        const portfolioDiff = portfolioReturns[i] - averagePortfolioReturn;
        const benchmarkDiff = benchmarkReturns[i] - averageBenchmarkReturn;
        covariance += portfolioDiff * benchmarkDiff;
        variance += benchmarkDiff ** 2;
    }
    covariance /= n;
    variance /= n;
    // Handle zero variance
    if (variance === 0) {
        console.warn('Benchmark variance is zero. Setting beta to 0.');
        return {
            beta: 0,
            covariance,
            variance,
            averagePortfolioReturn,
            averageBenchmarkReturn,
        };
    }
    const beta = covariance / variance;
    return {
        beta,
        covariance,
        variance,
        averagePortfolioReturn,
        averageBenchmarkReturn,
    };
}
/**
 * Calculates the information ratio of the portfolio compared to a benchmark.
 * @param portfolioHistory - The portfolio history data.
 * @param benchmarkBars - The historical price data of the benchmark.
 * @returns Information ratio as a formatted string.
 */
async function calculateInformationRatio$1(portfolioHistory, benchmarkBars) {
    const portfolioEquity = portfolioHistory.equity;
    let portfolioTimestamps = portfolioHistory.timestamp;
    const benchmarkPrices = benchmarkBars.map((bar) => bar.c);
    let benchmarkTimestamps = benchmarkBars.map((bar) => bar.t);
    if (!portfolioEquity || portfolioEquity.length < 2) {
        console.warn('No portfolio equity data available.');
        return 'N/A';
    }
    // **Convert portfolio timestamps from ISO strings to Unix milliseconds**
    portfolioTimestamps = portfolioTimestamps.map((timestamp) => new Date(timestamp).getTime());
    // **Normalize portfolio timestamps to midnight UTC**
    portfolioTimestamps = portfolioTimestamps.map((timestamp) => getMidnightTimestamp(timestamp));
    // **Convert benchmark timestamps from Unix seconds to Unix milliseconds**
    benchmarkTimestamps = benchmarkTimestamps.map((timestamp) => timestamp * 1000);
    // **Normalize benchmark timestamps to midnight UTC**
    benchmarkTimestamps = benchmarkTimestamps.map((timestamp) => getMidnightTimestamp(timestamp));
    // Calculate daily returns with timestamps
    const portfolioReturnsWithDates = calculateDailyReturnsWithTimestamps(portfolioEquity, portfolioTimestamps);
    const benchmarkReturnsWithDates = calculateDailyReturnsWithTimestamps(benchmarkPrices, benchmarkTimestamps);
    // Align returns by timestamp
    const portfolioReturnsMap = new Map();
    portfolioReturnsWithDates.forEach(({ timestamp, return: ret }) => {
        if (isFinite(ret)) {
            portfolioReturnsMap.set(timestamp, ret);
        }
    });
    const benchmarkReturnsMap = new Map();
    benchmarkReturnsWithDates.forEach(({ timestamp, return: ret }) => {
        if (isFinite(ret)) {
            benchmarkReturnsMap.set(timestamp, ret);
        }
    });
    // Find common timestamps
    const commonTimestamps = [...portfolioReturnsMap.keys()].filter((timestamp) => benchmarkReturnsMap.has(timestamp));
    if (commonTimestamps.length < 2) {
        console.warn('Not enough overlapping data to calculate information ratio.');
        return 'N/A';
    }
    // Extract aligned returns
    const activeReturns = [];
    for (const timestamp of commonTimestamps) {
        const portfolioRet = portfolioReturnsMap.get(timestamp);
        const benchmarkRet = benchmarkReturnsMap.get(timestamp);
        activeReturns.push(portfolioRet - benchmarkRet);
    }
    const n = activeReturns.length;
    // Calculate average active return
    const avgActiveReturn = activeReturns.reduce((sum, ret) => sum + ret, 0) / n;
    // Calculate tracking error (standard deviation of active returns)
    const squaredDiffs = activeReturns.map((ret) => Math.pow(ret - avgActiveReturn, 2));
    const variance = squaredDiffs.reduce((sum, diff) => sum + diff, 0) / (n - 1);
    const trackingError = Math.sqrt(variance);
    // Check for zero tracking error
    if (!isFinite(trackingError) || trackingError === 0) {
        console.warn('Tracking error is zero or non-finite, cannot calculate information ratio.');
        return 'N/A';
    }
    // Calculate information ratio
    const informationRatio = avgActiveReturn / trackingError;
    if (!isFinite(informationRatio)) {
        console.warn('Information ratio calculation resulted in a non-finite number.');
        return 'N/A';
    }
    return informationRatio.toFixed(4);
}
/**
 * Fetches performance metrics for a given Alpaca account.
 * @param params - The parameters for fetching performance metrics.
 * @param client - The Apollo client instance.
 * @param accountId - The ID of the Alpaca account.
 * @param alpacaAccount - The Alpaca account object.
 * @returns A promise that resolves to an object containing various performance metrics.
 * @throws Will throw an error if required parameters are missing or if fetching fails.
 */
async function fetchPerformanceMetrics({ params, client, accountId, alpacaAccount, }) {
    // Default response for error cases
    const defaultMetrics = {
        totalReturnYTD: 'N/A',
        alpha: 'N/A',
        beta: 'N/A',
        alphaAnnualized: 'N/A',
        informationRatio: 'N/A',
        riskAdjustedReturn: 'N/A',
        liquidityRatio: 'N/A',
        expenseRatio: 'N/A',
        dividendYield: 'N/A',
        maxDrawdown: 'N/A',
    };
    try {
        // Validate required parameters
        if (!params) {
            throw new Error('Missing required parameters');
        }
        if (!params.timeframe || !params.period) {
            throw new Error('Missing required timeframe or period parameters');
        }
        // Obtain Alpaca account
        let alpacaAccountObj = alpacaAccount ? alpacaAccount : null;
        if (!alpacaAccountObj && accountId) {
            try {
                // Use provided client or get the shared client
                const apolloClient = client || await getSharedApolloClient();
                alpacaAccountObj = (await adaptic$1.alpacaAccount.get({
                    id: accountId,
                }, apolloClient));
            }
            catch (error) {
                console.error('[fetchPerformanceMetrics] Error fetching Alpaca account:', error);
                throw new Error('Failed to retrieve Alpaca account details');
            }
        }
        // Validate Alpaca account
        if (!alpacaAccountObj || !alpacaAccountObj.APIKey || !alpacaAccountObj.APISecret) {
            throw new Error('Alpaca account not found or credentials missing');
        }
        // Fetch portfolio history with structured error handling
        let portfolioHistory;
        try {
            portfolioHistory = await fetchPortfolioHistory({
                params: params,
                alpacaAccount: alpacaAccountObj
            });
        }
        catch (error) {
            console.error('[fetchPerformanceMetrics] Error fetching portfolio history:', error);
            throw new Error('Failed to retrieve portfolio history data');
        }
        // Fetch benchmark data with enhanced error handling
        const benchmarkSymbol = 'SPY';
        let benchmarkBars = [];
        try {
            const { start, end } = await getStartAndEndTimestamps({
                timezone: 'America/New_York',
                period: (params?.period === "YTD" || params?.period === "1A") ? "1Y" : params?.period ? params?.period : '1Y',
                outputFormat: 'unix-ms',
                intraday_reporting: params?.intraday_reporting,
            });
            const response = await fetch(`/api/market-data/historical-prices?symbol=${benchmarkSymbol}&start=${start.toString()}&end=${end.toString()}&timeframe=${params.timeframe}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                },
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Failed to fetch benchmark data: ${response.statusText} - ${errorText}`);
            }
            benchmarkBars = await response.json();
            if (!benchmarkBars || !Array.isArray(benchmarkBars) || benchmarkBars.length === 0) {
                throw new Error('Received empty or invalid benchmark data');
            }
        }
        catch (error) {
            console.error('[fetchPerformanceMetrics] Error fetching benchmark data:', error);
            // Continue with partial metrics calculation if possible
        }
        // Calculate metrics in parallel for performance
        const metrics = await Promise.allSettled([
            calculateTotalReturnYTD(portfolioHistory),
            calculateAlphaAndBeta$1(portfolioHistory, benchmarkBars),
            calculateInformationRatio$1(portfolioHistory, benchmarkBars),
            calculateRiskAdjustedReturn$1(portfolioHistory),
            calculateLiquidityRatio({ alpacaAccount: alpacaAccountObj }),
            calculateExpenseRatio$1({ alpacaAccount: alpacaAccountObj }),
            getDividendYield(),
            calculateMaxDrawdown$1(portfolioHistory.equity),
        ]);
        // Extract results with error handling for each metric
        const result = { ...defaultMetrics };
        if (metrics[0].status === 'fulfilled')
            result.totalReturnYTD = metrics[0].value;
        if (metrics[1].status === 'fulfilled') {
            result.alpha = metrics[1].value.alpha;
            result.beta = metrics[1].value.beta;
            result.alphaAnnualized = metrics[1].value.alphaAnnualized;
        }
        if (metrics[2].status === 'fulfilled')
            result.informationRatio = metrics[2].value;
        if (metrics[3].status === 'fulfilled')
            result.riskAdjustedReturn = metrics[3].value;
        if (metrics[4].status === 'fulfilled')
            result.liquidityRatio = metrics[4].value;
        if (metrics[5].status === 'fulfilled')
            result.expenseRatio = metrics[5].value;
        if (metrics[6].status === 'fulfilled')
            result.dividendYield = metrics[6].value;
        if (metrics[7].status === 'fulfilled')
            result.maxDrawdown = metrics[7].value;
        return result;
    }
    catch (error) {
        console.error('[fetchPerformanceMetrics] Error:', error);
        return defaultMetrics;
    }
}

// time-utils.ts
// Helper function to convert timestamp to Unix timestamp in seconds
const toUnixTimestamp = (ts) => {
    return Math.floor(new Date(ts).getTime() / 1000);
};
function getTimeAgo(dateString) {
    // if format is like this: '20240919T102005', then first convert to '2024-09-19T10:20:05' format
    let dateValue = dateString;
    if (dateString && dateString.length === 15) {
        dateValue = dateString.replace(/(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})/, '$1-$2-$3T$4:$5:$6');
    }
    const date = new Date(dateValue);
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    const months = Math.floor(days / 30);
    const years = Math.floor(months / 12);
    if (years > 0) {
        return years === 1 ? '1 year ago' : `${years} years ago`;
    }
    else if (months > 0) {
        return months === 1 ? '1 month ago' : `${months} months ago`;
    }
    else if (days > 0) {
        return days === 1 ? '1 day ago' : `${days} days ago`;
    }
    else if (hours > 0) {
        return hours === 1 ? '1 hr ago' : `${hours} hrs ago`;
    }
    else if (minutes > 0) {
        return minutes === 1 ? '1 min ago' : `${minutes} mins ago`;
    }
    else {
        return 'A few seconds ago';
    }
}
function normalizeDate(timestamp) {
    const date = new Date(timestamp);
    return date.toISOString().split('T')[0]; // Returns 'YYYY-MM-DD'
}
// the function formerly known as CalculateRange, like a camel with two humps. Gross
function calculateTimeRange(range) {
    const currentDate = new Date();
    switch (range) {
        case '1d':
            currentDate.setDate(currentDate.getDate() - 1);
            break;
        case '3d':
            currentDate.setDate(currentDate.getDate() - 3);
            break;
        case '1w':
            currentDate.setDate(currentDate.getDate() - 7);
            break;
        case '1m':
            currentDate.setMonth(currentDate.getMonth() - 1);
            break;
        case '3m':
            currentDate.setMonth(currentDate.getMonth() - 3);
            break;
        case '1y':
            currentDate.setFullYear(currentDate.getFullYear() - 1);
            break;
        default:
            throw new Error(`Invalid range: ${range}`);
    }
    return currentDate.toISOString().split('T')[0]; // format date to 'YYYY-MM-DD'
}
const daysLeft = (accountCreationDate, maxDays) => {
    const now = new Date();
    const endPeriodDate = new Date(accountCreationDate);
    endPeriodDate.setDate(accountCreationDate.getDate() + maxDays);
    const diffInMilliseconds = endPeriodDate.getTime() - now.getTime();
    // Convert milliseconds to days and return
    return Math.ceil(diffInMilliseconds / (1000 * 60 * 60 * 24));
};
const cutoffDate = new Date('2023-10-17T00:00:00.000Z');
const calculateDaysLeft = (accountCreationDate) => {
    let maxDays;
    if (accountCreationDate < cutoffDate) {
        maxDays = 30;
        accountCreationDate = new Date('2023-10-01T00:00:00.000Z');
    }
    else {
        maxDays = 14;
    }
    return daysLeft(accountCreationDate, maxDays);
};
const timeAgo = (timestamp) => {
    if (!timestamp)
        return 'Just now';
    const diff = Date.now() - new Date(timestamp).getTime();
    if (diff < 60000) {
        // less than 1 second
        return 'Just now';
    }
    else if (diff > 82800000) {
        // more than 23 hours  similar to how Twitter displays timestamps
        return new Date(timestamp).toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            year: new Date(timestamp).getFullYear() !== new Date().getFullYear() ? 'numeric' : undefined,
        });
    }
    return `${ms(diff)} ago`;
};
// returns date utc
const formatDate = (dateString, updateDate) => {
    return new Date(dateString).toLocaleDateString('en-US', {
        day: 'numeric',
        month: 'long',
        year: updateDate && new Date(dateString).getFullYear() === new Date().getFullYear() ? undefined : 'numeric',
        timeZone: 'UTC',
    });
};
const formatDateToString = (date) => {
    return date.toLocaleDateString('en-US', {
        weekday: 'long',
        month: 'short',
        day: 'numeric',
        year: 'numeric',
    }) + ', at ' + date.toLocaleTimeString('en-US', {
        hour12: false,
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
    });
};
const parseETDateFromAV = (dateString) => {
    // Time zone identifier for Eastern Time
    const timeZone = 'America/New_York';
    // Split the input string into date and time components
    const [datePart, timePart] = dateString.split(' ');
    // Construct a full date-time string in ISO format
    const fullString = `${datePart}T${timePart}`;
    // Convert the string to a UTC Date object using date-fns-tz
    const utcDate = fromZonedTime(fullString, timeZone); // Convert to UTC
    return utcDate;
};
const formatToUSEastern = (date, justDate) => {
    const options = {
        timeZone: 'America/New_York',
        month: 'short',
        day: 'numeric',
        year: 'numeric',
    };
    if (!justDate) {
        options.hour = 'numeric';
        options.minute = '2-digit';
        options.hour12 = true;
    }
    return date.toLocaleString('en-US', options);
};
const unixTimetoUSEastern = (timestamp) => {
    const date = new Date(timestamp);
    const timeString = formatToUSEastern(date);
    const dateString = formatToUSEastern(date, true);
    return { date, timeString, dateString };
};
const timeDiffString = (milliseconds) => {
    const seconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    const remainingHours = hours % 24;
    const remainingMinutes = minutes % 60;
    const parts = [];
    if (days > 0)
        parts.push(`${days} day${days > 1 ? 's' : ''}`);
    if (remainingHours > 0)
        parts.push(`${remainingHours} hour${remainingHours > 1 ? 's' : ''}`);
    if (remainingMinutes > 0)
        parts.push(`${remainingMinutes} minute${remainingMinutes > 1 ? 's' : ''}`);
    return parts.join(', ');
};

// price-utils.ts
const calculateFees = async (action, trade, alpacaAccount) => {
    let fee = 0;
    const alpacaOrderId = action.alpacaOrderId;
    if (!alpacaOrderId)
        return fee;
    const order = await getOrder$1({
        adapticAccountId: trade.alpacaAccountId,
        alpacaApiKey: alpacaAccount.APIKey,
        alpacaApiSecret: alpacaAccount.APISecret,
    }, alpacaOrderId);
    if (!order)
        return fee;
    const assetType = "STOCK";
    Number(order.qty) || 0;
    order.notional || 0;
    Number(order.filled_avg_price || order.limit_price || order.stop_price) || 0;
    switch (assetType) {
        case "STOCK":
        // case "ETF" as enums.AssetType.ETF:
        //   commissionFee =
        //     (tradeValue * FEE_CONFIG.SHARES_COMMISSION_PERCENTAGE) / 100;
        //   regulatoryFee =
        //     (tradeValue * FEE_CONFIG.REGULATORY_FEES_PERCENTAGE) / 100;
        //   fee = commissionFee + regulatoryFee;
        //   break;
        // case "OPTION" as enums.AssetType.OPTION:
        //   perContractFee = qty * FEE_CONFIG.OPTIONS_PER_CONTRACT_FEE;
        //   baseCommission = FEE_CONFIG.OPTIONS_BASE_COMMISSION;
        //   fee = perContractFee + baseCommission;
        //   break;
        // case "CRYPTOCURRENCY" as enums.AssetType.CRYPTOCURRENCY:
        //   fee = (tradeValue * FEE_CONFIG.CRYPTO_TRANSACTION_PERCENTAGE) / 100;
        //   break;
        // case "FUTURE" as enums.AssetType.FUTURE:
        //   // Sum of all futures fees
        //   fee = 0.85 + 0.85 + 0.25 + 0.02 + 0.01 + 0.3 + 0.01;
        //   break;
        default:
            fee = 0;
            break;
    }
    return fee;
};
const computeTotalFees = async (trade) => {
    let totalFees = 0;
    // fetch alpaca account details using adaptic.alpacaAccount.get({id: trade.alpacaAccountId})
    const alpacaAccount = (await adaptic$1.alpacaAccount.get({
        id: trade.alpacaAccountId,
    }));
    if (!alpacaAccount)
        return totalFees;
    const feePromises = trade?.actions?.map((action) => calculateFees(action, trade, alpacaAccount));
    const fees = await Promise.all(feePromises || []);
    totalFees = fees.reduce((acc, fee) => acc + fee, 0);
    return totalFees;
};
/**
 * Rounds price based on value:
 * - For prices >= $1, rounds to nearest $0.01
 * - For prices < $1, rounds to nearest $0.0001
 */
function roundStockPrice(price) {
    if (price >= 1) {
        return Math.round(price * 100) / 100;
    }
    else {
        return Math.round(price * 10000) / 10000;
    }
}
function getEquityValues(equityData, portfolioHistory, marketTimeUtil, period) {
    if (!equityData.length) {
        return { latestEquity: 0, initialEquity: 0 };
    }
    // Sort data by time
    const sortedData = [...equityData].sort((a, b) => {
        const aDate = getDateInNY(a.time);
        const bDate = getDateInNY(b.time);
        return aDate.getTime() - bDate.getTime();
    });
    // Filter out invalid values and apply market hours filtering
    const validData = sortedData.filter((point) => {
        const value = Number(point.value);
        if (isNaN(value) || !isFinite(value)) {
            return false;
        }
        if (marketTimeUtil) {
            const pointDate = getDateInNY(point.time);
            // Only filter for market hours on '1D' period
            if (period === '1D') {
                return (marketTimeUtil.isMarketDay(pointDate) &&
                    marketTimeUtil.isWithinMarketHours(pointDate));
            }
            // For other periods, include all data points
            return true;
        }
        return true;
    });
    if (!validData.length) {
        if (sortedData.length > 0) {
            const lastPoint = sortedData[sortedData.length - 1];
            let initialValue;
            // Determine initial value based on period
            if (period && ['YTD', '1Y', '3M', '6M'].includes(period) && portfolioHistory?.base_value) {
                initialValue = portfolioHistory.base_value;
            }
            else {
                initialValue = Number(sortedData[0].value);
            }
            return {
                latestEquity: Number(lastPoint.value),
                initialEquity: initialValue,
                latestTimestamp: lastPoint.time,
                initialTimestamp: sortedData[0].time,
                baseValueAsOf: portfolioHistory?.base_value_asof,
                baseValue: portfolioHistory?.base_value,
            };
        }
        return { latestEquity: 0, initialEquity: 0 };
    }
    const latestPoint = Number(validData[validData.length - 1].value);
    let initialEquity;
    // Determine initial equity based on period and available data
    if (period) {
        switch (period) {
            case '1D':
                // For 1D, use the first valid market hours point
                initialEquity = Number(validData[0].value);
                break;
            case 'YTD':
            case '1Y':
            case '3M':
            case '6M':
                // For longer periods, prefer base_value if available and valid
                if (portfolioHistory?.base_value &&
                    portfolioHistory.base_value > 0 &&
                    portfolioHistory.base_value_asof) {
                    const baseValueDate = getDateInNY(portfolioHistory.base_value_asof);
                    const periodStartDate = getDateInNY(validData[0].time);
                    // Only use base_value if it's from before our period start
                    if (baseValueDate <= periodStartDate) {
                        initialEquity = portfolioHistory.base_value;
                    }
                    else {
                        initialEquity = Number(validData[0].value);
                    }
                }
                else {
                    initialEquity = Number(validData[0].value);
                }
                break;
            default:
                initialEquity = Number(validData[0].value);
        }
    }
    else {
        // If no period specified, use first valid value
        initialEquity = Number(validData[0].value);
    }
    return {
        latestEquity: Number(latestPoint.valueOf),
        initialEquity,
        latestTimestamp: validData[validData.length - 1].time,
        initialTimestamp: validData[0].time,
        baseValueAsOf: portfolioHistory?.base_value_asof,
        baseValue: portfolioHistory?.base_value,
    };
}

// metric-calcs.ts
/**
 * Calculates daily returns from an array of closing prices
 * @param prices - Array of closing prices (numbers)
 * @returns Array of daily returns in decimal form (e.g. 0.05 for 5% return)
 * @example
 * const prices = [100, 105, 102, 110];
 * const returns = calculateDailyReturns(prices); // [0.05, -0.02857, 0.07843]
 */
function calculateDailyReturns(prices) {
    const returns = [];
    for (let i = 1; i < prices.length; i++) {
        const prev = prices[i - 1];
        const current = prices[i];
        if (isFinite(prev) && isFinite(current) && prev !== 0) {
            const dailyReturn = (current - prev) / prev;
            returns.push(dailyReturn);
        }
    }
    return returns;
}
/**
 * Aligns trade and benchmark returns by matching dates
 * @param tradeBars - Array of Bar objects containing trade price data
 * @param benchmarkBars - Array of BenchmarkBar objects containing benchmark price data
 * @returns Object containing aligned arrays of trade and benchmark returns
 * @example
 * const tradeBars = [{ c: 100, t: "2023-01-01T00:00:00Z" }, { c: 105, t: "2023-01-02T00:00:00Z" }];
 * const benchmarkBars = [{ c: 200, t: 1672531200 }, { c: 210, t: 1672617600 }];
 * const aligned = alignReturns(tradeBars, benchmarkBars);
 * // aligned = { alignedTradeReturns: [0.05], alignedBenchmarkReturns: [0.05] }
 * @throws Will log warnings if there are no matching dates between trade and benchmark data
 */
function alignReturns(tradeBars, benchmarkBars) {
    // Normalize all dates to midnight UTC for consistent comparison
    const normalizeTimestamp = (timestamp) => {
        let date;
        if (typeof timestamp === 'string') {
            // Handle RFC-3339 format strings
            date = new Date(timestamp);
        }
        else {
            // Handle Unix timestamps (could be in seconds or milliseconds)
            date = new Date(timestamp * (timestamp < 10000000000 ? 1000 : 1));
        }
        date.setUTCHours(0, 0, 0, 0);
        return date.getTime();
    };
    // Create maps with normalized dates as keys
    const tradeMap = new Map();
    const benchmarkMap = new Map();
    // Process trade data
    for (let i = 1; i < tradeBars.length; i++) {
        const prevBar = tradeBars[i - 1];
        const currBar = tradeBars[i];
        if (isFinite(prevBar.c) && isFinite(currBar.c) && prevBar.c !== 0) {
            const dailyReturn = (currBar.c - prevBar.c) / prevBar.c;
            const normalizedDate = normalizeTimestamp(currBar.t);
            const originalDate = typeof currBar.t === 'string'
                ? currBar.t
                : new Date(currBar.t * (currBar.t < 10000000000 ? 1000 : 1)).toISOString();
            tradeMap.set(normalizedDate, { return: dailyReturn, originalDate });
        }
    }
    // Process benchmark data
    for (let i = 1; i < benchmarkBars.length; i++) {
        const prevBar = benchmarkBars[i - 1];
        const currBar = benchmarkBars[i];
        if (isFinite(prevBar.c) && isFinite(currBar.c) && prevBar.c !== 0) {
            const dailyReturn = (currBar.c - prevBar.c) / prevBar.c;
            const normalizedDate = normalizeTimestamp(currBar.t);
            const originalDate = typeof currBar.t === 'string'
                ? currBar.t
                : new Date(currBar.t * (currBar.t < 10000000000 ? 1000 : 1)).toISOString();
            benchmarkMap.set(normalizedDate, { return: dailyReturn, originalDate });
        }
    }
    // Find common dates between datasets
    const commonDates = [...tradeMap.keys()].filter(date => benchmarkMap.has(date))
        .sort((a, b) => a - b); // Ensure chronological order
    if (commonDates.length === 0) {
        console.warn('No common dates found between trade and benchmark data');
        return { alignedTradeReturns: [], alignedBenchmarkReturns: [], alignedDates: [] };
    }
    // Extract aligned returns
    const alignedTradeReturns = [];
    const alignedBenchmarkReturns = [];
    const alignedDates = [];
    commonDates.forEach(date => {
        const tradeData = tradeMap.get(date);
        const benchmarkData = benchmarkMap.get(date);
        alignedTradeReturns.push(tradeData.return);
        alignedBenchmarkReturns.push(benchmarkData.return);
        alignedDates.push(tradeData.originalDate);
    });
    return { alignedTradeReturns, alignedBenchmarkReturns, alignedDates };
}
/*
* Calculate Beta from Returns
* @param portfolioReturns - Array of portfolio returns
* @param benchmarkReturns - Array of benchmark returns
* @returns Object containing beta, covariance, variance, and average returns
* @example
* const portfolioReturns = [0.05, -0.02, 0.03];
* const benchmarkReturns = [0.03, -0.01, 0.02];
* const beta = calculateBetaFromReturns(portfolioReturns, benchmarkReturns);
* // beta = { beta: 1.5, covariance: 0.0005, variance: 0.0003, averagePortfolioReturn: 0.02, averageBenchmarkReturn: 0.02 }
* @throws Will log warnings if input data is invalid or insufficient
* @throws Will log warnings if benchmark variance is effectively zero
* @throws Will log warnings if beta calculation results in a non-finite value
* @throws Will log warnings if there are not enough valid data points for calculation
* @throws Will log warnings if benchmark variance is zero or non-finite
*/
function calculateBetaFromReturns(portfolioReturns, benchmarkReturns) {
    // Input validation
    if (!Array.isArray(portfolioReturns) || !Array.isArray(benchmarkReturns) ||
        portfolioReturns.length !== benchmarkReturns.length || portfolioReturns.length < 2) {
        console.warn('Invalid or insufficient return data for beta calculation');
        return {
            beta: 0,
            covariance: 0,
            variance: 0,
            averagePortfolioReturn: 0,
            averageBenchmarkReturn: 0,
        };
    }
    // Filter out any non-finite values before calculations
    const validIndices = [...Array(portfolioReturns.length).keys()].filter(i => isFinite(portfolioReturns[i]) && isFinite(benchmarkReturns[i]));
    if (validIndices.length < 2) {
        console.warn('Not enough valid data points for beta calculation');
        return {
            beta: 0,
            covariance: 0,
            variance: 0,
            averagePortfolioReturn: 0,
            averageBenchmarkReturn: 0,
        };
    }
    // Use validated indices only
    const validPortfolioReturns = validIndices.map(i => portfolioReturns[i]);
    const validBenchmarkReturns = validIndices.map(i => benchmarkReturns[i]);
    // Calculate means
    const n = validIndices.length;
    const averagePortfolioReturn = validPortfolioReturns.reduce((sum, ret) => sum + ret, 0) / n;
    const averageBenchmarkReturn = validBenchmarkReturns.reduce((sum, ret) => sum + ret, 0) / n;
    // Calculate covariance and variance with Welford's online algorithm for numerical stability
    let covariance = 0;
    let variance = 0;
    for (let i = 0; i < n; i++) {
        const portfolioDiff = validPortfolioReturns[i] - averagePortfolioReturn;
        const benchmarkDiff = validBenchmarkReturns[i] - averageBenchmarkReturn;
        covariance += portfolioDiff * benchmarkDiff;
        variance += benchmarkDiff * benchmarkDiff;
    }
    // Finalize calculations
    covariance /= n;
    variance /= n;
    // Handle zero variance case
    if (Math.abs(variance) < 1e-10) {
        console.warn('Benchmark variance is effectively zero. Setting beta to 0.');
        return {
            beta: 0,
            covariance,
            variance,
            averagePortfolioReturn,
            averageBenchmarkReturn,
        };
    }
    const beta = covariance / variance;
    return {
        beta,
        covariance,
        variance,
        averagePortfolioReturn,
        averageBenchmarkReturn,
    };
}
/**
 * Calculates the total return for a position, respecting position direction
 * @param tradeBars - Array of price bars
 * @param isShort - Whether it's a short position
 * @returns Formatted total return string
 */
async function calculateProfitLoss(tradeBars, isShort) {
    if (!tradeBars || tradeBars.length < 2) {
        console.warn("Not enough data to calculate total return.");
        return "N/A";
    }
    const startPrice = tradeBars[0].c;
    const endPrice = tradeBars[tradeBars.length - 1].c;
    if (startPrice <= 0 || isNaN(startPrice) || isNaN(endPrice)) {
        console.warn("Invalid price values for total return calculation.");
        return "N/A";
    }
    // For short positions, gains are made when price decreases
    let totalReturn;
    if (isShort) {
        totalReturn = ((startPrice - endPrice) / startPrice) * 100;
    }
    else {
        totalReturn = ((endPrice - startPrice) / startPrice) * 100;
    }
    return `${totalReturn.toFixed(2)}%`;
}
// Calculate Risk-Adjusted Return (Sharpe Ratio)
async function calculateRiskAdjustedReturn(tradeBars) {
    const returns = calculateDailyReturns(tradeBars.map(bar => bar.c));
    if (returns.length < 2) {
        console.warn("No sufficient returns data to calculate Sharpe Ratio.");
        return "N/A";
    }
    // Calculate average daily return
    const avgDailyReturn = returns.reduce((sum, ret) => sum + ret, 0) / returns.length;
    // Calculate standard deviation of daily returns
    const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - avgDailyReturn, 2), 0) / (returns.length - 1);
    const stdDevDaily = Math.sqrt(variance);
    // Annualize average return and standard deviation
    const tradingDaysPerYear = 252;
    const avgAnnualReturn = avgDailyReturn * tradingDaysPerYear;
    const stdDevAnnual = stdDevDaily * Math.sqrt(tradingDaysPerYear);
    if (!isFinite(stdDevAnnual) || stdDevAnnual === 0) {
        console.warn("Standard deviation is zero or non-finite, cannot calculate Sharpe ratio.");
        return "N/A";
    }
    // Assume a risk-free rate, e.g., 2%
    const riskFreeRate = 0.02; // Annual risk-free rate (2%)
    // Calculate Sharpe Ratio
    const sharpeRatio = (avgAnnualReturn - riskFreeRate) / stdDevAnnual;
    if (!isFinite(sharpeRatio)) {
        console.warn("Sharpe ratio calculation resulted in a non-finite number.");
        return "N/A";
    }
    return `${sharpeRatio.toFixed(2)}`;
}
/**
 * Calculates alpha and beta with position direction awareness
 * @param tradeBars - Trade price data
 * @param benchmarkBars - Benchmark price data
 * @param isShort - Whether it's a short position
 */
async function calculateAlphaAndBeta(tradeBars, benchmarkBars, isShort) {
    // First align the data
    const { alignedTradeReturns: rawTradeReturns, alignedBenchmarkReturns } = alignReturns(tradeBars, benchmarkBars);
    if (rawTradeReturns.length === 0 || alignedBenchmarkReturns.length === 0) {
        console.warn("No overlapping data to calculate Alpha.");
        return {
            alpha: "N/A",
            alphaAnnualized: "N/A",
            beta: "N/A"
        };
    }
    // Adjust trade returns based on position type
    const alignedTradeReturns = isShort
        ? rawTradeReturns.map(ret => -ret)
        : rawTradeReturns;
    // Calculate beta with position-adjusted returns
    const beta = calculateBetaFromReturns(alignedTradeReturns, alignedBenchmarkReturns);
    if (!isFinite(beta.beta)) {
        console.warn("Beta calculation resulted in a non-finite value.");
        return {
            alpha: "N/A",
            alphaAnnualized: "N/A",
            beta: "N/A"
        };
    }
    // For short positions, the interpretation of beta changes
    // A positive beta on a short means the position moves with the market,
    // which is bad for a short. We invert it for consistency.
    const positionAwareBeta = isShort ? -beta.beta : beta.beta;
    const avgTradeReturn = alignedTradeReturns.reduce((sum, ret) => sum + ret, 0) / alignedTradeReturns.length;
    const avgBenchmarkReturn = alignedBenchmarkReturns.reduce((sum, ret) => sum + ret, 0) / alignedBenchmarkReturns.length;
    const riskFreeRateDaily = 0.02 / 252; // Assuming 2% annual risk-free rate
    // Alpha calculation adjusts based on position direction
    const alpha = avgTradeReturn - (riskFreeRateDaily + positionAwareBeta * (avgBenchmarkReturn - riskFreeRateDaily));
    const alphaAnnualized = alpha * 252;
    if (!isFinite(alphaAnnualized)) {
        console.warn("Alpha calculation resulted in a non-finite value.");
        return {
            alpha: "N/A",
            alphaAnnualized: "N/A",
            beta: positionAwareBeta.toFixed(4),
        };
    }
    return {
        alpha: alpha.toFixed(4),
        alphaAnnualized: alphaAnnualized.toFixed(4),
        beta: positionAwareBeta.toFixed(4),
    };
}
/**
 * Calculate Information Ratio with position type awareness
 */
async function calculateInformationRatio(tradeBars, benchmarkBars, isShort) {
    const { alignedTradeReturns: rawTradeReturns, alignedBenchmarkReturns } = alignReturns(tradeBars, benchmarkBars);
    if (rawTradeReturns.length === 0 || alignedBenchmarkReturns.length === 0) {
        console.warn("No overlapping data to calculate Information Ratio.");
        return "N/A";
    }
    // Adjust returns for position type
    const alignedTradeReturns = isShort
        ? rawTradeReturns.map(ret => -ret)
        : rawTradeReturns;
    // For short positions, we invert the active return calculation
    // A short position outperforms when it goes down more than the benchmark goes up
    const activeReturns = isShort
        ? alignedTradeReturns.map((ret, idx) => ret - (-alignedBenchmarkReturns[idx]))
        : alignedTradeReturns.map((ret, idx) => ret - alignedBenchmarkReturns[idx]);
    const avgActiveReturn = activeReturns.reduce((sum, ret) => sum + ret, 0) / activeReturns.length;
    const variance = activeReturns.reduce((sum, ret) => sum + Math.pow(ret - avgActiveReturn, 2), 0) / (activeReturns.length - 1);
    const trackingError = Math.sqrt(variance);
    if (trackingError === 0 || !isFinite(trackingError)) {
        console.warn("Tracking error is zero or non-finite, cannot calculate Information Ratio.");
        return "N/A";
    }
    const informationRatio = avgActiveReturn / trackingError;
    if (!isFinite(informationRatio)) {
        console.warn("Information Ratio calculation resulted in a non-finite value.");
        return "N/A";
    }
    return informationRatio.toFixed(4);
}
/**
 * Calculate max drawdown taking position type into account
 * @param tradeBars - Array of price bars
 * @param isShort - Whether it's a short position
 */
async function calculateMaxDrawdown(tradeBars, isShort) {
    if (!tradeBars || tradeBars.length === 0) {
        console.warn("No trade bars data to calculate Max Drawdown.");
        return "N/A";
    }
    const equity = tradeBars.map(bar => bar.c);
    // For short positions, the drawdown happens when price increases
    // So we invert the prices for calculation purposes
    const positionAwareEquity = isShort
        ? equity.map(value => -value)
        : equity;
    let peak = positionAwareEquity[0];
    let maxDrawdown = 0;
    for (let i = 1; i < positionAwareEquity.length; i++) {
        if (positionAwareEquity[i] > peak) {
            peak = positionAwareEquity[i];
        }
        else {
            const drawdown = peak <= 0 ? 0 : (peak - positionAwareEquity[i]) / Math.abs(peak);
            if (drawdown > maxDrawdown) {
                maxDrawdown = drawdown;
            }
        }
    }
    const drawdownPercentage = Math.min(maxDrawdown * 100, 100);
    return `${drawdownPercentage.toFixed(2)}%`;
}
async function calculateExpenseRatio(trade) {
    const totalFees = await computeTotalFees(trade);
    return totalFees ? `${totalFees.toFixed(2)}%` : "N/A";
}
// Main function to fetch and calculate all trade metrics for one trade object
async function fetchTradeMetrics(trade, tradeBars, benchmarkBars) {
    const isShort = trade.actions?.find((a) => a.primary)?.type === "SELL" ? true : false;
    // Calculate metrics concurrently
    const [totalReturnYTD, { alpha, beta, alphaAnnualized }, informationRatio, riskAdjustedReturn, expenseRatio, maxDrawdown,] = await Promise.all([
        calculateProfitLoss(tradeBars, isShort),
        calculateAlphaAndBeta(tradeBars, benchmarkBars, isShort),
        calculateInformationRatio(tradeBars, benchmarkBars, isShort),
        calculateRiskAdjustedReturn(tradeBars),
        calculateExpenseRatio(trade),
        calculateMaxDrawdown(tradeBars, isShort),
    ]);
    return {
        totalReturnYTD,
        alpha, beta, alphaAnnualized,
        informationRatio,
        riskAdjustedReturn,
        expenseRatio,
        maxDrawdown,
        side: isShort ? 'short' : 'long'
    };
}

// format-tools.ts
/**
 * Capitalizes the first letter of a string
 * @param {string} str - The string to capitalize
 * @returns {string} The capitalized string, or original value if not a string
 * @example
 * capitalize('hello') // 'Hello'
 * capitalize(123) // 123
 */
function capitalize(str) {
    if (!str || typeof str !== 'string')
        return str;
    return str.charAt(0).toUpperCase() + str.slice(1);
}
/**
 * Transforms enum formatting to human readable format (e.g. 'STOCK_TICKER' to 'Stock Ticker')
 * @param {string} value - The enum string to format
 * @returns {string} The formatted string, or empty string if no value provided
 * @example
 * formatEnum('STOCK_TICKER') // 'Stock Ticker'
 */
function formatEnum(value) {
    if (!value)
        return '';
    return value
        .split('_')
        .map((word) => capitalize(word.toLowerCase()))
        .join(' ');
}
/**
 * Formats a number as US currency
 * @param {number} value - The number to format
 * @returns {string} The formatted currency string (e.g. '$1,234.56')
 * @example
 * formatCurrency(1234.56) // '$1,234.56'
 * formatCurrency(NaN) // '$0.00'
 */
function formatCurrency(value) {
    if (isNaN(value)) {
        return '$0.00';
    }
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
    }).format(value);
}
/**
 * Formats a number with commas
 * @param {number} value - The number to format
 * @returns {string} The formatted number string (e.g. '1,234.56')
 * @example
 * formatNumber(1234.56) // '1,234.56'
 * formatNumber(NaN) // '0'
 */
function formatNumber(value) {
    if (isNaN(value)) {
        return '0';
    }
    return new Intl.NumberFormat('en-US').format(value);
}
/**
 * Formats a number as a percentage
 * @param {number} value - The number to format (e.g. 0.75 for 75%)
 * @param {number} [decimalPlaces=2] - Number of decimal places to show
 * @returns {string} The formatted percentage string (e.g. '75.00%')
 * @example
 * formatPercentage(0.75) // '75.00%'
 * formatPercentage(0.753, 1) // '75.3%'
 */
function formatPercentage(value, decimalPlaces = 2) {
    if (isNaN(value)) {
        return '0%';
    }
    return new Intl.NumberFormat('en-US', {
        style: 'percent',
        minimumFractionDigits: decimalPlaces,
    }).format(value);
}
/**
 * Formats a Date object to Australian datetime format for Google Sheets
 * @param {Date} date - The date to format
 * @returns {string} The formatted datetime string in 'DD/MM/YYYY HH:MM:SS' format
 * @example
 * dateTimeForGS(new Date('2025-01-01T12:34:56')) // '01/01/2025 12:34:56'
 */
function dateTimeForGS(date) {
    return date
        .toLocaleString('en-AU', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false,
    })
        .replace(/\./g, '/');
}

var Types = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/*
How it works:
`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.
*/

class Node {
	value;
	next;

	constructor(value) {
		this.value = value;
	}
}

class Queue {
	#head;
	#tail;
	#size;

	constructor() {
		this.clear();
	}

	enqueue(value) {
		const node = new Node(value);

		if (this.#head) {
			this.#tail.next = node;
			this.#tail = node;
		} else {
			this.#head = node;
			this.#tail = node;
		}

		this.#size++;
	}

	dequeue() {
		const current = this.#head;
		if (!current) {
			return;
		}

		this.#head = this.#head.next;
		this.#size--;

		// Clean up tail reference when queue becomes empty
		if (!this.#head) {
			this.#tail = undefined;
		}

		return current.value;
	}

	peek() {
		if (!this.#head) {
			return;
		}

		return this.#head.value;

		// TODO: Node.js 18.
		// return this.#head?.value;
	}

	clear() {
		this.#head = undefined;
		this.#tail = undefined;
		this.#size = 0;
	}

	get size() {
		return this.#size;
	}

	* [Symbol.iterator]() {
		let current = this.#head;

		while (current) {
			yield current.value;
			current = current.next;
		}
	}

	* drain() {
		while (this.#head) {
			yield this.dequeue();
		}
	}
}

function pLimit(concurrency) {
	validateConcurrency(concurrency);

	const queue = new Queue();
	let activeCount = 0;

	const resumeNext = () => {
		if (activeCount < concurrency && queue.size > 0) {
			queue.dequeue()();
			// Since `pendingCount` has been decreased by one, increase `activeCount` by one.
			activeCount++;
		}
	};

	const next = () => {
		activeCount--;

		resumeNext();
	};

	const run = async (function_, resolve, arguments_) => {
		const result = (async () => function_(...arguments_))();

		resolve(result);

		try {
			await result;
		} catch {}

		next();
	};

	const enqueue = (function_, resolve, arguments_) => {
		// Queue `internalResolve` instead of the `run` function
		// to preserve asynchronous context.
		new Promise(internalResolve => {
			queue.enqueue(internalResolve);
		}).then(
			run.bind(undefined, function_, resolve, arguments_),
		);

		(async () => {
			// This function needs to wait until the next microtask before comparing
			// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
			// after the `internalResolve` function is dequeued and called. The comparison in the if-statement
			// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
			await Promise.resolve();

			if (activeCount < concurrency) {
				resumeNext();
			}
		})();
	};

	const generator = (function_, ...arguments_) => new Promise(resolve => {
		enqueue(function_, resolve, arguments_);
	});

	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount,
		},
		pendingCount: {
			get: () => queue.size,
		},
		clearQueue: {
			value() {
				queue.clear();
			},
		},
		concurrency: {
			get: () => concurrency,

			set(newConcurrency) {
				validateConcurrency(newConcurrency);
				concurrency = newConcurrency;

				queueMicrotask(() => {
					// eslint-disable-next-line no-unmodified-loop-condition
					while (activeCount < concurrency && queue.size > 0) {
						resumeNext();
					}
				});
			},
		},
	});

	return generator;
}

function validateConcurrency(concurrency) {
	if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}
}

/**********************************************************************************
 * Polygon.io calls
 **********************************************************************************/
// Constants from environment variables
const POLYGON_API_KEY = process.env.POLYGON_API_KEY;
// Define concurrency limits per API
const POLYGON_CONCURRENCY_LIMIT = 100;
const polygonLimit = pLimit(POLYGON_CONCURRENCY_LIMIT);
// Use to update general information about stocks
/**
 * Fetches general information about a stock ticker.
 * @param {string} symbol - The stock ticker symbol to fetch information for.
 * @param {Object} [options] - Optional parameters.
 * @param {string} [options.apiKey] - The API key to use for the request.
 * @returns {Promise<PolygonTickerInfo | null>} The ticker information or null if not found.
 */
const fetchTickerInfo = async (symbol, options) => {
    if (!options?.apiKey && !POLYGON_API_KEY) {
        throw new Error('Polygon API key is missing');
    }
    const baseUrl = `https://api.polygon.io/v3/reference/tickers/${encodeURIComponent(symbol)}`;
    const params = new URLSearchParams({
        apiKey: options?.apiKey || POLYGON_API_KEY,
    });
    return polygonLimit(async () => {
        try {
            const response = await fetchWithRetry(`${baseUrl}?${params.toString()}`, {}, 3, 1000);
            const data = await response.json();
            // Check for "NOT_FOUND" status and return null
            if (data.status === 'NOT_FOUND') {
                console.warn(`Ticker not found: ${symbol}`);
                return null;
            }
            // Map the results to the required structure
            const results = data.results;
            if (!results) {
                throw new Error('No results in Polygon API response');
            }
            // Validate required fields
            const requiredFields = [
                'active',
                'currency_name',
                'locale',
                'market',
                'name',
                'primary_exchange',
                'ticker',
                'type'
            ];
            for (const field of requiredFields) {
                if (results[field] === undefined) {
                    throw new Error(`Missing required field in Polygon API response: ${field}`);
                }
            }
            // Handle optional share_class_shares_outstanding field
            if (results.share_class_shares_outstanding === undefined) {
                results.share_class_shares_outstanding = null;
            }
            return {
                ticker: results.ticker,
                type: results.type,
                active: results.active,
                currency_name: results.currency_name,
                description: results.description ?? 'No description available',
                locale: results.locale,
                market: results.market,
                market_cap: results.market_cap ?? 0,
                name: results.name,
                primary_exchange: results.primary_exchange,
                share_class_shares_outstanding: results.share_class_shares_outstanding
            };
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            const contextualMessage = `Error fetching ticker info for ${symbol}`;
            console.error(`${contextualMessage}: ${errorMessage}`, {
                symbol,
                errorType: error instanceof Error && error.message.includes('AUTH_ERROR') ? 'AUTH_ERROR' :
                    error instanceof Error && error.message.includes('RATE_LIMIT') ? 'RATE_LIMIT' :
                        error instanceof Error && error.message.includes('NETWORK_ERROR') ? 'NETWORK_ERROR' : 'UNKNOWN',
                url: hideApiKeyFromurl(`${baseUrl}?${params.toString()}`),
                source: 'PolygonAPI.fetchTickerInfo',
                timestamp: new Date().toISOString()
            });
            throw new Error(`${contextualMessage}: ${errorMessage}`);
        }
    });
};
// Fetch last trade using Polygon.io
/**
 * Fetches the last trade for a given stock ticker.
 * @param {string} symbol - The stock ticker symbol to fetch the last trade for.
 * @param {Object} [options] - Optional parameters.
 * @param {string} [options.apiKey] - The API key to use for the request.
 * @returns {Promise<PolygonQuote>} The last trade information.
 */
const fetchLastTrade = async (symbol, options) => {
    if (!options?.apiKey && !POLYGON_API_KEY) {
        throw new Error('Polygon API key is missing');
    }
    const baseUrl = `https://api.polygon.io/v2/last/trade/${encodeURIComponent(symbol)}`;
    const params = new URLSearchParams({
        apiKey: options?.apiKey || POLYGON_API_KEY,
    });
    return polygonLimit(async () => {
        try {
            const response = await fetchWithRetry(`${baseUrl}?${params.toString()}`, {}, 3, 1000);
            const data = await response.json();
            if (data.status !== 'OK' || !data.results) {
                throw new Error(`Polygon.io API error: ${data.status || 'No results'} ${data.error || ''}`);
            }
            const { p: price, s: vol, t: timestamp } = data.results;
            if (typeof price !== 'number' || typeof vol !== 'number' || typeof timestamp !== 'number') {
                throw new Error('Invalid trade data received from Polygon.io API');
            }
            return {
                price,
                vol,
                time: new Date(Math.floor(timestamp / 1000000)), // Convert nanoseconds to milliseconds
            };
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            const contextualMessage = `Error fetching last trade for ${symbol}`;
            console.error(`${contextualMessage}: ${errorMessage}`, {
                symbol,
                errorType: error instanceof Error && error.message.includes('AUTH_ERROR') ? 'AUTH_ERROR' :
                    error instanceof Error && error.message.includes('RATE_LIMIT') ? 'RATE_LIMIT' :
                        error instanceof Error && error.message.includes('NETWORK_ERROR') ? 'NETWORK_ERROR' : 'UNKNOWN',
                url: hideApiKeyFromurl(`${baseUrl}?${params.toString()}`),
                source: 'PolygonAPI.fetchLastTrade',
                timestamp: new Date().toISOString()
            });
            throw new Error(`${contextualMessage}: ${errorMessage}`);
        }
    });
};
// use Polygon for all price data fetching
/**
 * Fetches price data for a given stock ticker.
 * @param {Object} params - The parameters for fetching price data.
 * @param {string} params.ticker - The stock ticker symbol.
 * @param {number} params.start - The start timestamp for fetching price data.
 * @param {number} [params.end] - The end timestamp for fetching price data.
 * @param {number} params.multiplier - The multiplier for the price data.
 * @param {string} params.timespan - The timespan for the price data.
 * @param {number} [params.limit] - The maximum number of price data points to fetch.
 * @param {Object} [options] - Optional parameters.
 * @param {string} [options.apiKey] - The API key to use for the request.
 * @returns {Promise<PolygonPriceData[]>} The fetched price data.
 */
const fetchPrices = async (params, options) => {
    if (!options?.apiKey && !POLYGON_API_KEY) {
        throw new Error('Polygon API key is missing');
    }
    const { ticker, start, end = Date.now().valueOf(), multiplier, timespan, limit = 1000 } = params;
    const baseUrl = `https://api.polygon.io/v2/aggs/ticker/${encodeURIComponent(ticker)}/range/${multiplier}/${timespan}/${start}/${end}`;
    const urlParams = new URLSearchParams({
        apiKey: options?.apiKey || POLYGON_API_KEY,
        adjusted: 'true',
        sort: 'asc',
        limit: limit.toString(),
    });
    return polygonLimit(async () => {
        try {
            let allResults = [];
            let nextUrl = `${baseUrl}?${urlParams.toString()}`;
            while (nextUrl) {
                //console.log(`Debug: Fetching ${nextUrl}`);
                const response = await fetchWithRetry(nextUrl, {}, 3, 1000);
                const data = await response.json();
                if (data.status !== 'OK') {
                    throw new Error(`Polygon.io API responded with status: ${data.status}`);
                }
                if (data.results) {
                    allResults = [...allResults, ...data.results];
                }
                // Check if there's a next page and append API key
                nextUrl = data.next_url ? `${data.next_url}&apiKey=${options?.apiKey || POLYGON_API_KEY}` : '';
            }
            return allResults.map((entry) => ({
                date: new Date(entry.t).toLocaleString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    timeZone: 'America/New_York',
                    timeZoneName: 'short',
                    hourCycle: 'h23',
                }),
                timeStamp: entry.t,
                open: entry.o,
                high: entry.h,
                low: entry.l,
                close: entry.c,
                vol: entry.v,
                vwap: entry.vw,
                trades: entry.n,
            }));
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            const contextualMessage = `Error fetching price data for ${ticker}`;
            console.error(`${contextualMessage}: ${errorMessage}`, {
                ticker,
                errorType: error instanceof Error && error.message.includes('AUTH_ERROR') ? 'AUTH_ERROR' :
                    error instanceof Error && error.message.includes('RATE_LIMIT') ? 'RATE_LIMIT' :
                        error instanceof Error && error.message.includes('NETWORK_ERROR') ? 'NETWORK_ERROR' : 'UNKNOWN',
                source: 'PolygonAPI.fetchPrices',
                timestamp: new Date().toISOString()
            });
            throw new Error(`${contextualMessage}: ${errorMessage}`);
        }
    });
};
/**
 * Analyzes the price data for a given stock.
 * @param {PolygonPriceData[]} priceData - The price data to analyze.
 * @returns {string} The analysis report.
 */
function analysePolygonPriceData(priceData) {
    if (!priceData || priceData.length === 0) {
        return 'No price data available for analysis.';
    }
    // Parse the dates into Date objects
    const parsedData = priceData.map((entry) => ({
        ...entry,
        date: new Date(entry.date),
    }));
    // Sort the data by date
    parsedData.sort((a, b) => a.date.getTime() - b.date.getTime());
    // Extract start and end times
    const startTime = parsedData[0].date;
    const endTime = parsedData[parsedData.length - 1].date;
    // Calculate the total time in hours
    (endTime.getTime() - startTime.getTime()) / (1000 * 60 * 60);
    // Calculate the interval between data points
    const intervals = parsedData
        .slice(1)
        .map((_, i) => (parsedData[i + 1].date.getTime() - parsedData[i].date.getTime()) / 1000); // in seconds
    const avgInterval = intervals.length > 0 ? intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length : 0;
    // Format the report
    const report = `
Report:
* Start time of data (US Eastern): ${startTime.toLocaleString('en-US', { timeZone: 'America/New_York' })}
* End time of data (US Eastern): ${endTime.toLocaleString('en-US', { timeZone: 'America/New_York' })}
* Number of data points: ${priceData.length}
* Average interval between data points (seconds): ${avgInterval.toFixed(2)}
  `;
    return report.trim();
}
/**
 * Fetches grouped daily price data for a specific date.
 * @param {string} date - The date to fetch grouped daily data for.
 * @param {Object} [options] - Optional parameters.
 * @param {string} [options.apiKey] - The API key to use for the request.
 * @param {boolean} [options.adjusted] - Whether to adjust the data.
 * @param {boolean} [options.includeOTC] - Whether to include OTC data.
 * @returns {Promise<PolygonGroupedDailyResponse>} The grouped daily response.
 */
const fetchGroupedDaily = async (date, options) => {
    if (!options?.apiKey && !POLYGON_API_KEY) {
        throw new Error('Polygon API key is missing');
    }
    const baseUrl = `https://api.polygon.io/v2/aggs/grouped/locale/us/market/stocks/${date}`;
    const params = new URLSearchParams({
        apiKey: options?.apiKey || POLYGON_API_KEY,
        adjusted: options?.adjusted !== false ? 'true' : 'false',
        include_otc: options?.includeOTC ? 'true' : 'false',
    });
    return polygonLimit(async () => {
        try {
            const response = await fetchWithRetry(`${baseUrl}?${params.toString()}`, {}, 3, 1000);
            const data = await response.json();
            if (data.status !== 'OK') {
                throw new Error(`Polygon.io API responded with status: ${data.status}`);
            }
            return {
                adjusted: data.adjusted,
                queryCount: data.queryCount,
                request_id: data.request_id,
                resultsCount: data.resultsCount,
                status: data.status,
                results: data.results.map((result) => ({
                    symbol: result.T,
                    timeStamp: result.t,
                    open: result.o,
                    high: result.h,
                    low: result.l,
                    close: result.c,
                    vol: result.v,
                    vwap: result.vw,
                    trades: result.n,
                })),
            };
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            const contextualMessage = `Error fetching grouped daily data for ${date}`;
            console.error(`${contextualMessage}: ${errorMessage}`, {
                date,
                errorType: error instanceof Error && error.message.includes('AUTH_ERROR') ? 'AUTH_ERROR' :
                    error instanceof Error && error.message.includes('RATE_LIMIT') ? 'RATE_LIMIT' :
                        error instanceof Error && error.message.includes('NETWORK_ERROR') ? 'NETWORK_ERROR' : 'UNKNOWN',
                url: hideApiKeyFromurl(`${baseUrl}?${params.toString()}`),
                source: 'PolygonAPI.fetchGroupedDaily',
                timestamp: new Date().toISOString()
            });
            throw new Error(`${contextualMessage}: ${errorMessage}`);
        }
    });
};
/**
 * Formats the price data into a readable string.
 * @param {PolygonPriceData[]} priceData - The price data to format.
 * @returns {string} The formatted price data.
 */
function formatPriceData(priceData) {
    if (!priceData || priceData.length === 0)
        return 'No price data available';
    return priceData
        .map((d) => {
        // For daily data, remove the time portion if it's all zeros
        const dateStr = d.date.includes(', 00:00:00') ? d.date.split(', 00:00:00')[0] : d.date;
        return [
            dateStr,
            `O: ${formatCurrency(d.open)}`,
            `H: ${formatCurrency(d.high)}`,
            `L: ${formatCurrency(d.low)}`,
            `C: ${formatCurrency(d.close)}`,
            `Vol: ${d.vol}`,
        ].join(' | ');
    })
        .join('\n');
}
const fetchDailyOpenClose = async (
/**
 * Fetches the daily open and close data for a given stock ticker.
 * @param {string} symbol - The stock ticker symbol to fetch data for.
 * @param {Date} [date=new Date()] - The date to fetch data for.
 * @param {Object} [options] - Optional parameters.
 * @param {string} [options.apiKey] - The API key to use for the request.
 * @param {boolean} [options.adjusted] - Whether to adjust the data.
 * @returns {Promise<PolygonDailyOpenClose>} The daily open and close data.
 */
symbol, date = new Date(), options) => {
    if (!options?.apiKey && !POLYGON_API_KEY) {
        throw new Error('Polygon API key is missing');
    }
    const formattedDate = date.toISOString().split('T')[0]; // Format as YYYY-MM-DD
    const baseUrl = `https://api.polygon.io/v1/open-close/${encodeURIComponent(symbol)}/${formattedDate}`;
    const params = new URLSearchParams({
        apiKey: options?.apiKey || POLYGON_API_KEY,
        adjusted: (options?.adjusted ?? true).toString(),
    });
    return polygonLimit(async () => {
        const response = await fetchWithRetry(`${baseUrl}?${params.toString()}`, {}, 3, 1000);
        const data = await response.json();
        if (data.status !== 'OK') {
            throw new Error(`Failed to fetch daily open/close data for ${symbol}: ${data.status}`);
        }
        return data;
    });
};
/**
 * Gets the previous close price for a given stock ticker.
 * @param {string} symbol - The stock ticker symbol to fetch the previous close for.
 * @param {Date} [referenceDate] - The reference date to use for fetching the previous close.
 * @returns {Promise<{ close: number; date: Date }>} The previous close price and date.
 */
async function getPreviousClose$1(symbol, referenceDate, options) {
    const previousDate = getLastFullTradingDate(referenceDate).date;
    const lastOpenClose = await fetchDailyOpenClose(symbol, previousDate, options);
    if (!lastOpenClose) {
        throw new Error(`Could not fetch last trade price for ${symbol}`);
    }
    return {
        close: lastOpenClose.close,
        date: previousDate,
    };
}
/**
 * Fetches trade data for a given stock ticker.
 * @param {string} symbol - The stock ticker symbol to fetch trades for.
 * @param {Object} [options] - Optional parameters.
 * @param {string} [options.apiKey] - The API key to use for the request.
 * @param {string | number} [options.timestamp] - The timestamp for fetching trades.
 * @param {string | number} [options.timestampgt] - Greater than timestamp for fetching trades.
 * @param {string | number} [options.timestampgte] - Greater than or equal to timestamp for fetching trades.
 * @param {string | number} [options.timestamplt] - Less than timestamp for fetching trades.
 * @param {string | number} [options.timestamplte] - Less than or equal to timestamp for fetching trades.
 * @param {'asc' | 'desc'} [options.order] - The order of the trades.
 * @param {number} [options.limit] - The maximum number of trades to fetch.
 * @param {string} [options.sort] - The sort order for the trades.
 * @returns {Promise<PolygonTradesResponse>} The fetched trades response.
 */
const fetchTrades = async (symbol, options) => {
    if (!options?.apiKey && !POLYGON_API_KEY) {
        throw new Error('Polygon API key is missing');
    }
    const baseUrl = `https://api.polygon.io/v3/trades/${encodeURIComponent(symbol)}`;
    const params = new URLSearchParams({
        apiKey: options?.apiKey || POLYGON_API_KEY,
    });
    // Add optional parameters if they exist
    if (options?.timestamp)
        params.append('timestamp', options.timestamp.toString());
    if (options?.timestampgt)
        params.append('timestamp.gt', options.timestampgt.toString());
    if (options?.timestampgte)
        params.append('timestamp.gte', options.timestampgte.toString());
    if (options?.timestamplt)
        params.append('timestamp.lt', options.timestamplt.toString());
    if (options?.timestamplte)
        params.append('timestamp.lte', options.timestamplte.toString());
    if (options?.order)
        params.append('order', options.order);
    if (options?.limit)
        params.append('limit', options.limit.toString());
    if (options?.sort)
        params.append('sort', options.sort);
    return polygonLimit(async () => {
        const url = `${baseUrl}?${params.toString()}`;
        try {
            console.log(`[DEBUG] Fetching trades for ${symbol} from ${url}`);
            const response = await fetchWithRetry(url, {}, 3, 1000);
            const data = await response.json();
            if ('message' in data) {
                // This is an error response
                throw new Error(`Polygon API Error: ${data.message}`);
            }
            return data;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            const contextualMessage = `Error fetching trades for ${symbol}`;
            console.error(`${contextualMessage}: ${errorMessage}`, {
                symbol,
                errorType: error instanceof Error && error.message.includes('AUTH_ERROR') ? 'AUTH_ERROR' :
                    error instanceof Error && error.message.includes('RATE_LIMIT') ? 'RATE_LIMIT' :
                        error instanceof Error && error.message.includes('NETWORK_ERROR') ? 'NETWORK_ERROR' : 'UNKNOWN',
                url: hideApiKeyFromurl(url),
                source: 'PolygonAPI.fetchTrades',
                timestamp: new Date().toISOString()
            });
            throw new Error(`${contextualMessage}: ${errorMessage}`);
        }
    });
};

/**
 * Polygon Indices API Implementation
 *
 * This module provides functions to interact with the Polygon.io Indices API.
 */
// Constants from environment variables
const { ALPACA_INDICES_API_KEY } = process.env;
// Define concurrency limits for API
const POLYGON_INDICES_CONCURRENCY_LIMIT = 5;
const polygonIndicesLimit = pLimit(POLYGON_INDICES_CONCURRENCY_LIMIT);
// Base URL for Polygon API
const POLYGON_API_BASE_URL = 'https://api.polygon.io';
/**
 * Validates that an API key is available
 * @param {string | undefined} apiKey - Optional API key to use
 * @throws {Error} If no API key is available
 */
const validateApiKey = (apiKey) => {
    const key = apiKey || ALPACA_INDICES_API_KEY;
    if (!key) {
        throw new Error('Polygon Indices API key is missing');
    }
    return key;
};
/**
 * Fetches aggregate bars for an index over a given date range in custom time window sizes.
 *
 * @param {PolygonIndicesAggregatesParams} params - Parameters for the aggregates request
 * @param {Object} [options] - Optional parameters
 * @param {string} [options.apiKey] - API key to use for the request
 * @returns {Promise<PolygonIndicesAggregatesResponse>} The aggregates response
 */
const fetchIndicesAggregates = async (params, options) => {
    const apiKey = validateApiKey(options?.apiKey);
    const { indicesTicker, multiplier, timespan, from, to, sort = 'asc', limit } = params;
    const url = new URL(`${POLYGON_API_BASE_URL}/v2/aggs/ticker/${encodeURIComponent(indicesTicker)}/range/${multiplier}/${timespan}/${from}/${to}`);
    const queryParams = new URLSearchParams();
    queryParams.append('apiKey', apiKey);
    if (sort) {
        queryParams.append('sort', sort);
    }
    if (limit) {
        queryParams.append('limit', limit.toString());
    }
    url.search = queryParams.toString();
    return polygonIndicesLimit(async () => {
        try {
            const response = await fetchWithRetry(url.toString(), {}, 3, 300);
            const data = await response.json();
            if (data.status === 'ERROR') {
                throw new Error(`Polygon API Error: ${data.error}`);
            }
            return data;
        }
        catch (error) {
            console.error('Error fetching indices aggregates:', error);
            throw error;
        }
    });
};
/**
 * Gets the previous day's open, high, low, and close (OHLC) for the specified index.
 *
 * @param {string} indicesTicker - The ticker symbol of the index
 * @param {Object} [options] - Optional parameters
 * @param {string} [options.apiKey] - API key to use for the request
 * @returns {Promise<PolygonIndicesPrevCloseResponse>} The previous close response
 */
const fetchIndicesPreviousClose = async (indicesTicker, options) => {
    const apiKey = validateApiKey(options?.apiKey);
    const url = new URL(`${POLYGON_API_BASE_URL}/v2/aggs/ticker/${encodeURIComponent(indicesTicker)}/prev`);
    const queryParams = new URLSearchParams();
    queryParams.append('apiKey', apiKey);
    url.search = queryParams.toString();
    return polygonIndicesLimit(async () => {
        try {
            const response = await fetchWithRetry(url.toString(), {}, 3, 300);
            const data = await response.json();
            if (data.status === 'ERROR') {
                throw new Error(`Polygon API Error: ${data.error}`);
            }
            return data;
        }
        catch (error) {
            console.error('Error fetching indices previous close:', error);
            throw error;
        }
    });
};
/**
 * Gets the open, close and afterhours values of an index symbol on a certain date.
 *
 * @param {string} indicesTicker - The ticker symbol of the index
 * @param {string} date - The date in YYYY-MM-DD format
 * @param {Object} [options] - Optional parameters
 * @param {string} [options.apiKey] - API key to use for the request
 * @returns {Promise<PolygonIndicesDailyOpenCloseResponse>} The daily open/close response
 */
const fetchIndicesDailyOpenClose = async (indicesTicker, date, options) => {
    const apiKey = validateApiKey(options?.apiKey);
    const url = new URL(`${POLYGON_API_BASE_URL}/v1/open-close/${encodeURIComponent(indicesTicker)}/${date}`);
    const queryParams = new URLSearchParams();
    queryParams.append('apiKey', apiKey);
    url.search = queryParams.toString();
    return polygonIndicesLimit(async () => {
        try {
            const response = await fetchWithRetry(url.toString(), {}, 3, 300);
            const data = await response.json();
            if (data.status === 'ERROR') {
                throw new Error(`Polygon API Error: ${data.error}`);
            }
            return data;
        }
        catch (error) {
            console.error('Error fetching indices daily open/close:', error);
            throw error;
        }
    });
};
/**
 * Gets a snapshot of indices data for specified tickers.
 *
 * @param {PolygonIndicesSnapshotParams} [params] - Parameters for the snapshot request
 * @param {Object} [options] - Optional parameters
 * @param {string} [options.apiKey] - API key to use for the request
 * @returns {Promise<PolygonIndicesSnapshotResponse>} The indices snapshot response
 */
const fetchIndicesSnapshot = async (params, options) => {
    const apiKey = validateApiKey(options?.apiKey);
    const url = new URL(`${POLYGON_API_BASE_URL}/v3/snapshot/indices`);
    const queryParams = new URLSearchParams();
    queryParams.append('apiKey', apiKey);
    if (params?.tickers?.length) {
        queryParams.append('ticker.any_of', params.tickers.join(','));
    }
    if (params?.order) {
        queryParams.append('order', params.order);
    }
    if (params?.limit) {
        queryParams.append('limit', params.limit.toString());
    }
    if (params?.sort) {
        queryParams.append('sort', params.sort);
    }
    url.search = queryParams.toString();
    return polygonIndicesLimit(async () => {
        try {
            const response = await fetchWithRetry(url.toString(), {}, 3, 300);
            const data = await response.json();
            if (data.status === 'ERROR') {
                throw new Error(`Polygon API Error: ${data.error}`);
            }
            return data;
        }
        catch (error) {
            console.error('Error fetching indices snapshot:', error);
            throw error;
        }
    });
};
/**
 * Gets snapshots for assets of all types, including indices.
 *
 * @param {string[]} tickers - Array of tickers to fetch snapshots for
 * @param {Object} [options] - Optional parameters
 * @param {string} [options.apiKey] - API key to use for the request
 * @param {string} [options.type] - Filter by asset type
 * @param {string} [options.order] - Order results
 * @param {number} [options.limit] - Limit the number of results
 * @param {string} [options.sort] - Sort field
 * @returns {Promise<any>} The universal snapshot response
 */
const fetchUniversalSnapshot = async (tickers, options) => {
    const apiKey = validateApiKey(options?.apiKey);
    const url = new URL(`${POLYGON_API_BASE_URL}/v3/snapshot`);
    const queryParams = new URLSearchParams();
    queryParams.append('apiKey', apiKey);
    if (tickers.length) {
        queryParams.append('ticker.any_of', tickers.join(','));
    }
    if (options?.type) {
        queryParams.append('type', options.type);
    }
    if (options?.order) {
        queryParams.append('order', options.order);
    }
    if (options?.limit) {
        queryParams.append('limit', options.limit.toString());
    }
    if (options?.sort) {
        queryParams.append('sort', options.sort);
    }
    url.search = queryParams.toString();
    return polygonIndicesLimit(async () => {
        try {
            const response = await fetchWithRetry(url.toString(), {}, 3, 300);
            const data = await response.json();
            if (data.status === 'ERROR') {
                throw new Error(`Polygon API Error: ${data.error}`);
            }
            return data;
        }
        catch (error) {
            console.error('Error fetching universal snapshot:', error);
            throw error;
        }
    });
};
/**
 * Converts Polygon Indices bar data to a more standardized format
 *
 * @param {PolygonIndicesAggregatesResponse} data - The raw aggregates response
 * @returns {Array<{date: string, open: number, high: number, low: number, close: number, timestamp: number}>} Formatted bar data
 */
const formatIndicesBarData = (data) => {
    return data.results.map(bar => {
        const date = new Date(bar.t);
        return {
            date: date.toISOString().split('T')[0],
            open: bar.o,
            high: bar.h,
            low: bar.l,
            close: bar.c,
            timestamp: bar.t,
        };
    });
};

/**********************************************************************************
 * AlphaVantage calls
 **********************************************************************************/
// Constants from environment variables
const ALPHA_VANTAGE_API_KEY = process.env.ALPHA_VANTAGE_API_KEY;
function checkEnvironment(apiKey) {
    if (!apiKey && !ALPHA_VANTAGE_API_KEY) {
        throw new Error('ALPHA_VANTAGE_API_KEY is not defined in environment variables or options.');
    }
}
// Define concurrency limits per API
const ALPHA_VANTAGE_CONCURRENCY_LIMIT = 5;
const AVBaseUrl = 'https://www.alphavantage.co/query?function=';
const alphaVantageLimit = pLimit(ALPHA_VANTAGE_CONCURRENCY_LIMIT);
// Fetch current quote. Does not need start / end date
/**
 * Fetches the current quote for a given ticker symbol.
 * @param {string} ticker - The ticker symbol to fetch the quote for.
 * @param {Object} [options] - Optional parameters.
 * @param {string} [options.apiKey] - The API key to use for the request.
 * @returns {Promise<AlphaVantageQuoteResponse>} The current quote response.
 */
const fetchQuote = async (ticker, options) => {
    checkEnvironment(options?.apiKey);
    const endpoint = `${AVBaseUrl}GLOBAL_QUOTE&symbol=${ticker.replace('.', '-')}&entitlement=realtime&apikey=${options?.apiKey || ALPHA_VANTAGE_API_KEY}`;
    return alphaVantageLimit(async () => {
        const response = await fetch(endpoint);
        if (!response.ok) {
            throw new Error(`Failed to fetch quote for ${ticker}`);
        }
        const data = await response.json();
        return data;
    });
};
/**
 * Converts a Date object to a string in the format YYYYMMDDTHHMM.
 * @param {Date} date - The date to convert.
 * @returns {string} The formatted date string.
 */
function convertDateToYYYYMMDDTHHMM(date) {
    const pad = (n) => n.toString().padStart(2, '0');
    const year = date.getFullYear();
    const month = pad(date.getMonth() + 1); // Months are zero-based
    const day = pad(date.getDate());
    const hours = pad(date.getHours());
    const minutes = pad(date.getMinutes());
    return `${year}${month}${day}T${hours}${minutes}`;
}
/**
 * Converts a string in the format YYYYMMDDTHHMMSS to a Date object.
 * @param {string} dateString - The date string to convert.
 * @returns {Date} The corresponding Date object.
 */
function convertYYYYMMDDTHHMMSSToDate(dateString) {
    const year = parseInt(dateString.substring(0, 4), 10);
    const month = parseInt(dateString.substring(4, 6), 10) - 1; // Months are 0-based in JavaScript
    const day = parseInt(dateString.substring(6, 8), 10);
    const hours = parseInt(dateString.substring(9, 11), 10);
    const minutes = parseInt(dateString.substring(11, 13), 10);
    const seconds = parseInt(dateString.substring(13, 15), 10);
    return new Date(Date.UTC(year, month, day, hours, minutes, seconds));
}
/**
 * Fetches news articles from AlphaVantage for a given ticker symbol. Performs filtering as the API endpoint doesn't respect the parameters.
 * @param {string} ticker - The ticker symbol to fetch news for.
 * @param {Object} [options] - Optional parameters.
 * @param {Date} [options.start] - The start date for fetching news.
 * @param {Date} [options.end] - The end date for fetching news.
 * @param {number} [options.limit] - The maximum number of news articles to fetch.
 * @param {string} [options.apiKey] - The API key to use for the request.
 * @returns {Promise<AVNewsArticle[]>} The fetched news articles.
 */
const fetchTickerNews = async (ticker, options = {
    start: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
    end: new Date(),
    limit: 10,
    sort: 'LATEST'
}) => {
    checkEnvironment(options?.apiKey);
    // Format start date as YYYYMMDDTHHMM
    const formattedStart = convertDateToYYYYMMDDTHHMM(options.start ?? new Date(Date.now() - 7 * 24 * 60 * 60 * 1000));
    const formattedEnd = convertDateToYYYYMMDDTHHMM(options.end ?? new Date());
    // Construct the API endpoint
    const endpoint = `${AVBaseUrl}NEWS_SENTIMENT&tickers=${ticker}&time_from=${formattedStart}&time_to=${formattedEnd}&sort=${options.sort}&limit=${options.limit}&apikey=${options?.apiKey || ALPHA_VANTAGE_API_KEY}`;
    return alphaVantageLimit(async () => {
        const response = await fetch(endpoint);
        if (!response.ok) {
            throw new Error(`Failed to fetch news for ticker ${ticker} from AlphaVantage`);
        }
        const data = (await response.json());
        let newsItems = [];
        if (data.items === 0) {
            logIfDebug(`No news found for ticker ${ticker}`);
        }
        else {
            logIfDebug(`Fetched ${data.items} news items for ticker ${ticker}`);
            // Filter articles within date range
            const startTime = options.start?.getTime() ?? new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).getTime();
            const endTime = options.end?.getTime() ?? new Date().getTime();
            newsItems = data && data.feed && data.feed.length > 0 ? data.feed.filter(article => {
                const articleDate = convertYYYYMMDDTHHMMSSToDate(article.time_published);
                return articleDate.getTime() >= startTime && articleDate.getTime() <= endTime;
            }) : [];
            // Sort articles based on the sort parameter
            newsItems.sort((a, b) => {
                const dateA = convertYYYYMMDDTHHMMSSToDate(a.time_published).getTime();
                const dateB = convertYYYYMMDDTHHMMSSToDate(b.time_published).getTime();
                if (options.sort === 'LATEST') {
                    return dateB - dateA;
                }
                else if (options.sort === 'EARLIEST') {
                    return dateA - dateB;
                }
                return 0; // For RELEVANCE, maintain API's order
            });
            // Apply limit after filtering and sorting
            newsItems = newsItems.slice(0, options.limit);
        }
        return newsItems;
    });
};

const ALPACA_API_BASE = 'https://data.alpaca.markets/v1beta3';
/**
 * Fetches cryptocurrency bars for the specified parameters.
 * This function retrieves historical price data for multiple cryptocurrencies.
 *
 * @param params - The parameters for fetching crypto bars.
 * @param params.symbols - An array of cryptocurrency symbols to fetch data for.
 * @param params.timeframe - The timeframe for the bars (e.g., '1Min', '5Min', '1H', '1D').
 * @param params.start - The start date for fetching bars (optional).
 * @param params.end - The end date for fetching bars (optional).
 * @param params.limit - The maximum number of bars to return (optional).
 * @param params.page_token - The token for pagination (optional).
 * @param params.sort - The sorting order for the results (optional).
 * @returns A promise that resolves to an object containing arrays of CryptoBar objects for each symbol.
 */
async function fetchBars(params) {
    // Convert symbols array to comma-separated string
    const symbolsParam = params.symbols.join(',');
    // Initialize result object to store all bars
    const allBars = {};
    params.symbols.forEach((symbol) => {
        allBars[symbol] = [];
    });
    let pageToken = params.page_token;
    let hasMorePages = true;
    while (hasMorePages) {
        // Convert Date objects to RFC-3339 strings for the API
        const queryParams = new URLSearchParams({
            symbols: symbolsParam,
            timeframe: params.timeframe,
            ...(params.start && { start: params.start.toISOString() }),
            ...(params.end && { end: params.end.toISOString() }),
            ...(params.limit && { limit: params.limit.toString() }),
            ...(pageToken && { page_token: pageToken }),
            ...(params.sort && { sort: params.sort }),
        });
        const url = `${ALPACA_API_BASE}/crypto/us/bars?${queryParams}`;
        logIfDebug(`Fetching crypto bars from: ${url}`);
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Alpaca API error (${response.status}): ${errorText}`);
            }
            const data = await response.json();
            // Convert timestamp strings to Date objects and merge bars
            Object.entries(data.bars).forEach(([symbol, bars]) => {
                if (allBars[symbol]) {
                    const barsWithDateObjects = bars.map((bar) => ({
                        ...bar,
                        t: new Date(bar.t),
                    }));
                    allBars[symbol].push(...barsWithDateObjects);
                }
            });
            // Check if there are more pages
            pageToken = data.next_page_token;
            hasMorePages = !!pageToken;
            logIfDebug(`Received ${Object.values(data.bars).flat().length} bars. More pages: ${hasMorePages}`);
        }
        catch (error) {
            logIfDebug(`Error fetching crypto bars: ${error}`);
            throw error;
        }
    }
    return allBars;
}
/**
 * Fetches news articles related to a specific cryptocurrency symbol.
 * This function retrieves news articles from the Alpaca API.
 *
 * @param params - The parameters for fetching news articles.
 * @param params.symbol - The cryptocurrency symbol to fetch news for.
 * @param params.start - The start date for fetching news (optional).
 * @param params.sort - The sorting order for the results (optional).
 * @param params.includeContent - Whether to include the full content of the articles (optional).
 * @param params.limit - The maximum number of articles to return (optional).
 * @param auth - The Alpaca authentication object containing API key and secret.
 * @returns A promise that resolves to an array of AlpacaNewsArticle objects.
 * @throws Will throw an error if required parameters are missing or if fetching fails.
 */
async function fetchNews(params, auth) {
    const { symbol, start = new Date(Date.now() - 24 * 60 * 60 * 1000), sort = 'desc', includeContent = false, limit = 1000, } = params;
    if (!auth.APIKey || !auth.APISecret) {
        throw new Error('Alpaca API key and secret are required');
    }
    if (!symbol) {
        throw new Error('Symbol is required');
    }
    const queryParams = new URLSearchParams({
        start: start.toISOString(),
        sort,
        symbols: symbol,
        include_content: includeContent.toString(),
        limit: limit.toString(),
    });
    const url = `${ALPACA_API_BASE}/news?${queryParams}`;
    logIfDebug(`Fetching news from: ${url}`);
    let newsArticles = [];
    let pageToken = null;
    let hasMorePages = true;
    while (hasMorePages) {
        if (pageToken) {
            queryParams.append('page_token', pageToken);
        }
        const response = await fetch(url);
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Alpaca API error (${response.status}): ${errorText}`);
        }
        const data = await response.json();
        newsArticles = newsArticles.concat(data.news.map((article) => ({
            title: article.headline,
            author: article.author,
            createdAt: article.created_at,
            headline: article.headline,
            source: article.source,
            summary: article.summary,
            url: article.url,
            content: article.content,
        })));
        pageToken = data.next_page_token;
        hasMorePages = !!pageToken;
        logIfDebug(`Received ${data.news.length} news articles. More pages: ${hasMorePages}`);
    }
    // If sort is "asc" and limit is 10, return only the 10 most recent articles
    if (sort === 'asc' && limit === 10) {
        return newsArticles.slice(-10);
    }
    return newsArticles;
}
/**
 * Fetches the latest trades for the specified cryptocurrency symbols.
 * This function retrieves the most recent trade price and volume for each symbol.
 *
 * @param params - The parameters for fetching latest trades.
 * @param params.symbols - An array of cryptocurrency symbols to fetch data for (e.g., ['BTC-USD', 'ETH-USD']).
 * @param params.loc - The location identifier (default: 'us'). Options: 'us' (Alpaca US), 'us-1' (Kraken US), 'eu-1' (Kraken EU).
 * @param auth - The Alpaca authentication object containing API key and secret.
 * @returns A promise that resolves to an object containing the latest trade for each symbol.
 * @throws Will throw an error if required parameters are missing or if fetching fails.
 */
async function fetchLatestTrades(params, auth) {
    const { symbols, loc = 'us' } = params;
    if (!auth.APIKey || !auth.APISecret) {
        throw new Error('Alpaca API key and secret are required');
    }
    if (!symbols || symbols.length === 0) {
        throw new Error('At least one symbol is required');
    }
    // Convert symbols array to comma-separated string
    const symbolsParam = symbols.join(',');
    const queryParams = new URLSearchParams({
        symbols: symbolsParam,
    });
    const url = `${ALPACA_API_BASE}/crypto/${loc}/latest/trades?${queryParams}`;
    logIfDebug(`Fetching crypto latest trades from: ${url}`);
    try {
        const response = await fetch(url, {
            headers: {
                'APCA-API-KEY-ID': auth.APIKey,
                'APCA-API-SECRET-KEY': auth.APISecret,
            },
        });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Alpaca API error (${response.status}): ${errorText}`);
        }
        const data = await response.json();
        logIfDebug(`Received latest trades for ${Object.keys(data.trades).length} symbols`);
        return data;
    }
    catch (error) {
        logIfDebug(`Error fetching crypto latest trades: ${error}`);
        throw error;
    }
}
/**
 * Fetches the latest quotes (bid/ask prices) for the specified cryptocurrency symbols.
 * This function retrieves the most recent bid and ask prices for each symbol.
 *
 * @param params - The parameters for fetching latest quotes.
 * @param params.symbols - An array of cryptocurrency symbols to fetch data for (e.g., ['BTC-USD', 'ETH-USD']).
 * @param params.loc - The location identifier (default: 'us'). Options: 'us' (Alpaca US), 'us-1' (Kraken US), 'eu-1' (Kraken EU).
 * @param auth - The Alpaca authentication object containing API key and secret.
 * @returns A promise that resolves to an object containing the latest quote for each symbol.
 * @throws Will throw an error if required parameters are missing or if fetching fails.
 */
async function fetchLatestQuotes(params, auth) {
    const { symbols, loc = 'us' } = params;
    if (!auth.APIKey || !auth.APISecret) {
        throw new Error('Alpaca API key and secret are required');
    }
    if (!symbols || symbols.length === 0) {
        throw new Error('At least one symbol is required');
    }
    // Convert symbols array to comma-separated string
    const symbolsParam = symbols.join(',');
    const queryParams = new URLSearchParams({
        symbols: symbolsParam,
    });
    const url = `${ALPACA_API_BASE}/crypto/${loc}/latest/quotes?${queryParams}`;
    logIfDebug(`Fetching crypto latest quotes from: ${url}`);
    try {
        const response = await fetch(url, {
            headers: {
                'APCA-API-KEY-ID': auth.APIKey,
                'APCA-API-SECRET-KEY': auth.APISecret,
            },
        });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Alpaca API error (${response.status}): ${errorText}`);
        }
        const data = await response.json();
        logIfDebug(`Received latest quotes for ${Object.keys(data.quotes).length} symbols`);
        return data;
    }
    catch (error) {
        logIfDebug(`Error fetching crypto latest quotes: ${error}`);
        throw error;
    }
}

/**
 * Calculates Bollinger Bands for a given set of price data.
 * Bollinger Bands consist of a middle band (SMA) and two outer bands
 * that are standard deviations away from the middle band.
 *
 * @param priceData - An array of price data objects containing closing prices.
 * @param params - An object containing optional parameters for the calculation.
 * @param params.period - The number of periods to use for the SMA (default is 20).
 * @param params.standardDeviations - The number of standard deviations for the outer bands (default is 2).
 * @returns An array of BollingerBandsData objects containing the calculated bands.
 */
function calculateBollingerBands(priceData, { period = 20, standardDeviations = 2 } = {}) {
    if (priceData.length < period) {
        logIfDebug(`Insufficient data for Bollinger Bands calculation: required periods: ${period}, but only received ${priceData.length} periods of data`);
        return [];
    }
    const result = [];
    for (let i = period - 1; i < priceData.length; i++) {
        const periodSlice = priceData.slice(i - period + 1, i + 1);
        const prices = periodSlice.map((d) => d.close);
        // Calculate middle band (SMA)
        const sum = prices.reduce((acc, price) => acc + price, 0);
        const sma = sum / period;
        // Calculate standard deviation
        const squaredDifferences = prices.map((price) => Math.pow(price - sma, 2));
        const variance = squaredDifferences.reduce((acc, val) => acc + val, 0) / period;
        const standardDeviation = Math.sqrt(variance);
        // Calculate bands
        const upperBand = sma + standardDeviation * standardDeviations;
        const lowerBand = sma - standardDeviation * standardDeviations;
        result.push({
            date: priceData[i].date,
            middle: parseFloat(sma.toFixed(2)),
            upper: parseFloat(upperBand.toFixed(2)),
            lower: parseFloat(lowerBand.toFixed(2)),
            close: priceData[i].close,
        });
    }
    // logIfDebug(`Calculated Bollinger Bands for ${result.length} periods`);
    return result;
}
/**
 * Calculates the Exponential Moving Average (EMA) for a given set of price data.
 * The EMA gives more weight to recent prices, making it more responsive to new information.
 *
 * @param priceData - An array of price data objects containing closing prices.
 * @param params - An object containing optional parameters for the calculation.
 * @param params.period - The number of periods to use for the EMA (default is 20).
 * @param params.period2 - An optional second period for a second EMA (default is 9).
 * @returns An array of EMAData objects containing the calculated EMA values.
 */
function calculateEMA(priceData, { period = 20, period2 = 9 } = {}) {
    if (priceData.length < period || (period2 && priceData.length < period2)) {
        logIfDebug(`Insufficient data for EMA calculation: required periods: ${period}, ${period2}, but only received ${priceData.length} periods of data`);
        return [];
    }
    const result = [];
    const multiplier = 2 / (period + 1);
    const multiplier2 = period2 ? 2 / (period2 + 1) : 0;
    // Calculate initial SMA for first period
    let sum = 0;
    for (let i = 0; i < period; i++) {
        sum += priceData[i].close;
    }
    let prevEMA = sum / period;
    // Calculate initial SMA for second period if needed
    let prevEMA2;
    if (period2) {
        sum = 0;
        for (let i = 0; i < period2; i++) {
            sum += priceData[i].close;
        }
        prevEMA2 = sum / period2;
    }
    // Add first EMA(s)
    const firstEntry = {
        date: priceData[Math.max(period, period2 || 0) - 1].date,
        ema: parseFloat(prevEMA.toFixed(2)),
        close: priceData[Math.max(period, period2 || 0) - 1].close,
    };
    if (period2) {
        firstEntry.ema2 = parseFloat(prevEMA2.toFixed(2));
    }
    result.push(firstEntry);
    // Calculate EMA for remaining periods
    for (let i = Math.max(period, period2 || 0); i < priceData.length; i++) {
        const currentClose = priceData[i].close;
        const currentEMA = (currentClose - prevEMA) * multiplier + prevEMA;
        prevEMA = currentEMA;
        const entry = {
            date: priceData[i].date,
            ema: parseFloat(currentEMA.toFixed(2)),
            close: currentClose,
        };
        if (period2) {
            const currentEMA2 = (currentClose - prevEMA2) * multiplier2 + prevEMA2;
            prevEMA2 = currentEMA2;
            entry.ema2 = parseFloat(currentEMA2.toFixed(2));
        }
        result.push(entry);
    }
    // logIfDebug(`Calculated EMA for ${result.length} periods`);
    return result;
}
/**
 * Calculates Fibonacci retracement and extension levels based on price data.
 * Fibonacci levels are used to identify potential support and resistance levels.
 *
 * @param priceData - An array of price data objects containing high and low prices.
 * @param params - An object containing optional parameters for the calculation.
 * @param params.lookbackPeriod - The number of periods to look back for swing high/low (default is 20).
 * @param params.retracementLevels - An array of retracement levels to calculate (default is [0.236, 0.382, 0.5, 0.618, 0.786]).
 * @param params.extensionLevels - An array of extension levels to calculate (default is [1.272, 1.618, 2.618]).
 * @param params.reverseDirection - A boolean indicating if the trend is reversed (default is false).
 * @returns An array of FibonacciData objects containing the calculated levels.
 */
function calculateFibonacciLevels(priceData, { lookbackPeriod = 20, retracementLevels = [0.236, 0.382, 0.5, 0.618, 0.786], extensionLevels = [1.272, 1.618, 2.618], reverseDirection = false, } = {}) {
    const result = [];
    for (let i = 0; i < priceData.length; i++) {
        const periodSlice = priceData.slice(Math.max(0, i - lookbackPeriod + 1), i + 1);
        const swingHigh = Math.max(...periodSlice.map((d) => d.high));
        const swingLow = Math.min(...periodSlice.map((d) => d.low));
        const priceRange = swingHigh - swingLow;
        const trend = reverseDirection ? 'downtrend' : 'uptrend';
        let levels = [];
        if (priceRange > 0) {
            // Calculate retracement levels
            retracementLevels.forEach((level) => {
                const price = reverseDirection ? swingLow + priceRange * level : swingHigh - priceRange * level;
                levels.push({
                    level,
                    price: parseFloat(price.toFixed(2)),
                    type: 'retracement',
                });
            });
            // Calculate extension levels
            extensionLevels.forEach((level) => {
                const price = reverseDirection
                    ? swingHigh - priceRange * (level - 1) // For downtrend
                    : swingHigh + priceRange * (level - 1); // For uptrend
                levels.push({
                    level,
                    price: parseFloat(price.toFixed(2)),
                    type: 'extension',
                });
            });
            // Sort levels by price
            levels.sort((a, b) => (reverseDirection ? b.price - a.price : a.price - b.price));
        }
        else {
            logIfDebug(`Price range is zero on date ${priceData[i].date}; no levels calculated.`);
        }
        result.push({
            date: priceData[i].date,
            levels,
            swingHigh,
            swingLow,
            trend,
            close: priceData[i].close,
        });
    }
    // logIfDebug(`Calculated Fibonacci levels for ${result.length} periods`);
    return result;
}
/**
 * Calculates the Moving Average Convergence Divergence (MACD) for a given set of price data.
 * MACD is a trend-following momentum indicator that shows the relationship between two EMAs.
 *
 * @param priceData - An array of price data objects containing closing prices.
 * @param params - An object containing optional parameters for the calculation.
 * @param params.shortPeriod - The short EMA period (default is 12).
 * @param params.longPeriod - The long EMA period (default is 26).
 * @param params.signalPeriod - The signal line period (default is 9).
 * @returns An array of MACDData objects containing the calculated MACD values.
 */
function calculateMACD(priceData, { shortPeriod = 12, longPeriod = 26, signalPeriod = 9 } = {}) {
    if (priceData.length < longPeriod + signalPeriod) {
        logIfDebug(`Insufficient data for MACD calculation: required periods: ${longPeriod + signalPeriod}, but only received ${priceData.length} periods of data`);
        return [];
    }
    const emaShort = calculateEMA(priceData, { period: shortPeriod });
    const emaLong = calculateEMA(priceData, { period: longPeriod });
    // Align EMAs by trimming the beginning of emaShort to match emaLong length
    if (emaShort.length < emaLong.length) {
        logIfDebug('Short EMA length is less than Long EMA length for MACD calculation');
        return [];
    }
    const emaShortAligned = emaShort.slice(emaShort.length - emaLong.length);
    const macdLine = emaShortAligned.map((short, i) => short.ema - emaLong[i].ema);
    const result = [];
    if (macdLine.length < signalPeriod) {
        logIfDebug(`Insufficient MACD data for Signal Line calculation: required periods: ${signalPeriod}, but only received ${macdLine.length} periods of data`);
        return [];
    }
    const signalMultiplier = 2 / (signalPeriod + 1);
    let signalEMA = macdLine.slice(0, signalPeriod).reduce((sum, val) => sum + val, 0) / signalPeriod;
    for (let i = signalPeriod; i < macdLine.length; i++) {
        const macdValue = macdLine[i];
        signalEMA = (macdValue - signalEMA) * signalMultiplier + signalEMA;
        const hist = macdValue - signalEMA;
        result.push({
            date: emaLong[i].date, // Use emaLong's date for alignment
            macd: parseFloat(macdValue.toFixed(2)),
            signal: parseFloat(signalEMA.toFixed(2)),
            histogram: parseFloat(hist.toFixed(2)),
            close: emaLong[i].close,
        });
    }
    // logIfDebug(`Calculated MACD for ${result.length} periods`);
    return result;
}
/**
 * Calculates the Relative Strength Index (RSI) for a given set of price data.
 * RSI is a momentum oscillator that measures the speed and change of price movements.
 *
 * @param priceData - An array of price data objects containing closing prices.
 * @param params - An object containing optional parameters for the calculation.
 * @param params.period - The number of periods to use for the RSI (default is 14).
 * @returns An array of RSIData objects containing the calculated RSI values.
 */
function calculateRSI(priceData, { period = 14 } = {}) {
    if (priceData.length < period + 1) {
        logIfDebug(`Insufficient data for RSI calculation: required periods: ${period + 1}, but only received ${priceData.length} periods of data`);
        return [];
    }
    const result = [];
    let avgGain = 0;
    let avgLoss = 0;
    // Calculate first average gain and loss
    for (let i = 1; i <= period; i++) {
        const change = priceData[i].close - priceData[i - 1].close;
        if (change >= 0) {
            avgGain += change;
        }
        else {
            avgLoss += Math.abs(change);
        }
    }
    avgGain = avgGain / period;
    avgLoss = avgLoss / period;
    // Calculate RSI for the first period
    let rs = avgGain / avgLoss;
    let rsi = 100 - 100 / (1 + rs);
    result.push({
        date: priceData[period].date,
        rsi: parseFloat(rsi.toFixed(2)),
        close: priceData[period].close,
    });
    // Calculate subsequent periods using smoothed averages
    for (let i = period + 1; i < priceData.length; i++) {
        const change = priceData[i].close - priceData[i - 1].close;
        const gain = change >= 0 ? change : 0;
        const loss = change < 0 ? Math.abs(change) : 0;
        // Use smoothed averages
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;
        rs = avgGain / avgLoss;
        rsi = 100 - 100 / (1 + rs);
        result.push({
            date: priceData[i].date,
            rsi: parseFloat(rsi.toFixed(2)),
            close: priceData[i].close,
        });
    }
    // logIfDebug(`Calculated RSI for ${result.length} periods`);
    return result;
}
/**
 * Calculates the Stochastic Oscillator for a given set of price data.
 * The Stochastic Oscillator compares a particular closing price of a security to a range of its prices over a certain period of time.
 *
 * @param priceData - An array of price data objects containing high, low, and closing prices.
 * @param params - An object containing optional parameters for the calculation.
 * @param params.lookbackPeriod - The number of periods to look back for the calculation of %K (default is 5).
 * @param params.signalPeriod - The number of periods for the %D signal line (default is 3).
 * @param params.smoothingFactor - The smoothing factor for %K (default is 3).
 * @returns An array of StochData objects containing the calculated %K and %D values.
 */
function calculateStochasticOscillator(priceData, { lookbackPeriod = 5, signalPeriod = 3, smoothingFactor = 3 } = {}) {
    if (priceData.length < lookbackPeriod) {
        logIfDebug(`Insufficient data for Stochastic Oscillator calculation: required periods: ${lookbackPeriod}, but only received ${priceData.length} periods of data`);
        return [];
    }
    const kValues = [];
    const result = [];
    let kSum = 0;
    let dSum = 0;
    for (let i = lookbackPeriod - 1; i < priceData.length; i++) {
        const periodSlice = priceData.slice(i - lookbackPeriod + 1, i + 1);
        const currentClose = periodSlice[periodSlice.length - 1].close;
        const highPrices = periodSlice.map((d) => d.high);
        const lowPrices = periodSlice.map((d) => d.low);
        const highestHigh = Math.max(...highPrices);
        const lowestLow = Math.min(...lowPrices);
        const k = highestHigh === lowestLow ? 0 : ((currentClose - lowestLow) / (highestHigh - lowestLow)) * 100;
        kValues.push(k);
        kSum += k;
        if (kValues.length > smoothingFactor)
            kSum -= kValues[kValues.length - smoothingFactor - 1];
        const smoothedK = kSum / Math.min(kValues.length, smoothingFactor);
        dSum += smoothedK;
        if (kValues.length > smoothingFactor + signalPeriod - 1)
            dSum -= kValues[kValues.length - smoothingFactor - signalPeriod];
        const smoothedD = dSum / Math.min(kValues.length - smoothingFactor + 1, signalPeriod);
        if (kValues.length >= smoothingFactor + signalPeriod - 1) {
            result.push({
                date: priceData[i].date,
                slowK: parseFloat(smoothedK.toFixed(2)),
                slowD: parseFloat(smoothedD.toFixed(2)),
                close: currentClose,
            });
        }
    }
    // logIfDebug(`Calculated Stochastic Oscillator for ${result.length} periods`);
    return result;
}
/**
 * Calculates support and resistance levels based on price data.
 * Support and resistance levels are price levels at which a stock tends to stop and reverse.
 *
 * @param priceData - An array of price data objects containing high, low, and closing prices.
 * @param params - An object containing optional parameters for the calculation.
 * @param params.maxLevels - The maximum number of support/resistance levels to return (default is 5).
 * @param params.lookbackPeriod - The number of periods to look back for pivot points (default is 10).
 * @returns An array of SupportResistanceData objects containing the calculated levels.
 */
function calculateSupportAndResistance(priceData, { maxLevels = 5, lookbackPeriod = 10 } = {}) {
    const result = [];
    for (let i = 0; i < priceData.length; i++) {
        const startIdx = Math.max(0, i - lookbackPeriod);
        const analysisWindow = priceData.slice(startIdx, i + 1);
        const pivotPoints = [];
        // **Compute Volatility Metrics**
        const priceChanges = analysisWindow.slice(1).map((bar, idx) => Math.abs(bar.close - analysisWindow[idx].close));
        const avgPriceChange = priceChanges.reduce((sum, change) => sum + change, 0) / priceChanges.length;
        const volatility = avgPriceChange / analysisWindow[0].close; // Relative volatility
        // **Adjust Sensitivity and minGapBetweenLevels Dynamically**
        const sensitivity = volatility * 2; // Adjust the multiplier as needed
        const minGapBetweenLevels = volatility * 100; // Convert to percentage
        // Analyze each point in window for pivot status
        for (let j = 1; j < analysisWindow.length - 1; j++) {
            const curr = analysisWindow[j];
            const prevBar = analysisWindow[j - 1];
            const nextBar = analysisWindow[j + 1];
            // Check for high pivot
            if (curr.high > prevBar.high && curr.high > nextBar.high) {
                const existingPivot = pivotPoints.find((p) => Math.abs(p.price - curr.high) / curr.high < sensitivity);
                if (existingPivot) {
                    existingPivot.count++;
                    existingPivot.volume += curr.vol; // **Include Volume**
                }
                else {
                    pivotPoints.push({ price: curr.high, count: 1, volume: curr.vol });
                }
            }
            // Check for low pivot
            if (curr.low < prevBar.low && curr.low < nextBar.low) {
                const existingPivot = pivotPoints.find((p) => Math.abs(p.price - curr.low) / curr.low < sensitivity);
                if (existingPivot) {
                    existingPivot.count++;
                    existingPivot.volume += curr.vol; // **Include Volume**
                }
                else {
                    pivotPoints.push({ price: curr.low, count: 1, volume: curr.vol });
                }
            }
        }
        // Group nearby levels
        const currentPrice = priceData[i].close;
        const levels = [];
        // Sort pivots by price
        pivotPoints.sort((a, b) => a.price - b.price);
        // Group close pivots
        let currentGroup = [];
        for (let j = 0; j < pivotPoints.length; j++) {
            if (currentGroup.length === 0) {
                currentGroup.push(pivotPoints[j]);
            }
            else {
                const lastPrice = currentGroup[currentGroup.length - 1].price;
                if ((Math.abs(pivotPoints[j].price - lastPrice) / lastPrice) * 100 <= minGapBetweenLevels) {
                    currentGroup.push(pivotPoints[j]);
                }
                else {
                    // Process current group
                    if (currentGroup.length > 0) {
                        const totalVolume = currentGroup.reduce((sum, p) => sum + p.volume, 0);
                        const avgPrice = currentGroup.reduce((sum, p) => sum + p.price * p.volume, 0) / totalVolume;
                        const totalStrength = currentGroup.reduce((sum, p) => sum + p.count * (p.volume / totalVolume), 0);
                        levels.push({
                            price: parseFloat(avgPrice.toFixed(2)),
                            strength: parseFloat(totalStrength.toFixed(2)),
                            type: avgPrice > currentPrice ? 'resistance' : 'support',
                        });
                    }
                    currentGroup = [pivotPoints[j]];
                }
            }
        }
        // Process final group
        if (currentGroup.length > 0) {
            const totalVolume = currentGroup.reduce((sum, p) => sum + p.volume, 0);
            const avgPrice = currentGroup.reduce((sum, p) => sum + p.price * p.volume, 0) / totalVolume;
            const totalStrength = currentGroup.reduce((sum, p) => sum + p.count * (p.volume / totalVolume), 0);
            levels.push({
                price: parseFloat(avgPrice.toFixed(2)),
                strength: parseFloat(totalStrength.toFixed(2)),
                type: avgPrice > currentPrice ? 'resistance' : 'support',
            });
        }
        // Sort by strength and limit
        const finalLevels = levels.sort((a, b) => b.strength - a.strength).slice(0, maxLevels);
        result.push({
            date: priceData[i].date,
            levels: finalLevels,
            close: currentPrice,
        });
    }
    logIfDebug(`Found ${result.reduce((sum, r) => sum + r.levels.length, 0)} support/resistance levels across ${result.length} periods`);
    return result;
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var bufferUtil = {exports: {}};

var constants;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;

	constants = {
	  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
	  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
	  kStatusCode: Symbol('status-code'),
	  kWebSocket: Symbol('websocket'),
	  EMPTY_BUFFER: Buffer.alloc(0),
	  NOOP: () => {}
	};
	return constants;
}

var hasRequiredBufferUtil;

function requireBufferUtil () {
	if (hasRequiredBufferUtil) return bufferUtil.exports;
	hasRequiredBufferUtil = 1;

	const { EMPTY_BUFFER } = requireConstants();

	/**
	 * Merges an array of buffers into a new buffer.
	 *
	 * @param {Buffer[]} list The array of buffers to concat
	 * @param {Number} totalLength The total length of buffers in the list
	 * @return {Buffer} The resulting buffer
	 * @public
	 */
	function concat(list, totalLength) {
	  if (list.length === 0) return EMPTY_BUFFER;
	  if (list.length === 1) return list[0];

	  const target = Buffer.allocUnsafe(totalLength);
	  let offset = 0;

	  for (let i = 0; i < list.length; i++) {
	    const buf = list[i];
	    target.set(buf, offset);
	    offset += buf.length;
	  }

	  if (offset < totalLength) return target.slice(0, offset);

	  return target;
	}

	/**
	 * Masks a buffer using the given mask.
	 *
	 * @param {Buffer} source The buffer to mask
	 * @param {Buffer} mask The mask to use
	 * @param {Buffer} output The buffer where to store the result
	 * @param {Number} offset The offset at which to start writing
	 * @param {Number} length The number of bytes to mask.
	 * @public
	 */
	function _mask(source, mask, output, offset, length) {
	  for (let i = 0; i < length; i++) {
	    output[offset + i] = source[i] ^ mask[i & 3];
	  }
	}

	/**
	 * Unmasks a buffer using the given mask.
	 *
	 * @param {Buffer} buffer The buffer to unmask
	 * @param {Buffer} mask The mask to use
	 * @public
	 */
	function _unmask(buffer, mask) {
	  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
	  const length = buffer.length;
	  for (let i = 0; i < length; i++) {
	    buffer[i] ^= mask[i & 3];
	  }
	}

	/**
	 * Converts a buffer to an `ArrayBuffer`.
	 *
	 * @param {Buffer} buf The buffer to convert
	 * @return {ArrayBuffer} Converted buffer
	 * @public
	 */
	function toArrayBuffer(buf) {
	  if (buf.byteLength === buf.buffer.byteLength) {
	    return buf.buffer;
	  }

	  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
	}

	/**
	 * Converts `data` to a `Buffer`.
	 *
	 * @param {*} data The data to convert
	 * @return {Buffer} The buffer
	 * @throws {TypeError}
	 * @public
	 */
	function toBuffer(data) {
	  toBuffer.readOnly = true;

	  if (Buffer.isBuffer(data)) return data;

	  let buf;

	  if (data instanceof ArrayBuffer) {
	    buf = Buffer.from(data);
	  } else if (ArrayBuffer.isView(data)) {
	    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
	  } else {
	    buf = Buffer.from(data);
	    toBuffer.readOnly = false;
	  }

	  return buf;
	}

	try {
	  const bufferUtil$1 = require('bufferutil');
	  const bu = bufferUtil$1.BufferUtil || bufferUtil$1;

	  bufferUtil.exports = {
	    concat,
	    mask(source, mask, output, offset, length) {
	      if (length < 48) _mask(source, mask, output, offset, length);
	      else bu.mask(source, mask, output, offset, length);
	    },
	    toArrayBuffer,
	    toBuffer,
	    unmask(buffer, mask) {
	      if (buffer.length < 32) _unmask(buffer, mask);
	      else bu.unmask(buffer, mask);
	    }
	  };
	} catch (e) /* istanbul ignore next */ {
	  bufferUtil.exports = {
	    concat,
	    mask: _mask,
	    toArrayBuffer,
	    toBuffer,
	    unmask: _unmask
	  };
	}
	return bufferUtil.exports;
}

var limiter;
var hasRequiredLimiter;

function requireLimiter () {
	if (hasRequiredLimiter) return limiter;
	hasRequiredLimiter = 1;

	const kDone = Symbol('kDone');
	const kRun = Symbol('kRun');

	/**
	 * A very simple job queue with adjustable concurrency. Adapted from
	 * https://github.com/STRML/async-limiter
	 */
	class Limiter {
	  /**
	   * Creates a new `Limiter`.
	   *
	   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
	   *     to run concurrently
	   */
	  constructor(concurrency) {
	    this[kDone] = () => {
	      this.pending--;
	      this[kRun]();
	    };
	    this.concurrency = concurrency || Infinity;
	    this.jobs = [];
	    this.pending = 0;
	  }

	  /**
	   * Adds a job to the queue.
	   *
	   * @param {Function} job The job to run
	   * @public
	   */
	  add(job) {
	    this.jobs.push(job);
	    this[kRun]();
	  }

	  /**
	   * Removes a job from the queue and runs it if possible.
	   *
	   * @private
	   */
	  [kRun]() {
	    if (this.pending === this.concurrency) return;

	    if (this.jobs.length) {
	      const job = this.jobs.shift();

	      this.pending++;
	      job(this[kDone]);
	    }
	  }
	}

	limiter = Limiter;
	return limiter;
}

var permessageDeflate;
var hasRequiredPermessageDeflate;

function requirePermessageDeflate () {
	if (hasRequiredPermessageDeflate) return permessageDeflate;
	hasRequiredPermessageDeflate = 1;

	const zlib = require$$0$1;

	const bufferUtil = requireBufferUtil();
	const Limiter = requireLimiter();
	const { kStatusCode, NOOP } = requireConstants();

	const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
	const kPerMessageDeflate = Symbol('permessage-deflate');
	const kTotalLength = Symbol('total-length');
	const kCallback = Symbol('callback');
	const kBuffers = Symbol('buffers');
	const kError = Symbol('error');

	//
	// We limit zlib concurrency, which prevents severe memory fragmentation
	// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
	// and https://github.com/websockets/ws/issues/1202
	//
	// Intentionally global; it's the global thread pool that's an issue.
	//
	let zlibLimiter;

	/**
	 * permessage-deflate implementation.
	 */
	class PerMessageDeflate {
	  /**
	   * Creates a PerMessageDeflate instance.
	   *
	   * @param {Object} [options] Configuration options
	   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
	   *     disabling of server context takeover
	   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
	   *     acknowledge disabling of client context takeover
	   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
	   *     use of a custom server window size
	   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
	   *     for, or request, a custom client window size
	   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
	   *     deflate
	   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
	   *     inflate
	   * @param {Number} [options.threshold=1024] Size (in bytes) below which
	   *     messages should not be compressed
	   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
	   *     calls to zlib
	   * @param {Boolean} [isServer=false] Create the instance in either server or
	   *     client mode
	   * @param {Number} [maxPayload=0] The maximum allowed message length
	   */
	  constructor(options, isServer, maxPayload) {
	    this._maxPayload = maxPayload | 0;
	    this._options = options || {};
	    this._threshold =
	      this._options.threshold !== undefined ? this._options.threshold : 1024;
	    this._isServer = !!isServer;
	    this._deflate = null;
	    this._inflate = null;

	    this.params = null;

	    if (!zlibLimiter) {
	      const concurrency =
	        this._options.concurrencyLimit !== undefined
	          ? this._options.concurrencyLimit
	          : 10;
	      zlibLimiter = new Limiter(concurrency);
	    }
	  }

	  /**
	   * @type {String}
	   */
	  static get extensionName() {
	    return 'permessage-deflate';
	  }

	  /**
	   * Create an extension negotiation offer.
	   *
	   * @return {Object} Extension parameters
	   * @public
	   */
	  offer() {
	    const params = {};

	    if (this._options.serverNoContextTakeover) {
	      params.server_no_context_takeover = true;
	    }
	    if (this._options.clientNoContextTakeover) {
	      params.client_no_context_takeover = true;
	    }
	    if (this._options.serverMaxWindowBits) {
	      params.server_max_window_bits = this._options.serverMaxWindowBits;
	    }
	    if (this._options.clientMaxWindowBits) {
	      params.client_max_window_bits = this._options.clientMaxWindowBits;
	    } else if (this._options.clientMaxWindowBits == null) {
	      params.client_max_window_bits = true;
	    }

	    return params;
	  }

	  /**
	   * Accept an extension negotiation offer/response.
	   *
	   * @param {Array} configurations The extension negotiation offers/reponse
	   * @return {Object} Accepted configuration
	   * @public
	   */
	  accept(configurations) {
	    configurations = this.normalizeParams(configurations);

	    this.params = this._isServer
	      ? this.acceptAsServer(configurations)
	      : this.acceptAsClient(configurations);

	    return this.params;
	  }

	  /**
	   * Releases all resources used by the extension.
	   *
	   * @public
	   */
	  cleanup() {
	    if (this._inflate) {
	      this._inflate.close();
	      this._inflate = null;
	    }

	    if (this._deflate) {
	      const callback = this._deflate[kCallback];

	      this._deflate.close();
	      this._deflate = null;

	      if (callback) {
	        callback(
	          new Error(
	            'The deflate stream was closed while data was being processed'
	          )
	        );
	      }
	    }
	  }

	  /**
	   *  Accept an extension negotiation offer.
	   *
	   * @param {Array} offers The extension negotiation offers
	   * @return {Object} Accepted configuration
	   * @private
	   */
	  acceptAsServer(offers) {
	    const opts = this._options;
	    const accepted = offers.find((params) => {
	      if (
	        (opts.serverNoContextTakeover === false &&
	          params.server_no_context_takeover) ||
	        (params.server_max_window_bits &&
	          (opts.serverMaxWindowBits === false ||
	            (typeof opts.serverMaxWindowBits === 'number' &&
	              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
	        (typeof opts.clientMaxWindowBits === 'number' &&
	          !params.client_max_window_bits)
	      ) {
	        return false;
	      }

	      return true;
	    });

	    if (!accepted) {
	      throw new Error('None of the extension offers can be accepted');
	    }

	    if (opts.serverNoContextTakeover) {
	      accepted.server_no_context_takeover = true;
	    }
	    if (opts.clientNoContextTakeover) {
	      accepted.client_no_context_takeover = true;
	    }
	    if (typeof opts.serverMaxWindowBits === 'number') {
	      accepted.server_max_window_bits = opts.serverMaxWindowBits;
	    }
	    if (typeof opts.clientMaxWindowBits === 'number') {
	      accepted.client_max_window_bits = opts.clientMaxWindowBits;
	    } else if (
	      accepted.client_max_window_bits === true ||
	      opts.clientMaxWindowBits === false
	    ) {
	      delete accepted.client_max_window_bits;
	    }

	    return accepted;
	  }

	  /**
	   * Accept the extension negotiation response.
	   *
	   * @param {Array} response The extension negotiation response
	   * @return {Object} Accepted configuration
	   * @private
	   */
	  acceptAsClient(response) {
	    const params = response[0];

	    if (
	      this._options.clientNoContextTakeover === false &&
	      params.client_no_context_takeover
	    ) {
	      throw new Error('Unexpected parameter "client_no_context_takeover"');
	    }

	    if (!params.client_max_window_bits) {
	      if (typeof this._options.clientMaxWindowBits === 'number') {
	        params.client_max_window_bits = this._options.clientMaxWindowBits;
	      }
	    } else if (
	      this._options.clientMaxWindowBits === false ||
	      (typeof this._options.clientMaxWindowBits === 'number' &&
	        params.client_max_window_bits > this._options.clientMaxWindowBits)
	    ) {
	      throw new Error(
	        'Unexpected or invalid parameter "client_max_window_bits"'
	      );
	    }

	    return params;
	  }

	  /**
	   * Normalize parameters.
	   *
	   * @param {Array} configurations The extension negotiation offers/reponse
	   * @return {Array} The offers/response with normalized parameters
	   * @private
	   */
	  normalizeParams(configurations) {
	    configurations.forEach((params) => {
	      Object.keys(params).forEach((key) => {
	        let value = params[key];

	        if (value.length > 1) {
	          throw new Error(`Parameter "${key}" must have only a single value`);
	        }

	        value = value[0];

	        if (key === 'client_max_window_bits') {
	          if (value !== true) {
	            const num = +value;
	            if (!Number.isInteger(num) || num < 8 || num > 15) {
	              throw new TypeError(
	                `Invalid value for parameter "${key}": ${value}`
	              );
	            }
	            value = num;
	          } else if (!this._isServer) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else if (key === 'server_max_window_bits') {
	          const num = +value;
	          if (!Number.isInteger(num) || num < 8 || num > 15) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	          value = num;
	        } else if (
	          key === 'client_no_context_takeover' ||
	          key === 'server_no_context_takeover'
	        ) {
	          if (value !== true) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else {
	          throw new Error(`Unknown parameter "${key}"`);
	        }

	        params[key] = value;
	      });
	    });

	    return configurations;
	  }

	  /**
	   * Decompress data. Concurrency limited.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @public
	   */
	  decompress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._decompress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }

	  /**
	   * Compress data. Concurrency limited.
	   *
	   * @param {Buffer} data Data to compress
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @public
	   */
	  compress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._compress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }

	  /**
	   * Decompress data.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @private
	   */
	  _decompress(data, fin, callback) {
	    const endpoint = this._isServer ? 'client' : 'server';

	    if (!this._inflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];

	      this._inflate = zlib.createInflateRaw({
	        ...this._options.zlibInflateOptions,
	        windowBits
	      });
	      this._inflate[kPerMessageDeflate] = this;
	      this._inflate[kTotalLength] = 0;
	      this._inflate[kBuffers] = [];
	      this._inflate.on('error', inflateOnError);
	      this._inflate.on('data', inflateOnData);
	    }

	    this._inflate[kCallback] = callback;

	    this._inflate.write(data);
	    if (fin) this._inflate.write(TRAILER);

	    this._inflate.flush(() => {
	      const err = this._inflate[kError];

	      if (err) {
	        this._inflate.close();
	        this._inflate = null;
	        callback(err);
	        return;
	      }

	      const data = bufferUtil.concat(
	        this._inflate[kBuffers],
	        this._inflate[kTotalLength]
	      );

	      if (this._inflate._readableState.endEmitted) {
	        this._inflate.close();
	        this._inflate = null;
	      } else {
	        this._inflate[kTotalLength] = 0;
	        this._inflate[kBuffers] = [];

	        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	          this._inflate.reset();
	        }
	      }

	      callback(null, data);
	    });
	  }

	  /**
	   * Compress data.
	   *
	   * @param {Buffer} data Data to compress
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @private
	   */
	  _compress(data, fin, callback) {
	    const endpoint = this._isServer ? 'server' : 'client';

	    if (!this._deflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];

	      this._deflate = zlib.createDeflateRaw({
	        ...this._options.zlibDeflateOptions,
	        windowBits
	      });

	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];

	      //
	      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the
	      // `zlib.DeflateRaw` instance is closed while data is being processed.
	      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong
	      // time due to an abnormal WebSocket closure.
	      //
	      this._deflate.on('error', NOOP);
	      this._deflate.on('data', deflateOnData);
	    }

	    this._deflate[kCallback] = callback;

	    this._deflate.write(data);
	    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
	      if (!this._deflate) {
	        //
	        // The deflate stream was closed while data was being processed.
	        //
	        return;
	      }

	      let data = bufferUtil.concat(
	        this._deflate[kBuffers],
	        this._deflate[kTotalLength]
	      );

	      if (fin) data = data.slice(0, data.length - 4);

	      //
	      // Ensure that the callback will not be called again in
	      // `PerMessageDeflate#cleanup()`.
	      //
	      this._deflate[kCallback] = null;

	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];

	      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	        this._deflate.reset();
	      }

	      callback(null, data);
	    });
	  }
	}

	permessageDeflate = PerMessageDeflate;

	/**
	 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function deflateOnData(chunk) {
	  this[kBuffers].push(chunk);
	  this[kTotalLength] += chunk.length;
	}

	/**
	 * The listener of the `zlib.InflateRaw` stream `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function inflateOnData(chunk) {
	  this[kTotalLength] += chunk.length;

	  if (
	    this[kPerMessageDeflate]._maxPayload < 1 ||
	    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
	  ) {
	    this[kBuffers].push(chunk);
	    return;
	  }

	  this[kError] = new RangeError('Max payload size exceeded');
	  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
	  this[kError][kStatusCode] = 1009;
	  this.removeListener('data', inflateOnData);
	  this.reset();
	}

	/**
	 * The listener of the `zlib.InflateRaw` stream `'error'` event.
	 *
	 * @param {Error} err The emitted error
	 * @private
	 */
	function inflateOnError(err) {
	  //
	  // There is no need to call `Zlib#close()` as the handle is automatically
	  // closed when an error is emitted.
	  //
	  this[kPerMessageDeflate]._inflate = null;
	  err[kStatusCode] = 1007;
	  this[kCallback](err);
	}
	return permessageDeflate;
}

var validation = {exports: {}};

var hasRequiredValidation;

function requireValidation () {
	if (hasRequiredValidation) return validation.exports;
	hasRequiredValidation = 1;

	/**
	 * Checks if a status code is allowed in a close frame.
	 *
	 * @param {Number} code The status code
	 * @return {Boolean} `true` if the status code is valid, else `false`
	 * @public
	 */
	function isValidStatusCode(code) {
	  return (
	    (code >= 1000 &&
	      code <= 1014 &&
	      code !== 1004 &&
	      code !== 1005 &&
	      code !== 1006) ||
	    (code >= 3000 && code <= 4999)
	  );
	}

	/**
	 * Checks if a given buffer contains only correct UTF-8.
	 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	 * Markus Kuhn.
	 *
	 * @param {Buffer} buf The buffer to check
	 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	 * @public
	 */
	function _isValidUTF8(buf) {
	  const len = buf.length;
	  let i = 0;

	  while (i < len) {
	    if ((buf[i] & 0x80) === 0) {
	      // 0xxxxxxx
	      i++;
	    } else if ((buf[i] & 0xe0) === 0xc0) {
	      // 110xxxxx 10xxxxxx
	      if (
	        i + 1 === len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i] & 0xfe) === 0xc0 // Overlong
	      ) {
	        return false;
	      }

	      i += 2;
	    } else if ((buf[i] & 0xf0) === 0xe0) {
	      // 1110xxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 2 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
	        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
	      ) {
	        return false;
	      }

	      i += 3;
	    } else if ((buf[i] & 0xf8) === 0xf0) {
	      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 3 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i + 3] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
	        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
	        buf[i] > 0xf4 // > U+10FFFF
	      ) {
	        return false;
	      }

	      i += 4;
	    } else {
	      return false;
	    }
	  }

	  return true;
	}

	try {
	  let isValidUTF8 = require('utf-8-validate');

	  /* istanbul ignore if */
	  if (typeof isValidUTF8 === 'object') {
	    isValidUTF8 = isValidUTF8.Validation.isValidUTF8; // utf-8-validate@<3.0.0
	  }

	  validation.exports = {
	    isValidStatusCode,
	    isValidUTF8(buf) {
	      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
	    }
	  };
	} catch (e) /* istanbul ignore next */ {
	  validation.exports = {
	    isValidStatusCode,
	    isValidUTF8: _isValidUTF8
	  };
	}
	return validation.exports;
}

var receiver;
var hasRequiredReceiver;

function requireReceiver () {
	if (hasRequiredReceiver) return receiver;
	hasRequiredReceiver = 1;

	const { Writable } = require$$0$2;

	const PerMessageDeflate = requirePermessageDeflate();
	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  kStatusCode,
	  kWebSocket
	} = requireConstants();
	const { concat, toArrayBuffer, unmask } = requireBufferUtil();
	const { isValidStatusCode, isValidUTF8 } = requireValidation();

	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;

	/**
	 * HyBi Receiver implementation.
	 *
	 * @extends Writable
	 */
	class Receiver extends Writable {
	  /**
	   * Creates a Receiver instance.
	   *
	   * @param {String} [binaryType=nodebuffer] The type for binary data
	   * @param {Object} [extensions] An object containing the negotiated extensions
	   * @param {Boolean} [isServer=false] Specifies whether to operate in client or
	   *     server mode
	   * @param {Number} [maxPayload=0] The maximum allowed message length
	   */
	  constructor(binaryType, extensions, isServer, maxPayload) {
	    super();

	    this._binaryType = binaryType || BINARY_TYPES[0];
	    this[kWebSocket] = undefined;
	    this._extensions = extensions || {};
	    this._isServer = !!isServer;
	    this._maxPayload = maxPayload | 0;

	    this._bufferedBytes = 0;
	    this._buffers = [];

	    this._compressed = false;
	    this._payloadLength = 0;
	    this._mask = undefined;
	    this._fragmented = 0;
	    this._masked = false;
	    this._fin = false;
	    this._opcode = 0;

	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragments = [];

	    this._state = GET_INFO;
	    this._loop = false;
	  }

	  /**
	   * Implements `Writable.prototype._write()`.
	   *
	   * @param {Buffer} chunk The chunk of data to write
	   * @param {String} encoding The character encoding of `chunk`
	   * @param {Function} cb Callback
	   * @private
	   */
	  _write(chunk, encoding, cb) {
	    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

	    this._bufferedBytes += chunk.length;
	    this._buffers.push(chunk);
	    this.startLoop(cb);
	  }

	  /**
	   * Consumes `n` bytes from the buffered data.
	   *
	   * @param {Number} n The number of bytes to consume
	   * @return {Buffer} The consumed bytes
	   * @private
	   */
	  consume(n) {
	    this._bufferedBytes -= n;

	    if (n === this._buffers[0].length) return this._buffers.shift();

	    if (n < this._buffers[0].length) {
	      const buf = this._buffers[0];
	      this._buffers[0] = buf.slice(n);
	      return buf.slice(0, n);
	    }

	    const dst = Buffer.allocUnsafe(n);

	    do {
	      const buf = this._buffers[0];
	      const offset = dst.length - n;

	      if (n >= buf.length) {
	        dst.set(this._buffers.shift(), offset);
	      } else {
	        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
	        this._buffers[0] = buf.slice(n);
	      }

	      n -= buf.length;
	    } while (n > 0);

	    return dst;
	  }

	  /**
	   * Starts the parsing loop.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  startLoop(cb) {
	    let err;
	    this._loop = true;

	    do {
	      switch (this._state) {
	        case GET_INFO:
	          err = this.getInfo();
	          break;
	        case GET_PAYLOAD_LENGTH_16:
	          err = this.getPayloadLength16();
	          break;
	        case GET_PAYLOAD_LENGTH_64:
	          err = this.getPayloadLength64();
	          break;
	        case GET_MASK:
	          this.getMask();
	          break;
	        case GET_DATA:
	          err = this.getData(cb);
	          break;
	        default:
	          // `INFLATING`
	          this._loop = false;
	          return;
	      }
	    } while (this._loop);

	    cb(err);
	  }

	  /**
	   * Reads the first two bytes of a frame.
	   *
	   * @return {(RangeError|undefined)} A possible error
	   * @private
	   */
	  getInfo() {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }

	    const buf = this.consume(2);

	    if ((buf[0] & 0x30) !== 0x00) {
	      this._loop = false;
	      return error(
	        RangeError,
	        'RSV2 and RSV3 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_2_3'
	      );
	    }

	    const compressed = (buf[0] & 0x40) === 0x40;

	    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
	      this._loop = false;
	      return error(
	        RangeError,
	        'RSV1 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_1'
	      );
	    }

	    this._fin = (buf[0] & 0x80) === 0x80;
	    this._opcode = buf[0] & 0x0f;
	    this._payloadLength = buf[1] & 0x7f;

	    if (this._opcode === 0x00) {
	      if (compressed) {
	        this._loop = false;
	        return error(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );
	      }

	      if (!this._fragmented) {
	        this._loop = false;
	        return error(
	          RangeError,
	          'invalid opcode 0',
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );
	      }

	      this._opcode = this._fragmented;
	    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
	      if (this._fragmented) {
	        this._loop = false;
	        return error(
	          RangeError,
	          `invalid opcode ${this._opcode}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );
	      }

	      this._compressed = compressed;
	    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
	      if (!this._fin) {
	        this._loop = false;
	        return error(
	          RangeError,
	          'FIN must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_FIN'
	        );
	      }

	      if (compressed) {
	        this._loop = false;
	        return error(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );
	      }

	      if (this._payloadLength > 0x7d) {
	        this._loop = false;
	        return error(
	          RangeError,
	          `invalid payload length ${this._payloadLength}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
	        );
	      }
	    } else {
	      this._loop = false;
	      return error(
	        RangeError,
	        `invalid opcode ${this._opcode}`,
	        true,
	        1002,
	        'WS_ERR_INVALID_OPCODE'
	      );
	    }

	    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
	    this._masked = (buf[1] & 0x80) === 0x80;

	    if (this._isServer) {
	      if (!this._masked) {
	        this._loop = false;
	        return error(
	          RangeError,
	          'MASK must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_MASK'
	        );
	      }
	    } else if (this._masked) {
	      this._loop = false;
	      return error(
	        RangeError,
	        'MASK must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_MASK'
	      );
	    }

	    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
	    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
	    else return this.haveLength();
	  }

	  /**
	   * Gets extended payload length (7+16).
	   *
	   * @return {(RangeError|undefined)} A possible error
	   * @private
	   */
	  getPayloadLength16() {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }

	    this._payloadLength = this.consume(2).readUInt16BE(0);
	    return this.haveLength();
	  }

	  /**
	   * Gets extended payload length (7+64).
	   *
	   * @return {(RangeError|undefined)} A possible error
	   * @private
	   */
	  getPayloadLength64() {
	    if (this._bufferedBytes < 8) {
	      this._loop = false;
	      return;
	    }

	    const buf = this.consume(8);
	    const num = buf.readUInt32BE(0);

	    //
	    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
	    // if payload length is greater than this number.
	    //
	    if (num > Math.pow(2, 53 - 32) - 1) {
	      this._loop = false;
	      return error(
	        RangeError,
	        'Unsupported WebSocket frame: payload length > 2^53 - 1',
	        false,
	        1009,
	        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
	      );
	    }

	    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
	    return this.haveLength();
	  }

	  /**
	   * Payload length has been read.
	   *
	   * @return {(RangeError|undefined)} A possible error
	   * @private
	   */
	  haveLength() {
	    if (this._payloadLength && this._opcode < 0x08) {
	      this._totalPayloadLength += this._payloadLength;
	      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
	        this._loop = false;
	        return error(
	          RangeError,
	          'Max payload size exceeded',
	          false,
	          1009,
	          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	        );
	      }
	    }

	    if (this._masked) this._state = GET_MASK;
	    else this._state = GET_DATA;
	  }

	  /**
	   * Reads mask bytes.
	   *
	   * @private
	   */
	  getMask() {
	    if (this._bufferedBytes < 4) {
	      this._loop = false;
	      return;
	    }

	    this._mask = this.consume(4);
	    this._state = GET_DATA;
	  }

	  /**
	   * Reads data bytes.
	   *
	   * @param {Function} cb Callback
	   * @return {(Error|RangeError|undefined)} A possible error
	   * @private
	   */
	  getData(cb) {
	    let data = EMPTY_BUFFER;

	    if (this._payloadLength) {
	      if (this._bufferedBytes < this._payloadLength) {
	        this._loop = false;
	        return;
	      }

	      data = this.consume(this._payloadLength);
	      if (this._masked) unmask(data, this._mask);
	    }

	    if (this._opcode > 0x07) return this.controlMessage(data);

	    if (this._compressed) {
	      this._state = INFLATING;
	      this.decompress(data, cb);
	      return;
	    }

	    if (data.length) {
	      //
	      // This message is not compressed so its lenght is the sum of the payload
	      // length of all fragments.
	      //
	      this._messageLength = this._totalPayloadLength;
	      this._fragments.push(data);
	    }

	    return this.dataMessage();
	  }

	  /**
	   * Decompresses data.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Function} cb Callback
	   * @private
	   */
	  decompress(data, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

	    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
	      if (err) return cb(err);

	      if (buf.length) {
	        this._messageLength += buf.length;
	        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
	          return cb(
	            error(
	              RangeError,
	              'Max payload size exceeded',
	              false,
	              1009,
	              'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	            )
	          );
	        }

	        this._fragments.push(buf);
	      }

	      const er = this.dataMessage();
	      if (er) return cb(er);

	      this.startLoop(cb);
	    });
	  }

	  /**
	   * Handles a data message.
	   *
	   * @return {(Error|undefined)} A possible error
	   * @private
	   */
	  dataMessage() {
	    if (this._fin) {
	      const messageLength = this._messageLength;
	      const fragments = this._fragments;

	      this._totalPayloadLength = 0;
	      this._messageLength = 0;
	      this._fragmented = 0;
	      this._fragments = [];

	      if (this._opcode === 2) {
	        let data;

	        if (this._binaryType === 'nodebuffer') {
	          data = concat(fragments, messageLength);
	        } else if (this._binaryType === 'arraybuffer') {
	          data = toArrayBuffer(concat(fragments, messageLength));
	        } else {
	          data = fragments;
	        }

	        this.emit('message', data);
	      } else {
	        const buf = concat(fragments, messageLength);

	        if (!isValidUTF8(buf)) {
	          this._loop = false;
	          return error(
	            Error,
	            'invalid UTF-8 sequence',
	            true,
	            1007,
	            'WS_ERR_INVALID_UTF8'
	          );
	        }

	        this.emit('message', buf.toString());
	      }
	    }

	    this._state = GET_INFO;
	  }

	  /**
	   * Handles a control message.
	   *
	   * @param {Buffer} data Data to handle
	   * @return {(Error|RangeError|undefined)} A possible error
	   * @private
	   */
	  controlMessage(data) {
	    if (this._opcode === 0x08) {
	      this._loop = false;

	      if (data.length === 0) {
	        this.emit('conclude', 1005, '');
	        this.end();
	      } else if (data.length === 1) {
	        return error(
	          RangeError,
	          'invalid payload length 1',
	          true,
	          1002,
	          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
	        );
	      } else {
	        const code = data.readUInt16BE(0);

	        if (!isValidStatusCode(code)) {
	          return error(
	            RangeError,
	            `invalid status code ${code}`,
	            true,
	            1002,
	            'WS_ERR_INVALID_CLOSE_CODE'
	          );
	        }

	        const buf = data.slice(2);

	        if (!isValidUTF8(buf)) {
	          return error(
	            Error,
	            'invalid UTF-8 sequence',
	            true,
	            1007,
	            'WS_ERR_INVALID_UTF8'
	          );
	        }

	        this.emit('conclude', code, buf.toString());
	        this.end();
	      }
	    } else if (this._opcode === 0x09) {
	      this.emit('ping', data);
	    } else {
	      this.emit('pong', data);
	    }

	    this._state = GET_INFO;
	  }
	}

	receiver = Receiver;

	/**
	 * Builds an error object.
	 *
	 * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
	 * @param {String} message The error message
	 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
	 *     `message`
	 * @param {Number} statusCode The status code
	 * @param {String} errorCode The exposed error code
	 * @return {(Error|RangeError)} The error
	 * @private
	 */
	function error(ErrorCtor, message, prefix, statusCode, errorCode) {
	  const err = new ErrorCtor(
	    prefix ? `Invalid WebSocket frame: ${message}` : message
	  );

	  Error.captureStackTrace(err, error);
	  err.code = errorCode;
	  err[kStatusCode] = statusCode;
	  return err;
	}
	return receiver;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls$" }] */

var sender;
var hasRequiredSender;

function requireSender () {
	if (hasRequiredSender) return sender;
	hasRequiredSender = 1;
	const { randomFillSync } = require$$5;

	const PerMessageDeflate = requirePermessageDeflate();
	const { EMPTY_BUFFER } = requireConstants();
	const { isValidStatusCode } = requireValidation();
	const { mask: applyMask, toBuffer } = requireBufferUtil();

	const mask = Buffer.alloc(4);

	/**
	 * HyBi Sender implementation.
	 */
	class Sender {
	  /**
	   * Creates a Sender instance.
	   *
	   * @param {(net.Socket|tls.Socket)} socket The connection socket
	   * @param {Object} [extensions] An object containing the negotiated extensions
	   */
	  constructor(socket, extensions) {
	    this._extensions = extensions || {};
	    this._socket = socket;

	    this._firstFragment = true;
	    this._compress = false;

	    this._bufferedBytes = 0;
	    this._deflating = false;
	    this._queue = [];
	  }

	  /**
	   * Frames a piece of data according to the HyBi WebSocket protocol.
	   *
	   * @param {Buffer} data The data to frame
	   * @param {Object} options Options object
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @return {Buffer[]} The framed data as a list of `Buffer` instances
	   * @public
	   */
	  static frame(data, options) {
	    const merge = options.mask && options.readOnly;
	    let offset = options.mask ? 6 : 2;
	    let payloadLength = data.length;

	    if (data.length >= 65536) {
	      offset += 8;
	      payloadLength = 127;
	    } else if (data.length > 125) {
	      offset += 2;
	      payloadLength = 126;
	    }

	    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

	    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
	    if (options.rsv1) target[0] |= 0x40;

	    target[1] = payloadLength;

	    if (payloadLength === 126) {
	      target.writeUInt16BE(data.length, 2);
	    } else if (payloadLength === 127) {
	      target.writeUInt32BE(0, 2);
	      target.writeUInt32BE(data.length, 6);
	    }

	    if (!options.mask) return [target, data];

	    randomFillSync(mask, 0, 4);

	    target[1] |= 0x80;
	    target[offset - 4] = mask[0];
	    target[offset - 3] = mask[1];
	    target[offset - 2] = mask[2];
	    target[offset - 1] = mask[3];

	    if (merge) {
	      applyMask(data, mask, target, offset, data.length);
	      return [target];
	    }

	    applyMask(data, mask, data, 0, data.length);
	    return [target, data];
	  }

	  /**
	   * Sends a close message to the other peer.
	   *
	   * @param {Number} [code] The status code component of the body
	   * @param {String} [data] The message component of the body
	   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  close(code, data, mask, cb) {
	    let buf;

	    if (code === undefined) {
	      buf = EMPTY_BUFFER;
	    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
	      throw new TypeError('First argument must be a valid error code number');
	    } else if (data === undefined || data === '') {
	      buf = Buffer.allocUnsafe(2);
	      buf.writeUInt16BE(code, 0);
	    } else {
	      const length = Buffer.byteLength(data);

	      if (length > 123) {
	        throw new RangeError('The message must not be greater than 123 bytes');
	      }

	      buf = Buffer.allocUnsafe(2 + length);
	      buf.writeUInt16BE(code, 0);
	      buf.write(data, 2);
	    }

	    if (this._deflating) {
	      this.enqueue([this.doClose, buf, mask, cb]);
	    } else {
	      this.doClose(buf, mask, cb);
	    }
	  }

	  /**
	   * Frames and sends a close message.
	   *
	   * @param {Buffer} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  doClose(data, mask, cb) {
	    this.sendFrame(
	      Sender.frame(data, {
	        fin: true,
	        rsv1: false,
	        opcode: 0x08,
	        mask,
	        readOnly: false
	      }),
	      cb
	    );
	  }

	  /**
	   * Sends a ping message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  ping(data, mask, cb) {
	    const buf = toBuffer(data);

	    if (buf.length > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }

	    if (this._deflating) {
	      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);
	    } else {
	      this.doPing(buf, mask, toBuffer.readOnly, cb);
	    }
	  }

	  /**
	   * Frames and sends a ping message.
	   *
	   * @param {Buffer} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  doPing(data, mask, readOnly, cb) {
	    this.sendFrame(
	      Sender.frame(data, {
	        fin: true,
	        rsv1: false,
	        opcode: 0x09,
	        mask,
	        readOnly
	      }),
	      cb
	    );
	  }

	  /**
	   * Sends a pong message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  pong(data, mask, cb) {
	    const buf = toBuffer(data);

	    if (buf.length > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }

	    if (this._deflating) {
	      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);
	    } else {
	      this.doPong(buf, mask, toBuffer.readOnly, cb);
	    }
	  }

	  /**
	   * Frames and sends a pong message.
	   *
	   * @param {Buffer} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  doPong(data, mask, readOnly, cb) {
	    this.sendFrame(
	      Sender.frame(data, {
	        fin: true,
	        rsv1: false,
	        opcode: 0x0a,
	        mask,
	        readOnly
	      }),
	      cb
	    );
	  }

	  /**
	   * Sends a data message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Object} options Options object
	   * @param {Boolean} [options.compress=false] Specifies whether or not to
	   *     compress `data`
	   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
	   *     or text
	   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
	   *     last one
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  send(data, options, cb) {
	    const buf = toBuffer(data);
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
	    let opcode = options.binary ? 2 : 1;
	    let rsv1 = options.compress;

	    if (this._firstFragment) {
	      this._firstFragment = false;
	      if (rsv1 && perMessageDeflate) {
	        rsv1 = buf.length >= perMessageDeflate._threshold;
	      }
	      this._compress = rsv1;
	    } else {
	      rsv1 = false;
	      opcode = 0;
	    }

	    if (options.fin) this._firstFragment = true;

	    if (perMessageDeflate) {
	      const opts = {
	        fin: options.fin,
	        rsv1,
	        opcode,
	        mask: options.mask,
	        readOnly: toBuffer.readOnly
	      };

	      if (this._deflating) {
	        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
	      } else {
	        this.dispatch(buf, this._compress, opts, cb);
	      }
	    } else {
	      this.sendFrame(
	        Sender.frame(buf, {
	          fin: options.fin,
	          rsv1: false,
	          opcode,
	          mask: options.mask,
	          readOnly: toBuffer.readOnly
	        }),
	        cb
	      );
	    }
	  }

	  /**
	   * Dispatches a data message.
	   *
	   * @param {Buffer} data The message to send
	   * @param {Boolean} [compress=false] Specifies whether or not to compress
	   *     `data`
	   * @param {Object} options Options object
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  dispatch(data, compress, options, cb) {
	    if (!compress) {
	      this.sendFrame(Sender.frame(data, options), cb);
	      return;
	    }

	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

	    this._bufferedBytes += data.length;
	    this._deflating = true;
	    perMessageDeflate.compress(data, options.fin, (_, buf) => {
	      if (this._socket.destroyed) {
	        const err = new Error(
	          'The socket was closed while data was being compressed'
	        );

	        if (typeof cb === 'function') cb(err);

	        for (let i = 0; i < this._queue.length; i++) {
	          const callback = this._queue[i][4];

	          if (typeof callback === 'function') callback(err);
	        }

	        return;
	      }

	      this._bufferedBytes -= data.length;
	      this._deflating = false;
	      options.readOnly = false;
	      this.sendFrame(Sender.frame(buf, options), cb);
	      this.dequeue();
	    });
	  }

	  /**
	   * Executes queued send operations.
	   *
	   * @private
	   */
	  dequeue() {
	    while (!this._deflating && this._queue.length) {
	      const params = this._queue.shift();

	      this._bufferedBytes -= params[1].length;
	      Reflect.apply(params[0], this, params.slice(1));
	    }
	  }

	  /**
	   * Enqueues a send operation.
	   *
	   * @param {Array} params Send operation parameters.
	   * @private
	   */
	  enqueue(params) {
	    this._bufferedBytes += params[1].length;
	    this._queue.push(params);
	  }

	  /**
	   * Sends a frame.
	   *
	   * @param {Buffer[]} list The frame to send
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  sendFrame(list, cb) {
	    if (list.length === 2) {
	      this._socket.cork();
	      this._socket.write(list[0]);
	      this._socket.write(list[1], cb);
	      this._socket.uncork();
	    } else {
	      this._socket.write(list[0], cb);
	    }
	  }
	}

	sender = Sender;
	return sender;
}

var eventTarget;
var hasRequiredEventTarget;

function requireEventTarget () {
	if (hasRequiredEventTarget) return eventTarget;
	hasRequiredEventTarget = 1;

	/**
	 * Class representing an event.
	 *
	 * @private
	 */
	class Event {
	  /**
	   * Create a new `Event`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} target A reference to the target to which the event was
	   *     dispatched
	   */
	  constructor(type, target) {
	    this.target = target;
	    this.type = type;
	  }
	}

	/**
	 * Class representing a message event.
	 *
	 * @extends Event
	 * @private
	 */
	class MessageEvent extends Event {
	  /**
	   * Create a new `MessageEvent`.
	   *
	   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
	   * @param {WebSocket} target A reference to the target to which the event was
	   *     dispatched
	   */
	  constructor(data, target) {
	    super('message', target);

	    this.data = data;
	  }
	}

	/**
	 * Class representing a close event.
	 *
	 * @extends Event
	 * @private
	 */
	class CloseEvent extends Event {
	  /**
	   * Create a new `CloseEvent`.
	   *
	   * @param {Number} code The status code explaining why the connection is being
	   *     closed
	   * @param {String} reason A human-readable string explaining why the
	   *     connection is closing
	   * @param {WebSocket} target A reference to the target to which the event was
	   *     dispatched
	   */
	  constructor(code, reason, target) {
	    super('close', target);

	    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
	    this.reason = reason;
	    this.code = code;
	  }
	}

	/**
	 * Class representing an open event.
	 *
	 * @extends Event
	 * @private
	 */
	class OpenEvent extends Event {
	  /**
	   * Create a new `OpenEvent`.
	   *
	   * @param {WebSocket} target A reference to the target to which the event was
	   *     dispatched
	   */
	  constructor(target) {
	    super('open', target);
	  }
	}

	/**
	 * Class representing an error event.
	 *
	 * @extends Event
	 * @private
	 */
	class ErrorEvent extends Event {
	  /**
	   * Create a new `ErrorEvent`.
	   *
	   * @param {Object} error The error that generated this event
	   * @param {WebSocket} target A reference to the target to which the event was
	   *     dispatched
	   */
	  constructor(error, target) {
	    super('error', target);

	    this.message = error.message;
	    this.error = error;
	  }
	}

	/**
	 * This provides methods for emulating the `EventTarget` interface. It's not
	 * meant to be used directly.
	 *
	 * @mixin
	 */
	const EventTarget = {
	  /**
	   * Register an event listener.
	   *
	   * @param {String} type A string representing the event type to listen for
	   * @param {Function} listener The listener to add
	   * @param {Object} [options] An options object specifies characteristics about
	   *     the event listener
	   * @param {Boolean} [options.once=false] A `Boolean`` indicating that the
	   *     listener should be invoked at most once after being added. If `true`,
	   *     the listener would be automatically removed when invoked.
	   * @public
	   */
	  addEventListener(type, listener, options) {
	    if (typeof listener !== 'function') return;

	    function onMessage(data) {
	      listener.call(this, new MessageEvent(data, this));
	    }

	    function onClose(code, message) {
	      listener.call(this, new CloseEvent(code, message, this));
	    }

	    function onError(error) {
	      listener.call(this, new ErrorEvent(error, this));
	    }

	    function onOpen() {
	      listener.call(this, new OpenEvent(this));
	    }

	    const method = options && options.once ? 'once' : 'on';

	    if (type === 'message') {
	      onMessage._listener = listener;
	      this[method](type, onMessage);
	    } else if (type === 'close') {
	      onClose._listener = listener;
	      this[method](type, onClose);
	    } else if (type === 'error') {
	      onError._listener = listener;
	      this[method](type, onError);
	    } else if (type === 'open') {
	      onOpen._listener = listener;
	      this[method](type, onOpen);
	    } else {
	      this[method](type, listener);
	    }
	  },

	  /**
	   * Remove an event listener.
	   *
	   * @param {String} type A string representing the event type to remove
	   * @param {Function} listener The listener to remove
	   * @public
	   */
	  removeEventListener(type, listener) {
	    const listeners = this.listeners(type);

	    for (let i = 0; i < listeners.length; i++) {
	      if (listeners[i] === listener || listeners[i]._listener === listener) {
	        this.removeListener(type, listeners[i]);
	      }
	    }
	  }
	};

	eventTarget = EventTarget;
	return eventTarget;
}

var extension;
var hasRequiredExtension;

function requireExtension () {
	if (hasRequiredExtension) return extension;
	hasRequiredExtension = 1;

	//
	// Allowed token characters:
	//
	// '!', '#', '$', '%', '&', ''', '*', '+', '-',
	// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
	//
	// tokenChars[32] === 0 // ' '
	// tokenChars[33] === 1 // '!'
	// tokenChars[34] === 0 // '"'
	// ...
	//
	// prettier-ignore
	const tokenChars = [
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
	  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
	  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
	];

	/**
	 * Adds an offer to the map of extension offers or a parameter to the map of
	 * parameters.
	 *
	 * @param {Object} dest The map of extension offers or parameters
	 * @param {String} name The extension or parameter name
	 * @param {(Object|Boolean|String)} elem The extension parameters or the
	 *     parameter value
	 * @private
	 */
	function push(dest, name, elem) {
	  if (dest[name] === undefined) dest[name] = [elem];
	  else dest[name].push(elem);
	}

	/**
	 * Parses the `Sec-WebSocket-Extensions` header into an object.
	 *
	 * @param {String} header The field value of the header
	 * @return {Object} The parsed object
	 * @public
	 */
	function parse(header) {
	  const offers = Object.create(null);

	  if (header === undefined || header === '') return offers;

	  let params = Object.create(null);
	  let mustUnescape = false;
	  let isEscaping = false;
	  let inQuotes = false;
	  let extensionName;
	  let paramName;
	  let start = -1;
	  let end = -1;
	  let i = 0;

	  for (; i < header.length; i++) {
	    const code = header.charCodeAt(i);

	    if (extensionName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\t' */) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        const name = header.slice(start, end);
	        if (code === 0x2c) {
	          push(offers, name, params);
	          params = Object.create(null);
	        } else {
	          extensionName = name;
	        }

	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else if (paramName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (code === 0x20 || code === 0x09) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        push(params, header.slice(start, end), true);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }

	        start = end = -1;
	      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
	        paramName = header.slice(start, i);
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else {
	      //
	      // The value of a quoted-string after unescaping must conform to the
	      // token ABNF, so only token characters are valid.
	      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
	      //
	      if (isEscaping) {
	        if (tokenChars[code] !== 1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	        if (start === -1) start = i;
	        else if (!mustUnescape) mustUnescape = true;
	        isEscaping = false;
	      } else if (inQuotes) {
	        if (tokenChars[code] === 1) {
	          if (start === -1) start = i;
	        } else if (code === 0x22 /* '"' */ && start !== -1) {
	          inQuotes = false;
	          end = i;
	        } else if (code === 0x5c /* '\' */) {
	          isEscaping = true;
	        } else {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
	        inQuotes = true;
	      } else if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
	        if (end === -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        let value = header.slice(start, end);
	        if (mustUnescape) {
	          value = value.replace(/\\/g, '');
	          mustUnescape = false;
	        }
	        push(params, paramName, value);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }

	        paramName = undefined;
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    }
	  }

	  if (start === -1 || inQuotes) {
	    throw new SyntaxError('Unexpected end of input');
	  }

	  if (end === -1) end = i;
	  const token = header.slice(start, end);
	  if (extensionName === undefined) {
	    push(offers, token, params);
	  } else {
	    if (paramName === undefined) {
	      push(params, token, true);
	    } else if (mustUnescape) {
	      push(params, paramName, token.replace(/\\/g, ''));
	    } else {
	      push(params, paramName, token);
	    }
	    push(offers, extensionName, params);
	  }

	  return offers;
	}

	/**
	 * Builds the `Sec-WebSocket-Extensions` header field value.
	 *
	 * @param {Object} extensions The map of extensions and parameters to format
	 * @return {String} A string representing the given object
	 * @public
	 */
	function format(extensions) {
	  return Object.keys(extensions)
	    .map((extension) => {
	      let configurations = extensions[extension];
	      if (!Array.isArray(configurations)) configurations = [configurations];
	      return configurations
	        .map((params) => {
	          return [extension]
	            .concat(
	              Object.keys(params).map((k) => {
	                let values = params[k];
	                if (!Array.isArray(values)) values = [values];
	                return values
	                  .map((v) => (v === true ? k : `${k}=${v}`))
	                  .join('; ');
	              })
	            )
	            .join('; ');
	        })
	        .join(', ');
	    })
	    .join(', ');
	}

	extension = { format, parse };
	return extension;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Readable$" }] */

var websocket$1;
var hasRequiredWebsocket$1;

function requireWebsocket$1 () {
	if (hasRequiredWebsocket$1) return websocket$1;
	hasRequiredWebsocket$1 = 1;

	const EventEmitter = require$$0$3;
	const https = require$$2;
	const http = require$$1;
	const net = require$$3;
	const tls = require$$4;
	const { randomBytes, createHash } = require$$5;
	const { Readable } = require$$0$2;
	const { URL } = require$$7;

	const PerMessageDeflate = requirePermessageDeflate();
	const Receiver = requireReceiver();
	const Sender = requireSender();
	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  GUID,
	  kStatusCode,
	  kWebSocket,
	  NOOP
	} = requireConstants();
	const { addEventListener, removeEventListener } = requireEventTarget();
	const { format, parse } = requireExtension();
	const { toBuffer } = requireBufferUtil();

	const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
	const protocolVersions = [8, 13];
	const closeTimeout = 30 * 1000;

	/**
	 * Class representing a WebSocket.
	 *
	 * @extends EventEmitter
	 */
	class WebSocket extends EventEmitter {
	  /**
	   * Create a new `WebSocket`.
	   *
	   * @param {(String|URL)} address The URL to which to connect
	   * @param {(String|String[])} [protocols] The subprotocols
	   * @param {Object} [options] Connection options
	   */
	  constructor(address, protocols, options) {
	    super();

	    this._binaryType = BINARY_TYPES[0];
	    this._closeCode = 1006;
	    this._closeFrameReceived = false;
	    this._closeFrameSent = false;
	    this._closeMessage = '';
	    this._closeTimer = null;
	    this._extensions = {};
	    this._protocol = '';
	    this._readyState = WebSocket.CONNECTING;
	    this._receiver = null;
	    this._sender = null;
	    this._socket = null;

	    if (address !== null) {
	      this._bufferedAmount = 0;
	      this._isServer = false;
	      this._redirects = 0;

	      if (Array.isArray(protocols)) {
	        protocols = protocols.join(', ');
	      } else if (typeof protocols === 'object' && protocols !== null) {
	        options = protocols;
	        protocols = undefined;
	      }

	      initAsClient(this, address, protocols, options);
	    } else {
	      this._isServer = true;
	    }
	  }

	  /**
	   * This deviates from the WHATWG interface since ws doesn't support the
	   * required default "blob" type (instead we define a custom "nodebuffer"
	   * type).
	   *
	   * @type {String}
	   */
	  get binaryType() {
	    return this._binaryType;
	  }

	  set binaryType(type) {
	    if (!BINARY_TYPES.includes(type)) return;

	    this._binaryType = type;

	    //
	    // Allow to change `binaryType` on the fly.
	    //
	    if (this._receiver) this._receiver._binaryType = type;
	  }

	  /**
	   * @type {Number}
	   */
	  get bufferedAmount() {
	    if (!this._socket) return this._bufferedAmount;

	    return this._socket._writableState.length + this._sender._bufferedBytes;
	  }

	  /**
	   * @type {String}
	   */
	  get extensions() {
	    return Object.keys(this._extensions).join();
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onclose() {
	    return undefined;
	  }

	  /* istanbul ignore next */
	  set onclose(listener) {}

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onerror() {
	    return undefined;
	  }

	  /* istanbul ignore next */
	  set onerror(listener) {}

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onopen() {
	    return undefined;
	  }

	  /* istanbul ignore next */
	  set onopen(listener) {}

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onmessage() {
	    return undefined;
	  }

	  /* istanbul ignore next */
	  set onmessage(listener) {}

	  /**
	   * @type {String}
	   */
	  get protocol() {
	    return this._protocol;
	  }

	  /**
	   * @type {Number}
	   */
	  get readyState() {
	    return this._readyState;
	  }

	  /**
	   * @type {String}
	   */
	  get url() {
	    return this._url;
	  }

	  /**
	   * Set up the socket and the internal resources.
	   *
	   * @param {(net.Socket|tls.Socket)} socket The network socket between the
	   *     server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Number} [maxPayload=0] The maximum allowed message size
	   * @private
	   */
	  setSocket(socket, head, maxPayload) {
	    const receiver = new Receiver(
	      this.binaryType,
	      this._extensions,
	      this._isServer,
	      maxPayload
	    );

	    this._sender = new Sender(socket, this._extensions);
	    this._receiver = receiver;
	    this._socket = socket;

	    receiver[kWebSocket] = this;
	    socket[kWebSocket] = this;

	    receiver.on('conclude', receiverOnConclude);
	    receiver.on('drain', receiverOnDrain);
	    receiver.on('error', receiverOnError);
	    receiver.on('message', receiverOnMessage);
	    receiver.on('ping', receiverOnPing);
	    receiver.on('pong', receiverOnPong);

	    socket.setTimeout(0);
	    socket.setNoDelay();

	    if (head.length > 0) socket.unshift(head);

	    socket.on('close', socketOnClose);
	    socket.on('data', socketOnData);
	    socket.on('end', socketOnEnd);
	    socket.on('error', socketOnError);

	    this._readyState = WebSocket.OPEN;
	    this.emit('open');
	  }

	  /**
	   * Emit the `'close'` event.
	   *
	   * @private
	   */
	  emitClose() {
	    if (!this._socket) {
	      this._readyState = WebSocket.CLOSED;
	      this.emit('close', this._closeCode, this._closeMessage);
	      return;
	    }

	    if (this._extensions[PerMessageDeflate.extensionName]) {
	      this._extensions[PerMessageDeflate.extensionName].cleanup();
	    }

	    this._receiver.removeAllListeners();
	    this._readyState = WebSocket.CLOSED;
	    this.emit('close', this._closeCode, this._closeMessage);
	  }

	  /**
	   * Start a closing handshake.
	   *
	   *          +----------+   +-----------+   +----------+
	   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
	   *    |     +----------+   +-----------+   +----------+     |
	   *          +----------+   +-----------+         |
	   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
	   *          +----------+   +-----------+   |
	   *    |           |                        |   +---+        |
	   *                +------------------------+-->|fin| - - - -
	   *    |         +---+                      |   +---+
	   *     - - - - -|fin|<---------------------+
	   *              +---+
	   *
	   * @param {Number} [code] Status code explaining why the connection is closing
	   * @param {String} [data] A string explaining why the connection is closing
	   * @public
	   */
	  close(code, data) {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      return abortHandshake(this, this._req, msg);
	    }

	    if (this.readyState === WebSocket.CLOSING) {
	      if (
	        this._closeFrameSent &&
	        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
	      ) {
	        this._socket.end();
	      }

	      return;
	    }

	    this._readyState = WebSocket.CLOSING;
	    this._sender.close(code, data, !this._isServer, (err) => {
	      //
	      // This error is handled by the `'error'` listener on the socket. We only
	      // want to know if the close frame has been sent here.
	      //
	      if (err) return;

	      this._closeFrameSent = true;

	      if (
	        this._closeFrameReceived ||
	        this._receiver._writableState.errorEmitted
	      ) {
	        this._socket.end();
	      }
	    });

	    //
	    // Specify a timeout for the closing handshake to complete.
	    //
	    this._closeTimer = setTimeout(
	      this._socket.destroy.bind(this._socket),
	      closeTimeout
	    );
	  }

	  /**
	   * Send a ping.
	   *
	   * @param {*} [data] The data to send
	   * @param {Boolean} [mask] Indicates whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when the ping is sent
	   * @public
	   */
	  ping(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    if (mask === undefined) mask = !this._isServer;
	    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
	  }

	  /**
	   * Send a pong.
	   *
	   * @param {*} [data] The data to send
	   * @param {Boolean} [mask] Indicates whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when the pong is sent
	   * @public
	   */
	  pong(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    if (mask === undefined) mask = !this._isServer;
	    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
	  }

	  /**
	   * Send a data message.
	   *
	   * @param {*} data The message to send
	   * @param {Object} [options] Options object
	   * @param {Boolean} [options.compress] Specifies whether or not to compress
	   *     `data`
	   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
	   *     text
	   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
	   *     last one
	   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when data is written out
	   * @public
	   */
	  send(data, options, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof options === 'function') {
	      cb = options;
	      options = {};
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    const opts = {
	      binary: typeof data !== 'string',
	      mask: !this._isServer,
	      compress: true,
	      fin: true,
	      ...options
	    };

	    if (!this._extensions[PerMessageDeflate.extensionName]) {
	      opts.compress = false;
	    }

	    this._sender.send(data || EMPTY_BUFFER, opts, cb);
	  }

	  /**
	   * Forcibly close the connection.
	   *
	   * @public
	   */
	  terminate() {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      return abortHandshake(this, this._req, msg);
	    }

	    if (this._socket) {
	      this._readyState = WebSocket.CLOSING;
	      this._socket.destroy();
	    }
	  }
	}

	/**
	 * @constant {Number} CONNECTING
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});

	/**
	 * @constant {Number} CONNECTING
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});

	/**
	 * @constant {Number} OPEN
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});

	/**
	 * @constant {Number} OPEN
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});

	/**
	 * @constant {Number} CLOSING
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});

	/**
	 * @constant {Number} CLOSING
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});

	/**
	 * @constant {Number} CLOSED
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});

	/**
	 * @constant {Number} CLOSED
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});

	[
	  'binaryType',
	  'bufferedAmount',
	  'extensions',
	  'protocol',
	  'readyState',
	  'url'
	].forEach((property) => {
	  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
	});

	//
	// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
	// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
	//
	['open', 'error', 'close', 'message'].forEach((method) => {
	  Object.defineProperty(WebSocket.prototype, `on${method}`, {
	    enumerable: true,
	    get() {
	      const listeners = this.listeners(method);
	      for (let i = 0; i < listeners.length; i++) {
	        if (listeners[i]._listener) return listeners[i]._listener;
	      }

	      return undefined;
	    },
	    set(listener) {
	      const listeners = this.listeners(method);
	      for (let i = 0; i < listeners.length; i++) {
	        //
	        // Remove only the listeners added via `addEventListener`.
	        //
	        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
	      }
	      this.addEventListener(method, listener);
	    }
	  });
	});

	WebSocket.prototype.addEventListener = addEventListener;
	WebSocket.prototype.removeEventListener = removeEventListener;

	websocket$1 = WebSocket;

	/**
	 * Initialize a WebSocket client.
	 *
	 * @param {WebSocket} websocket The client to initialize
	 * @param {(String|URL)} address The URL to which to connect
	 * @param {String} [protocols] The subprotocols
	 * @param {Object} [options] Connection options
	 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
	 *     permessage-deflate
	 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
	 *     handshake request
	 * @param {Number} [options.protocolVersion=13] Value of the
	 *     `Sec-WebSocket-Version` header
	 * @param {String} [options.origin] Value of the `Origin` or
	 *     `Sec-WebSocket-Origin` header
	 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
	 *     size
	 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
	 *     redirects
	 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
	 *     allowed
	 * @private
	 */
	function initAsClient(websocket, address, protocols, options) {
	  const opts = {
	    protocolVersion: protocolVersions[1],
	    maxPayload: 100 * 1024 * 1024,
	    perMessageDeflate: true,
	    followRedirects: false,
	    maxRedirects: 10,
	    ...options,
	    createConnection: undefined,
	    socketPath: undefined,
	    hostname: undefined,
	    protocol: undefined,
	    timeout: undefined,
	    method: undefined,
	    host: undefined,
	    path: undefined,
	    port: undefined
	  };

	  if (!protocolVersions.includes(opts.protocolVersion)) {
	    throw new RangeError(
	      `Unsupported protocol version: ${opts.protocolVersion} ` +
	        `(supported versions: ${protocolVersions.join(', ')})`
	    );
	  }

	  let parsedUrl;

	  if (address instanceof URL) {
	    parsedUrl = address;
	    websocket._url = address.href;
	  } else {
	    parsedUrl = new URL(address);
	    websocket._url = address;
	  }

	  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';

	  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
	    const err = new Error(`Invalid URL: ${websocket.url}`);

	    if (websocket._redirects === 0) {
	      throw err;
	    } else {
	      emitErrorAndClose(websocket, err);
	      return;
	    }
	  }

	  const isSecure =
	    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
	  const defaultPort = isSecure ? 443 : 80;
	  const key = randomBytes(16).toString('base64');
	  const get = isSecure ? https.get : http.get;
	  let perMessageDeflate;

	  opts.createConnection = isSecure ? tlsConnect : netConnect;
	  opts.defaultPort = opts.defaultPort || defaultPort;
	  opts.port = parsedUrl.port || defaultPort;
	  opts.host = parsedUrl.hostname.startsWith('[')
	    ? parsedUrl.hostname.slice(1, -1)
	    : parsedUrl.hostname;
	  opts.headers = {
	    'Sec-WebSocket-Version': opts.protocolVersion,
	    'Sec-WebSocket-Key': key,
	    Connection: 'Upgrade',
	    Upgrade: 'websocket',
	    ...opts.headers
	  };
	  opts.path = parsedUrl.pathname + parsedUrl.search;
	  opts.timeout = opts.handshakeTimeout;

	  if (opts.perMessageDeflate) {
	    perMessageDeflate = new PerMessageDeflate(
	      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
	      false,
	      opts.maxPayload
	    );
	    opts.headers['Sec-WebSocket-Extensions'] = format({
	      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
	    });
	  }
	  if (protocols) {
	    opts.headers['Sec-WebSocket-Protocol'] = protocols;
	  }
	  if (opts.origin) {
	    if (opts.protocolVersion < 13) {
	      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
	    } else {
	      opts.headers.Origin = opts.origin;
	    }
	  }
	  if (parsedUrl.username || parsedUrl.password) {
	    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
	  }

	  if (isUnixSocket) {
	    const parts = opts.path.split(':');

	    opts.socketPath = parts[0];
	    opts.path = parts[1];
	  }

	  if (opts.followRedirects) {
	    if (websocket._redirects === 0) {
	      websocket._originalUnixSocket = isUnixSocket;
	      websocket._originalSecure = isSecure;
	      websocket._originalHostOrSocketPath = isUnixSocket
	        ? opts.socketPath
	        : parsedUrl.host;

	      const headers = options && options.headers;

	      //
	      // Shallow copy the user provided options so that headers can be changed
	      // without mutating the original object.
	      //
	      options = { ...options, headers: {} };

	      if (headers) {
	        for (const [key, value] of Object.entries(headers)) {
	          options.headers[key.toLowerCase()] = value;
	        }
	      }
	    } else {
	      const isSameHost = isUnixSocket
	        ? websocket._originalUnixSocket
	          ? opts.socketPath === websocket._originalHostOrSocketPath
	          : false
	        : websocket._originalUnixSocket
	        ? false
	        : parsedUrl.host === websocket._originalHostOrSocketPath;

	      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
	        //
	        // Match curl 7.77.0 behavior and drop the following headers. These
	        // headers are also dropped when following a redirect to a subdomain.
	        //
	        delete opts.headers.authorization;
	        delete opts.headers.cookie;

	        if (!isSameHost) delete opts.headers.host;

	        opts.auth = undefined;
	      }
	    }

	    //
	    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
	    // If the `Authorization` header is set, then there is nothing to do as it
	    // will take precedence.
	    //
	    if (opts.auth && !options.headers.authorization) {
	      options.headers.authorization =
	        'Basic ' + Buffer.from(opts.auth).toString('base64');
	    }
	  }

	  let req = (websocket._req = get(opts));

	  if (opts.timeout) {
	    req.on('timeout', () => {
	      abortHandshake(websocket, req, 'Opening handshake has timed out');
	    });
	  }

	  req.on('error', (err) => {
	    if (req === null || req.aborted) return;

	    req = websocket._req = null;
	    emitErrorAndClose(websocket, err);
	  });

	  req.on('response', (res) => {
	    const location = res.headers.location;
	    const statusCode = res.statusCode;

	    if (
	      location &&
	      opts.followRedirects &&
	      statusCode >= 300 &&
	      statusCode < 400
	    ) {
	      if (++websocket._redirects > opts.maxRedirects) {
	        abortHandshake(websocket, req, 'Maximum redirects exceeded');
	        return;
	      }

	      req.abort();

	      let addr;

	      try {
	        addr = new URL(location, address);
	      } catch (err) {
	        emitErrorAndClose(websocket, err);
	        return;
	      }

	      initAsClient(websocket, addr, protocols, options);
	    } else if (!websocket.emit('unexpected-response', req, res)) {
	      abortHandshake(
	        websocket,
	        req,
	        `Unexpected server response: ${res.statusCode}`
	      );
	    }
	  });

	  req.on('upgrade', (res, socket, head) => {
	    websocket.emit('upgrade', res);

	    //
	    // The user may have closed the connection from a listener of the `upgrade`
	    // event.
	    //
	    if (websocket.readyState !== WebSocket.CONNECTING) return;

	    req = websocket._req = null;

	    const upgrade = res.headers.upgrade;

	    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
	      abortHandshake(websocket, socket, 'Invalid Upgrade header');
	      return;
	    }

	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');

	    if (res.headers['sec-websocket-accept'] !== digest) {
	      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
	      return;
	    }

	    const serverProt = res.headers['sec-websocket-protocol'];
	    const protList = (protocols || '').split(/, */);
	    let protError;

	    if (!protocols && serverProt) {
	      protError = 'Server sent a subprotocol but none was requested';
	    } else if (protocols && !serverProt) {
	      protError = 'Server sent no subprotocol';
	    } else if (serverProt && !protList.includes(serverProt)) {
	      protError = 'Server sent an invalid subprotocol';
	    }

	    if (protError) {
	      abortHandshake(websocket, socket, protError);
	      return;
	    }

	    if (serverProt) websocket._protocol = serverProt;

	    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

	    if (secWebSocketExtensions !== undefined) {
	      if (!perMessageDeflate) {
	        const message =
	          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
	          'was requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      let extensions;

	      try {
	        extensions = parse(secWebSocketExtensions);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      const extensionNames = Object.keys(extensions);

	      if (extensionNames.length) {
	        if (
	          extensionNames.length !== 1 ||
	          extensionNames[0] !== PerMessageDeflate.extensionName
	        ) {
	          const message =
	            'Server indicated an extension that was not requested';
	          abortHandshake(websocket, socket, message);
	          return;
	        }

	        try {
	          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
	        } catch (err) {
	          const message = 'Invalid Sec-WebSocket-Extensions header';
	          abortHandshake(websocket, socket, message);
	          return;
	        }

	        websocket._extensions[PerMessageDeflate.extensionName] =
	          perMessageDeflate;
	      }
	    }

	    websocket.setSocket(socket, head, opts.maxPayload);
	  });
	}

	/**
	 * Emit the `'error'` and `'close'` event.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {Error} The error to emit
	 * @private
	 */
	function emitErrorAndClose(websocket, err) {
	  websocket._readyState = WebSocket.CLOSING;
	  websocket.emit('error', err);
	  websocket.emitClose();
	}

	/**
	 * Create a `net.Socket` and initiate a connection.
	 *
	 * @param {Object} options Connection options
	 * @return {net.Socket} The newly created socket used to start the connection
	 * @private
	 */
	function netConnect(options) {
	  options.path = options.socketPath;
	  return net.connect(options);
	}

	/**
	 * Create a `tls.TLSSocket` and initiate a connection.
	 *
	 * @param {Object} options Connection options
	 * @return {tls.TLSSocket} The newly created socket used to start the connection
	 * @private
	 */
	function tlsConnect(options) {
	  options.path = undefined;

	  if (!options.servername && options.servername !== '') {
	    options.servername = net.isIP(options.host) ? '' : options.host;
	  }

	  return tls.connect(options);
	}

	/**
	 * Abort the handshake and emit an error.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
	 *     abort or the socket to destroy
	 * @param {String} message The error message
	 * @private
	 */
	function abortHandshake(websocket, stream, message) {
	  websocket._readyState = WebSocket.CLOSING;

	  const err = new Error(message);
	  Error.captureStackTrace(err, abortHandshake);

	  if (stream.setHeader) {
	    stream.abort();

	    if (stream.socket && !stream.socket.destroyed) {
	      //
	      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
	      // called after the request completed. See
	      // https://github.com/websockets/ws/issues/1869.
	      //
	      stream.socket.destroy();
	    }

	    stream.once('abort', websocket.emitClose.bind(websocket));
	    websocket.emit('error', err);
	  } else {
	    stream.destroy(err);
	    stream.once('error', websocket.emit.bind(websocket, 'error'));
	    stream.once('close', websocket.emitClose.bind(websocket));
	  }
	}

	/**
	 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
	 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {*} [data] The data to send
	 * @param {Function} [cb] Callback
	 * @private
	 */
	function sendAfterClose(websocket, data, cb) {
	  if (data) {
	    const length = toBuffer(data).length;

	    //
	    // The `_bufferedAmount` property is used only when the peer is a client and
	    // the opening handshake fails. Under these circumstances, in fact, the
	    // `setSocket()` method is not called, so the `_socket` and `_sender`
	    // properties are set to `null`.
	    //
	    if (websocket._socket) websocket._sender._bufferedBytes += length;
	    else websocket._bufferedAmount += length;
	  }

	  if (cb) {
	    const err = new Error(
	      `WebSocket is not open: readyState ${websocket.readyState} ` +
	        `(${readyStates[websocket.readyState]})`
	    );
	    cb(err);
	  }
	}

	/**
	 * The listener of the `Receiver` `'conclude'` event.
	 *
	 * @param {Number} code The status code
	 * @param {String} reason The reason for closing
	 * @private
	 */
	function receiverOnConclude(code, reason) {
	  const websocket = this[kWebSocket];

	  websocket._closeFrameReceived = true;
	  websocket._closeMessage = reason;
	  websocket._closeCode = code;

	  if (websocket._socket[kWebSocket] === undefined) return;

	  websocket._socket.removeListener('data', socketOnData);
	  process.nextTick(resume, websocket._socket);

	  if (code === 1005) websocket.close();
	  else websocket.close(code, reason);
	}

	/**
	 * The listener of the `Receiver` `'drain'` event.
	 *
	 * @private
	 */
	function receiverOnDrain() {
	  this[kWebSocket]._socket.resume();
	}

	/**
	 * The listener of the `Receiver` `'error'` event.
	 *
	 * @param {(RangeError|Error)} err The emitted error
	 * @private
	 */
	function receiverOnError(err) {
	  const websocket = this[kWebSocket];

	  if (websocket._socket[kWebSocket] !== undefined) {
	    websocket._socket.removeListener('data', socketOnData);

	    //
	    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
	    // https://github.com/websockets/ws/issues/1940.
	    //
	    process.nextTick(resume, websocket._socket);

	    websocket.close(err[kStatusCode]);
	  }

	  websocket.emit('error', err);
	}

	/**
	 * The listener of the `Receiver` `'finish'` event.
	 *
	 * @private
	 */
	function receiverOnFinish() {
	  this[kWebSocket].emitClose();
	}

	/**
	 * The listener of the `Receiver` `'message'` event.
	 *
	 * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message
	 * @private
	 */
	function receiverOnMessage(data) {
	  this[kWebSocket].emit('message', data);
	}

	/**
	 * The listener of the `Receiver` `'ping'` event.
	 *
	 * @param {Buffer} data The data included in the ping frame
	 * @private
	 */
	function receiverOnPing(data) {
	  const websocket = this[kWebSocket];

	  websocket.pong(data, !websocket._isServer, NOOP);
	  websocket.emit('ping', data);
	}

	/**
	 * The listener of the `Receiver` `'pong'` event.
	 *
	 * @param {Buffer} data The data included in the pong frame
	 * @private
	 */
	function receiverOnPong(data) {
	  this[kWebSocket].emit('pong', data);
	}

	/**
	 * Resume a readable stream
	 *
	 * @param {Readable} stream The readable stream
	 * @private
	 */
	function resume(stream) {
	  stream.resume();
	}

	/**
	 * The listener of the `net.Socket` `'close'` event.
	 *
	 * @private
	 */
	function socketOnClose() {
	  const websocket = this[kWebSocket];

	  this.removeListener('close', socketOnClose);
	  this.removeListener('data', socketOnData);
	  this.removeListener('end', socketOnEnd);

	  websocket._readyState = WebSocket.CLOSING;

	  let chunk;

	  //
	  // The close frame might not have been received or the `'end'` event emitted,
	  // for example, if the socket was destroyed due to an error. Ensure that the
	  // `receiver` stream is closed after writing any remaining buffered data to
	  // it. If the readable side of the socket is in flowing mode then there is no
	  // buffered data as everything has been already written and `readable.read()`
	  // will return `null`. If instead, the socket is paused, any possible buffered
	  // data will be read as a single chunk.
	  //
	  if (
	    !this._readableState.endEmitted &&
	    !websocket._closeFrameReceived &&
	    !websocket._receiver._writableState.errorEmitted &&
	    (chunk = websocket._socket.read()) !== null
	  ) {
	    websocket._receiver.write(chunk);
	  }

	  websocket._receiver.end();

	  this[kWebSocket] = undefined;

	  clearTimeout(websocket._closeTimer);

	  if (
	    websocket._receiver._writableState.finished ||
	    websocket._receiver._writableState.errorEmitted
	  ) {
	    websocket.emitClose();
	  } else {
	    websocket._receiver.on('error', receiverOnFinish);
	    websocket._receiver.on('finish', receiverOnFinish);
	  }
	}

	/**
	 * The listener of the `net.Socket` `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function socketOnData(chunk) {
	  if (!this[kWebSocket]._receiver.write(chunk)) {
	    this.pause();
	  }
	}

	/**
	 * The listener of the `net.Socket` `'end'` event.
	 *
	 * @private
	 */
	function socketOnEnd() {
	  const websocket = this[kWebSocket];

	  websocket._readyState = WebSocket.CLOSING;
	  websocket._receiver.end();
	  this.end();
	}

	/**
	 * The listener of the `net.Socket` `'error'` event.
	 *
	 * @private
	 */
	function socketOnError() {
	  const websocket = this[kWebSocket];

	  this.removeListener('error', socketOnError);
	  this.on('error', NOOP);

	  if (websocket) {
	    websocket._readyState = WebSocket.CLOSING;
	    this.destroy();
	  }
	}
	return websocket$1;
}

var stream$1;
var hasRequiredStream$1;

function requireStream$1 () {
	if (hasRequiredStream$1) return stream$1;
	hasRequiredStream$1 = 1;

	const { Duplex } = require$$0$2;

	/**
	 * Emits the `'close'` event on a stream.
	 *
	 * @param {Duplex} stream The stream.
	 * @private
	 */
	function emitClose(stream) {
	  stream.emit('close');
	}

	/**
	 * The listener of the `'end'` event.
	 *
	 * @private
	 */
	function duplexOnEnd() {
	  if (!this.destroyed && this._writableState.finished) {
	    this.destroy();
	  }
	}

	/**
	 * The listener of the `'error'` event.
	 *
	 * @param {Error} err The error
	 * @private
	 */
	function duplexOnError(err) {
	  this.removeListener('error', duplexOnError);
	  this.destroy();
	  if (this.listenerCount('error') === 0) {
	    // Do not suppress the throwing behavior.
	    this.emit('error', err);
	  }
	}

	/**
	 * Wraps a `WebSocket` in a duplex stream.
	 *
	 * @param {WebSocket} ws The `WebSocket` to wrap
	 * @param {Object} [options] The options for the `Duplex` constructor
	 * @return {Duplex} The duplex stream
	 * @public
	 */
	function createWebSocketStream(ws, options) {
	  let resumeOnReceiverDrain = true;
	  let terminateOnDestroy = true;

	  function receiverOnDrain() {
	    if (resumeOnReceiverDrain) ws._socket.resume();
	  }

	  if (ws.readyState === ws.CONNECTING) {
	    ws.once('open', function open() {
	      ws._receiver.removeAllListeners('drain');
	      ws._receiver.on('drain', receiverOnDrain);
	    });
	  } else {
	    ws._receiver.removeAllListeners('drain');
	    ws._receiver.on('drain', receiverOnDrain);
	  }

	  const duplex = new Duplex({
	    ...options,
	    autoDestroy: false,
	    emitClose: false,
	    objectMode: false,
	    writableObjectMode: false
	  });

	  ws.on('message', function message(msg) {
	    if (!duplex.push(msg)) {
	      resumeOnReceiverDrain = false;
	      ws._socket.pause();
	    }
	  });

	  ws.once('error', function error(err) {
	    if (duplex.destroyed) return;

	    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
	    //
	    // - If the `'error'` event is emitted before the `'open'` event, then
	    //   `ws.terminate()` is a noop as no socket is assigned.
	    // - Otherwise, the error is re-emitted by the listener of the `'error'`
	    //   event of the `Receiver` object. The listener already closes the
	    //   connection by calling `ws.close()`. This allows a close frame to be
	    //   sent to the other peer. If `ws.terminate()` is called right after this,
	    //   then the close frame might not be sent.
	    terminateOnDestroy = false;
	    duplex.destroy(err);
	  });

	  ws.once('close', function close() {
	    if (duplex.destroyed) return;

	    duplex.push(null);
	  });

	  duplex._destroy = function (err, callback) {
	    if (ws.readyState === ws.CLOSED) {
	      callback(err);
	      process.nextTick(emitClose, duplex);
	      return;
	    }

	    let called = false;

	    ws.once('error', function error(err) {
	      called = true;
	      callback(err);
	    });

	    ws.once('close', function close() {
	      if (!called) callback(err);
	      process.nextTick(emitClose, duplex);
	    });

	    if (terminateOnDestroy) ws.terminate();
	  };

	  duplex._final = function (callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._final(callback);
	      });
	      return;
	    }

	    // If the value of the `_socket` property is `null` it means that `ws` is a
	    // client websocket and the handshake failed. In fact, when this happens, a
	    // socket is never assigned to the websocket. Wait for the `'error'` event
	    // that will be emitted by the websocket.
	    if (ws._socket === null) return;

	    if (ws._socket._writableState.finished) {
	      callback();
	      if (duplex._readableState.endEmitted) duplex.destroy();
	    } else {
	      ws._socket.once('finish', function finish() {
	        // `duplex` is not destroyed here because the `'end'` event will be
	        // emitted on `duplex` after this `'finish'` event. The EOF signaling
	        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
	        callback();
	      });
	      ws.close();
	    }
	  };

	  duplex._read = function () {
	    if (
	      (ws.readyState === ws.OPEN || ws.readyState === ws.CLOSING) &&
	      !resumeOnReceiverDrain
	    ) {
	      resumeOnReceiverDrain = true;
	      if (!ws._receiver._writableState.needDrain) ws._socket.resume();
	    }
	  };

	  duplex._write = function (chunk, encoding, callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._write(chunk, encoding, callback);
	      });
	      return;
	    }

	    ws.send(chunk, callback);
	  };

	  duplex.on('end', duplexOnEnd);
	  duplex.on('error', duplexOnError);
	  return duplex;
	}

	stream$1 = createWebSocketStream;
	return stream$1;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls|https$" }] */

var websocketServer;
var hasRequiredWebsocketServer;

function requireWebsocketServer () {
	if (hasRequiredWebsocketServer) return websocketServer;
	hasRequiredWebsocketServer = 1;

	const EventEmitter = require$$0$3;
	const http = require$$1;
	const { createHash } = require$$5;

	const PerMessageDeflate = requirePermessageDeflate();
	const WebSocket = requireWebsocket$1();
	const { format, parse } = requireExtension();
	const { GUID, kWebSocket } = requireConstants();

	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;

	/**
	 * Class representing a WebSocket server.
	 *
	 * @extends EventEmitter
	 */
	class WebSocketServer extends EventEmitter {
	  /**
	   * Create a `WebSocketServer` instance.
	   *
	   * @param {Object} options Configuration options
	   * @param {Number} [options.backlog=511] The maximum length of the queue of
	   *     pending connections
	   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
	   *     track clients
	   * @param {Function} [options.handleProtocols] A hook to handle protocols
	   * @param {String} [options.host] The hostname where to bind the server
	   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
	   *     size
	   * @param {Boolean} [options.noServer=false] Enable no server mode
	   * @param {String} [options.path] Accept only connections matching this path
	   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
	   *     permessage-deflate
	   * @param {Number} [options.port] The port where to bind the server
	   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
	   *     server to use
	   * @param {Function} [options.verifyClient] A hook to reject connections
	   * @param {Function} [callback] A listener for the `listening` event
	   */
	  constructor(options, callback) {
	    super();

	    options = {
	      maxPayload: 100 * 1024 * 1024,
	      perMessageDeflate: false,
	      handleProtocols: null,
	      clientTracking: true,
	      verifyClient: null,
	      noServer: false,
	      backlog: null, // use default (511 as implemented in net.js)
	      server: null,
	      host: null,
	      path: null,
	      port: null,
	      ...options
	    };

	    if (
	      (options.port == null && !options.server && !options.noServer) ||
	      (options.port != null && (options.server || options.noServer)) ||
	      (options.server && options.noServer)
	    ) {
	      throw new TypeError(
	        'One and only one of the "port", "server", or "noServer" options ' +
	          'must be specified'
	      );
	    }

	    if (options.port != null) {
	      this._server = http.createServer((req, res) => {
	        const body = http.STATUS_CODES[426];

	        res.writeHead(426, {
	          'Content-Length': body.length,
	          'Content-Type': 'text/plain'
	        });
	        res.end(body);
	      });
	      this._server.listen(
	        options.port,
	        options.host,
	        options.backlog,
	        callback
	      );
	    } else if (options.server) {
	      this._server = options.server;
	    }

	    if (this._server) {
	      const emitConnection = this.emit.bind(this, 'connection');

	      this._removeListeners = addListeners(this._server, {
	        listening: this.emit.bind(this, 'listening'),
	        error: this.emit.bind(this, 'error'),
	        upgrade: (req, socket, head) => {
	          this.handleUpgrade(req, socket, head, emitConnection);
	        }
	      });
	    }

	    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
	    if (options.clientTracking) this.clients = new Set();
	    this.options = options;
	    this._state = RUNNING;
	  }

	  /**
	   * Returns the bound address, the address family name, and port of the server
	   * as reported by the operating system if listening on an IP socket.
	   * If the server is listening on a pipe or UNIX domain socket, the name is
	   * returned as a string.
	   *
	   * @return {(Object|String|null)} The address of the server
	   * @public
	   */
	  address() {
	    if (this.options.noServer) {
	      throw new Error('The server is operating in "noServer" mode');
	    }

	    if (!this._server) return null;
	    return this._server.address();
	  }

	  /**
	   * Close the server.
	   *
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  close(cb) {
	    if (cb) this.once('close', cb);

	    if (this._state === CLOSED) {
	      process.nextTick(emitClose, this);
	      return;
	    }

	    if (this._state === CLOSING) return;
	    this._state = CLOSING;

	    //
	    // Terminate all associated clients.
	    //
	    if (this.clients) {
	      for (const client of this.clients) client.terminate();
	    }

	    const server = this._server;

	    if (server) {
	      this._removeListeners();
	      this._removeListeners = this._server = null;

	      //
	      // Close the http server if it was internally created.
	      //
	      if (this.options.port != null) {
	        server.close(emitClose.bind(undefined, this));
	        return;
	      }
	    }

	    process.nextTick(emitClose, this);
	  }

	  /**
	   * See if a given request should be handled by this server instance.
	   *
	   * @param {http.IncomingMessage} req Request object to inspect
	   * @return {Boolean} `true` if the request is valid, else `false`
	   * @public
	   */
	  shouldHandle(req) {
	    if (this.options.path) {
	      const index = req.url.indexOf('?');
	      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

	      if (pathname !== this.options.path) return false;
	    }

	    return true;
	  }

	  /**
	   * Handle a HTTP Upgrade request.
	   *
	   * @param {http.IncomingMessage} req The request object
	   * @param {(net.Socket|tls.Socket)} socket The network socket between the
	   *     server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Function} cb Callback
	   * @public
	   */
	  handleUpgrade(req, socket, head, cb) {
	    socket.on('error', socketOnError);

	    const key =
	      req.headers['sec-websocket-key'] !== undefined
	        ? req.headers['sec-websocket-key'].trim()
	        : false;
	    const upgrade = req.headers.upgrade;
	    const version = +req.headers['sec-websocket-version'];
	    const extensions = {};

	    if (
	      req.method !== 'GET' ||
	      upgrade === undefined ||
	      upgrade.toLowerCase() !== 'websocket' ||
	      !key ||
	      !keyRegex.test(key) ||
	      (version !== 8 && version !== 13) ||
	      !this.shouldHandle(req)
	    ) {
	      return abortHandshake(socket, 400);
	    }

	    if (this.options.perMessageDeflate) {
	      const perMessageDeflate = new PerMessageDeflate(
	        this.options.perMessageDeflate,
	        true,
	        this.options.maxPayload
	      );

	      try {
	        const offers = parse(req.headers['sec-websocket-extensions']);

	        if (offers[PerMessageDeflate.extensionName]) {
	          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
	          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
	        }
	      } catch (err) {
	        return abortHandshake(socket, 400);
	      }
	    }

	    //
	    // Optionally call external client verification handler.
	    //
	    if (this.options.verifyClient) {
	      const info = {
	        origin:
	          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
	        secure: !!(req.socket.authorized || req.socket.encrypted),
	        req
	      };

	      if (this.options.verifyClient.length === 2) {
	        this.options.verifyClient(info, (verified, code, message, headers) => {
	          if (!verified) {
	            return abortHandshake(socket, code || 401, message, headers);
	          }

	          this.completeUpgrade(key, extensions, req, socket, head, cb);
	        });
	        return;
	      }

	      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
	    }

	    this.completeUpgrade(key, extensions, req, socket, head, cb);
	  }

	  /**
	   * Upgrade the connection to WebSocket.
	   *
	   * @param {String} key The value of the `Sec-WebSocket-Key` header
	   * @param {Object} extensions The accepted extensions
	   * @param {http.IncomingMessage} req The request object
	   * @param {(net.Socket|tls.Socket)} socket The network socket between the
	   *     server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Function} cb Callback
	   * @throws {Error} If called more than once with the same socket
	   * @private
	   */
	  completeUpgrade(key, extensions, req, socket, head, cb) {
	    //
	    // Destroy the socket if the client has already sent a FIN packet.
	    //
	    if (!socket.readable || !socket.writable) return socket.destroy();

	    if (socket[kWebSocket]) {
	      throw new Error(
	        'server.handleUpgrade() was called more than once with the same ' +
	          'socket, possibly due to a misconfiguration'
	      );
	    }

	    if (this._state > RUNNING) return abortHandshake(socket, 503);

	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');

	    const headers = [
	      'HTTP/1.1 101 Switching Protocols',
	      'Upgrade: websocket',
	      'Connection: Upgrade',
	      `Sec-WebSocket-Accept: ${digest}`
	    ];

	    const ws = new WebSocket(null);
	    let protocol = req.headers['sec-websocket-protocol'];

	    if (protocol) {
	      protocol = protocol.split(',').map(trim);

	      //
	      // Optionally call external protocol selection handler.
	      //
	      if (this.options.handleProtocols) {
	        protocol = this.options.handleProtocols(protocol, req);
	      } else {
	        protocol = protocol[0];
	      }

	      if (protocol) {
	        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
	        ws._protocol = protocol;
	      }
	    }

	    if (extensions[PerMessageDeflate.extensionName]) {
	      const params = extensions[PerMessageDeflate.extensionName].params;
	      const value = format({
	        [PerMessageDeflate.extensionName]: [params]
	      });
	      headers.push(`Sec-WebSocket-Extensions: ${value}`);
	      ws._extensions = extensions;
	    }

	    //
	    // Allow external modification/inspection of handshake headers.
	    //
	    this.emit('headers', headers, req);

	    socket.write(headers.concat('\r\n').join('\r\n'));
	    socket.removeListener('error', socketOnError);

	    ws.setSocket(socket, head, this.options.maxPayload);

	    if (this.clients) {
	      this.clients.add(ws);
	      ws.on('close', () => this.clients.delete(ws));
	    }

	    cb(ws, req);
	  }
	}

	websocketServer = WebSocketServer;

	/**
	 * Add event listeners on an `EventEmitter` using a map of <event, listener>
	 * pairs.
	 *
	 * @param {EventEmitter} server The event emitter
	 * @param {Object.<String, Function>} map The listeners to add
	 * @return {Function} A function that will remove the added listeners when
	 *     called
	 * @private
	 */
	function addListeners(server, map) {
	  for (const event of Object.keys(map)) server.on(event, map[event]);

	  return function removeListeners() {
	    for (const event of Object.keys(map)) {
	      server.removeListener(event, map[event]);
	    }
	  };
	}

	/**
	 * Emit a `'close'` event on an `EventEmitter`.
	 *
	 * @param {EventEmitter} server The event emitter
	 * @private
	 */
	function emitClose(server) {
	  server._state = CLOSED;
	  server.emit('close');
	}

	/**
	 * Handle premature socket errors.
	 *
	 * @private
	 */
	function socketOnError() {
	  this.destroy();
	}

	/**
	 * Close the connection when preconditions are not fulfilled.
	 *
	 * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request
	 * @param {Number} code The HTTP response status code
	 * @param {String} [message] The HTTP response body
	 * @param {Object} [headers] Additional HTTP response headers
	 * @private
	 */
	function abortHandshake(socket, code, message, headers) {
	  if (socket.writable) {
	    message = message || http.STATUS_CODES[code];
	    headers = {
	      Connection: 'close',
	      'Content-Type': 'text/html',
	      'Content-Length': Buffer.byteLength(message),
	      ...headers
	    };

	    socket.write(
	      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
	        Object.keys(headers)
	          .map((h) => `${h}: ${headers[h]}`)
	          .join('\r\n') +
	        '\r\n\r\n' +
	        message
	    );
	  }

	  socket.removeListener('error', socketOnError);
	  socket.destroy();
	}

	/**
	 * Remove whitespace characters from both ends of a string.
	 *
	 * @param {String} str The string
	 * @return {String} A new string representing `str` stripped of whitespace
	 *     characters from both its beginning and end
	 * @private
	 */
	function trim(str) {
	  return str.trim();
	}
	return websocketServer;
}

var ws;
var hasRequiredWs;

function requireWs () {
	if (hasRequiredWs) return ws;
	hasRequiredWs = 1;

	const WebSocket = requireWebsocket$1();

	WebSocket.createWebSocketStream = requireStream$1();
	WebSocket.Server = requireWebsocketServer();
	WebSocket.Receiver = requireReceiver();
	WebSocket.Sender = requireSender();

	ws = WebSocket;
	return ws;
}

var wsExports = requireWs();
var WebSocket = /*@__PURE__*/getDefaultExportFromCjs(wsExports);

const ANSI_BACKGROUND_OFFSET = 10;

const wrapAnsi16 = (offset = 0) => code => `\u001B[${code + offset}m`;

const wrapAnsi256 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;

const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;

const styles$1 = {
	modifier: {
		reset: [0, 0],
		// 21 isn't widely supported and 22 does the same thing
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29],
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],

		// Bright color
		blackBright: [90, 39],
		gray: [90, 39], // Alias of `blackBright`
		grey: [90, 39], // Alias of `blackBright`
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39],
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],

		// Bright color
		bgBlackBright: [100, 49],
		bgGray: [100, 49], // Alias of `bgBlackBright`
		bgGrey: [100, 49], // Alias of `bgBlackBright`
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49],
	},
};

Object.keys(styles$1.modifier);
const foregroundColorNames = Object.keys(styles$1.color);
const backgroundColorNames = Object.keys(styles$1.bgColor);
[...foregroundColorNames, ...backgroundColorNames];

function assembleStyles() {
	const codes = new Map();

	for (const [groupName, group] of Object.entries(styles$1)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles$1[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`,
			};

			group[styleName] = styles$1[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles$1, groupName, {
			value: group,
			enumerable: false,
		});
	}

	Object.defineProperty(styles$1, 'codes', {
		value: codes,
		enumerable: false,
	});

	styles$1.color.close = '\u001B[39m';
	styles$1.bgColor.close = '\u001B[49m';

	styles$1.color.ansi = wrapAnsi16();
	styles$1.color.ansi256 = wrapAnsi256();
	styles$1.color.ansi16m = wrapAnsi16m();
	styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);

	// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
	Object.defineProperties(styles$1, {
		rgbToAnsi256: {
			value(red, green, blue) {
				// We use the extended greyscale palette here, with the exception of
				// black and white. normal palette only has 4 greyscale shades.
				if (red === green && green === blue) {
					if (red < 8) {
						return 16;
					}

					if (red > 248) {
						return 231;
					}

					return Math.round(((red - 8) / 247) * 24) + 232;
				}

				return 16
					+ (36 * Math.round(red / 255 * 5))
					+ (6 * Math.round(green / 255 * 5))
					+ Math.round(blue / 255 * 5);
			},
			enumerable: false,
		},
		hexToRgb: {
			value(hex) {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) {
					return [0, 0, 0];
				}

				let [colorString] = matches;

				if (colorString.length === 3) {
					colorString = [...colorString].map(character => character + character).join('');
				}

				const integer = Number.parseInt(colorString, 16);

				return [
					/* eslint-disable no-bitwise */
					(integer >> 16) & 0xFF,
					(integer >> 8) & 0xFF,
					integer & 0xFF,
					/* eslint-enable no-bitwise */
				];
			},
			enumerable: false,
		},
		hexToAnsi256: {
			value: hex => styles$1.rgbToAnsi256(...styles$1.hexToRgb(hex)),
			enumerable: false,
		},
		ansi256ToAnsi: {
			value(code) {
				if (code < 8) {
					return 30 + code;
				}

				if (code < 16) {
					return 90 + (code - 8);
				}

				let red;
				let green;
				let blue;

				if (code >= 232) {
					red = (((code - 232) * 10) + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;

					const remainder = code % 36;

					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = (remainder % 6) / 5;
				}

				const value = Math.max(red, green, blue) * 2;

				if (value === 0) {
					return 30;
				}

				// eslint-disable-next-line no-bitwise
				let result = 30 + ((Math.round(blue) << 2) | (Math.round(green) << 1) | Math.round(red));

				if (value === 2) {
					result += 60;
				}

				return result;
			},
			enumerable: false,
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(red, green, blue)),
			enumerable: false,
		},
		hexToAnsi: {
			value: hex => styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(hex)),
			enumerable: false,
		},
	});

	return styles$1;
}

const ansiStyles = assembleStyles();

/* eslint-env browser */

const level = (() => {
	if (!('navigator' in globalThis)) {
		return 0;
	}

	if (globalThis.navigator.userAgentData) {
		const brand = navigator.userAgentData.brands.find(({brand}) => brand === 'Chromium');
		if (brand && brand.version > 93) {
			return 3;
		}
	}

	if (/\b(Chrome|Chromium)\//.test(globalThis.navigator.userAgent)) {
		return 1;
	}

	return 0;
})();

const colorSupport = level !== 0 && {
	level};

const supportsColor = {
	stdout: colorSupport,
	stderr: colorSupport,
};

// TODO: When targeting Node.js 16, use `String.prototype.replaceAll`.
function stringReplaceAll(string, substring, replacer) {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.slice(endIndex, index) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.slice(endIndex);
	return returnValue;
}

function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.slice(endIndex, (gotCR ? index - 1 : index)) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.slice(endIndex);
	return returnValue;
}

const {stdout: stdoutColor, stderr: stderrColor} = supportsColor;

const GENERATOR = Symbol('GENERATOR');
const STYLER = Symbol('STYLER');
const IS_EMPTY = Symbol('IS_EMPTY');

// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m',
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

const chalkFactory = options => {
	const chalk = (...strings) => strings.join(' ');
	applyOptions(chalk, options);

	Object.setPrototypeOf(chalk, createChalk.prototype);

	return chalk;
};

function createChalk(options) {
	return chalkFactory(options);
}

Object.setPrototypeOf(createChalk.prototype, Function.prototype);

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		},
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this[STYLER], true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	},
};

const getModelAnsi = (model, level, type, ...arguments_) => {
	if (model === 'rgb') {
		if (level === 'ansi16m') {
			return ansiStyles[type].ansi16m(...arguments_);
		}

		if (level === 'ansi256') {
			return ansiStyles[type].ansi256(ansiStyles.rgbToAnsi256(...arguments_));
		}

		return ansiStyles[type].ansi(ansiStyles.rgbToAnsi(...arguments_));
	}

	if (model === 'hex') {
		return getModelAnsi('rgb', level, type, ...ansiStyles.hexToRgb(...arguments_));
	}

	return ansiStyles[type][model](...arguments_);
};

const usedModels = ['rgb', 'hex', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], 'color', ...arguments_), ansiStyles.color.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		},
	};

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_), ansiStyles.bgColor.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		},
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this[GENERATOR].level;
		},
		set(level) {
			this[GENERATOR].level = level;
		},
	},
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent,
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	// Single argument is hot path, implicit coercion is faster than anything
	// eslint-disable-next-line no-implicit-coercion
	const builder = (...arguments_) => applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder[GENERATOR] = self;
	builder[STYLER] = _styler;
	builder[IS_EMPTY] = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self[IS_EMPTY] ? '' : string;
	}

	let styler = self[STYLER];

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.includes('\u001B')) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

Object.defineProperties(createChalk.prototype, styles);

const chalk = createChalk();
createChalk({level: stderrColor ? stderrColor.level : 0});

class DisplayManager {
    static instance;
    promptText = '';
    constructor() { }
    static getInstance() {
        if (!DisplayManager.instance) {
            DisplayManager.instance = new DisplayManager();
        }
        return DisplayManager.instance;
    }
    setPrompt(prompt) {
        this.promptText = prompt;
    }
    /**
     * Logs a message while preserving the prompt at the bottom
     */
    log(message, options) {
        // Clear the current prompt line
        clearLine(process.stdout, 0);
        cursorTo(process.stdout, 0);
        // Format the timestamp
        const date = new Date();
        const timestamp = date.toLocaleString('en-US', { timeZone: 'America/New_York' });
        const account = options?.account;
        const symbol = options?.symbol;
        // Build the log message
        let logMessage = `[${timestamp}]${options?.source ? ` [${options.source}] ` : ''}${account ? ` [${account}] ` : ''}${symbol ? ` [${symbol}] ` : ''}${message}`;
        // Add color based on type
        if (options?.type === 'error') {
            logMessage = chalk.red(logMessage);
        }
        else if (options?.type === 'warn') {
            logMessage = chalk.yellow(logMessage);
        }
        // Write the log message
        process.stdout.write(logMessage + '\n');
        // Log to file
        if (symbol) {
            // Log to symbol-specific file if symbol is provided
            this.writeSymbolLog(symbol, date, logMessage, options);
        }
        else if (options?.logToFile) {
            // Log to a generic file if explicitly requested
            this.writeGenericLog(date, logMessage, options);
        }
        // Rewrite the prompt
        this.writePrompt();
    }
    /**
     * Writes a log entry to a symbol-specific log file
     */
    writeSymbolLog(symbol, date, logMessage, options) {
        try {
            // Create logs directory if it doesn't exist
            if (!fs.existsSync('logs')) {
                fs.mkdirSync('logs', { recursive: true });
            }
            // Format date for filename: YYYY-MM-DD
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            // Create filename: SYM-YYYY-MM-DD.log
            const filename = `${symbol}-${year}-${month}-${day}.log`;
            const filePath = path.join('logs', filename);
            // Strip ANSI color codes from log message
            const plainLogMessage = logMessage.replace(/\x1B\[\d+m/g, '');
            // Write to file (append if exists, create if not)
            fs.appendFileSync(filePath, plainLogMessage + '\n');
        }
        catch (error) {
            // Only log to console - don't try to log to file again to avoid potential infinite loop
            process.stdout.write(`Error writing to symbol log file: ${error}\n`);
        }
    }
    /**
     * Writes a log entry to a generic log file when no symbol is provided
     */
    writeGenericLog(date, logMessage, options) {
        try {
            // Create logs directory if it doesn't exist
            if (!fs.existsSync('logs')) {
                fs.mkdirSync('logs', { recursive: true });
            }
            // Format date for filename: YYYY-MM-DD
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            // Create filename: system-YYYY-MM-DD.log
            const source = options?.source?.toLowerCase().replace(/\s+/g, '-') || 'system';
            const filename = `${source}-${year}-${month}-${day}.log`;
            const filePath = path.join('logs', filename);
            // Strip ANSI color codes from log message
            const plainLogMessage = logMessage.replace(/\x1B\[\d+m/g, '');
            // Write to file (append if exists, create if not)
            fs.appendFileSync(filePath, plainLogMessage + '\n');
        }
        catch (error) {
            // Only log to console - don't try to log to file again to avoid potential infinite loop
            process.stdout.write(`Error writing to generic log file: ${error}\n`);
        }
    }
    writePrompt() {
        process.stdout.write(this.promptText);
    }
    clearPrompt() {
        clearLine(process.stdout, 0);
        cursorTo(process.stdout, 0);
    }
    restorePrompt() {
        this.writePrompt();
    }
}

/**
 * Logs a message to the console.
 * @param message The message to log.
 * @param options Optional options.
 * @param options.source The source of the message.
 * @param options.type The type of message to log.
 * @param options.symbol The trading symbol associated with this log.
 * @param options.logToFile Force logging to a file even when no symbol is provided.
 */
function log$l(message, options = { source: 'Server', type: 'info' }) {
    const displayManager = DisplayManager.getInstance();
    displayManager.log(message, options);
}

const log$k = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: 'AlpacaMarketDataAPI' });
};
// Default settings for market data API
const DEFAULT_ADJUSTMENT = 'all';
const DEFAULT_FEED = 'sip';
const DEFAULT_CURRENCY = 'USD';
/**
 * Singleton class for interacting with Alpaca Market Data API
 * Provides methods for fetching historical bars, latest bars, last trades, latest trades, latest quotes, and latest quote for a single symbol
 */
class AlpacaMarketDataAPI extends EventEmitter {
    static instance;
    headers;
    dataURL;
    apiURL;
    v1beta1url;
    stockStreamUrl = 'wss://stream.data.alpaca.markets/v2/sip'; // production values
    optionStreamUrl = 'wss://stream.data.alpaca.markets/v1beta3/options'; // production values
    cryptoStreamUrl = 'wss://stream.data.alpaca.markets/v1beta3/crypto/us'; // production values
    stockWs = null;
    optionWs = null;
    cryptoWs = null;
    stockSubscriptions = { trades: [], quotes: [], bars: [] };
    optionSubscriptions = { trades: [], quotes: [], bars: [] };
    cryptoSubscriptions = { trades: [], quotes: [], bars: [] };
    setMode(mode = 'production') {
        if (mode === 'sandbox') { // sandbox mode
            this.stockStreamUrl = 'wss://stream.data.sandbox.alpaca.markets/v2/sip';
            this.optionStreamUrl = 'wss://stream.data.sandbox.alpaca.markets/v1beta3/options';
            this.cryptoStreamUrl = 'wss://stream.data.sandbox.alpaca.markets/v1beta3/crypto/us';
        }
        else if (mode === 'test') { // test mode, can only use ticker FAKEPACA
            this.stockStreamUrl = 'wss://stream.data.alpaca.markets/v2/test';
            this.optionStreamUrl = 'wss://stream.data.alpaca.markets/v1beta3/options'; // there's no test mode for options
            this.cryptoStreamUrl = 'wss://stream.data.alpaca.markets/v1beta3/crypto/us'; // there's no test mode for crypto
        }
        else { // production
            this.stockStreamUrl = 'wss://stream.data.alpaca.markets/v2/sip';
            this.optionStreamUrl = 'wss://stream.data.alpaca.markets/v1beta3/options';
            this.cryptoStreamUrl = 'wss://stream.data.alpaca.markets/v1beta3/crypto/us';
        }
    }
    getMode() {
        if (this.stockStreamUrl.includes('sandbox')) {
            return 'sandbox';
        }
        else if (this.stockStreamUrl.includes('test')) {
            return 'test';
        }
        else {
            return 'production';
        }
    }
    constructor() {
        super();
        this.dataURL = 'https://data.alpaca.markets/v2';
        this.apiURL =
            process.env.ALPACA_ACCOUNT_TYPE === 'PAPER'
                ? 'https://paper-api.alpaca.markets/v2'
                : 'https://api.alpaca.markets/v2'; // used by some, e.g. getAssets
        this.v1beta1url = 'https://data.alpaca.markets/v1beta1'; // used for options endpoints
        this.setMode('production'); // sets stockStreamUrl and optionStreamUrl
        this.headers = {
            'APCA-API-KEY-ID': process.env.ALPACA_API_KEY,
            'APCA-API-SECRET-KEY': process.env.ALPACA_SECRET_KEY,
            'Content-Type': 'application/json',
        };
    }
    static getInstance() {
        if (!AlpacaMarketDataAPI.instance) {
            AlpacaMarketDataAPI.instance = new AlpacaMarketDataAPI();
        }
        return AlpacaMarketDataAPI.instance;
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    connect(streamType) {
        let url;
        if (streamType === 'stock') {
            url = this.stockStreamUrl;
        }
        else if (streamType === 'option') {
            url = this.optionStreamUrl;
        }
        else {
            url = this.cryptoStreamUrl;
        }
        const ws = new WebSocket(url);
        if (streamType === 'stock') {
            this.stockWs = ws;
        }
        else if (streamType === 'option') {
            this.optionWs = ws;
        }
        else {
            this.cryptoWs = ws;
        }
        ws.on('open', () => {
            log$k(`${streamType} stream connected`, { type: 'info' });
            const authMessage = {
                action: 'auth',
                key: process.env.ALPACA_API_KEY,
                secret: process.env.ALPACA_SECRET_KEY,
            };
            ws.send(JSON.stringify(authMessage));
        });
        ws.on('message', (data) => {
            const rawData = data.toString();
            let messages;
            try {
                messages = JSON.parse(rawData);
            }
            catch (e) {
                log$k(`${streamType} stream received invalid JSON: ${rawData.substring(0, 200)}`, { type: 'error' });
                return;
            }
            for (const message of messages) {
                if (message.T === 'success' && message.msg === 'authenticated') {
                    log$k(`${streamType} stream authenticated`, { type: 'info' });
                    this.sendSubscription(streamType);
                }
                else if (message.T === 'success' && message.msg === 'connected') {
                    log$k(`${streamType} stream connected message received`, { type: 'debug' });
                }
                else if (message.T === 'subscription') {
                    log$k(`${streamType} subscription confirmed: trades=${message.trades?.length || 0}, quotes=${message.quotes?.length || 0}, bars=${message.bars?.length || 0}`, { type: 'info' });
                }
                else if (message.T === 'error') {
                    log$k(`${streamType} stream error: ${message.msg} (code: ${message.code}, raw: ${JSON.stringify(message)})`, { type: 'error' });
                }
                else if (message.S) {
                    super.emit(`${streamType}-${message.T}`, message);
                    super.emit(`${streamType}-data`, message);
                }
                else {
                    log$k(`${streamType} received unknown message type: ${JSON.stringify(message)}`, { type: 'debug' });
                }
            }
        });
        ws.on('close', () => {
            log$k(`${streamType} stream disconnected`, { type: 'warn' });
            if (streamType === 'stock') {
                this.stockWs = null;
            }
            else if (streamType === 'option') {
                this.optionWs = null;
            }
            else {
                this.cryptoWs = null;
            }
            // Optional: implement reconnect logic
        });
        ws.on('error', (error) => {
            log$k(`${streamType} stream error: ${error.message}`, { type: 'error' });
        });
    }
    sendSubscription(streamType) {
        let ws;
        let subscriptions;
        if (streamType === 'stock') {
            ws = this.stockWs;
            subscriptions = this.stockSubscriptions;
        }
        else if (streamType === 'option') {
            ws = this.optionWs;
            subscriptions = this.optionSubscriptions;
        }
        else {
            ws = this.cryptoWs;
            subscriptions = this.cryptoSubscriptions;
        }
        log$k(`sendSubscription called for ${streamType} (wsReady=${ws?.readyState === WebSocket.OPEN}, trades=${subscriptions.trades?.length || 0}, quotes=${subscriptions.quotes?.length || 0}, bars=${subscriptions.bars?.length || 0})`, {
            type: 'debug',
        });
        if (ws && ws.readyState === WebSocket.OPEN) {
            const subMessagePayload = {};
            if (subscriptions.trades.length > 0) {
                subMessagePayload.trades = subscriptions.trades;
            }
            if (subscriptions.quotes.length > 0) {
                subMessagePayload.quotes = subscriptions.quotes;
            }
            if (subscriptions.bars.length > 0) {
                subMessagePayload.bars = subscriptions.bars;
            }
            if (Object.keys(subMessagePayload).length > 0) {
                const subMessage = {
                    action: 'subscribe',
                    ...subMessagePayload,
                };
                const messageJson = JSON.stringify(subMessage);
                log$k(`Sending ${streamType} subscription: ${messageJson}`, { type: 'info' });
                ws.send(messageJson);
            }
            else {
                log$k(`No ${streamType} subscriptions to send (all arrays empty)`, { type: 'debug' });
            }
        }
        else {
            log$k(`Cannot send ${streamType} subscription: WebSocket not ready`, { type: 'warn' });
        }
    }
    connectStockStream() {
        if (!this.stockWs) {
            this.connect('stock');
        }
    }
    connectOptionStream() {
        if (!this.optionWs) {
            this.connect('option');
        }
    }
    connectCryptoStream() {
        if (!this.cryptoWs) {
            this.connect('crypto');
        }
    }
    disconnectStockStream() {
        if (this.stockWs) {
            this.stockWs.close();
        }
    }
    disconnectOptionStream() {
        if (this.optionWs) {
            this.optionWs.close();
        }
    }
    disconnectCryptoStream() {
        if (this.cryptoWs) {
            this.cryptoWs.close();
        }
    }
    /**
     * Check if a specific stream is connected
     * @param streamType - The type of stream to check
     * @returns True if the stream is connected
     */
    isStreamConnected(streamType) {
        if (streamType === 'stock') {
            return this.stockWs !== null && this.stockWs.readyState === WebSocket.OPEN;
        }
        else if (streamType === 'option') {
            return this.optionWs !== null && this.optionWs.readyState === WebSocket.OPEN;
        }
        else {
            return this.cryptoWs !== null && this.cryptoWs.readyState === WebSocket.OPEN;
        }
    }
    subscribe(streamType, subscriptions) {
        let currentSubscriptions;
        if (streamType === 'stock') {
            currentSubscriptions = this.stockSubscriptions;
        }
        else if (streamType === 'option') {
            currentSubscriptions = this.optionSubscriptions;
        }
        else {
            currentSubscriptions = this.cryptoSubscriptions;
        }
        Object.entries(subscriptions).forEach(([key, value]) => {
            if (value) {
                currentSubscriptions[key] = [...new Set([...(currentSubscriptions[key] || []), ...value])];
            }
        });
        this.sendSubscription(streamType);
    }
    unsubscribe(streamType, subscriptions) {
        let currentSubscriptions;
        if (streamType === 'stock') {
            currentSubscriptions = this.stockSubscriptions;
        }
        else if (streamType === 'option') {
            currentSubscriptions = this.optionSubscriptions;
        }
        else {
            currentSubscriptions = this.cryptoSubscriptions;
        }
        Object.entries(subscriptions).forEach(([key, value]) => {
            if (value) {
                currentSubscriptions[key] = (currentSubscriptions[key] || []).filter(s => !value.includes(s));
            }
        });
        const unsubMessage = {
            action: 'unsubscribe',
            ...subscriptions,
        };
        let ws;
        if (streamType === 'stock') {
            ws = this.stockWs;
        }
        else if (streamType === 'option') {
            ws = this.optionWs;
        }
        else {
            ws = this.cryptoWs;
        }
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(unsubMessage));
        }
    }
    async makeRequest(endpoint, method = 'GET', params, baseUrlName = 'data') {
        const baseUrl = baseUrlName === 'data' ? this.dataURL : baseUrlName === 'api' ? this.apiURL : this.v1beta1url;
        const url = new URL(`${baseUrl}${endpoint}`);
        try {
            if (params) {
                Object.entries(params).forEach(([key, value]) => {
                    if (Array.isArray(value)) {
                        url.searchParams.append(key, value.join(','));
                    }
                    else if (value !== undefined) {
                        url.searchParams.append(key, value.toString());
                    }
                });
            }
            const response = await fetch(url.toString(), {
                method,
                headers: this.headers,
            });
            if (!response.ok) {
                const errorText = await response.text();
                log$k(`Market Data API error (${response.status}): ${errorText}`, { type: 'error' });
                throw new Error(`Market Data API error (${response.status}): ${errorText}`);
            }
            const data = await response.json();
            return data;
        }
        catch (err) {
            const error = err;
            log$k(`Error in makeRequest: ${error.message}. Endpoint: ${endpoint}. Url: ${url.toString()}`, { type: 'error' });
            if (error instanceof TypeError) {
                log$k(`Network error details: ${error.stack}`, { type: 'error' });
            }
            throw error;
        }
    }
    /**
     * Get historical OHLCV bars for specified symbols, including pre-market and post-market data
     * Automatically handles pagination to fetch all available data
     * @param params Parameters for historical bars request
     * @returns Historical bars data with all pages combined
     */
    async getHistoricalBars(params) {
        const symbols = params.symbols;
        const symbolsStr = symbols.join(',');
        let allBars = {};
        let pageToken = null;
        let hasMorePages = true;
        let totalBarsCount = 0;
        let pageCount = 0;
        let currency = '';
        // Initialize bar arrays for each symbol
        symbols.forEach(symbol => {
            allBars[symbol] = [];
        });
        log$k(`Starting historical bars fetch for ${symbolsStr} (${params.timeframe}, ${params.start || 'no start'} to ${params.end || 'no end'})`, {
            type: 'info'
        });
        while (hasMorePages) {
            pageCount++;
            const requestParams = {
                ...params,
                adjustment: DEFAULT_ADJUSTMENT,
                feed: DEFAULT_FEED,
                ...(pageToken && { page_token: pageToken }),
            };
            const response = await this.makeRequest('/stocks/bars', 'GET', requestParams);
            if (!response.bars) {
                log$k(`No bars data found in response for ${symbolsStr}`, { type: 'warn' });
                break;
            }
            // Track currency from first response
            if (!currency) {
                currency = response.currency;
            }
            // Combine bars for each symbol
            let pageBarsCount = 0;
            let earliestTimestamp = null;
            let latestTimestamp = null;
            Object.entries(response.bars).forEach(([symbol, bars]) => {
                if (bars && bars.length > 0) {
                    allBars[symbol] = [...allBars[symbol], ...bars];
                    pageBarsCount += bars.length;
                    // Track date range for this page
                    bars.forEach(bar => {
                        const barDate = new Date(bar.t);
                        if (!earliestTimestamp || barDate < earliestTimestamp) {
                            earliestTimestamp = barDate;
                        }
                        if (!latestTimestamp || barDate > latestTimestamp) {
                            latestTimestamp = barDate;
                        }
                    });
                }
            });
            totalBarsCount += pageBarsCount;
            pageToken = response.next_page_token || null;
            hasMorePages = !!pageToken;
            // Enhanced logging with date range and progress info
            const dateRangeStr = earliestTimestamp && latestTimestamp
                ? `${earliestTimestamp.toLocaleDateString('en-US', { timeZone: 'America/New_York' })} to ${latestTimestamp.toLocaleDateString('en-US', { timeZone: 'America/New_York' })}`
                : 'unknown range';
            log$k(`Page ${pageCount}: Fetched ${pageBarsCount.toLocaleString()} bars (total: ${totalBarsCount.toLocaleString()}) for ${symbolsStr}, date range: ${dateRangeStr}${hasMorePages ? ', more pages available' : ', complete'}`, {
                type: 'info'
            });
            // Prevent infinite loops
            if (pageCount > 1000) {
                log$k(`Stopping pagination after ${pageCount} pages to prevent infinite loop`, { type: 'warn' });
                break;
            }
        }
        // Final summary
        const symbolCounts = Object.entries(allBars).map(([symbol, bars]) => `${symbol}: ${bars.length}`).join(', ');
        log$k(`Historical bars fetch complete: ${totalBarsCount.toLocaleString()} total bars across ${pageCount} pages (${symbolCounts})`, {
            type: 'info'
        });
        return {
            bars: allBars,
            next_page_token: null, // Always null since we fetch all pages
            currency: currency || DEFAULT_CURRENCY,
        };
    }
    /**
     * Get the most recent minute bar for requested symbols
     * @param symbols Array of stock symbols to query
     * @param currency Optional currency in ISO 4217 format
     * @returns Latest bar data for each symbol
     
     */
    async getLatestBars(symbols, currency) {
        return this.makeRequest('/stocks/bars/latest', 'GET', {
            symbols,
            feed: DEFAULT_FEED,
            currency: currency || DEFAULT_CURRENCY,
        });
    }
    /**
     * Get the last trade for a single symbol
     * @param symbol The stock symbol to query
     * @returns Last trade details including price, size, exchange, and conditions
     */
    async getLastTrade(symbol) {
        return this.makeRequest(`/v1/last/stocks/${symbol}`, 'GET');
    }
    /**
     * Get the most recent trades for requested symbols
     * @param symbols Array of stock symbols to query
     * @param feed Optional data source (sip/iex/delayed_sip)
     * @param currency Optional currency in ISO 4217 format
     * @returns Latest trade data for each symbol
     
     */
    async getLatestTrades(symbols, feed, currency) {
        return this.makeRequest('/stocks/trades/latest', 'GET', {
            symbols,
            feed: feed || DEFAULT_FEED,
            currency: currency || DEFAULT_CURRENCY,
        });
    }
    /**
     * Get the most recent quotes for requested symbols
     * @param symbols Array of stock symbols to query
     * @param feed Optional data source (sip/iex/delayed_sip)
     * @param currency Optional currency in ISO 4217 format
     * @returns Latest quote data for each symbol
     */
    async getLatestQuotes(symbols, feed, currency) {
        // Return empty response if symbols array is empty to avoid API error
        if (!symbols || symbols.length === 0) {
            log$k('No symbols provided to getLatestQuotes, returning empty response', { type: 'warn' });
            return {
                quotes: {},
                currency: currency || DEFAULT_CURRENCY,
            };
        }
        return this.makeRequest('/stocks/quotes/latest', 'GET', {
            symbols,
            feed: feed || DEFAULT_FEED,
            currency: currency || DEFAULT_CURRENCY,
        });
    }
    /**
     * Get the latest quote for a single symbol
     * @param symbol The stock symbol to query
     * @param feed Optional data source (sip/iex/delayed_sip)
     * @param currency Optional currency in ISO 4217 format
     * @returns Latest quote data with symbol and currency information
     */
    async getLatestQuote(symbol, feed, currency) {
        return this.makeRequest(`/stocks/${symbol}/quotes/latest`, 'GET', {
            feed: feed || DEFAULT_FEED,
            currency,
        });
    }
    /**
     * Get the previous day's closing price for a symbol
     * @param symbol The stock symbol to query
     * @param referenceDate Optional reference date to get the previous close for
     * @returns Previous day's closing price data
     */
    async getPreviousClose(symbol, referenceDate) {
        const date = referenceDate || new Date();
        const prevMarketDate = getLastFullTradingDate(date);
        const response = await this.getHistoricalBars({
            symbols: [symbol],
            timeframe: '1Day',
            start: prevMarketDate.date.toISOString(),
            end: prevMarketDate.date.toISOString(),
            limit: 1,
        });
        if (!response.bars[symbol] || response.bars[symbol].length === 0) {
            log$k(`No previous close data available for ${symbol}`, { type: 'error', symbol });
            return null;
        }
        return response.bars[symbol][0];
    }
    /**
     * Get hourly price data for a symbol
     * @param symbol The stock symbol to query
     * @param start Start time in milliseconds
     * @param end End time in milliseconds
     * @returns Array of hourly price bars
     */
    async getHourlyPrices(symbol, start, end) {
        const response = await this.getHistoricalBars({
            symbols: [symbol],
            timeframe: '1Hour',
            start: new Date(start).toISOString(),
            end: new Date(end).toISOString(),
            limit: 96, // Last 96 hours (4 days)
        });
        return response.bars[symbol] || [];
    }
    /**
     * Get half-hourly price data for a symbol
     * @param symbol The stock symbol to query
     * @param start Start time in milliseconds
     * @param end End time in milliseconds
     * @returns Array of half-hourly price bars
     */
    async getHalfHourlyPrices(symbol, start, end) {
        const response = await this.getHistoricalBars({
            symbols: [symbol],
            timeframe: '30Min',
            start: new Date(start).toISOString(),
            end: new Date(end).toISOString(),
            limit: 16 * 2 * 4, // last 4 days, 16 hours per day, 2 bars per hour
        });
        return response.bars[symbol] || [];
    }
    /**
     * Get daily price data for a symbol
     * @param symbol The stock symbol to query
     * @param start Start time in milliseconds
     * @param end End time in milliseconds
     * @returns Array of daily price bars
     */
    async getDailyPrices(symbol, start, end) {
        const response = await this.getHistoricalBars({
            symbols: [symbol],
            timeframe: '1Day',
            start: new Date(start).toISOString(),
            end: new Date(end).toISOString(),
            limit: 100, // Last 100 days
        });
        return response.bars[symbol] || [];
    }
    /**
     * Get intraday price data for a symbol
     * @param symbol The stock symbol to query
     * @param minutePeriod Minutes per bar (1, 5, 15, etc.)
     * @param start Start time in milliseconds
     * @param end End time in milliseconds
     * @returns Array of intraday price bars
     */
    async getIntradayPrices(symbol, minutePeriod, start, end) {
        const timeframe = `${minutePeriod}Min`;
        const response = await this.getHistoricalBars({
            symbols: [symbol],
            timeframe,
            start: new Date(start).toISOString(),
            end: new Date(end).toISOString(),
        });
        return response.bars[symbol] || [];
    }
    /**
     * Analyzes an array of price bars and returns a summary string
     * @param bars Array of price bars to analyze
     * @returns A string summarizing the price data
     */
    static analyzeBars(bars) {
        if (!bars || bars.length === 0) {
            return 'No price data available';
        }
        const firstBar = bars[0];
        const lastBar = bars[bars.length - 1];
        const priceChange = lastBar.c - firstBar.o;
        const percentChange = (priceChange / firstBar.o) * 100;
        const volumeChange = lastBar.v - firstBar.v;
        const percentVolumeChange = (volumeChange / firstBar.v) * 100;
        const high = Math.max(...bars.map((bar) => bar.h));
        const low = Math.min(...bars.map((bar) => bar.l));
        const totalVolume = bars.reduce((sum, bar) => sum + bar.v, 0);
        const avgVolume = totalVolume / bars.length;
        return (`Price: $${firstBar.o.toFixed(2)} -> $${lastBar.c.toFixed(2)} (${percentChange.toFixed(2)}%), ` +
            `Volume: ${firstBar.v.toLocaleString()} -> ${lastBar.v.toLocaleString()} (${percentVolumeChange.toFixed(2)}%), ` +
            `High: $${high.toFixed(2)}, Low: $${low.toFixed(2)}, ` +
            `Avg Volume: ${avgVolume.toLocaleString()}`);
    }
    /**
     * Get all assets available for trade and data consumption from Alpaca
     * @param params Optional query params: status (e.g. 'active'), asset_class (e.g. 'us_equity', 'crypto')
     * @returns Array of AlpacaAsset objects
     * @see https://docs.alpaca.markets/reference/get-v2-assets-1
     */
    async getAssets(params) {
        // Endpoint: GET /v2/assets
        return this.makeRequest('/assets', 'GET', params, 'api'); // use apiURL
    }
    /**
     * Get a single asset by symbol or asset_id
     * @param symbolOrAssetId Symbol or asset_id
     * @returns AlpacaAsset object
     * @see https://docs.alpaca.markets/reference/get-v2-assets-symbol_or_asset_id
     */
    async getAsset(symbolOrAssetId) {
        // Endpoint: GET /v2/assets/{symbol_or_asset_id}
        return this.makeRequest(`/assets/${encodeURIComponent(symbolOrAssetId)}`, 'GET', undefined, 'api');
    }
    // ===== OPTIONS MARKET DATA METHODS =====
    /**
     * Get options chain for an underlying symbol
     * Provides the latest trade, latest quote, and greeks for each contract symbol of the underlying symbol
     * @param params Options chain request parameters
     * @returns Options chain data with snapshots for each contract
     * @see https://docs.alpaca.markets/reference/optionchain
     */
    async getOptionsChain(params) {
        const { underlying_symbol, ...queryParams } = params;
        return this.makeRequest(`/options/snapshots/${encodeURIComponent(underlying_symbol)}`, 'GET', queryParams, 'v1beta1');
    }
    /**
     * Get the most recent trades for requested option contract symbols
     * @param params Latest options trades request parameters
     * @returns Latest trade data for each option contract symbol
     
     * @see https://docs.alpaca.markets/reference/optionlatesttrades
     */
    async getLatestOptionsTrades(params) {
        // Remove limit and page_token as they're not supported by this endpoint
        const { limit, page_token, ...requestParams } = params;
        return this.makeRequest('/options/trades/latest', 'GET', requestParams, 'v1beta1');
    }
    /**
     * Get the most recent quotes for requested option contract symbols
     * @param params Latest options quotes request parameters
     * @returns Latest quote data for each option contract symbol
     
     * @see https://docs.alpaca.markets/reference/optionlatestquotes
     */
    async getLatestOptionsQuotes(params) {
        // Remove limit and page_token as they're not supported by this endpoint
        const { limit, page_token, ...requestParams } = params;
        return this.makeRequest('/options/quotes/latest', 'GET', requestParams, 'v1beta1');
    }
    /**
     * Get historical OHLCV bars for option contract symbols
     * Automatically handles pagination to fetch all available data
     * @param params Historical options bars request parameters
     * @returns Historical bar data for each option contract symbol with all pages combined
     
     * @see https://docs.alpaca.markets/reference/optionbars
     */
    async getHistoricalOptionsBars(params) {
        const symbols = params.symbols;
        const symbolsStr = symbols.join(',');
        let allBars = {};
        let pageToken = null;
        let hasMorePages = true;
        let totalBarsCount = 0;
        let pageCount = 0;
        // Initialize bar arrays for each symbol
        symbols.forEach(symbol => {
            allBars[symbol] = [];
        });
        log$k(`Starting historical options bars fetch for ${symbolsStr} (${params.timeframe}, ${params.start || 'no start'} to ${params.end || 'no end'})`, {
            type: 'info'
        });
        while (hasMorePages) {
            pageCount++;
            const requestParams = {
                ...params,
                ...(pageToken && { page_token: pageToken }),
            };
            const response = await this.makeRequest('/options/bars', 'GET', requestParams, 'v1beta1');
            if (!response.bars) {
                log$k(`No options bars data found in response for ${symbolsStr}`, { type: 'warn' });
                break;
            }
            // Combine bars for each symbol
            let pageBarsCount = 0;
            let earliestTimestamp = null;
            let latestTimestamp = null;
            Object.entries(response.bars).forEach(([symbol, bars]) => {
                if (bars && bars.length > 0) {
                    allBars[symbol] = [...allBars[symbol], ...bars];
                    pageBarsCount += bars.length;
                    // Track date range for this page
                    bars.forEach(bar => {
                        const barDate = new Date(bar.t);
                        if (!earliestTimestamp || barDate < earliestTimestamp) {
                            earliestTimestamp = barDate;
                        }
                        if (!latestTimestamp || barDate > latestTimestamp) {
                            latestTimestamp = barDate;
                        }
                    });
                }
            });
            totalBarsCount += pageBarsCount;
            pageToken = response.next_page_token || null;
            hasMorePages = !!pageToken;
            // Enhanced logging with date range and progress info
            const dateRangeStr = earliestTimestamp && latestTimestamp
                ? `${earliestTimestamp.toLocaleDateString('en-US', { timeZone: 'America/New_York' })} to ${latestTimestamp.toLocaleDateString('en-US', { timeZone: 'America/New_York' })}`
                : 'unknown range';
            log$k(`Page ${pageCount}: Fetched ${pageBarsCount.toLocaleString()} option bars (total: ${totalBarsCount.toLocaleString()}) for ${symbolsStr}, date range: ${dateRangeStr}${hasMorePages ? ', more pages available' : ', complete'}`, {
                type: 'info'
            });
            // Prevent infinite loops
            if (pageCount > 1000) {
                log$k(`Stopping options bars pagination after ${pageCount} pages to prevent infinite loop`, { type: 'warn' });
                break;
            }
        }
        // Final summary
        const symbolCounts = Object.entries(allBars).map(([symbol, bars]) => `${symbol}: ${bars.length}`).join(', ');
        log$k(`Historical options bars fetch complete: ${totalBarsCount.toLocaleString()} total bars across ${pageCount} pages (${symbolCounts})`, {
            type: 'info'
        });
        return {
            bars: allBars,
            next_page_token: undefined, // Always undefined since we fetch all pages
        };
    }
    /**
     * Get historical trades for option contract symbols
     * Automatically handles pagination to fetch all available data
     * @param params Historical options trades request parameters
     * @returns Historical trade data for each option contract symbol with all pages combined
     
     * @see https://docs.alpaca.markets/reference/optiontrades
     */
    async getHistoricalOptionsTrades(params) {
        const symbols = params.symbols;
        const symbolsStr = symbols.join(',');
        let allTrades = {};
        let pageToken = null;
        let hasMorePages = true;
        let totalTradesCount = 0;
        let pageCount = 0;
        // Initialize trades arrays for each symbol
        symbols.forEach(symbol => {
            allTrades[symbol] = [];
        });
        log$k(`Starting historical options trades fetch for ${symbolsStr} (${params.start || 'no start'} to ${params.end || 'no end'})`, {
            type: 'info'
        });
        while (hasMorePages) {
            pageCount++;
            const requestParams = {
                ...params,
                ...(pageToken && { page_token: pageToken }),
            };
            const response = await this.makeRequest('/options/trades', 'GET', requestParams, 'v1beta1');
            if (!response.trades) {
                log$k(`No options trades data found in response for ${symbolsStr}`, { type: 'warn' });
                break;
            }
            // Combine trades for each symbol
            let pageTradesCount = 0;
            let earliestTimestamp = null;
            let latestTimestamp = null;
            Object.entries(response.trades).forEach(([symbol, trades]) => {
                if (trades && trades.length > 0) {
                    allTrades[symbol] = [...allTrades[symbol], ...trades];
                    pageTradesCount += trades.length;
                    // Track date range for this page
                    trades.forEach(trade => {
                        const tradeDate = new Date(trade.t);
                        if (!earliestTimestamp || tradeDate < earliestTimestamp) {
                            earliestTimestamp = tradeDate;
                        }
                        if (!latestTimestamp || tradeDate > latestTimestamp) {
                            latestTimestamp = tradeDate;
                        }
                    });
                }
            });
            totalTradesCount += pageTradesCount;
            pageToken = response.next_page_token || null;
            hasMorePages = !!pageToken;
            // Enhanced logging with date range and progress info
            const dateRangeStr = earliestTimestamp && latestTimestamp
                ? `${earliestTimestamp.toLocaleDateString('en-US', { timeZone: 'America/New_York' })} to ${latestTimestamp.toLocaleDateString('en-US', { timeZone: 'America/New_York' })}`
                : 'unknown range';
            log$k(`Page ${pageCount}: Fetched ${pageTradesCount.toLocaleString()} option trades (total: ${totalTradesCount.toLocaleString()}) for ${symbolsStr}, date range: ${dateRangeStr}${hasMorePages ? ', more pages available' : ', complete'}`, {
                type: 'info'
            });
            // Prevent infinite loops
            if (pageCount > 1000) {
                log$k(`Stopping options trades pagination after ${pageCount} pages to prevent infinite loop`, { type: 'warn' });
                break;
            }
        }
        // Final summary
        const symbolCounts = Object.entries(allTrades).map(([symbol, trades]) => `${symbol}: ${trades.length}`).join(', ');
        log$k(`Historical options trades fetch complete: ${totalTradesCount.toLocaleString()} total trades across ${pageCount} pages (${symbolCounts})`, {
            type: 'info'
        });
        return {
            trades: allTrades,
            next_page_token: undefined, // Always undefined since we fetch all pages
        };
    }
    /**
     * Get snapshots for option contract symbols
     * Provides latest trade, latest quote, and greeks for each contract symbol
     * @param params Options snapshots request parameters
     * @returns Snapshot data for each option contract symbol
     
     * @see https://docs.alpaca.markets/reference/optionsnapshots
     */
    async getOptionsSnapshot(params) {
        // Remove limit and page_token as they may not be supported by this endpoint
        const { limit, page_token, ...requestParams } = params;
        return this.makeRequest('/options/snapshots', 'GET', requestParams, 'v1beta1');
    }
    /**
     * Get condition codes for options trades or quotes
     * Returns the mapping between condition codes and their descriptions
     * @param tickType The type of tick data ('trade' or 'quote')
     * @returns Mapping of condition codes to descriptions
     
     * @see https://docs.alpaca.markets/reference/optionmetaconditions
     */
    async getOptionsConditionCodes(tickType) {
        return this.makeRequest(`/options/meta/conditions/${tickType}`, 'GET', undefined, 'v1beta1');
    }
    /**
     * Get exchange codes for options
     * Returns the mapping between option exchange codes and exchange names
     * @returns Mapping of exchange codes to exchange names
     
     * @see https://docs.alpaca.markets/reference/optionmetaexchanges
     */
    async getOptionsExchangeCodes() {
        return this.makeRequest('/options/meta/exchanges', 'GET', undefined, 'v1beta1');
    }
    /**
     * Analyzes an array of option bars and returns a summary string
     * @param bars Array of option bars to analyze
     * @returns A string summarizing the option price data
     */
    static analyzeOptionBars(bars) {
        if (!bars || bars.length === 0) {
            return 'No option price data available';
        }
        const firstBar = bars[0];
        const lastBar = bars[bars.length - 1];
        const priceChange = lastBar.c - firstBar.o;
        const percentChange = (priceChange / firstBar.o) * 100;
        const volumeChange = lastBar.v - firstBar.v;
        const percentVolumeChange = firstBar.v > 0 ? (volumeChange / firstBar.v) * 100 : 0;
        const high = Math.max(...bars.map((bar) => bar.h));
        const low = Math.min(...bars.map((bar) => bar.l));
        const totalVolume = bars.reduce((sum, bar) => sum + bar.v, 0);
        const avgVolume = totalVolume / bars.length;
        return (`Option Price: $${firstBar.o.toFixed(2)} -> $${lastBar.c.toFixed(2)} (${percentChange.toFixed(2)}%), ` +
            `Volume: ${firstBar.v.toLocaleString()} -> ${lastBar.v.toLocaleString()} (${percentVolumeChange.toFixed(2)}%), ` +
            `High: $${high.toFixed(2)}, Low: $${low.toFixed(2)}, ` +
            `Avg Volume: ${avgVolume.toLocaleString()}`);
    }
    /**
     * Formats option greeks for display
     * @param greeks Option greeks object
     * @returns Formatted string with greek values
     */
    static formatOptionGreeks(greeks) {
        if (!greeks) {
            return 'No greeks data available';
        }
        const parts = [];
        if (greeks.delta !== undefined)
            parts.push(`Delta: ${greeks.delta.toFixed(4)}`);
        if (greeks.gamma !== undefined)
            parts.push(`Gamma: ${greeks.gamma.toFixed(4)}`);
        if (greeks.theta !== undefined)
            parts.push(`Theta: ${greeks.theta.toFixed(4)}`);
        if (greeks.vega !== undefined)
            parts.push(`Vega: ${greeks.vega.toFixed(4)}`);
        if (greeks.rho !== undefined)
            parts.push(`Rho: ${greeks.rho.toFixed(4)}`);
        return parts.length > 0 ? parts.join(', ') : 'No greeks data available';
    }
    /**
     * Interprets condition codes using the provided condition codes mapping
     * @param conditionCodes Array of condition codes from trade or quote
     * @param conditionCodesMap Mapping of condition codes to descriptions
     * @returns Formatted string with condition descriptions
     */
    static interpretConditionCodes(conditionCodes, conditionCodesMap) {
        if (!conditionCodes || conditionCodes.length === 0) {
            return 'No conditions';
        }
        const descriptions = conditionCodes
            .map((code) => conditionCodesMap[code] || `Unknown (${code})`)
            .filter((desc) => desc !== undefined);
        return descriptions.length > 0 ? descriptions.join(', ') : 'No condition descriptions available';
    }
    /**
     * Gets the exchange name from exchange code using the provided exchange codes mapping
     * @param exchangeCode Exchange code from trade or quote
     * @param exchangeCodesMap Mapping of exchange codes to names
     * @returns Exchange name or formatted unknown exchange
     */
    static getExchangeName(exchangeCode, exchangeCodesMap) {
        return exchangeCodesMap[exchangeCode] || `Unknown Exchange (${exchangeCode})`;
    }
    /**
     * Fetches news articles from Alpaca API for a symbol, paginating through all results.
     * @param symbol The symbol to fetch news for (e.g., 'AAPL')
     * @param params Optional parameters: start, end, limit, sort, include_content
     * @returns Array of SimpleNews articles
     */
    async fetchNews(symbol, params) {
        const defaultParams = {
            start: new Date(Date.now() - 24 * 60 * 60 * 1000),
            end: new Date(),
            limit: 10,
            sort: 'desc',
            include_content: true,
        };
        const mergedParams = { ...defaultParams, ...params };
        let newsArticles = [];
        let pageToken = null;
        let hasMorePages = true;
        let fetchedCount = 0;
        const maxLimit = mergedParams.limit;
        // Utility to clean content
        function cleanContent(content) {
            if (!content)
                return undefined;
            // Remove excessive whitespace, newlines, and trim
            return content.replace(/\s+/g, ' ').trim();
        }
        while (hasMorePages) {
            const queryParams = new URLSearchParams({
                ...(mergedParams.start && { start: new Date(mergedParams.start).toISOString() }),
                ...(mergedParams.end && { end: new Date(mergedParams.end).toISOString() }),
                ...(symbol && { symbols: symbol }),
                ...(mergedParams.limit && { limit: Math.min(50, maxLimit - fetchedCount).toString() }),
                ...(mergedParams.sort && { sort: mergedParams.sort }),
                ...(mergedParams.include_content !== undefined ? { include_content: mergedParams.include_content.toString() } : {}),
                ...(pageToken && { page_token: pageToken }),
            });
            const url = `${this.v1beta1url}/news?${queryParams}`;
            log$k(`Fetching news from: ${url}`, { type: 'debug', symbol });
            const response = await fetch(url, {
                method: 'GET',
                headers: this.headers,
            });
            if (!response.ok) {
                const errorText = await response.text();
                log$k(`Alpaca news API error (${response.status}): ${errorText}`, { type: 'error', symbol });
                throw new Error(`Alpaca news API error (${response.status}): ${errorText}`);
            }
            const data = await response.json();
            if (!data.news || !Array.isArray(data.news)) {
                log$k(`No news data found in Alpaca response for ${symbol}`, { type: 'warn', symbol });
                break;
            }
            const transformedNews = data.news.map((article) => ({
                symbols: article.symbols,
                title: article.headline,
                summary: cleanContent(article.summary) ?? '',
                content: article.content ? cleanContent(article.content) : undefined,
                url: article.url,
                source: article.source,
                author: article.author,
                date: article.updated_at || article.created_at,
                updatedDate: article.updated_at || article.created_at,
                sentiment: 0,
            }));
            newsArticles = newsArticles.concat(transformedNews);
            fetchedCount = newsArticles.length;
            pageToken = data.next_page_token || null;
            hasMorePages = !!pageToken && (!maxLimit || fetchedCount < maxLimit);
            log$k(`Fetched ${transformedNews.length} news articles (total: ${fetchedCount}) for ${symbol}. More pages: ${hasMorePages}`, { type: 'debug', symbol });
            if (maxLimit && fetchedCount >= maxLimit) {
                newsArticles = newsArticles.slice(0, maxLimit);
                break;
            }
        }
        return newsArticles;
    }
}
// Export the singleton instance
const marketDataAPI = AlpacaMarketDataAPI.getInstance();

const limitPriceSlippagePercent100 = 0.1; // 0.1%
/**
Websocket example
  const alpacaAPI = createAlpacaTradingAPI(credentials); // type AlpacaCredentials
  alpacaAPI.onTradeUpdate((update: TradeUpdate) => {
   this.log(`Received trade update: event ${update.event} for an order to ${update.order.side} ${update.order.qty} of ${update.order.symbol}`);
  });
  alpacaAPI.connectWebsocket(); // necessary to connect to the WebSocket
*/
class AlpacaTradingAPI {
    static new(credentials) {
        return new AlpacaTradingAPI(credentials);
    }
    static getInstance(credentials) {
        return new AlpacaTradingAPI(credentials);
    }
    ws = null;
    headers;
    tradeUpdateCallback = null;
    credentials;
    apiBaseUrl;
    wsUrl;
    authenticated = false;
    connecting = false;
    reconnectDelay = 10000; // 10 seconds between reconnection attempts
    reconnectTimeout = null;
    messageHandlers = new Map();
    debugLogging = false;
    /**
     * Constructor for AlpacaTradingAPI
     * @param credentials - Alpaca credentials,
     *   accountName: string; // The account identifier used inthis.logs and tracking
     *   apiKey: string; // Alpaca API key
     *   apiSecret: string; // Alpaca API secret
     *   type: AlpacaAccountType;
     *   orderType: AlpacaOrderType;
     * @param options - Optional options
     *   debugLogging: boolean; // Whether to log messages of type 'debug'
     */
    constructor(credentials, options) {
        this.credentials = credentials;
        // Set URLs based on account type
        this.apiBaseUrl =
            credentials.type === 'PAPER' ? 'https://paper-api.alpaca.markets/v2' : 'https://api.alpaca.markets/v2';
        this.wsUrl =
            credentials.type === 'PAPER' ? 'wss://paper-api.alpaca.markets/stream' : 'wss://api.alpaca.markets/stream';
        this.headers = {
            'APCA-API-KEY-ID': credentials.apiKey,
            'APCA-API-SECRET-KEY': credentials.apiSecret,
            'Content-Type': 'application/json',
        };
        // Initialize message handlers
        this.messageHandlers.set('authorization', this.handleAuthMessage.bind(this));
        this.messageHandlers.set('listening', this.handleListenMessage.bind(this));
        this.messageHandlers.set('trade_updates', this.handleTradeUpdate.bind(this));
        this.debugLogging = options?.debugLogging || false;
    }
    log(message, options = { type: 'info' }) {
        if (this.debugLogging && options.type === 'debug') {
            return;
        }
        log$l(message, { ...options, source: 'AlpacaTradingAPI', account: this.credentials.accountName });
    }
    /**
     * Round a price to the nearest 2 decimal places for Alpaca, or 4 decimal places for prices less than $1
     * @param price - The price to round
     * @returns The rounded price
     */
    roundPriceForAlpaca = (price) => {
        return price >= 1 ? Math.round(price * 100) / 100 : Math.round(price * 10000) / 10000;
    };
    handleAuthMessage(data) {
        if (data.status === 'authorized') {
            this.authenticated = true;
            this.log('WebSocket authenticated');
        }
        else {
            this.log(`Authentication failed: ${data.message || 'Unknown error'}`, {
                type: 'error',
            });
        }
    }
    handleListenMessage(data) {
        if (data.streams?.includes('trade_updates')) {
            this.log('Successfully subscribed to trade updates');
        }
    }
    handleTradeUpdate(data) {
        if (this.tradeUpdateCallback) {
            this.log(`Trade update: ${data.event} to ${data.order.side} ${data.order.qty} shares, type ${data.order.type}`, {
                symbol: data.order.symbol,
                type: 'debug',
            });
            this.tradeUpdateCallback(data);
        }
    }
    handleMessage(message) {
        try {
            const data = JSON.parse(message);
            const handler = this.messageHandlers.get(data.stream);
            if (handler) {
                handler(data.data);
            }
            else {
                this.log(`Received message for unknown stream: ${data.stream}`, {
                    type: 'warn',
                });
            }
        }
        catch (error) {
            this.log('Failed to parse WebSocket message', {
                type: 'error',
                metadata: { error: error instanceof Error ? error.message : 'Unknown error' },
            });
        }
    }
    connectWebsocket() {
        if (this.connecting) {
            this.log('Connection attempt skipped - already connecting');
            return;
        }
        if (this.ws?.readyState === WebSocket.OPEN) {
            this.log('Connection attempt skipped - already connected');
            return;
        }
        this.connecting = true;
        if (this.ws) {
            this.ws.removeAllListeners();
            this.ws.terminate();
            this.ws = null;
        }
        this.log(`Connecting to WebSocket at ${this.wsUrl}...`);
        this.ws = new WebSocket(this.wsUrl);
        this.ws.on('open', async () => {
            try {
                this.log('WebSocket connected');
                await this.authenticate();
                await this.subscribeToTradeUpdates();
                this.connecting = false;
            }
            catch (error) {
                this.log('Failed to setup WebSocket connection', {
                    type: 'error',
                    metadata: { error: error instanceof Error ? error.message : 'Unknown error' },
                });
                this.ws?.close();
            }
        });
        this.ws.on('message', (data) => {
            this.handleMessage(data.toString());
        });
        this.ws.on('error', (error) => {
            this.log('WebSocket error', {
                type: 'error',
                metadata: { error: error instanceof Error ? error.message : 'Unknown error' },
            });
            this.connecting = false;
        });
        this.ws.on('close', () => {
            this.log('WebSocket connection closed');
            this.authenticated = false;
            this.connecting = false;
            // Clear any existing reconnect timeout
            if (this.reconnectTimeout) {
                clearTimeout(this.reconnectTimeout);
                this.reconnectTimeout = null;
            }
            // Schedule reconnection
            this.reconnectTimeout = setTimeout(() => {
                this.log('Attempting to reconnect...');
                this.connectWebsocket();
            }, this.reconnectDelay);
        });
    }
    async authenticate() {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            throw new Error('WebSocket not ready for authentication');
        }
        const authMessage = {
            action: 'auth',
            key: this.credentials.apiKey,
            secret: this.credentials.apiSecret,
        };
        this.ws.send(JSON.stringify(authMessage));
        return new Promise((resolve, reject) => {
            const authTimeout = setTimeout(() => {
                this.log('Authentication timeout', { type: 'error' });
                reject(new Error('Authentication timed out'));
            }, 10000);
            const handleAuthResponse = (data) => {
                try {
                    const message = JSON.parse(data.toString());
                    if (message.stream === 'authorization') {
                        this.ws?.removeListener('message', handleAuthResponse);
                        clearTimeout(authTimeout);
                        if (message.data?.status === 'authorized') {
                            this.authenticated = true;
                            this.log('WebSocket authenticated');
                            resolve();
                        }
                        else {
                            const error = `Authentication failed: ${message.data?.message || 'Unknown error'}`;
                            this.log(error, { type: 'error' });
                            reject(new Error(error));
                        }
                    }
                }
                catch (error) {
                    this.log('Failed to parse auth response', {
                        type: 'error',
                        metadata: { error: error instanceof Error ? error.message : 'Unknown error' },
                    });
                }
            };
            this.ws?.on('message', handleAuthResponse);
        });
    }
    async subscribeToTradeUpdates() {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN || !this.authenticated) {
            throw new Error('WebSocket not ready for subscription');
        }
        const listenMessage = {
            action: 'listen',
            data: {
                streams: ['trade_updates'],
            },
        };
        this.ws.send(JSON.stringify(listenMessage));
        return new Promise((resolve, reject) => {
            const listenTimeout = setTimeout(() => {
                reject(new Error('Subscribe timeout'));
            }, 10000);
            const handleListenResponse = (data) => {
                try {
                    const message = JSON.parse(data.toString());
                    if (message.stream === 'listening') {
                        this.ws?.removeListener('message', handleListenResponse);
                        clearTimeout(listenTimeout);
                        if (message.data?.streams?.includes('trade_updates')) {
                            this.log('Subscribed to trade updates');
                            resolve();
                        }
                        else {
                            reject(new Error('Failed to subscribe to trade updates'));
                        }
                    }
                }
                catch (error) {
                    this.log('Failed to parse listen response', {
                        type: 'error',
                        metadata: { error: error instanceof Error ? error.message : 'Unknown error' },
                    });
                }
            };
            this.ws?.on('message', handleListenResponse);
        });
    }
    async makeRequest(endpoint, method = 'GET', body, queryString = '') {
        const url = `${this.apiBaseUrl}${endpoint}${queryString}`;
        try {
            const response = await fetch(url, {
                method,
                headers: this.headers,
                body: body ? JSON.stringify(body) : undefined,
            });
            if (!response.ok) {
                const errorText = await response.text();
                this.log(`Alpaca API error (${response.status}): ${errorText}`, { type: 'error' });
                throw new Error(`Alpaca API error (${response.status}): ${errorText}`);
            }
            // Handle responses with no content (e.g., 204 No Content)
            if (response.status === 204 || response.headers.get('content-length') === '0') {
                return null;
            }
            const contentType = response.headers.get('content-type');
            if (contentType && contentType.includes('application/json')) {
                return await response.json();
            }
            // For non-JSON responses, return the text content
            const textContent = await response.text();
            return textContent || null;
        }
        catch (err) {
            const error = err;
            this.log(`Error in makeRequest: ${error.message}. Url: ${url}`, {
                source: 'AlpacaAPI',
                type: 'error',
            });
            throw error;
        }
    }
    async getPositions(assetClass) {
        const positions = (await this.makeRequest('/positions'));
        if (assetClass) {
            return positions.filter((position) => position.asset_class === assetClass);
        }
        return positions;
    }
    /**
     * Get all orders
     * @param params (GetOrdersParams) - optional parameters to filter the orders
     * - status: 'open' | 'closed' | 'all'
     * - limit: number
     * - after: string
     * - until: string
     * - direction: 'asc' | 'desc'
     * - nested: boolean
     * - symbols: string[], an array of all the symbols
     * - side: 'buy' | 'sell'
     * @returns all orders
     */
    async getOrders(params = {}) {
        const queryParams = new URLSearchParams();
        if (params.status)
            queryParams.append('status', params.status);
        if (params.limit)
            queryParams.append('limit', params.limit.toString());
        if (params.after)
            queryParams.append('after', params.after);
        if (params.until)
            queryParams.append('until', params.until);
        if (params.direction)
            queryParams.append('direction', params.direction);
        if (params.nested)
            queryParams.append('nested', params.nested.toString());
        if (params.symbols)
            queryParams.append('symbols', params.symbols.join(','));
        if (params.side)
            queryParams.append('side', params.side);
        const endpoint = `/orders${queryParams.toString() ? `?${queryParams.toString()}` : ''}`;
        try {
            return await this.makeRequest(endpoint);
        }
        catch (error) {
            this.log(`Error getting orders: ${error}`, { type: 'error' });
            throw error;
        }
    }
    async getAccountDetails() {
        try {
            return await this.makeRequest('/account');
        }
        catch (error) {
            this.log(`Error getting account details: ${error}`, { type: 'error' });
            throw error;
        }
    }
    /**
     * Create a trailing stop order
     * @param symbol (string) - the symbol of the order
     * @param qty (number) - the quantity of the order
     * @param side (string) - the side of the order
     * @param trailPercent100 (number) - the trail percent of the order (scale 100, i.e. 0.5 = 0.5%)
     * @param position_intent (string) - the position intent of the order
     */
    async createTrailingStop(symbol, qty, side, trailPercent100, position_intent) {
        this.log(`Creating trailing stop ${side.toUpperCase()} ${qty} shares for ${symbol} with trail percent ${trailPercent100}%`, {
            symbol,
        });
        try {
            await this.makeRequest(`/orders`, 'POST', {
                symbol,
                qty: Math.abs(qty),
                side,
                position_intent,
                order_class: 'simple',
                type: 'trailing_stop',
                trail_percent: trailPercent100, // Already in decimal form (e.g., 4 for 4%)
                time_in_force: 'gtc',
            });
        }
        catch (error) {
            this.log(`Error creating trailing stop: ${error}`, {
                symbol,
                type: 'error',
            });
            throw error;
        }
    }
    /**
     * Create a market order
     * @param symbol (string) - the symbol of the order
     * @param qty (number) - the quantity of the order
     * @param side (string) - the side of the order
     * @param position_intent (string) - the position intent of the order. Important for knowing if a position needs a trailing stop.
     */
    async createMarketOrder(symbol, qty, side, position_intent, client_order_id) {
        this.log(`Creating market order for ${symbol}: ${side} ${qty} shares (${position_intent})`, {
            symbol,
        });
        const body = {
            symbol,
            qty: Math.abs(qty).toString(),
            side,
            position_intent,
            type: 'market',
            time_in_force: 'day',
            order_class: 'simple',
        };
        if (client_order_id !== undefined) {
            body.client_order_id = client_order_id;
        }
        try {
            return await this.makeRequest('/orders', 'POST', body);
        }
        catch (error) {
            this.log(`Error creating market order: ${error}`, { type: 'error' });
            throw error;
        }
    }
    /**
     * Get the current trail percent for a symbol, assuming that it has an open position and a trailing stop order to close it. Because this relies on an orders request for one symbol, you can't do it too often.
     * @param symbol (string) - the symbol of the order
     * @returns the current trail percent
     */
    async getCurrentTrailPercent(symbol) {
        try {
            const orders = await this.getOrders({
                status: 'open',
                symbols: [symbol],
            });
            const trailingStopOrder = orders.find((order) => order.type === 'trailing_stop' &&
                (order.position_intent === 'sell_to_close' || order.position_intent === 'buy_to_close'));
            if (!trailingStopOrder) {
                this.log(`No closing trailing stop order found for ${symbol}`, {
                    symbol,
                });
                return null;
            }
            if (!trailingStopOrder.trail_percent) {
                this.log(`Trailing stop order found for ${symbol} but no trail_percent value`, {
                    symbol,
                });
                return null;
            }
            const trailPercent = parseFloat(trailingStopOrder.trail_percent);
            return trailPercent;
        }
        catch (error) {
            this.log(`Error getting current trail percent: ${error}`, {
                symbol,
                type: 'error',
            });
            throw error;
        }
    }
    /**
     * Update the trail percent for a trailing stop order
     * @param symbol (string) - the symbol of the order
     * @param trailPercent100 (number) - the trail percent of the order (scale 100, i.e. 0.5 = 0.5%)
     */
    async updateTrailingStop(symbol, trailPercent100) {
        // First get all open orders for this symbol
        const orders = await this.getOrders({
            status: 'open',
            symbols: [symbol],
        });
        // Find the trailing stop order
        const trailingStopOrder = orders.find((order) => order.type === 'trailing_stop');
        if (!trailingStopOrder) {
            this.log(`No open trailing stop order found for ${symbol}`, { type: 'error', symbol });
            return;
        }
        // Check if the trail_percent is already set to the desired value
        const currentTrailPercent = trailingStopOrder.trail_percent ? parseFloat(trailingStopOrder.trail_percent) : null;
        // Compare with a small epsilon to handle floating point precision
        const epsilon = 0.0001;
        if (currentTrailPercent !== null && Math.abs(currentTrailPercent - trailPercent100) < epsilon) {
            this.log(`Trailing stop for ${symbol} already set to ${trailPercent100}% (current: ${currentTrailPercent}%), skipping update`, {
                symbol,
            });
            return;
        }
        this.log(`Updating trailing stop for ${symbol} from ${currentTrailPercent}% to ${trailPercent100}%`, {
            symbol,
        });
        try {
            await this.makeRequest(`/orders/${trailingStopOrder.id}`, 'PATCH', {
                trail: trailPercent100.toString(), // Changed from trail_percent to trail
            });
        }
        catch (error) {
            this.log(`Error updating trailing stop: ${error}`, {
                symbol,
                type: 'error',
            });
            throw error;
        }
    }
    /**
     * Cancel all open orders
     */
    async cancelAllOrders() {
        this.log(`Canceling all open orders`);
        try {
            await this.makeRequest('/orders', 'DELETE');
        }
        catch (error) {
            this.log(`Error canceling all orders: ${error}`, { type: 'error' });
        }
    }
    /**
     * Cancel a specific order by its ID
     * @param orderId The id of the order to cancel
     * @throws Error if the order is not cancelable (status 422) or if the order doesn't exist
     * @returns Promise that resolves when the order is successfully canceled
     */
    async cancelOrder(orderId) {
        this.log(`Attempting to cancel order ${orderId}`);
        try {
            await this.makeRequest(`/orders/${orderId}`, 'DELETE');
            this.log(`Successfully canceled order ${orderId}`);
        }
        catch (error) {
            // If the error is a 422, it means the order is not cancelable
            if (error instanceof Error && error.message.includes('422')) {
                this.log(`Order ${orderId} is not cancelable`, {
                    type: 'error',
                });
                throw new Error(`Order ${orderId} is not cancelable`);
            }
            // Re-throw other errors
            throw error;
        }
    }
    /**
     * Create a limit order
     * @param symbol (string) - the symbol of the order
     * @param qty (number) - the quantity of the order
     * @param side (string) - the side of the order
     * @param limitPrice (number) - the limit price of the order
     * @param position_intent (string) - the position intent of the order
     * @param extended_hours (boolean) - whether the order is in extended hours
     * @param client_order_id (string) - the client order id of the order
     */
    async createLimitOrder(symbol, qty, side, limitPrice, position_intent, extended_hours = false, client_order_id) {
        this.log(`Creating limit order for ${symbol}: ${side} ${qty} shares at $${limitPrice.toFixed(2)} (${position_intent})`, {
            symbol,
        });
        const body = {
            symbol,
            qty: Math.abs(qty).toString(),
            side,
            position_intent,
            type: 'limit',
            limit_price: this.roundPriceForAlpaca(limitPrice).toString(),
            time_in_force: 'day',
            order_class: 'simple',
            extended_hours,
        };
        if (client_order_id !== undefined) {
            body.client_order_id = client_order_id;
        }
        try {
            return await this.makeRequest('/orders', 'POST', body);
        }
        catch (error) {
            this.log(`Error creating limit order: ${error}`, { type: 'error' });
            throw error;
        }
    }
    /**
     * Close all equities positions
     * @param options (object) - the options for closing the positions
     * - cancel_orders (boolean) - whether to cancel related orders
     * - useLimitOrders (boolean) - whether to use limit orders to close the positions
     */
    async closeAllPositions(options = { cancel_orders: true, useLimitOrders: false }) {
        this.log(`Closing all positions${options.useLimitOrders ? ' using limit orders' : ''}${options.cancel_orders ? ' and canceling open orders' : ''}`);
        if (options.useLimitOrders) {
            // Get all positions
            const positions = await this.getPositions('us_equity');
            if (positions.length === 0) {
                this.log('No positions to close');
                return;
            }
            this.log(`Found ${positions.length} positions to close`);
            // Get latest quotes for all positions
            const symbols = positions.map((position) => position.symbol);
            const quotesResponse = await marketDataAPI.getLatestQuotes(symbols);
            const lengthOfQuotes = Object.keys(quotesResponse.quotes).length;
            if (lengthOfQuotes === 0) {
                this.log('No quotes available for positions, received 0 quotes', {
                    type: 'error',
                });
                return;
            }
            if (lengthOfQuotes !== positions.length) {
                this.log(`Received ${lengthOfQuotes} quotes for ${positions.length} positions, expected ${positions.length} quotes`, { type: 'warn' });
                return;
            }
            // Create limit orders to close each position
            for (const position of positions) {
                const quote = quotesResponse.quotes[position.symbol];
                if (!quote) {
                    this.log(`No quote available for ${position.symbol}, skipping limit order`, {
                        symbol: position.symbol,
                        type: 'warn',
                    });
                    continue;
                }
                const qty = Math.abs(parseFloat(position.qty));
                const side = position.side === 'long' ? 'sell' : 'buy';
                const positionIntent = side === 'sell' ? 'sell_to_close' : 'buy_to_close';
                // Get the current price from the quote
                const currentPrice = side === 'sell' ? quote.bp : quote.ap; // Use bid for sells, ask for buys
                if (!currentPrice) {
                    this.log(`No valid price available for ${position.symbol}, skipping limit order`, {
                        symbol: position.symbol,
                        type: 'warn',
                    });
                    continue;
                }
                // Apply slippage from config
                const limitSlippagePercent1 = limitPriceSlippagePercent100 / 100;
                const limitPrice = side === 'sell'
                    ? this.roundPriceForAlpaca(currentPrice * (1 - limitSlippagePercent1)) // Sell slightly lower
                    : this.roundPriceForAlpaca(currentPrice * (1 + limitSlippagePercent1)); // Buy slightly higher
                this.log(`Creating limit order to close ${position.symbol} position: ${side} ${qty} shares at $${limitPrice.toFixed(2)}`, {
                    symbol: position.symbol,
                });
                await this.createLimitOrder(position.symbol, qty, side, limitPrice, positionIntent);
            }
        }
        else {
            await this.makeRequest('/positions', 'DELETE', undefined, options.cancel_orders ? '?cancel_orders=true' : '');
        }
    }
    /**
     * Close all equities positions using limit orders during extended hours trading
     * @param cancelOrders Whether to cancel related orders (default: true)
     * @returns Promise that resolves when all positions are closed
     */
    async closeAllPositionsAfterHours() {
        this.log('Closing all positions using limit orders during extended hours trading');
        // Get all positions
        const positions = await this.getPositions();
        this.log(`Found ${positions.length} positions to close`);
        if (positions.length === 0) {
            this.log('No positions to close');
            return;
        }
        await this.cancelAllOrders();
        this.log(`Cancelled all open orders`);
        // Get latest quotes for all positions
        const symbols = positions.map((position) => position.symbol);
        const quotesResponse = await marketDataAPI.getLatestQuotes(symbols);
        // Create limit orders to close each position
        for (const position of positions) {
            const quote = quotesResponse.quotes[position.symbol];
            if (!quote) {
                this.log(`No quote available for ${position.symbol}, skipping limit order`, {
                    symbol: position.symbol,
                    type: 'warn',
                });
                continue;
            }
            const qty = Math.abs(parseFloat(position.qty));
            const side = position.side === 'long' ? 'sell' : 'buy';
            const positionIntent = side === 'sell' ? 'sell_to_close' : 'buy_to_close';
            // Get the current price from the quote
            const currentPrice = side === 'sell' ? quote.bp : quote.ap; // Use bid for sells, ask for buys
            if (!currentPrice) {
                this.log(`No valid price available for ${position.symbol}, skipping limit order`, {
                    symbol: position.symbol,
                    type: 'warn',
                });
                continue;
            }
            // Apply slippage from config
            const limitSlippagePercent1 = limitPriceSlippagePercent100 / 100;
            const limitPrice = side === 'sell'
                ? this.roundPriceForAlpaca(currentPrice * (1 - limitSlippagePercent1)) // Sell slightly lower
                : this.roundPriceForAlpaca(currentPrice * (1 + limitSlippagePercent1)); // Buy slightly higher
            this.log(`Creating extended hours limit order to close ${position.symbol} position: ${side} ${qty} shares at $${limitPrice.toFixed(2)}`, {
                symbol: position.symbol,
            });
            await this.createLimitOrder(position.symbol, qty, side, limitPrice, positionIntent, true // Enable extended hours trading
            );
        }
        this.log(`All positions closed: ${positions.map((p) => p.symbol).join(', ')}`);
    }
    onTradeUpdate(callback) {
        this.tradeUpdateCallback = callback;
    }
    /**
     * Get portfolio history for the account
     * @param params Parameters for the portfolio history request
     * @returns Portfolio history data
     */
    async getPortfolioHistory(params) {
        const queryParams = new URLSearchParams();
        if (params.timeframe)
            queryParams.append('timeframe', params.timeframe);
        if (params.period)
            queryParams.append('period', params.period);
        if (params.extended_hours !== undefined)
            queryParams.append('extended_hours', params.extended_hours.toString());
        if (params.date_end)
            queryParams.append('date_end', params.date_end);
        const response = await this.makeRequest(`/account/portfolio/history?${queryParams.toString()}`);
        return response;
    }
    /**
     * Get option contracts based on specified parameters
     * @param params Parameters to filter option contracts
     * @returns Option contracts matching the criteria
     */
    async getOptionContracts(params) {
        const queryParams = new URLSearchParams();
        queryParams.append('underlying_symbols', params.underlying_symbols.join(','));
        if (params.expiration_date_gte)
            queryParams.append('expiration_date_gte', params.expiration_date_gte);
        if (params.expiration_date_lte)
            queryParams.append('expiration_date_lte', params.expiration_date_lte);
        if (params.strike_price_gte)
            queryParams.append('strike_price_gte', params.strike_price_gte);
        if (params.strike_price_lte)
            queryParams.append('strike_price_lte', params.strike_price_lte);
        if (params.type)
            queryParams.append('type', params.type);
        if (params.status)
            queryParams.append('status', params.status);
        if (params.limit)
            queryParams.append('limit', params.limit.toString());
        if (params.page_token)
            queryParams.append('page_token', params.page_token);
        this.log(`Fetching option contracts for ${params.underlying_symbols.join(', ')}`, {
            symbol: params.underlying_symbols.join(', '),
        });
        const response = (await this.makeRequest(`/options/contracts?${queryParams.toString()}`));
        this.log(`Found ${response.option_contracts.length} option contracts`, {
            symbol: params.underlying_symbols.join(', '),
        });
        return response;
    }
    /**
     * Get a specific option contract by symbol or ID
     * @param symbolOrId The symbol or ID of the option contract
     * @returns The option contract details
     */
    async getOptionContract(symbolOrId) {
        this.log(`Fetching option contract details for ${symbolOrId}`, {
            symbol: symbolOrId,
        });
        const response = (await this.makeRequest(`/options/contracts/${symbolOrId}`));
        this.log(`Found option contract details for ${symbolOrId}: ${response.name}`, {
            symbol: symbolOrId,
        });
        return response;
    }
    /**
     * Create a simple option order (market or limit)
     * @param symbol Option contract symbol
     * @param qty Quantity of contracts (must be a whole number)
     * @param side Buy or sell
     * @param position_intent Position intent (buy_to_open, buy_to_close, sell_to_open, sell_to_close)
     * @param type Order type (market or limit)
     * @param limitPrice Limit price (required for limit orders)
     * @returns The created order
     */
    async createOptionOrder(symbol, qty, side, position_intent, type, limitPrice) {
        if (!Number.isInteger(qty) || qty <= 0) {
            this.log('Quantity must be a positive whole number for option orders', { type: 'error' });
        }
        if (type === 'limit' && limitPrice === undefined) {
            this.log('Limit price is required for limit orders', { type: 'error' });
        }
        this.log(`Creating ${type} option order for ${symbol}: ${side} ${qty} contracts (${position_intent})${type === 'limit' ? ` at $${limitPrice?.toFixed(2)}` : ''}`, {
            symbol,
        });
        const orderData = {
            symbol,
            qty: qty.toString(),
            side,
            position_intent,
            type,
            time_in_force: 'day',
            order_class: 'simple',
            extended_hours: false,
        };
        if (type === 'limit' && limitPrice !== undefined) {
            orderData.limit_price = this.roundPriceForAlpaca(limitPrice).toString();
        }
        return this.makeRequest('/orders', 'POST', orderData);
    }
    /**
     * Create a multi-leg option order
     * @param legs Array of order legs
     * @param qty Quantity of the multi-leg order (must be a whole number)
     * @param type Order type (market or limit)
     * @param limitPrice Limit price (required for limit orders)
     * @returns The created multi-leg order
     */
    async createMultiLegOptionOrder(legs, qty, type, limitPrice) {
        if (!Number.isInteger(qty) || qty <= 0) {
            this.log('Quantity must be a positive whole number for option orders', { type: 'error' });
        }
        if (type === 'limit' && limitPrice === undefined) {
            this.log('Limit price is required for limit orders', { type: 'error' });
        }
        if (legs.length < 2) {
            this.log('Multi-leg orders require at least 2 legs', { type: 'error' });
        }
        const legSymbols = legs.map((leg) => leg.symbol).join(', ');
        this.log(`Creating multi-leg ${type} option order with ${legs.length} legs (${legSymbols})${type === 'limit' ? ` at $${limitPrice?.toFixed(2)}` : ''}`, {
            symbol: legSymbols,
        });
        const orderData = {
            order_class: 'mleg',
            qty: qty.toString(),
            type,
            time_in_force: 'day',
            legs,
        };
        if (type === 'limit' && limitPrice !== undefined) {
            orderData.limit_price = this.roundPriceForAlpaca(limitPrice).toString();
        }
        return this.makeRequest('/orders', 'POST', orderData);
    }
    /**
     * Exercise an option contract
     * @param symbolOrContractId The symbol or ID of the option contract to exercise
     * @returns Response from the exercise request
     */
    async exerciseOption(symbolOrContractId) {
        this.log(`Exercising option contract ${symbolOrContractId}`, {
            symbol: symbolOrContractId,
        });
        return this.makeRequest(`/positions/${symbolOrContractId}/exercise`, 'POST');
    }
    /**
     * Get option positions
     * @returns Array of option positions
     */
    async getOptionPositions() {
        this.log('Fetching option positions');
        const positions = await this.getPositions('us_option');
        return positions;
    }
    async getOptionsOpenSpreadTrades() {
        this.log('Fetching option open trades');
        // this function will get all open positions, extract the symbol and see when they were created.
        // figures out when the earliest date was (should be today)
        // then it pulls all orders after the earliest date that were closed and that were of class 'mleg'
        // Each of these contains two orders. they look like this:
    }
    /**
     * Get option account activities (exercises, assignments, expirations)
     * @param activityType Type of option activity to filter by
     * @param date Date to filter activities (YYYY-MM-DD format)
     * @returns Array of option account activities
     */
    async getOptionActivities(activityType, date) {
        const queryParams = new URLSearchParams();
        if (activityType) {
            queryParams.append('activity_types', activityType);
        }
        else {
            queryParams.append('activity_types', 'OPEXC,OPASN,OPEXP');
        }
        if (date) {
            queryParams.append('date', date);
        }
        this.log(`Fetching option activities${activityType ? ` of type ${activityType}` : ''}${date ? ` for date ${date}` : ''}`);
        return this.makeRequest(`/account/activities?${queryParams.toString()}`);
    }
    /**
     * Create a long call spread (buy lower strike call, sell higher strike call)
     * @param lowerStrikeCallSymbol Symbol of the lower strike call option
     * @param higherStrikeCallSymbol Symbol of the higher strike call option
     * @param qty Quantity of spreads to create (must be a whole number)
     * @param limitPrice Limit price for the spread
     * @returns The created multi-leg order
     */
    async createLongCallSpread(lowerStrikeCallSymbol, higherStrikeCallSymbol, qty, limitPrice) {
        this.log(`Creating long call spread: Buy ${lowerStrikeCallSymbol}, Sell ${higherStrikeCallSymbol}, Qty: ${qty}, Price: $${limitPrice.toFixed(2)}`, {
            symbol: `${lowerStrikeCallSymbol},${higherStrikeCallSymbol}`,
        });
        const legs = [
            {
                symbol: lowerStrikeCallSymbol,
                ratio_qty: '1',
                side: 'buy',
                position_intent: 'buy_to_open',
            },
            {
                symbol: higherStrikeCallSymbol,
                ratio_qty: '1',
                side: 'sell',
                position_intent: 'sell_to_open',
            },
        ];
        return this.createMultiLegOptionOrder(legs, qty, 'limit', limitPrice);
    }
    /**
     * Create a long put spread (buy higher strike put, sell lower strike put)
     * @param higherStrikePutSymbol Symbol of the higher strike put option
     * @param lowerStrikePutSymbol Symbol of the lower strike put option
     * @param qty Quantity of spreads to create (must be a whole number)
     * @param limitPrice Limit price for the spread
     * @returns The created multi-leg order
     */
    async createLongPutSpread(higherStrikePutSymbol, lowerStrikePutSymbol, qty, limitPrice) {
        this.log(`Creating long put spread: Buy ${higherStrikePutSymbol}, Sell ${lowerStrikePutSymbol}, Qty: ${qty}, Price: $${limitPrice.toFixed(2)}`, {
            symbol: `${higherStrikePutSymbol},${lowerStrikePutSymbol}`,
        });
        const legs = [
            {
                symbol: higherStrikePutSymbol,
                ratio_qty: '1',
                side: 'buy',
                position_intent: 'buy_to_open',
            },
            {
                symbol: lowerStrikePutSymbol,
                ratio_qty: '1',
                side: 'sell',
                position_intent: 'sell_to_open',
            },
        ];
        return this.createMultiLegOptionOrder(legs, qty, 'limit', limitPrice);
    }
    /**
     * Create an iron condor (sell call spread and put spread)
     * @param longPutSymbol Symbol of the lower strike put (long)
     * @param shortPutSymbol Symbol of the higher strike put (short)
     * @param shortCallSymbol Symbol of the lower strike call (short)
     * @param longCallSymbol Symbol of the higher strike call (long)
     * @param qty Quantity of iron condors to create (must be a whole number)
     * @param limitPrice Limit price for the iron condor (credit)
     * @returns The created multi-leg order
     */
    async createIronCondor(longPutSymbol, shortPutSymbol, shortCallSymbol, longCallSymbol, qty, limitPrice) {
        this.log(`Creating iron condor with ${qty} contracts at $${limitPrice.toFixed(2)}`, {
            symbol: `${longPutSymbol},${shortPutSymbol},${shortCallSymbol},${longCallSymbol}`,
        });
        const legs = [
            {
                symbol: longPutSymbol,
                ratio_qty: '1',
                side: 'buy',
                position_intent: 'buy_to_open',
            },
            {
                symbol: shortPutSymbol,
                ratio_qty: '1',
                side: 'sell',
                position_intent: 'sell_to_open',
            },
            {
                symbol: shortCallSymbol,
                ratio_qty: '1',
                side: 'sell',
                position_intent: 'sell_to_open',
            },
            {
                symbol: longCallSymbol,
                ratio_qty: '1',
                side: 'buy',
                position_intent: 'buy_to_open',
            },
        ];
        try {
            return await this.createMultiLegOptionOrder(legs, qty, 'limit', limitPrice);
        }
        catch (error) {
            this.log(`Error creating iron condor: ${error}`, { type: 'error' });
            throw error;
        }
    }
    /**
     * Create a covered call (sell call option against owned stock)
     * @param stockSymbol Symbol of the underlying stock
     * @param callOptionSymbol Symbol of the call option to sell
     * @param qty Quantity of covered calls to create (must be a whole number)
     * @param limitPrice Limit price for the call option
     * @returns The created order
     */
    async createCoveredCall(stockSymbol, callOptionSymbol, qty, limitPrice) {
        this.log(`Creating covered call: Sell ${callOptionSymbol} against ${stockSymbol}, Qty: ${qty}, Price: $${limitPrice.toFixed(2)}`, {
            symbol: `${stockSymbol},${callOptionSymbol}`,
        });
        // For covered calls, we don't need to include the stock leg if we already own the shares
        // We just create a simple sell order for the call option
        try {
            return await this.createOptionOrder(callOptionSymbol, qty, 'sell', 'sell_to_open', 'limit', limitPrice);
        }
        catch (error) {
            this.log(`Error creating covered call: ${error}`, { type: 'error' });
            throw error;
        }
    }
    /**
     * Roll an option position to a new expiration or strike
     * @param currentOptionSymbol Symbol of the current option position
     * @param newOptionSymbol Symbol of the new option to roll to
     * @param qty Quantity of options to roll (must be a whole number)
     * @param currentPositionSide Side of the current position ('buy' or 'sell')
     * @param limitPrice Net limit price for the roll
     * @returns The created multi-leg order
     */
    async rollOptionPosition(currentOptionSymbol, newOptionSymbol, qty, currentPositionSide, limitPrice) {
        this.log(`Rolling ${qty} ${currentOptionSymbol} to ${newOptionSymbol} at net price $${limitPrice.toFixed(2)}`, {
            symbol: `${currentOptionSymbol},${newOptionSymbol}`,
        });
        // If current position is long, we need to sell to close and buy to open
        // If current position is short, we need to buy to close and sell to open
        const closePositionSide = currentPositionSide === 'buy' ? 'sell' : 'buy';
        const openPositionSide = currentPositionSide;
        const closePositionIntent = closePositionSide === 'buy' ? 'buy_to_close' : 'sell_to_close';
        const openPositionIntent = openPositionSide === 'buy' ? 'buy_to_open' : 'sell_to_open';
        const legs = [
            {
                symbol: currentOptionSymbol,
                ratio_qty: '1',
                side: closePositionSide,
                position_intent: closePositionIntent,
            },
            {
                symbol: newOptionSymbol,
                ratio_qty: '1',
                side: openPositionSide,
                position_intent: openPositionIntent,
            },
        ];
        try {
            return await this.createMultiLegOptionOrder(legs, qty, 'limit', limitPrice);
        }
        catch (error) {
            this.log(`Error rolling option position: ${error}`, { type: 'error' });
            throw error;
        }
    }
    /**
     * Get option chain for a specific underlying symbol and expiration date
     * @param underlyingSymbol The underlying stock symbol
     * @param expirationDate The expiration date (YYYY-MM-DD format)
     * @returns Option contracts for the specified symbol and expiration date
     */
    async getOptionChain(underlyingSymbol, expirationDate) {
        this.log(`Fetching option chain for ${underlyingSymbol} with expiration date ${expirationDate}`, {
            symbol: underlyingSymbol,
        });
        try {
            const params = {
                underlying_symbols: [underlyingSymbol],
                expiration_date_gte: expirationDate,
                expiration_date_lte: expirationDate,
                status: 'active',
                limit: 500, // Get a large number to ensure we get all strikes
            };
            const response = await this.getOptionContracts(params);
            return response.option_contracts || [];
        }
        catch (error) {
            this.log(`Failed to fetch option chain for ${underlyingSymbol}: ${error instanceof Error ? error.message : 'Unknown error'}`, {
                type: 'error',
                symbol: underlyingSymbol,
            });
            return [];
        }
    }
    /**
     * Get all available expiration dates for a specific underlying symbol
     * @param underlyingSymbol The underlying stock symbol
     * @returns Array of available expiration dates
     */
    async getOptionExpirationDates(underlyingSymbol) {
        this.log(`Fetching available expiration dates for ${underlyingSymbol}`, {
            symbol: underlyingSymbol,
        });
        try {
            const params = {
                underlying_symbols: [underlyingSymbol],
                status: 'active',
                limit: 1000, // Get a large number to ensure we get contracts with all expiration dates
            };
            const response = await this.getOptionContracts(params);
            // Extract unique expiration dates
            const expirationDates = new Set();
            if (response.option_contracts) {
                response.option_contracts.forEach((contract) => {
                    expirationDates.add(contract.expiration_date);
                });
            }
            // Convert to array and sort
            return Array.from(expirationDates).sort();
        }
        catch (error) {
            this.log(`Failed to fetch expiration dates for ${underlyingSymbol}: ${error instanceof Error ? error.message : 'Unknown error'}`, {
                type: 'error',
                symbol: underlyingSymbol,
            });
            return [];
        }
    }
    /**
     * Get the current options trading level for the account
     * @returns The options trading level (0-3)
     */
    async getOptionsTradingLevel() {
        this.log('Fetching options trading level');
        const accountDetails = await this.getAccountDetails();
        return accountDetails.options_trading_level || 0;
    }
    /**
     * Check if the account has options trading enabled
     * @returns Boolean indicating if options trading is enabled
     */
    async isOptionsEnabled() {
        this.log('Checking if options trading is enabled');
        const accountDetails = await this.getAccountDetails();
        // Check if options trading level is 2 or higher (Level 2+ allows buying calls/puts)
        // Level 0: Options disabled
        // Level 1: Only covered calls and cash-secured puts
        // Level 2+: Can buy calls and puts (required for executeOptionsOrder)
        const optionsLevel = accountDetails.options_trading_level || 0;
        const isEnabled = optionsLevel >= 2;
        this.log(`Options trading level: ${optionsLevel}, enabled: ${isEnabled}`);
        return isEnabled;
    }
    /**
     * Close all option positions
     * @param cancelOrders Whether to cancel related orders (default: true)
     * @returns Response from the close positions request
     */
    async closeAllOptionPositions(cancelOrders = true) {
        this.log(`Closing all option positions${cancelOrders ? ' and canceling related orders' : ''}`);
        const optionPositions = await this.getOptionPositions();
        if (optionPositions.length === 0) {
            this.log('No option positions to close');
            return;
        }
        // Create market orders to close each position
        for (const position of optionPositions) {
            const side = position.side === 'long' ? 'sell' : 'buy';
            const positionIntent = side === 'sell' ? 'sell_to_close' : 'buy_to_close';
            this.log(`Closing ${position.side} position of ${position.qty} contracts for ${position.symbol}`, {
                symbol: position.symbol,
            });
            await this.createOptionOrder(position.symbol, parseInt(position.qty), side, positionIntent, 'market');
        }
        if (cancelOrders) {
            // Get all open option orders
            const orders = await this.getOrders({ status: 'open' });
            const optionOrders = orders.filter((order) => order.asset_class === 'us_option');
            // Cancel each open option order
            for (const order of optionOrders) {
                this.log(`Canceling open order for ${order.symbol}`, {
                    symbol: order.symbol,
                });
                await this.makeRequest(`/orders/${order.id}`, 'DELETE');
            }
        }
    }
    /**
     * Close a specific option position
     * @param symbol The option contract symbol
     * @param qty Optional quantity to close (defaults to entire position)
     * @returns The created order
     */
    async closeOptionPosition(symbol, qty) {
        this.log(`Closing option position for ${symbol}${qty ? ` (${qty} contracts)` : ''}`, {
            symbol,
        });
        // Get the position details
        const positions = await this.getOptionPositions();
        const position = positions.find((p) => p.symbol === symbol);
        if (!position) {
            throw new Error(`No position found for option contract ${symbol}`);
        }
        const quantityToClose = qty || parseInt(position.qty);
        const side = position.side === 'long' ? 'sell' : 'buy';
        const positionIntent = side === 'sell' ? 'sell_to_close' : 'buy_to_close';
        try {
            return await this.createOptionOrder(symbol, quantityToClose, side, positionIntent, 'market');
        }
        catch (error) {
            this.log(`Error closing option position: ${error}`, { type: 'error' });
            throw error;
        }
    }
    /**
     * Create a complete equities trade with optional stop loss and take profit
     * @param params Trade parameters including symbol, qty, side, and optional referencePrice
     * @param options Trade options including order type, extended hours, stop loss, and take profit settings
     * @returns The created order
     */
    async createEquitiesTrade(params, options) {
        const { symbol, qty, side, referencePrice } = params;
        const { type = 'market', limitPrice, extendedHours = false, useStopLoss = false, stopPrice, stopPercent100, useTakeProfit = false, takeProfitPrice, takeProfitPercent100, clientOrderId, } = options || {};
        // Validation: Extended hours + market order is not allowed
        if (extendedHours && type === 'market') {
            this.log('Cannot create market order with extended hours enabled', {
                symbol,
                type: 'error',
            });
            throw new Error('Cannot create market order with extended hours enabled');
        }
        // Validation: Limit orders require limit price
        if (type === 'limit' && limitPrice === undefined) {
            this.log('Limit price is required for limit orders', {
                symbol,
                type: 'error',
            });
            throw new Error('Limit price is required for limit orders');
        }
        let calculatedStopPrice;
        let calculatedTakeProfitPrice;
        // Handle stop loss validation and calculation
        if (useStopLoss) {
            if (stopPrice === undefined && stopPercent100 === undefined) {
                this.log('Either stopPrice or stopPercent100 must be provided when useStopLoss is true', {
                    symbol,
                    type: 'error',
                });
                throw new Error('Either stopPrice or stopPercent100 must be provided when useStopLoss is true');
            }
            if (stopPercent100 !== undefined) {
                if (referencePrice === undefined) {
                    this.log('referencePrice is required when using stopPercent100', {
                        symbol,
                        type: 'error',
                    });
                    throw new Error('referencePrice is required when using stopPercent100');
                }
                // Calculate stop price based on percentage and side
                const stopPercentDecimal = stopPercent100 / 100;
                if (side === 'buy') {
                    // For buy orders, stop loss is below the reference price
                    calculatedStopPrice = referencePrice * (1 - stopPercentDecimal);
                }
                else {
                    // For sell orders, stop loss is above the reference price
                    calculatedStopPrice = referencePrice * (1 + stopPercentDecimal);
                }
            }
            else {
                calculatedStopPrice = stopPrice;
            }
        }
        // Handle take profit validation and calculation
        if (useTakeProfit) {
            if (takeProfitPrice === undefined && takeProfitPercent100 === undefined) {
                this.log('Either takeProfitPrice or takeProfitPercent100 must be provided when useTakeProfit is true', {
                    symbol,
                    type: 'error',
                });
                throw new Error('Either takeProfitPrice or takeProfitPercent100 must be provided when useTakeProfit is true');
            }
            if (takeProfitPercent100 !== undefined) {
                if (referencePrice === undefined) {
                    this.log('referencePrice is required when using takeProfitPercent100', {
                        symbol,
                        type: 'error',
                    });
                    throw new Error('referencePrice is required when using takeProfitPercent100');
                }
                // Calculate take profit price based on percentage and side
                const takeProfitPercentDecimal = takeProfitPercent100 / 100;
                if (side === 'buy') {
                    // For buy orders, take profit is above the reference price
                    calculatedTakeProfitPrice = referencePrice * (1 + takeProfitPercentDecimal);
                }
                else {
                    // For sell orders, take profit is below the reference price
                    calculatedTakeProfitPrice = referencePrice * (1 - takeProfitPercentDecimal);
                }
            }
            else {
                calculatedTakeProfitPrice = takeProfitPrice;
            }
        }
        // Determine order class based on what's enabled
        let orderClass = 'simple';
        if (useStopLoss && useTakeProfit) {
            orderClass = 'bracket';
        }
        else if (useStopLoss || useTakeProfit) {
            orderClass = 'oto';
        }
        // Build the order request
        const orderData = {
            symbol,
            qty: Math.abs(qty).toString(),
            side,
            type,
            time_in_force: 'day',
            order_class: orderClass,
            extended_hours: extendedHours,
            position_intent: side === 'buy' ? 'buy_to_open' : 'sell_to_open',
        };
        if (clientOrderId) {
            orderData.client_order_id = clientOrderId;
        }
        // Add limit price for limit orders
        if (type === 'limit' && limitPrice !== undefined) {
            orderData.limit_price = this.roundPriceForAlpaca(limitPrice).toString();
        }
        // Add stop loss if enabled
        if (useStopLoss && calculatedStopPrice !== undefined) {
            orderData.stop_loss = {
                stop_price: this.roundPriceForAlpaca(calculatedStopPrice).toString(),
            };
        }
        // Add take profit if enabled
        if (useTakeProfit && calculatedTakeProfitPrice !== undefined) {
            orderData.take_profit = {
                limit_price: this.roundPriceForAlpaca(calculatedTakeProfitPrice).toString(),
            };
        }
        const logMessage = `Creating ${orderClass} ${type} ${side} order for ${symbol}: ${qty} shares${type === 'limit' ? ` at $${limitPrice?.toFixed(2)}` : ''}${useStopLoss ? ` with stop loss at $${calculatedStopPrice?.toFixed(2)}` : ''}${useTakeProfit ? ` with take profit at $${calculatedTakeProfitPrice?.toFixed(2)}` : ''}${extendedHours ? ' (extended hours)' : ''}`;
        this.log(logMessage, {
            symbol,
        });
        try {
            return await this.makeRequest('/orders', 'POST', orderData);
        }
        catch (error) {
            this.log(`Error creating equities trade: ${error}`, {
                symbol,
                type: 'error',
            });
            throw error;
        }
    }
}

var dist$1 = {exports: {}};

var main = {};

/* @flow */

var hasRequiredMain;

function requireMain () {
	if (hasRequiredMain) return main;
	hasRequiredMain = 1;
	/*::

	type DotenvParseOptions = {
	  debug?: boolean
	}

	// keys and values from src
	type DotenvParseOutput = { [string]: string }

	type DotenvConfigOptions = {
	  path?: string, // path to .env file
	  encoding?: string, // encoding of .env file
	  debug?: string // turn on logging for debugging purposes
	}

	type DotenvConfigOutput = {
	  parsed?: DotenvParseOutput,
	  error?: Error
	}

	*/

	const fs = fs__default;
	const path = path__default;

	function log (message /*: string */) {
	  console.log(`[dotenv][DEBUG] ${message}`);
	}

	// Parses src into an Object
	function parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {
	  const debug = Boolean(options && options.debug);
	  const obj = {};

	  // convert Buffers before splitting into lines and processing
	  src.toString().split('\n').forEach(function (line, idx) {
	    // matching "KEY' and 'VAL' in 'KEY=VAL'
	    const keyValueArr = line.match(/^\s*([\w.-]+)\s*=\s*(.*)?\s*$/);
	    // matched?
	    if (keyValueArr != null) {
	      const key = keyValueArr[1];

	      // default undefined or missing values to empty string
	      let value = keyValueArr[2] || '';

	      // expand newlines in quoted values
	      const len = value ? value.length : 0;
	      if (len > 0 && value.charAt(0) === '"' && value.charAt(len - 1) === '"') {
	        value = value.replace(/\\n/gm, '\n');
	      }

	      // remove any surrounding quotes and extra spaces
	      value = value.replace(/(^['"]|['"]$)/g, '').trim();

	      obj[key] = value;
	    } else if (debug) {
	      log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
	    }
	  });

	  return obj
	}

	// Populates process.env from .env file
	function config (options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */ {
	  let dotenvPath = path.resolve(process.cwd(), '.env');
	  let encoding /*: string */ = 'utf8';
	  let debug = false;

	  if (options) {
	    if (options.path != null) {
	      dotenvPath = options.path;
	    }
	    if (options.encoding != null) {
	      encoding = options.encoding;
	    }
	    if (options.debug != null) {
	      debug = true;
	    }
	  }

	  try {
	    // specifying an encoding returns a string instead of a buffer
	    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug });

	    Object.keys(parsed).forEach(function (key) {
	      if (!process.env.hasOwnProperty(key)) {
	        process.env[key] = parsed[key];
	      } else if (debug) {
	        log(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
	      }
	    });

	    return { parsed }
	  } catch (e) {
	    return { error: e }
	  }
	}

	main.config = config;
	main.load = config;
	main.parse = parse;
	return main;
}

var axios$1 = {exports: {}};

var bind;
var hasRequiredBind;

function requireBind () {
	if (hasRequiredBind) return bind;
	hasRequiredBind = 1;

	bind = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};
	return bind;
}

var utils;
var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;

	var bind = requireBind();

	// utils is a library of generic helper functions non-specific to axios

	var toString = Object.prototype.toString;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}

	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}

	/**
	 * Determine if a value is a Buffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Buffer, otherwise false
	 */
	function isBuffer(val) {
	  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
	    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
	}

	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}

	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}

	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject(val) {
	  return val !== null && typeof val === 'object';
	}

	/**
	 * Determine if a value is a plain Object
	 *
	 * @param {Object} val The value to test
	 * @return {boolean} True if value is a plain Object, otherwise false
	 */
	function isPlainObject(val) {
	  if (toString.call(val) !== '[object Object]') {
	    return false;
	  }

	  var prototype = Object.getPrototypeOf(val);
	  return prototype === null || prototype === Object.prototype;
	}

	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}

	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}

	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	}

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 * nativescript
	 *  navigator.product -> 'NativeScript' or 'NS'
	 */
	function isStandardBrowserEnv() {
	  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
	                                           navigator.product === 'NativeScript' ||
	                                           navigator.product === 'NS')) {
	    return false;
	  }
	  return (
	    typeof window !== 'undefined' &&
	    typeof document !== 'undefined'
	  );
	}

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (isPlainObject(result[key]) && isPlainObject(val)) {
	      result[key] = merge(result[key], val);
	    } else if (isPlainObject(val)) {
	      result[key] = merge({}, val);
	    } else if (isArray(val)) {
	      result[key] = val.slice();
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}

	/**
	 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
	 *
	 * @param {string} content with BOM
	 * @return {string} content value without BOM
	 */
	function stripBOM(content) {
	  if (content.charCodeAt(0) === 0xFEFF) {
	    content = content.slice(1);
	  }
	  return content;
	}

	utils = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isBuffer: isBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isPlainObject: isPlainObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend,
	  trim: trim,
	  stripBOM: stripBOM
	};
	return utils;
}

var buildURL;
var hasRequiredBuildURL;

function requireBuildURL () {
	if (hasRequiredBuildURL) return buildURL;
	hasRequiredBuildURL = 1;

	var utils = requireUtils();

	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	buildURL = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }

	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];

	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }

	      if (utils.isArray(val)) {
	        key = key + '[]';
	      } else {
	        val = [val];
	      }

	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });

	    serializedParams = parts.join('&');
	  }

	  if (serializedParams) {
	    var hashmarkIndex = url.indexOf('#');
	    if (hashmarkIndex !== -1) {
	      url = url.slice(0, hashmarkIndex);
	    }

	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	};
	return buildURL;
}

var InterceptorManager_1;
var hasRequiredInterceptorManager;

function requireInterceptorManager () {
	if (hasRequiredInterceptorManager) return InterceptorManager_1;
	hasRequiredInterceptorManager = 1;

	var utils = requireUtils();

	function InterceptorManager() {
	  this.handlers = [];
	}

	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected,
	    synchronous: options ? options.synchronous : false,
	    runWhen: options ? options.runWhen : null
	  });
	  return this.handlers.length - 1;
	};

	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};

	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};

	InterceptorManager_1 = InterceptorManager;
	return InterceptorManager_1;
}

var normalizeHeaderName;
var hasRequiredNormalizeHeaderName;

function requireNormalizeHeaderName () {
	if (hasRequiredNormalizeHeaderName) return normalizeHeaderName;
	hasRequiredNormalizeHeaderName = 1;

	var utils = requireUtils();

	normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};
	return normalizeHeaderName;
}

var enhanceError;
var hasRequiredEnhanceError;

function requireEnhanceError () {
	if (hasRequiredEnhanceError) return enhanceError;
	hasRequiredEnhanceError = 1;

	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	enhanceError = function enhanceError(error, config, code, request, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }

	  error.request = request;
	  error.response = response;
	  error.isAxiosError = true;

	  error.toJSON = function toJSON() {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: this.config,
	      code: this.code
	    };
	  };
	  return error;
	};
	return enhanceError;
}

var createError;
var hasRequiredCreateError;

function requireCreateError () {
	if (hasRequiredCreateError) return createError;
	hasRequiredCreateError = 1;

	var enhanceError = requireEnhanceError();

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	createError = function createError(message, config, code, request, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, request, response);
	};
	return createError;
}

var settle;
var hasRequiredSettle;

function requireSettle () {
	if (hasRequiredSettle) return settle;
	hasRequiredSettle = 1;

	var createError = requireCreateError();

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	settle = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError(
	      'Request failed with status code ' + response.status,
	      response.config,
	      null,
	      response.request,
	      response
	    ));
	  }
	};
	return settle;
}

var cookies;
var hasRequiredCookies;

function requireCookies () {
	if (hasRequiredCookies) return cookies;
	hasRequiredCookies = 1;

	var utils = requireUtils();

	cookies = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs support document.cookie
	    (function standardBrowserEnv() {
	      return {
	        write: function write(name, value, expires, path, domain, secure) {
	          var cookie = [];
	          cookie.push(name + '=' + encodeURIComponent(value));

	          if (utils.isNumber(expires)) {
	            cookie.push('expires=' + new Date(expires).toGMTString());
	          }

	          if (utils.isString(path)) {
	            cookie.push('path=' + path);
	          }

	          if (utils.isString(domain)) {
	            cookie.push('domain=' + domain);
	          }

	          if (secure === true) {
	            cookie.push('secure');
	          }

	          document.cookie = cookie.join('; ');
	        },

	        read: function read(name) {
	          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	          return (match ? decodeURIComponent(match[3]) : null);
	        },

	        remove: function remove(name) {
	          this.write(name, '', Date.now() - 86400000);
	        }
	      };
	    })() :

	  // Non standard browser env (web workers, react-native) lack needed support.
	    (function nonStandardBrowserEnv() {
	      return {
	        write: function write() {},
	        read: function read() { return null; },
	        remove: function remove() {}
	      };
	    })()
	);
	return cookies;
}

var isAbsoluteURL;
var hasRequiredIsAbsoluteURL;

function requireIsAbsoluteURL () {
	if (hasRequiredIsAbsoluteURL) return isAbsoluteURL;
	hasRequiredIsAbsoluteURL = 1;

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	isAbsoluteURL = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
	};
	return isAbsoluteURL;
}

var combineURLs;
var hasRequiredCombineURLs;

function requireCombineURLs () {
	if (hasRequiredCombineURLs) return combineURLs;
	hasRequiredCombineURLs = 1;

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	combineURLs = function combineURLs(baseURL, relativeURL) {
	  return relativeURL
	    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
	    : baseURL;
	};
	return combineURLs;
}

var buildFullPath;
var hasRequiredBuildFullPath;

function requireBuildFullPath () {
	if (hasRequiredBuildFullPath) return buildFullPath;
	hasRequiredBuildFullPath = 1;

	var isAbsoluteURL = requireIsAbsoluteURL();
	var combineURLs = requireCombineURLs();

	/**
	 * Creates a new URL by combining the baseURL with the requestedURL,
	 * only when the requestedURL is not already an absolute URL.
	 * If the requestURL is absolute, this function returns the requestedURL untouched.
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} requestedURL Absolute or relative URL to combine
	 * @returns {string} The combined full path
	 */
	buildFullPath = function buildFullPath(baseURL, requestedURL) {
	  if (baseURL && !isAbsoluteURL(requestedURL)) {
	    return combineURLs(baseURL, requestedURL);
	  }
	  return requestedURL;
	};
	return buildFullPath;
}

var parseHeaders;
var hasRequiredParseHeaders;

function requireParseHeaders () {
	if (hasRequiredParseHeaders) return parseHeaders;
	hasRequiredParseHeaders = 1;

	var utils = requireUtils();

	// Headers whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	var ignoreDuplicateOf = [
	  'age', 'authorization', 'content-length', 'content-type', 'etag',
	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
	  'referer', 'retry-after', 'user-agent'
	];

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	parseHeaders = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;

	  if (!headers) { return parsed; }

	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));

	    if (key) {
	      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
	        return;
	      }
	      if (key === 'set-cookie') {
	        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
	      } else {
	        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	      }
	    }
	  });

	  return parsed;
	};
	return parseHeaders;
}

var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;

function requireIsURLSameOrigin () {
	if (hasRequiredIsURLSameOrigin) return isURLSameOrigin;
	hasRequiredIsURLSameOrigin = 1;

	var utils = requireUtils();

	isURLSameOrigin = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	    (function standardBrowserEnv() {
	      var msie = /(msie|trident)/i.test(navigator.userAgent);
	      var urlParsingNode = document.createElement('a');
	      var originURL;

	      /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	      function resolveURL(url) {
	        var href = url;

	        if (msie) {
	        // IE needs attribute set twice to normalize properties
	          urlParsingNode.setAttribute('href', href);
	          href = urlParsingNode.href;
	        }

	        urlParsingNode.setAttribute('href', href);

	        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	        return {
	          href: urlParsingNode.href,
	          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	          host: urlParsingNode.host,
	          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	          hostname: urlParsingNode.hostname,
	          port: urlParsingNode.port,
	          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	            urlParsingNode.pathname :
	            '/' + urlParsingNode.pathname
	        };
	      }

	      originURL = resolveURL(window.location.href);

	      /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	      return function isURLSameOrigin(requestURL) {
	        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	        return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	      };
	    })() :

	  // Non standard browser envs (web workers, react-native) lack needed support.
	    (function nonStandardBrowserEnv() {
	      return function isURLSameOrigin() {
	        return true;
	      };
	    })()
	);
	return isURLSameOrigin;
}

var xhr;
var hasRequiredXhr;

function requireXhr () {
	if (hasRequiredXhr) return xhr;
	hasRequiredXhr = 1;

	var utils = requireUtils();
	var settle = requireSettle();
	var cookies = requireCookies();
	var buildURL = requireBuildURL();
	var buildFullPath = requireBuildFullPath();
	var parseHeaders = requireParseHeaders();
	var isURLSameOrigin = requireIsURLSameOrigin();
	var createError = requireCreateError();

	xhr = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;
	    var responseType = config.responseType;

	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }

	    var request = new XMLHttpRequest();

	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }

	    var fullPath = buildFullPath(config.baseURL, config.url);
	    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

	    // Set the request timeout in MS
	    request.timeout = config.timeout;

	    function onloadend() {
	      if (!request) {
	        return;
	      }
	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
	        request.responseText : request.response;
	      var response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };

	      settle(resolve, reject, response);

	      // Clean up request
	      request = null;
	    }

	    if ('onloadend' in request) {
	      // Use onloadend if available
	      request.onloadend = onloadend;
	    } else {
	      // Listen for ready state to emulate onloadend
	      request.onreadystatechange = function handleLoad() {
	        if (!request || request.readyState !== 4) {
	          return;
	        }

	        // The request errored out and we didn't get a response, this will be
	        // handled by onerror instead
	        // With one exception: request that using file: protocol, most browsers
	        // will return status as 0 even though it's a successful request
	        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	          return;
	        }
	        // readystate handler is calling before onerror or ontimeout handlers,
	        // so we should call onloadend on the next 'tick'
	        setTimeout(onloadend);
	      };
	    }

	    // Handle browser request cancellation (as opposed to a manual cancellation)
	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }

	      reject(createError('Request aborted', config, 'ECONNABORTED', request));

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config, null, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
	      if (config.timeoutErrorMessage) {
	        timeoutErrorMessage = config.timeoutErrorMessage;
	      }
	      reject(createError(
	        timeoutErrorMessage,
	        config,
	        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
	        request));

	      // Clean up request
	      request = null;
	    };

	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
	        cookies.read(config.xsrfCookieName) :
	        undefined;

	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }

	    // Add withCredentials to request if needed
	    if (!utils.isUndefined(config.withCredentials)) {
	      request.withCredentials = !!config.withCredentials;
	    }

	    // Add responseType to request if needed
	    if (responseType && responseType !== 'json') {
	      request.responseType = config.responseType;
	    }

	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }

	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }

	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }

	        request.abort();
	        reject(cancel);
	        // Clean up request
	        request = null;
	      });
	    }

	    if (!requestData) {
	      requestData = null;
	    }

	    // Send the request
	    request.send(requestData);
	  });
	};
	return xhr;
}

var followRedirects = {exports: {}};

var src = {exports: {}};

var browser = {exports: {}};

var common;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */

	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = ms;
		createDebug.destroy = destroy;

		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});

		/**
		* The currently active debug mode names, and names to skip.
		*/

		createDebug.names = [];
		createDebug.skips = [];

		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};

		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;

			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}

			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;

		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;

			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}

				const self = debug;

				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;

				args[0] = createDebug.coerce(args[0]);

				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}

				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);

						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});

				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);

				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}

			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}

					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});

			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}

			return debug;
		}

		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}

		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;

			createDebug.names = [];
			createDebug.skips = [];

			const split = (typeof namespaces === 'string' ? namespaces : '')
				.trim()
				.replace(/\s+/g, ',')
				.split(',')
				.filter(Boolean);

			for (const ns of split) {
				if (ns[0] === '-') {
					createDebug.skips.push(ns.slice(1));
				} else {
					createDebug.names.push(ns);
				}
			}
		}

		/**
		 * Checks if the given string matches a namespace template, honoring
		 * asterisks as wildcards.
		 *
		 * @param {String} search
		 * @param {String} template
		 * @return {Boolean}
		 */
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;

			while (searchIndex < search.length) {
				if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
					// Match character or proceed with wildcard
					if (template[templateIndex] === '*') {
						starIndex = templateIndex;
						matchIndex = searchIndex;
						templateIndex++; // Skip the '*'
					} else {
						searchIndex++;
						templateIndex++;
					}
				} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
					// Backtrack to the last '*' and try to match more characters
					templateIndex = starIndex + 1;
					matchIndex++;
					searchIndex = matchIndex;
				} else {
					return false; // No match
				}
			}

			// Handle trailing '*' in template
			while (templateIndex < template.length && template[templateIndex] === '*') {
				templateIndex++;
			}

			return templateIndex === template.length;
		}

		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names,
				...createDebug.skips.map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}

		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			for (const skip of createDebug.skips) {
				if (matchesTemplate(name, skip)) {
					return false;
				}
			}

			for (const ns of createDebug.names) {
				if (matchesTemplate(name, ns)) {
					return true;
				}
			}

			return false;
		}

		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}

		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}

		createDebug.enable(createDebug.load());

		return createDebug;
	}

	common = setup;
	return common;
}

/* eslint-env browser */

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser.exports;
	hasRequiredBrowser = 1;
	(function (module, exports$1) {
		/**
		 * This is the web browser implementation of `debug()`.
		 */

		exports$1.formatArgs = formatArgs;
		exports$1.save = save;
		exports$1.load = load;
		exports$1.useColors = useColors;
		exports$1.storage = localstorage();
		exports$1.destroy = (() => {
			let warned = false;

			return () => {
				if (!warned) {
					warned = true;
					console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
				}
			};
		})();

		/**
		 * Colors.
		 */

		exports$1.colors = [
			'#0000CC',
			'#0000FF',
			'#0033CC',
			'#0033FF',
			'#0066CC',
			'#0066FF',
			'#0099CC',
			'#0099FF',
			'#00CC00',
			'#00CC33',
			'#00CC66',
			'#00CC99',
			'#00CCCC',
			'#00CCFF',
			'#3300CC',
			'#3300FF',
			'#3333CC',
			'#3333FF',
			'#3366CC',
			'#3366FF',
			'#3399CC',
			'#3399FF',
			'#33CC00',
			'#33CC33',
			'#33CC66',
			'#33CC99',
			'#33CCCC',
			'#33CCFF',
			'#6600CC',
			'#6600FF',
			'#6633CC',
			'#6633FF',
			'#66CC00',
			'#66CC33',
			'#9900CC',
			'#9900FF',
			'#9933CC',
			'#9933FF',
			'#99CC00',
			'#99CC33',
			'#CC0000',
			'#CC0033',
			'#CC0066',
			'#CC0099',
			'#CC00CC',
			'#CC00FF',
			'#CC3300',
			'#CC3333',
			'#CC3366',
			'#CC3399',
			'#CC33CC',
			'#CC33FF',
			'#CC6600',
			'#CC6633',
			'#CC9900',
			'#CC9933',
			'#CCCC00',
			'#CCCC33',
			'#FF0000',
			'#FF0033',
			'#FF0066',
			'#FF0099',
			'#FF00CC',
			'#FF00FF',
			'#FF3300',
			'#FF3333',
			'#FF3366',
			'#FF3399',
			'#FF33CC',
			'#FF33FF',
			'#FF6600',
			'#FF6633',
			'#FF9900',
			'#FF9933',
			'#FFCC00',
			'#FFCC33'
		];

		/**
		 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
		 * and the Firebug extension (any Firefox version) are known
		 * to support "%c" CSS customizations.
		 *
		 * TODO: add a `localStorage` variable to explicitly enable/disable colors
		 */

		// eslint-disable-next-line complexity
		function useColors() {
			// NB: In an Electron preload script, document will be defined but not fully
			// initialized. Since we know we're in Chrome, we'll just detect this case
			// explicitly
			if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
				return true;
			}

			// Internet Explorer and Edge do not support colors.
			if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
				return false;
			}

			let m;

			// Is webkit? http://stackoverflow.com/a/16459606/376773
			// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
			// eslint-disable-next-line no-return-assign
			return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
				// Is firebug? http://stackoverflow.com/a/398120/376773
				(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
				// Is firefox >= v31?
				// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
				(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
				// Double check webkit in userAgent just in case we are in a worker
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
		}

		/**
		 * Colorize log arguments if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			args[0] = (this.useColors ? '%c' : '') +
				this.namespace +
				(this.useColors ? ' %c' : ' ') +
				args[0] +
				(this.useColors ? '%c ' : ' ') +
				'+' + module.exports.humanize(this.diff);

			if (!this.useColors) {
				return;
			}

			const c = 'color: ' + this.color;
			args.splice(1, 0, c, 'color: inherit');

			// The final "%c" is somewhat tricky, because there could be other
			// arguments passed either before or after the %c, so we need to
			// figure out the correct index to insert the CSS into
			let index = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, match => {
				if (match === '%%') {
					return;
				}
				index++;
				if (match === '%c') {
					// We only are interested in the *last* %c
					// (the user may have provided their own)
					lastC = index;
				}
			});

			args.splice(lastC, 0, c);
		}

		/**
		 * Invokes `console.debug()` when available.
		 * No-op when `console.debug` is not a "function".
		 * If `console.debug` is not available, falls back
		 * to `console.log`.
		 *
		 * @api public
		 */
		exports$1.log = console.debug || console.log || (() => {});

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			try {
				if (namespaces) {
					exports$1.storage.setItem('debug', namespaces);
				} else {
					exports$1.storage.removeItem('debug');
				}
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */
		function load() {
			let r;
			try {
				r = exports$1.storage.getItem('debug') || exports$1.storage.getItem('DEBUG') ;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}

			// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
			if (!r && typeof process !== 'undefined' && 'env' in process) {
				r = process.env.DEBUG;
			}

			return r;
		}

		/**
		 * Localstorage attempts to return the localstorage.
		 *
		 * This is necessary because safari throws
		 * when a user disables cookies/localstorage
		 * and you attempt to access it.
		 *
		 * @return {LocalStorage}
		 * @api private
		 */

		function localstorage() {
			try {
				// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
				// The Browser also has localStorage in the global context.
				return localStorage;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		module.exports = requireCommon()(exports$1);

		const {formatters} = module.exports;

		/**
		 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		 */

		formatters.j = function (v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return '[UnexpectedJSONParseError]: ' + error.message;
			}
		}; 
	} (browser, browser.exports));
	return browser.exports;
}

var node$1 = {exports: {}};

var hasFlag;
var hasRequiredHasFlag;

function requireHasFlag () {
	if (hasRequiredHasFlag) return hasFlag;
	hasRequiredHasFlag = 1;

	hasFlag = (flag, argv = process.argv) => {
		const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf('--');
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
	return hasFlag;
}

var supportsColor_1;
var hasRequiredSupportsColor;

function requireSupportsColor () {
	if (hasRequiredSupportsColor) return supportsColor_1;
	hasRequiredSupportsColor = 1;
	const os = require$$0$4;
	const tty = require$$1$1;
	const hasFlag = requireHasFlag();

	const {env} = process;

	let forceColor;
	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false') ||
		hasFlag('color=never')) {
		forceColor = 0;
	} else if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		forceColor = 1;
	}

	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			forceColor = 1;
		} else if (env.FORCE_COLOR === 'false') {
			forceColor = 0;
		} else {
			forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
		}
	}

	function translateLevel(level) {
		if (level === 0) {
			return false;
		}

		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}

	function supportsColor(haveStream, streamIsTTY) {
		if (forceColor === 0) {
			return 0;
		}

		if (hasFlag('color=16m') ||
			hasFlag('color=full') ||
			hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}

		if (haveStream && !streamIsTTY && forceColor === undefined) {
			return 0;
		}

		const min = forceColor || 0;

		if (env.TERM === 'dumb') {
			return min;
		}

		if (process.platform === 'win32') {
			// Windows 10 build 10586 is the first Windows release that supports 256 colors.
			// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
			const osRelease = os.release().split('.');
			if (
				Number(osRelease[0]) >= 10 &&
				Number(osRelease[2]) >= 10586
			) {
				return Number(osRelease[2]) >= 14931 ? 3 : 2;
			}

			return 1;
		}

		if ('CI' in env) {
			if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
				return 1;
			}

			return min;
		}

		if ('TEAMCITY_VERSION' in env) {
			return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		}

		if (env.COLORTERM === 'truecolor') {
			return 3;
		}

		if ('TERM_PROGRAM' in env) {
			const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

			switch (env.TERM_PROGRAM) {
				case 'iTerm.app':
					return version >= 3 ? 3 : 2;
				case 'Apple_Terminal':
					return 2;
				// No default
			}
		}

		if (/-256(color)?$/i.test(env.TERM)) {
			return 2;
		}

		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
			return 1;
		}

		if ('COLORTERM' in env) {
			return 1;
		}

		return min;
	}

	function getSupportLevel(stream) {
		const level = supportsColor(stream, stream && stream.isTTY);
		return translateLevel(level);
	}

	supportsColor_1 = {
		supportsColor: getSupportLevel,
		stdout: translateLevel(supportsColor(true, tty.isatty(1))),
		stderr: translateLevel(supportsColor(true, tty.isatty(2)))
	};
	return supportsColor_1;
}

/**
 * Module dependencies.
 */

var hasRequiredNode$1;

function requireNode$1 () {
	if (hasRequiredNode$1) return node$1.exports;
	hasRequiredNode$1 = 1;
	(function (module, exports$1) {
		const tty = require$$1$1;
		const util = require$$1$2;

		/**
		 * This is the Node.js implementation of `debug()`.
		 */

		exports$1.init = init;
		exports$1.log = log;
		exports$1.formatArgs = formatArgs;
		exports$1.save = save;
		exports$1.load = load;
		exports$1.useColors = useColors;
		exports$1.destroy = util.deprecate(
			() => {},
			'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
		);

		/**
		 * Colors.
		 */

		exports$1.colors = [6, 2, 3, 4, 5, 1];

		try {
			// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
			// eslint-disable-next-line import/no-extraneous-dependencies
			const supportsColor = requireSupportsColor();

			if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
				exports$1.colors = [
					20,
					21,
					26,
					27,
					32,
					33,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					56,
					57,
					62,
					63,
					68,
					69,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					92,
					93,
					98,
					99,
					112,
					113,
					128,
					129,
					134,
					135,
					148,
					149,
					160,
					161,
					162,
					163,
					164,
					165,
					166,
					167,
					168,
					169,
					170,
					171,
					172,
					173,
					178,
					179,
					184,
					185,
					196,
					197,
					198,
					199,
					200,
					201,
					202,
					203,
					204,
					205,
					206,
					207,
					208,
					209,
					214,
					215,
					220,
					221
				];
			}
		} catch (error) {
			// Swallow - we only care if `supports-color` is available; it doesn't have to be.
		}

		/**
		 * Build up the default `inspectOpts` object from the environment variables.
		 *
		 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
		 */

		exports$1.inspectOpts = Object.keys(process.env).filter(key => {
			return /^debug_/i.test(key);
		}).reduce((obj, key) => {
			// Camel-case
			const prop = key
				.substring(6)
				.toLowerCase()
				.replace(/_([a-z])/g, (_, k) => {
					return k.toUpperCase();
				});

			// Coerce string value into JS value
			let val = process.env[key];
			if (/^(yes|on|true|enabled)$/i.test(val)) {
				val = true;
			} else if (/^(no|off|false|disabled)$/i.test(val)) {
				val = false;
			} else if (val === 'null') {
				val = null;
			} else {
				val = Number(val);
			}

			obj[prop] = val;
			return obj;
		}, {});

		/**
		 * Is stdout a TTY? Colored output is enabled when `true`.
		 */

		function useColors() {
			return 'colors' in exports$1.inspectOpts ?
				Boolean(exports$1.inspectOpts.colors) :
				tty.isatty(process.stderr.fd);
		}

		/**
		 * Adds ANSI color escape codes if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			const {namespace: name, useColors} = this;

			if (useColors) {
				const c = this.color;
				const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
				const prefix = `  ${colorCode};1m${name} \u001B[0m`;

				args[0] = prefix + args[0].split('\n').join('\n' + prefix);
				args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
			} else {
				args[0] = getDate() + name + ' ' + args[0];
			}
		}

		function getDate() {
			if (exports$1.inspectOpts.hideDate) {
				return '';
			}
			return new Date().toISOString() + ' ';
		}

		/**
		 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
		 */

		function log(...args) {
			return process.stderr.write(util.formatWithOptions(exports$1.inspectOpts, ...args) + '\n');
		}

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			if (namespaces) {
				process.env.DEBUG = namespaces;
			} else {
				// If you set a process.env field to null or undefined, it gets cast to the
				// string 'null' or 'undefined'. Just delete instead.
				delete process.env.DEBUG;
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */

		function load() {
			return process.env.DEBUG;
		}

		/**
		 * Init logic for `debug` instances.
		 *
		 * Create a new `inspectOpts` object in case `useColors` is set
		 * differently for a particular `debug` instance.
		 */

		function init(debug) {
			debug.inspectOpts = {};

			const keys = Object.keys(exports$1.inspectOpts);
			for (let i = 0; i < keys.length; i++) {
				debug.inspectOpts[keys[i]] = exports$1.inspectOpts[keys[i]];
			}
		}

		module.exports = requireCommon()(exports$1);

		const {formatters} = module.exports;

		/**
		 * Map %o to `util.inspect()`, all on a single line.
		 */

		formatters.o = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts)
				.split('\n')
				.map(str => str.trim())
				.join(' ');
		};

		/**
		 * Map %O to `util.inspect()`, allowing multiple lines if needed.
		 */

		formatters.O = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts);
		}; 
	} (node$1, node$1.exports));
	return node$1.exports;
}

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src.exports;
	hasRequiredSrc = 1;
	if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
		src.exports = requireBrowser();
	} else {
		src.exports = requireNode$1();
	}
	return src.exports;
}

var debug_1;
var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug_1;
	hasRequiredDebug = 1;
	var debug;

	debug_1 = function () {
	  if (!debug) {
	    try {
	      /* eslint global-require: off */
	      debug = requireSrc()("follow-redirects");
	    }
	    catch (error) { /* */ }
	    if (typeof debug !== "function") {
	      debug = function () { /* */ };
	    }
	  }
	  debug.apply(null, arguments);
	};
	return debug_1;
}

var hasRequiredFollowRedirects;

function requireFollowRedirects () {
	if (hasRequiredFollowRedirects) return followRedirects.exports;
	hasRequiredFollowRedirects = 1;
	var url = require$$7;
	var URL = url.URL;
	var http = require$$1;
	var https = require$$2;
	var Writable = require$$0$2.Writable;
	var assert = require$$4$1;
	var debug = requireDebug();

	// Preventive platform detection
	// istanbul ignore next
	(function detectUnsupportedEnvironment() {
	  var looksLikeNode = typeof process !== "undefined";
	  var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
	  var looksLikeV8 = isFunction(Error.captureStackTrace);
	  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
	    console.warn("The follow-redirects package should be excluded from browser builds.");
	  }
	}());

	// Whether to use the native URL object or the legacy url module
	var useNativeURL = false;
	try {
	  assert(new URL(""));
	}
	catch (error) {
	  useNativeURL = error.code === "ERR_INVALID_URL";
	}

	// URL fields to preserve in copy operations
	var preservedUrlFields = [
	  "auth",
	  "host",
	  "hostname",
	  "href",
	  "path",
	  "pathname",
	  "port",
	  "protocol",
	  "query",
	  "search",
	  "hash",
	];

	// Create handlers that pass events from native requests
	var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
	var eventHandlers = Object.create(null);
	events.forEach(function (event) {
	  eventHandlers[event] = function (arg1, arg2, arg3) {
	    this._redirectable.emit(event, arg1, arg2, arg3);
	  };
	});

	// Error types with codes
	var InvalidUrlError = createErrorType(
	  "ERR_INVALID_URL",
	  "Invalid URL",
	  TypeError
	);
	var RedirectionError = createErrorType(
	  "ERR_FR_REDIRECTION_FAILURE",
	  "Redirected request failed"
	);
	var TooManyRedirectsError = createErrorType(
	  "ERR_FR_TOO_MANY_REDIRECTS",
	  "Maximum number of redirects exceeded",
	  RedirectionError
	);
	var MaxBodyLengthExceededError = createErrorType(
	  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
	  "Request body larger than maxBodyLength limit"
	);
	var WriteAfterEndError = createErrorType(
	  "ERR_STREAM_WRITE_AFTER_END",
	  "write after end"
	);

	// istanbul ignore next
	var destroy = Writable.prototype.destroy || noop;

	// An HTTP(S) request that can be redirected
	function RedirectableRequest(options, responseCallback) {
	  // Initialize the request
	  Writable.call(this);
	  this._sanitizeOptions(options);
	  this._options = options;
	  this._ended = false;
	  this._ending = false;
	  this._redirectCount = 0;
	  this._redirects = [];
	  this._requestBodyLength = 0;
	  this._requestBodyBuffers = [];

	  // Attach a callback if passed
	  if (responseCallback) {
	    this.on("response", responseCallback);
	  }

	  // React to responses of native requests
	  var self = this;
	  this._onNativeResponse = function (response) {
	    try {
	      self._processResponse(response);
	    }
	    catch (cause) {
	      self.emit("error", cause instanceof RedirectionError ?
	        cause : new RedirectionError({ cause: cause }));
	    }
	  };

	  // Perform the first request
	  this._performRequest();
	}
	RedirectableRequest.prototype = Object.create(Writable.prototype);

	RedirectableRequest.prototype.abort = function () {
	  destroyRequest(this._currentRequest);
	  this._currentRequest.abort();
	  this.emit("abort");
	};

	RedirectableRequest.prototype.destroy = function (error) {
	  destroyRequest(this._currentRequest, error);
	  destroy.call(this, error);
	  return this;
	};

	// Writes buffered data to the current native request
	RedirectableRequest.prototype.write = function (data, encoding, callback) {
	  // Writing is not allowed if end has been called
	  if (this._ending) {
	    throw new WriteAfterEndError();
	  }

	  // Validate input and shift parameters if necessary
	  if (!isString(data) && !isBuffer(data)) {
	    throw new TypeError("data should be a string, Buffer or Uint8Array");
	  }
	  if (isFunction(encoding)) {
	    callback = encoding;
	    encoding = null;
	  }

	  // Ignore empty buffers, since writing them doesn't invoke the callback
	  // https://github.com/nodejs/node/issues/22066
	  if (data.length === 0) {
	    if (callback) {
	      callback();
	    }
	    return;
	  }
	  // Only write when we don't exceed the maximum body length
	  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
	    this._requestBodyLength += data.length;
	    this._requestBodyBuffers.push({ data: data, encoding: encoding });
	    this._currentRequest.write(data, encoding, callback);
	  }
	  // Error when we exceed the maximum body length
	  else {
	    this.emit("error", new MaxBodyLengthExceededError());
	    this.abort();
	  }
	};

	// Ends the current native request
	RedirectableRequest.prototype.end = function (data, encoding, callback) {
	  // Shift parameters if necessary
	  if (isFunction(data)) {
	    callback = data;
	    data = encoding = null;
	  }
	  else if (isFunction(encoding)) {
	    callback = encoding;
	    encoding = null;
	  }

	  // Write data if needed and end
	  if (!data) {
	    this._ended = this._ending = true;
	    this._currentRequest.end(null, null, callback);
	  }
	  else {
	    var self = this;
	    var currentRequest = this._currentRequest;
	    this.write(data, encoding, function () {
	      self._ended = true;
	      currentRequest.end(null, null, callback);
	    });
	    this._ending = true;
	  }
	};

	// Sets a header value on the current native request
	RedirectableRequest.prototype.setHeader = function (name, value) {
	  this._options.headers[name] = value;
	  this._currentRequest.setHeader(name, value);
	};

	// Clears a header value on the current native request
	RedirectableRequest.prototype.removeHeader = function (name) {
	  delete this._options.headers[name];
	  this._currentRequest.removeHeader(name);
	};

	// Global timeout for all underlying requests
	RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
	  var self = this;

	  // Destroys the socket on timeout
	  function destroyOnTimeout(socket) {
	    socket.setTimeout(msecs);
	    socket.removeListener("timeout", socket.destroy);
	    socket.addListener("timeout", socket.destroy);
	  }

	  // Sets up a timer to trigger a timeout event
	  function startTimer(socket) {
	    if (self._timeout) {
	      clearTimeout(self._timeout);
	    }
	    self._timeout = setTimeout(function () {
	      self.emit("timeout");
	      clearTimer();
	    }, msecs);
	    destroyOnTimeout(socket);
	  }

	  // Stops a timeout from triggering
	  function clearTimer() {
	    // Clear the timeout
	    if (self._timeout) {
	      clearTimeout(self._timeout);
	      self._timeout = null;
	    }

	    // Clean up all attached listeners
	    self.removeListener("abort", clearTimer);
	    self.removeListener("error", clearTimer);
	    self.removeListener("response", clearTimer);
	    self.removeListener("close", clearTimer);
	    if (callback) {
	      self.removeListener("timeout", callback);
	    }
	    if (!self.socket) {
	      self._currentRequest.removeListener("socket", startTimer);
	    }
	  }

	  // Attach callback if passed
	  if (callback) {
	    this.on("timeout", callback);
	  }

	  // Start the timer if or when the socket is opened
	  if (this.socket) {
	    startTimer(this.socket);
	  }
	  else {
	    this._currentRequest.once("socket", startTimer);
	  }

	  // Clean up on events
	  this.on("socket", destroyOnTimeout);
	  this.on("abort", clearTimer);
	  this.on("error", clearTimer);
	  this.on("response", clearTimer);
	  this.on("close", clearTimer);

	  return this;
	};

	// Proxy all other public ClientRequest methods
	[
	  "flushHeaders", "getHeader",
	  "setNoDelay", "setSocketKeepAlive",
	].forEach(function (method) {
	  RedirectableRequest.prototype[method] = function (a, b) {
	    return this._currentRequest[method](a, b);
	  };
	});

	// Proxy all public ClientRequest properties
	["aborted", "connection", "socket"].forEach(function (property) {
	  Object.defineProperty(RedirectableRequest.prototype, property, {
	    get: function () { return this._currentRequest[property]; },
	  });
	});

	RedirectableRequest.prototype._sanitizeOptions = function (options) {
	  // Ensure headers are always present
	  if (!options.headers) {
	    options.headers = {};
	  }

	  // Since http.request treats host as an alias of hostname,
	  // but the url module interprets host as hostname plus port,
	  // eliminate the host property to avoid confusion.
	  if (options.host) {
	    // Use hostname if set, because it has precedence
	    if (!options.hostname) {
	      options.hostname = options.host;
	    }
	    delete options.host;
	  }

	  // Complete the URL object when necessary
	  if (!options.pathname && options.path) {
	    var searchPos = options.path.indexOf("?");
	    if (searchPos < 0) {
	      options.pathname = options.path;
	    }
	    else {
	      options.pathname = options.path.substring(0, searchPos);
	      options.search = options.path.substring(searchPos);
	    }
	  }
	};


	// Executes the next native request (initial or redirect)
	RedirectableRequest.prototype._performRequest = function () {
	  // Load the native protocol
	  var protocol = this._options.protocol;
	  var nativeProtocol = this._options.nativeProtocols[protocol];
	  if (!nativeProtocol) {
	    throw new TypeError("Unsupported protocol " + protocol);
	  }

	  // If specified, use the agent corresponding to the protocol
	  // (HTTP and HTTPS use different types of agents)
	  if (this._options.agents) {
	    var scheme = protocol.slice(0, -1);
	    this._options.agent = this._options.agents[scheme];
	  }

	  // Create the native request and set up its event handlers
	  var request = this._currentRequest =
	        nativeProtocol.request(this._options, this._onNativeResponse);
	  request._redirectable = this;
	  for (var event of events) {
	    request.on(event, eventHandlers[event]);
	  }

	  // RFC72305.3.1: When making a request directly to an origin server, []
	  // a client MUST send only the absolute path [] as the request-target.
	  this._currentUrl = /^\//.test(this._options.path) ?
	    url.format(this._options) :
	    // When making a request to a proxy, []
	    // a client MUST send the target URI in absolute-form [].
	    this._options.path;

	  // End a redirected request
	  // (The first request must be ended explicitly with RedirectableRequest#end)
	  if (this._isRedirect) {
	    // Write the request entity and end
	    var i = 0;
	    var self = this;
	    var buffers = this._requestBodyBuffers;
	    (function writeNext(error) {
	      // Only write if this request has not been redirected yet
	      // istanbul ignore else
	      if (request === self._currentRequest) {
	        // Report any write errors
	        // istanbul ignore if
	        if (error) {
	          self.emit("error", error);
	        }
	        // Write the next buffer if there are still left
	        else if (i < buffers.length) {
	          var buffer = buffers[i++];
	          // istanbul ignore else
	          if (!request.finished) {
	            request.write(buffer.data, buffer.encoding, writeNext);
	          }
	        }
	        // End the request if `end` has been called on us
	        else if (self._ended) {
	          request.end();
	        }
	      }
	    }());
	  }
	};

	// Processes a response from the current native request
	RedirectableRequest.prototype._processResponse = function (response) {
	  // Store the redirected response
	  var statusCode = response.statusCode;
	  if (this._options.trackRedirects) {
	    this._redirects.push({
	      url: this._currentUrl,
	      headers: response.headers,
	      statusCode: statusCode,
	    });
	  }

	  // RFC72316.4: The 3xx (Redirection) class of status code indicates
	  // that further action needs to be taken by the user agent in order to
	  // fulfill the request. If a Location header field is provided,
	  // the user agent MAY automatically redirect its request to the URI
	  // referenced by the Location field value,
	  // even if the specific status code is not understood.

	  // If the response is not a redirect; return it as-is
	  var location = response.headers.location;
	  if (!location || this._options.followRedirects === false ||
	      statusCode < 300 || statusCode >= 400) {
	    response.responseUrl = this._currentUrl;
	    response.redirects = this._redirects;
	    this.emit("response", response);

	    // Clean up
	    this._requestBodyBuffers = [];
	    return;
	  }

	  // The response is a redirect, so abort the current request
	  destroyRequest(this._currentRequest);
	  // Discard the remainder of the response to avoid waiting for data
	  response.destroy();

	  // RFC72316.4: A client SHOULD detect and intervene
	  // in cyclical redirections (i.e., "infinite" redirection loops).
	  if (++this._redirectCount > this._options.maxRedirects) {
	    throw new TooManyRedirectsError();
	  }

	  // Store the request headers if applicable
	  var requestHeaders;
	  var beforeRedirect = this._options.beforeRedirect;
	  if (beforeRedirect) {
	    requestHeaders = Object.assign({
	      // The Host header was set by nativeProtocol.request
	      Host: response.req.getHeader("host"),
	    }, this._options.headers);
	  }

	  // RFC72316.4: Automatic redirection needs to done with
	  // care for methods not known to be safe, []
	  // RFC72316.4.23: For historical reasons, a user agent MAY change
	  // the request method from POST to GET for the subsequent request.
	  var method = this._options.method;
	  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
	      // RFC72316.4.4: The 303 (See Other) status code indicates that
	      // the server is redirecting the user agent to a different resource []
	      // A user agent can perform a retrieval request targeting that URI
	      // (a GET or HEAD request if using HTTP) []
	      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
	    this._options.method = "GET";
	    // Drop a possible entity and headers related to it
	    this._requestBodyBuffers = [];
	    removeMatchingHeaders(/^content-/i, this._options.headers);
	  }

	  // Drop the Host header, as the redirect might lead to a different host
	  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

	  // If the redirect is relative, carry over the host of the last request
	  var currentUrlParts = parseUrl(this._currentUrl);
	  var currentHost = currentHostHeader || currentUrlParts.host;
	  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
	    url.format(Object.assign(currentUrlParts, { host: currentHost }));

	  // Create the redirected request
	  var redirectUrl = resolveUrl(location, currentUrl);
	  debug("redirecting to", redirectUrl.href);
	  this._isRedirect = true;
	  spreadUrlObject(redirectUrl, this._options);

	  // Drop confidential headers when redirecting to a less secure protocol
	  // or to a different domain that is not a superdomain
	  if (redirectUrl.protocol !== currentUrlParts.protocol &&
	     redirectUrl.protocol !== "https:" ||
	     redirectUrl.host !== currentHost &&
	     !isSubdomain(redirectUrl.host, currentHost)) {
	    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
	  }

	  // Evaluate the beforeRedirect callback
	  if (isFunction(beforeRedirect)) {
	    var responseDetails = {
	      headers: response.headers,
	      statusCode: statusCode,
	    };
	    var requestDetails = {
	      url: currentUrl,
	      method: method,
	      headers: requestHeaders,
	    };
	    beforeRedirect(this._options, responseDetails, requestDetails);
	    this._sanitizeOptions(this._options);
	  }

	  // Perform the redirected request
	  this._performRequest();
	};

	// Wraps the key/value object of protocols with redirect functionality
	function wrap(protocols) {
	  // Default settings
	  var exports$1 = {
	    maxRedirects: 21,
	    maxBodyLength: 10 * 1024 * 1024,
	  };

	  // Wrap each protocol
	  var nativeProtocols = {};
	  Object.keys(protocols).forEach(function (scheme) {
	    var protocol = scheme + ":";
	    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
	    var wrappedProtocol = exports$1[scheme] = Object.create(nativeProtocol);

	    // Executes a request, following redirects
	    function request(input, options, callback) {
	      // Parse parameters, ensuring that input is an object
	      if (isURL(input)) {
	        input = spreadUrlObject(input);
	      }
	      else if (isString(input)) {
	        input = spreadUrlObject(parseUrl(input));
	      }
	      else {
	        callback = options;
	        options = validateUrl(input);
	        input = { protocol: protocol };
	      }
	      if (isFunction(options)) {
	        callback = options;
	        options = null;
	      }

	      // Set defaults
	      options = Object.assign({
	        maxRedirects: exports$1.maxRedirects,
	        maxBodyLength: exports$1.maxBodyLength,
	      }, input, options);
	      options.nativeProtocols = nativeProtocols;
	      if (!isString(options.host) && !isString(options.hostname)) {
	        options.hostname = "::1";
	      }

	      assert.equal(options.protocol, protocol, "protocol mismatch");
	      debug("options", options);
	      return new RedirectableRequest(options, callback);
	    }

	    // Executes a GET request, following redirects
	    function get(input, options, callback) {
	      var wrappedRequest = wrappedProtocol.request(input, options, callback);
	      wrappedRequest.end();
	      return wrappedRequest;
	    }

	    // Expose the properties on the wrapped protocol
	    Object.defineProperties(wrappedProtocol, {
	      request: { value: request, configurable: true, enumerable: true, writable: true },
	      get: { value: get, configurable: true, enumerable: true, writable: true },
	    });
	  });
	  return exports$1;
	}

	function noop() { /* empty */ }

	function parseUrl(input) {
	  var parsed;
	  // istanbul ignore else
	  if (useNativeURL) {
	    parsed = new URL(input);
	  }
	  else {
	    // Ensure the URL is valid and absolute
	    parsed = validateUrl(url.parse(input));
	    if (!isString(parsed.protocol)) {
	      throw new InvalidUrlError({ input });
	    }
	  }
	  return parsed;
	}

	function resolveUrl(relative, base) {
	  // istanbul ignore next
	  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
	}

	function validateUrl(input) {
	  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
	    throw new InvalidUrlError({ input: input.href || input });
	  }
	  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
	    throw new InvalidUrlError({ input: input.href || input });
	  }
	  return input;
	}

	function spreadUrlObject(urlObject, target) {
	  var spread = target || {};
	  for (var key of preservedUrlFields) {
	    spread[key] = urlObject[key];
	  }

	  // Fix IPv6 hostname
	  if (spread.hostname.startsWith("[")) {
	    spread.hostname = spread.hostname.slice(1, -1);
	  }
	  // Ensure port is a number
	  if (spread.port !== "") {
	    spread.port = Number(spread.port);
	  }
	  // Concatenate path
	  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;

	  return spread;
	}

	function removeMatchingHeaders(regex, headers) {
	  var lastValue;
	  for (var header in headers) {
	    if (regex.test(header)) {
	      lastValue = headers[header];
	      delete headers[header];
	    }
	  }
	  return (lastValue === null || typeof lastValue === "undefined") ?
	    undefined : String(lastValue).trim();
	}

	function createErrorType(code, message, baseClass) {
	  // Create constructor
	  function CustomError(properties) {
	    // istanbul ignore else
	    if (isFunction(Error.captureStackTrace)) {
	      Error.captureStackTrace(this, this.constructor);
	    }
	    Object.assign(this, properties || {});
	    this.code = code;
	    this.message = this.cause ? message + ": " + this.cause.message : message;
	  }

	  // Attach constructor and set default properties
	  CustomError.prototype = new (baseClass || Error)();
	  Object.defineProperties(CustomError.prototype, {
	    constructor: {
	      value: CustomError,
	      enumerable: false,
	    },
	    name: {
	      value: "Error [" + code + "]",
	      enumerable: false,
	    },
	  });
	  return CustomError;
	}

	function destroyRequest(request, error) {
	  for (var event of events) {
	    request.removeListener(event, eventHandlers[event]);
	  }
	  request.on("error", noop);
	  request.destroy(error);
	}

	function isSubdomain(subdomain, domain) {
	  assert(isString(subdomain) && isString(domain));
	  var dot = subdomain.length - domain.length - 1;
	  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
	}

	function isString(value) {
	  return typeof value === "string" || value instanceof String;
	}

	function isFunction(value) {
	  return typeof value === "function";
	}

	function isBuffer(value) {
	  return typeof value === "object" && ("length" in value);
	}

	function isURL(value) {
	  return URL && value instanceof URL;
	}

	// Exports
	followRedirects.exports = wrap({ http: http, https: https });
	followRedirects.exports.wrap = wrap;
	return followRedirects.exports;
}

var version = "0.21.4";
var require$$0 = {
	version: version};

var http_1;
var hasRequiredHttp;

function requireHttp () {
	if (hasRequiredHttp) return http_1;
	hasRequiredHttp = 1;

	var utils = requireUtils();
	var settle = requireSettle();
	var buildFullPath = requireBuildFullPath();
	var buildURL = requireBuildURL();
	var http = require$$1;
	var https = require$$2;
	var httpFollow = requireFollowRedirects().http;
	var httpsFollow = requireFollowRedirects().https;
	var url = require$$7;
	var zlib = require$$0$1;
	var pkg = require$$0;
	var createError = requireCreateError();
	var enhanceError = requireEnhanceError();

	var isHttps = /https:?/;

	/**
	 *
	 * @param {http.ClientRequestArgs} options
	 * @param {AxiosProxyConfig} proxy
	 * @param {string} location
	 */
	function setProxy(options, proxy, location) {
	  options.hostname = proxy.host;
	  options.host = proxy.host;
	  options.port = proxy.port;
	  options.path = location;

	  // Basic proxy authorization
	  if (proxy.auth) {
	    var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');
	    options.headers['Proxy-Authorization'] = 'Basic ' + base64;
	  }

	  // If a proxy is used, any redirects must also pass through the proxy
	  options.beforeRedirect = function beforeRedirect(redirection) {
	    redirection.headers.host = redirection.host;
	    setProxy(redirection, proxy, redirection.href);
	  };
	}

	/*eslint consistent-return:0*/
	http_1 = function httpAdapter(config) {
	  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
	    var resolve = function resolve(value) {
	      resolvePromise(value);
	    };
	    var reject = function reject(value) {
	      rejectPromise(value);
	    };
	    var data = config.data;
	    var headers = config.headers;

	    // Set User-Agent (required by some servers)
	    // See https://github.com/axios/axios/issues/69
	    if ('User-Agent' in headers || 'user-agent' in headers) {
	      // User-Agent is specified; handle case where no UA header is desired
	      if (!headers['User-Agent'] && !headers['user-agent']) {
	        delete headers['User-Agent'];
	        delete headers['user-agent'];
	      }
	      // Otherwise, use specified value
	    } else {
	      // Only set header if it hasn't been set in config
	      headers['User-Agent'] = 'axios/' + pkg.version;
	    }

	    if (data && !utils.isStream(data)) {
	      if (Buffer.isBuffer(data)) ; else if (utils.isArrayBuffer(data)) {
	        data = Buffer.from(new Uint8Array(data));
	      } else if (utils.isString(data)) {
	        data = Buffer.from(data, 'utf-8');
	      } else {
	        return reject(createError(
	          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
	          config
	        ));
	      }

	      // Add Content-Length header if data exists
	      headers['Content-Length'] = data.length;
	    }

	    // HTTP basic authentication
	    var auth = undefined;
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      auth = username + ':' + password;
	    }

	    // Parse url
	    var fullPath = buildFullPath(config.baseURL, config.url);
	    var parsed = url.parse(fullPath);
	    var protocol = parsed.protocol || 'http:';

	    if (!auth && parsed.auth) {
	      var urlAuth = parsed.auth.split(':');
	      var urlUsername = urlAuth[0] || '';
	      var urlPassword = urlAuth[1] || '';
	      auth = urlUsername + ':' + urlPassword;
	    }

	    if (auth) {
	      delete headers.Authorization;
	    }

	    var isHttpsRequest = isHttps.test(protocol);
	    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;

	    var options = {
	      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
	      method: config.method.toUpperCase(),
	      headers: headers,
	      agent: agent,
	      agents: { http: config.httpAgent, https: config.httpsAgent },
	      auth: auth
	    };

	    if (config.socketPath) {
	      options.socketPath = config.socketPath;
	    } else {
	      options.hostname = parsed.hostname;
	      options.port = parsed.port;
	    }

	    var proxy = config.proxy;
	    if (!proxy && proxy !== false) {
	      var proxyEnv = protocol.slice(0, -1) + '_proxy';
	      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
	      if (proxyUrl) {
	        var parsedProxyUrl = url.parse(proxyUrl);
	        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
	        var shouldProxy = true;

	        if (noProxyEnv) {
	          var noProxy = noProxyEnv.split(',').map(function trim(s) {
	            return s.trim();
	          });

	          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
	            if (!proxyElement) {
	              return false;
	            }
	            if (proxyElement === '*') {
	              return true;
	            }
	            if (proxyElement[0] === '.' &&
	                parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
	              return true;
	            }

	            return parsed.hostname === proxyElement;
	          });
	        }

	        if (shouldProxy) {
	          proxy = {
	            host: parsedProxyUrl.hostname,
	            port: parsedProxyUrl.port,
	            protocol: parsedProxyUrl.protocol
	          };

	          if (parsedProxyUrl.auth) {
	            var proxyUrlAuth = parsedProxyUrl.auth.split(':');
	            proxy.auth = {
	              username: proxyUrlAuth[0],
	              password: proxyUrlAuth[1]
	            };
	          }
	        }
	      }
	    }

	    if (proxy) {
	      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
	      setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
	    }

	    var transport;
	    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
	    if (config.transport) {
	      transport = config.transport;
	    } else if (config.maxRedirects === 0) {
	      transport = isHttpsProxy ? https : http;
	    } else {
	      if (config.maxRedirects) {
	        options.maxRedirects = config.maxRedirects;
	      }
	      transport = isHttpsProxy ? httpsFollow : httpFollow;
	    }

	    if (config.maxBodyLength > -1) {
	      options.maxBodyLength = config.maxBodyLength;
	    }

	    // Create the request
	    var req = transport.request(options, function handleResponse(res) {
	      if (req.aborted) return;

	      // uncompress the response body transparently if required
	      var stream = res;

	      // return the last request in case of redirects
	      var lastRequest = res.req || req;


	      // if no content, is HEAD request or decompress disabled we should not decompress
	      if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {
	        switch (res.headers['content-encoding']) {
	        /*eslint default-case:0*/
	        case 'gzip':
	        case 'compress':
	        case 'deflate':
	        // add the unzipper to the body stream processing pipeline
	          stream = stream.pipe(zlib.createUnzip());

	          // remove the content-encoding in order to not confuse downstream operations
	          delete res.headers['content-encoding'];
	          break;
	        }
	      }

	      var response = {
	        status: res.statusCode,
	        statusText: res.statusMessage,
	        headers: res.headers,
	        config: config,
	        request: lastRequest
	      };

	      if (config.responseType === 'stream') {
	        response.data = stream;
	        settle(resolve, reject, response);
	      } else {
	        var responseBuffer = [];
	        var totalResponseBytes = 0;
	        stream.on('data', function handleStreamData(chunk) {
	          responseBuffer.push(chunk);
	          totalResponseBytes += chunk.length;

	          // make sure the content length is not over the maxContentLength if specified
	          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
	            stream.destroy();
	            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
	              config, null, lastRequest));
	          }
	        });

	        stream.on('error', function handleStreamError(err) {
	          if (req.aborted) return;
	          reject(enhanceError(err, config, null, lastRequest));
	        });

	        stream.on('end', function handleStreamEnd() {
	          var responseData = Buffer.concat(responseBuffer);
	          if (config.responseType !== 'arraybuffer') {
	            responseData = responseData.toString(config.responseEncoding);
	            if (!config.responseEncoding || config.responseEncoding === 'utf8') {
	              responseData = utils.stripBOM(responseData);
	            }
	          }

	          response.data = responseData;
	          settle(resolve, reject, response);
	        });
	      }
	    });

	    // Handle errors
	    req.on('error', function handleRequestError(err) {
	      if (req.aborted && err.code !== 'ERR_FR_TOO_MANY_REDIRECTS') return;
	      reject(enhanceError(err, config, null, req));
	    });

	    // Handle request timeout
	    if (config.timeout) {
	      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
	      var timeout = parseInt(config.timeout, 10);

	      if (isNaN(timeout)) {
	        reject(createError(
	          'error trying to parse `config.timeout` to int',
	          config,
	          'ERR_PARSE_TIMEOUT',
	          req
	        ));

	        return;
	      }

	      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
	      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
	      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
	      // And then these socket which be hang up will devoring CPU little by little.
	      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
	      req.setTimeout(timeout, function handleRequestTimeout() {
	        req.abort();
	        reject(createError(
	          'timeout of ' + timeout + 'ms exceeded',
	          config,
	          config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
	          req
	        ));
	      });
	    }

	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (req.aborted) return;

	        req.abort();
	        reject(cancel);
	      });
	    }

	    // Send the request
	    if (utils.isStream(data)) {
	      data.on('error', function handleStreamError(err) {
	        reject(enhanceError(err, config, null, req));
	      }).pipe(req);
	    } else {
	      req.end(data);
	    }
	  });
	};
	return http_1;
}

var defaults_1;
var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults_1;
	hasRequiredDefaults = 1;

	var utils = requireUtils();
	var normalizeHeaderName = requireNormalizeHeaderName();
	var enhanceError = requireEnhanceError();

	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};

	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}

	function getDefaultAdapter() {
	  var adapter;
	  if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = requireXhr();
	  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
	    // For node use HTTP adapter
	    adapter = requireHttp();
	  }
	  return adapter;
	}

	function stringifySafely(rawValue, parser, encoder) {
	  if (utils.isString(rawValue)) {
	    try {
	      (parser || JSON.parse)(rawValue);
	      return utils.trim(rawValue);
	    } catch (e) {
	      if (e.name !== 'SyntaxError') {
	        throw e;
	      }
	    }
	  }

	  return (encoder || JSON.stringify)(rawValue);
	}

	var defaults = {

	  transitional: {
	    silentJSONParsing: true,
	    forcedJSONParsing: true,
	    clarifyTimeoutError: false
	  },

	  adapter: getDefaultAdapter(),

	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Accept');
	    normalizeHeaderName(headers, 'Content-Type');

	    if (utils.isFormData(data) ||
	      utils.isArrayBuffer(data) ||
	      utils.isBuffer(data) ||
	      utils.isStream(data) ||
	      utils.isFile(data) ||
	      utils.isBlob(data)
	    ) {
	      return data;
	    }
	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
	      setContentTypeIfUnset(headers, 'application/json');
	      return stringifySafely(data);
	    }
	    return data;
	  }],

	  transformResponse: [function transformResponse(data) {
	    var transitional = this.transitional;
	    var silentJSONParsing = transitional && transitional.silentJSONParsing;
	    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
	    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

	    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
	      try {
	        return JSON.parse(data);
	      } catch (e) {
	        if (strictJSONParsing) {
	          if (e.name === 'SyntaxError') {
	            throw enhanceError(e, this, 'E_JSON_PARSE');
	          }
	          throw e;
	        }
	      }
	    }

	    return data;
	  }],

	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,

	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',

	  maxContentLength: -1,
	  maxBodyLength: -1,

	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};

	defaults.headers = {
	  common: {
	    'Accept': 'application/json, text/plain, */*'
	  }
	};

	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  defaults.headers[method] = {};
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
	});

	defaults_1 = defaults;
	return defaults_1;
}

var transformData;
var hasRequiredTransformData;

function requireTransformData () {
	if (hasRequiredTransformData) return transformData;
	hasRequiredTransformData = 1;

	var utils = requireUtils();
	var defaults = requireDefaults();

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	transformData = function transformData(data, headers, fns) {
	  var context = this || defaults;
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn.call(context, data, headers);
	  });

	  return data;
	};
	return transformData;
}

var isCancel;
var hasRequiredIsCancel;

function requireIsCancel () {
	if (hasRequiredIsCancel) return isCancel;
	hasRequiredIsCancel = 1;

	isCancel = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};
	return isCancel;
}

var dispatchRequest;
var hasRequiredDispatchRequest;

function requireDispatchRequest () {
	if (hasRequiredDispatchRequest) return dispatchRequest;
	hasRequiredDispatchRequest = 1;

	var utils = requireUtils();
	var transformData = requireTransformData();
	var isCancel = requireIsCancel();
	var defaults = requireDefaults();

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	dispatchRequest = function dispatchRequest(config) {
	  throwIfCancellationRequested(config);

	  // Ensure headers exist
	  config.headers = config.headers || {};

	  // Transform request data
	  config.data = transformData.call(
	    config,
	    config.data,
	    config.headers,
	    config.transformRequest
	  );

	  // Flatten headers
	  config.headers = utils.merge(
	    config.headers.common || {},
	    config.headers[config.method] || {},
	    config.headers
	  );

	  utils.forEach(
	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	    function cleanHeaderConfig(method) {
	      delete config.headers[method];
	    }
	  );

	  var adapter = config.adapter || defaults.adapter;

	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData.call(
	      config,
	      response.data,
	      response.headers,
	      config.transformResponse
	    );

	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData.call(
	          config,
	          reason.response.data,
	          reason.response.headers,
	          config.transformResponse
	        );
	      }
	    }

	    return Promise.reject(reason);
	  });
	};
	return dispatchRequest;
}

var mergeConfig;
var hasRequiredMergeConfig;

function requireMergeConfig () {
	if (hasRequiredMergeConfig) return mergeConfig;
	hasRequiredMergeConfig = 1;

	var utils = requireUtils();

	/**
	 * Config-specific merge-function which creates a new config-object
	 * by merging two configuration objects together.
	 *
	 * @param {Object} config1
	 * @param {Object} config2
	 * @returns {Object} New object resulting from merging config2 to config1
	 */
	mergeConfig = function mergeConfig(config1, config2) {
	  // eslint-disable-next-line no-param-reassign
	  config2 = config2 || {};
	  var config = {};

	  var valueFromConfig2Keys = ['url', 'method', 'data'];
	  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
	  var defaultToConfig2Keys = [
	    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
	    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
	    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
	    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
	    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
	  ];
	  var directMergeKeys = ['validateStatus'];

	  function getMergedValue(target, source) {
	    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
	      return utils.merge(target, source);
	    } else if (utils.isPlainObject(source)) {
	      return utils.merge({}, source);
	    } else if (utils.isArray(source)) {
	      return source.slice();
	    }
	    return source;
	  }

	  function mergeDeepProperties(prop) {
	    if (!utils.isUndefined(config2[prop])) {
	      config[prop] = getMergedValue(config1[prop], config2[prop]);
	    } else if (!utils.isUndefined(config1[prop])) {
	      config[prop] = getMergedValue(undefined, config1[prop]);
	    }
	  }

	  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
	    if (!utils.isUndefined(config2[prop])) {
	      config[prop] = getMergedValue(undefined, config2[prop]);
	    }
	  });

	  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

	  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
	    if (!utils.isUndefined(config2[prop])) {
	      config[prop] = getMergedValue(undefined, config2[prop]);
	    } else if (!utils.isUndefined(config1[prop])) {
	      config[prop] = getMergedValue(undefined, config1[prop]);
	    }
	  });

	  utils.forEach(directMergeKeys, function merge(prop) {
	    if (prop in config2) {
	      config[prop] = getMergedValue(config1[prop], config2[prop]);
	    } else if (prop in config1) {
	      config[prop] = getMergedValue(undefined, config1[prop]);
	    }
	  });

	  var axiosKeys = valueFromConfig2Keys
	    .concat(mergeDeepPropertiesKeys)
	    .concat(defaultToConfig2Keys)
	    .concat(directMergeKeys);

	  var otherKeys = Object
	    .keys(config1)
	    .concat(Object.keys(config2))
	    .filter(function filterAxiosKeys(key) {
	      return axiosKeys.indexOf(key) === -1;
	    });

	  utils.forEach(otherKeys, mergeDeepProperties);

	  return config;
	};
	return mergeConfig;
}

var validator;
var hasRequiredValidator;

function requireValidator () {
	if (hasRequiredValidator) return validator;
	hasRequiredValidator = 1;

	var pkg = require$$0;

	var validators = {};

	// eslint-disable-next-line func-names
	['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
	  validators[type] = function validator(thing) {
	    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
	  };
	});

	var deprecatedWarnings = {};
	var currentVerArr = pkg.version.split('.');

	/**
	 * Compare package versions
	 * @param {string} version
	 * @param {string?} thanVersion
	 * @returns {boolean}
	 */
	function isOlderVersion(version, thanVersion) {
	  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
	  var destVer = version.split('.');
	  for (var i = 0; i < 3; i++) {
	    if (pkgVersionArr[i] > destVer[i]) {
	      return true;
	    } else if (pkgVersionArr[i] < destVer[i]) {
	      return false;
	    }
	  }
	  return false;
	}

	/**
	 * Transitional option validator
	 * @param {function|boolean?} validator
	 * @param {string?} version
	 * @param {string} message
	 * @returns {function}
	 */
	validators.transitional = function transitional(validator, version, message) {
	  var isDeprecated = version && isOlderVersion(version);

	  function formatMessage(opt, desc) {
	    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
	  }

	  // eslint-disable-next-line func-names
	  return function(value, opt, opts) {
	    if (validator === false) {
	      throw new Error(formatMessage(opt, ' has been removed in ' + version));
	    }

	    if (isDeprecated && !deprecatedWarnings[opt]) {
	      deprecatedWarnings[opt] = true;
	      // eslint-disable-next-line no-console
	      console.warn(
	        formatMessage(
	          opt,
	          ' has been deprecated since v' + version + ' and will be removed in the near future'
	        )
	      );
	    }

	    return validator ? validator(value, opt, opts) : true;
	  };
	};

	/**
	 * Assert object's properties type
	 * @param {object} options
	 * @param {object} schema
	 * @param {boolean?} allowUnknown
	 */

	function assertOptions(options, schema, allowUnknown) {
	  if (typeof options !== 'object') {
	    throw new TypeError('options must be an object');
	  }
	  var keys = Object.keys(options);
	  var i = keys.length;
	  while (i-- > 0) {
	    var opt = keys[i];
	    var validator = schema[opt];
	    if (validator) {
	      var value = options[opt];
	      var result = value === undefined || validator(value, opt, options);
	      if (result !== true) {
	        throw new TypeError('option ' + opt + ' must be ' + result);
	      }
	      continue;
	    }
	    if (allowUnknown !== true) {
	      throw Error('Unknown option ' + opt);
	    }
	  }
	}

	validator = {
	  isOlderVersion: isOlderVersion,
	  assertOptions: assertOptions,
	  validators: validators
	};
	return validator;
}

var Axios_1;
var hasRequiredAxios$2;

function requireAxios$2 () {
	if (hasRequiredAxios$2) return Axios_1;
	hasRequiredAxios$2 = 1;

	var utils = requireUtils();
	var buildURL = requireBuildURL();
	var InterceptorManager = requireInterceptorManager();
	var dispatchRequest = requireDispatchRequest();
	var mergeConfig = requireMergeConfig();
	var validator = requireValidator();

	var validators = validator.validators;
	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 */
	function Axios(instanceConfig) {
	  this.defaults = instanceConfig;
	  this.interceptors = {
	    request: new InterceptorManager(),
	    response: new InterceptorManager()
	  };
	}

	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = arguments[1] || {};
	    config.url = arguments[0];
	  } else {
	    config = config || {};
	  }

	  config = mergeConfig(this.defaults, config);

	  // Set config.method
	  if (config.method) {
	    config.method = config.method.toLowerCase();
	  } else if (this.defaults.method) {
	    config.method = this.defaults.method.toLowerCase();
	  } else {
	    config.method = 'get';
	  }

	  var transitional = config.transitional;

	  if (transitional !== undefined) {
	    validator.assertOptions(transitional, {
	      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
	      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
	      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
	    }, false);
	  }

	  // filter out skipped interceptors
	  var requestInterceptorChain = [];
	  var synchronousRequestInterceptors = true;
	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
	      return;
	    }

	    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

	    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });

	  var responseInterceptorChain = [];
	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
	  });

	  var promise;

	  if (!synchronousRequestInterceptors) {
	    var chain = [dispatchRequest, undefined];

	    Array.prototype.unshift.apply(chain, requestInterceptorChain);
	    chain = chain.concat(responseInterceptorChain);

	    promise = Promise.resolve(config);
	    while (chain.length) {
	      promise = promise.then(chain.shift(), chain.shift());
	    }

	    return promise;
	  }


	  var newConfig = config;
	  while (requestInterceptorChain.length) {
	    var onFulfilled = requestInterceptorChain.shift();
	    var onRejected = requestInterceptorChain.shift();
	    try {
	      newConfig = onFulfilled(newConfig);
	    } catch (error) {
	      onRejected(error);
	      break;
	    }
	  }

	  try {
	    promise = dispatchRequest(newConfig);
	  } catch (error) {
	    return Promise.reject(error);
	  }

	  while (responseInterceptorChain.length) {
	    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
	  }

	  return promise;
	};

	Axios.prototype.getUri = function getUri(config) {
	  config = mergeConfig(this.defaults, config);
	  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
	};

	// Provide aliases for supported request methods
	utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, config) {
	    return this.request(mergeConfig(config || {}, {
	      method: method,
	      url: url,
	      data: (config || {}).data
	    }));
	  };
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, data, config) {
	    return this.request(mergeConfig(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});

	Axios_1 = Axios;
	return Axios_1;
}

var Cancel_1;
var hasRequiredCancel;

function requireCancel () {
	if (hasRequiredCancel) return Cancel_1;
	hasRequiredCancel = 1;

	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	function Cancel(message) {
	  this.message = message;
	}

	Cancel.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};

	Cancel.prototype.__CANCEL__ = true;

	Cancel_1 = Cancel;
	return Cancel_1;
}

var CancelToken_1;
var hasRequiredCancelToken;

function requireCancelToken () {
	if (hasRequiredCancelToken) return CancelToken_1;
	hasRequiredCancelToken = 1;

	var Cancel = requireCancel();

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }

	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });

	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }

	    token.reason = new Cancel(message);
	    resolvePromise(token.reason);
	  });
	}

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};

	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};

	CancelToken_1 = CancelToken;
	return CancelToken_1;
}

var spread;
var hasRequiredSpread;

function requireSpread () {
	if (hasRequiredSpread) return spread;
	hasRequiredSpread = 1;

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	spread = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};
	return spread;
}

var isAxiosError;
var hasRequiredIsAxiosError;

function requireIsAxiosError () {
	if (hasRequiredIsAxiosError) return isAxiosError;
	hasRequiredIsAxiosError = 1;

	/**
	 * Determines whether the payload is an error thrown by Axios
	 *
	 * @param {*} payload The value to test
	 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
	 */
	isAxiosError = function isAxiosError(payload) {
	  return (typeof payload === 'object') && (payload.isAxiosError === true);
	};
	return isAxiosError;
}

var hasRequiredAxios$1;

function requireAxios$1 () {
	if (hasRequiredAxios$1) return axios$1.exports;
	hasRequiredAxios$1 = 1;

	var utils = requireUtils();
	var bind = requireBind();
	var Axios = requireAxios$2();
	var mergeConfig = requireMergeConfig();
	var defaults = requireDefaults();

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios(defaultConfig);
	  var instance = bind(Axios.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios.prototype, context);

	  // Copy context to instance
	  utils.extend(instance, context);

	  return instance;
	}

	// Create the default instance to be exported
	var axios = createInstance(defaults);

	// Expose Axios class to allow class inheritance
	axios.Axios = Axios;

	// Factory for creating new instances
	axios.create = function create(instanceConfig) {
	  return createInstance(mergeConfig(axios.defaults, instanceConfig));
	};

	// Expose Cancel & CancelToken
	axios.Cancel = requireCancel();
	axios.CancelToken = requireCancelToken();
	axios.isCancel = requireIsCancel();

	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = requireSpread();

	// Expose isAxiosError
	axios.isAxiosError = requireIsAxiosError();

	axios$1.exports = axios;

	// Allow use of default import syntax in TypeScript
	axios$1.exports.default = axios;
	return axios$1.exports;
}

var axios;
var hasRequiredAxios;

function requireAxios () {
	if (hasRequiredAxios) return axios;
	hasRequiredAxios = 1;
	axios = requireAxios$1();
	return axios;
}

var extend;
var hasRequiredExtend;

function requireExtend () {
	if (hasRequiredExtend) return extend;
	hasRequiredExtend = 1;
	var hasOwn = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var defineProperty = Object.defineProperty;
	var gOPD = Object.getOwnPropertyDescriptor;

	var isArray = function isArray(arr) {
		if (typeof Array.isArray === 'function') {
			return Array.isArray(arr);
		}

		return toStr.call(arr) === '[object Array]';
	};

	var isPlainObject = function isPlainObject(obj) {

		if (!obj || toStr.call(obj) !== '[object Object]') {
			return false;
		}

		var hasOwnConstructor = hasOwn.call(obj, 'constructor');
		var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
		// Not own constructor property must be Object
		if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var key;
		for (key in obj) { /**/ }

		return typeof key === 'undefined' || hasOwn.call(obj, key);
	};

	// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
	var setProperty = function setProperty(target, options) {
		if (defineProperty && options.name === '__proto__') {
			defineProperty(target, options.name, {
				enumerable: true,
				configurable: true,
				value: options.newValue,
				writable: true
			});
		} else {
			target[options.name] = options.newValue;
		}
	};

	// Return undefined instead of __proto__ if '__proto__' is not an own property
	var getProperty = function getProperty(obj, name) {
		if (name === '__proto__') {
			if (!hasOwn.call(obj, name)) {
				return void 0;
			} else if (gOPD) {
				// In early versions of node, obj['__proto__'] is buggy when obj has
				// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
				return gOPD(obj, name).value;
			}
		}

		return obj[name];
	};

	extend = function extend() {

		var options, name, src, copy, copyIsArray, clone;
		var target = arguments[0];
		var i = 1;
		var length = arguments.length;
		var deep = false;

		// Handle a deep copy situation
		if (typeof target === 'boolean') {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		}
		if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
			target = {};
		}

		for (; i < length; ++i) {
			options = arguments[i];
			// Only deal with non-null/undefined values
			if (options != null) {
				// Extend the base object
				for (name in options) {
					src = getProperty(target, name);
					copy = getProperty(options, name);

					// Prevent never-ending loop
					if (target !== copy) {
						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && isArray(src) ? src : [];
							} else {
								clone = src && isPlainObject(src) ? src : {};
							}

							// Never move original objects, clone them
							setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

						// Don't bring in undefined values
						} else if (typeof copy !== 'undefined') {
							setProperty(target, { name: name, newValue: copy });
						}
					}
				}
			}
		}

		// Return the modified object
		return target;
	};
	return extend;
}

/**
 * Copyright (C) 2014 yanni4night.com
 * index.js
 *
 * changelog
 * 2014-08-16[14:31:02]:authorized
 * 2014-08-19[14:05:43]:fixed crash when first piece is empty
 * 2014-11-16[21:15:06]:support windows \\
 *
 * @author yanni4night@gmail.com
 * @version 0.1.2
 * @since 0.1.0
 */

var urljoin;
var hasRequiredUrljoin;

function requireUrljoin () {
	if (hasRequiredUrljoin) return urljoin;
	hasRequiredUrljoin = 1;

	var extend = requireExtend();
	var url = require$$7;
	var path = path__default;

	/**
	 * Join two or more url pieces into one.
	 *
	 * Only the protocol/port/host in the first piece is saved,but all the get parameters
	 * will be saved.
	 *
	 * @param {String|Function}... Multiple url pieces in function or string type.
	 * @return {String} The URL joined.
	 */
	urljoin = function urljoin() {

	    //convert to Array
	    var pieces = Array.prototype.slice.call(arguments);
	    var query = {};
	    var first, paths;

	    if (!pieces.length) {
	        return '';
	    } else if (1 === pieces.length) {
	        return pieces[0];
	    }

	    paths = pieces.map(function(piece) {
	        var pieceStr = 'function' === typeof piece ? piece() : String(piece || '');

	        if (!pieceStr) {
	            return '';
	        }

	        var parsed = url.parse(pieceStr, true);

	        if (!first && parsed) {
	            first = parsed;
	        }

	        extend(query, parsed.query);
	        return parsed.pathname;
	    }).filter(function(piece) {
	        return !!piece;
	    });

	    delete first.search; //we use query instead of search
	    first.query = query;
	    first.pathname = path.join.apply(path, paths).replace(new RegExp('\\' + path.sep, 'g'), '/');
	    return url.format(first);
	};
	return urljoin;
}

var api;
var hasRequiredApi;

function requireApi () {
	if (hasRequiredApi) return api;
	hasRequiredApi = 1;
	const axios = requireAxios();
	const joinUrl = requireUrljoin();
	function httpRequest(endpoint, queryParams, body, method) {
	    const { baseUrl, keyId, secretKey, apiVersion, oauth } = this.configuration;
	    const req = {
	        method: method || "GET",
	        url: joinUrl(baseUrl, apiVersion, endpoint),
	        params: queryParams || {},
	        headers: oauth !== ""
	            ? {
	                "content-type": method !== "DELETE" ? "application/json" : "",
	                Authorization: "Bearer " + oauth,
	            }
	            : {
	                "content-type": method !== "DELETE" ? "application/json" : "",
	                "APCA-API-KEY-ID": keyId,
	                "APCA-API-SECRET-KEY": secretKey,
	            },
	        data: body || undefined,
	    };
	    return axios(req);
	}
	function dataHttpRequest(endpoint, queryParams, body, method) {
	    const { dataBaseUrl, keyId, secretKey, oauth } = this.configuration;
	    const req = {
	        method: method || "GET",
	        url: joinUrl(dataBaseUrl, "v1", endpoint),
	        params: queryParams || {},
	        headers: oauth !== ""
	            ? {
	                "content-type": method !== "DELETE" ? "application/json" : "",
	                Authorization: "Bearer " + oauth,
	            }
	            : {
	                "content-type": method !== "DELETE" ? "application/json" : "",
	                "APCA-API-KEY-ID": keyId,
	                "APCA-API-SECRET-KEY": secretKey,
	            },
	        data: body || undefined,
	    };
	    return axios(req);
	}
	function sendRequest(f, endpoint, queryParams, body, method) {
	    return f(endpoint, queryParams, body, method).then((resp) => resp.data);
	}
	api = {
	    httpRequest,
	    dataHttpRequest,
	    sendRequest,
	};
	return api;
}

var lodash$1 = {exports: {}};

/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports;

var hasRequiredLodash;

function requireLodash () {
	if (hasRequiredLodash) return lodash$1.exports;
	hasRequiredLodash = 1;
	(function (module, exports$1) {
(function() {

		  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
		  var undefined$1;

		  /** Used as the semantic version number. */
		  var VERSION = '4.17.23';

		  /** Used as the size to enable large array optimizations. */
		  var LARGE_ARRAY_SIZE = 200;

		  /** Error message constants. */
		  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
		      FUNC_ERROR_TEXT = 'Expected a function',
		      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

		  /** Used to stand-in for `undefined` hash values. */
		  var HASH_UNDEFINED = '__lodash_hash_undefined__';

		  /** Used as the maximum memoize cache size. */
		  var MAX_MEMOIZE_SIZE = 500;

		  /** Used as the internal argument placeholder. */
		  var PLACEHOLDER = '__lodash_placeholder__';

		  /** Used to compose bitmasks for cloning. */
		  var CLONE_DEEP_FLAG = 1,
		      CLONE_FLAT_FLAG = 2,
		      CLONE_SYMBOLS_FLAG = 4;

		  /** Used to compose bitmasks for value comparisons. */
		  var COMPARE_PARTIAL_FLAG = 1,
		      COMPARE_UNORDERED_FLAG = 2;

		  /** Used to compose bitmasks for function metadata. */
		  var WRAP_BIND_FLAG = 1,
		      WRAP_BIND_KEY_FLAG = 2,
		      WRAP_CURRY_BOUND_FLAG = 4,
		      WRAP_CURRY_FLAG = 8,
		      WRAP_CURRY_RIGHT_FLAG = 16,
		      WRAP_PARTIAL_FLAG = 32,
		      WRAP_PARTIAL_RIGHT_FLAG = 64,
		      WRAP_ARY_FLAG = 128,
		      WRAP_REARG_FLAG = 256,
		      WRAP_FLIP_FLAG = 512;

		  /** Used as default options for `_.truncate`. */
		  var DEFAULT_TRUNC_LENGTH = 30,
		      DEFAULT_TRUNC_OMISSION = '...';

		  /** Used to detect hot functions by number of calls within a span of milliseconds. */
		  var HOT_COUNT = 800,
		      HOT_SPAN = 16;

		  /** Used to indicate the type of lazy iteratees. */
		  var LAZY_FILTER_FLAG = 1,
		      LAZY_MAP_FLAG = 2,
		      LAZY_WHILE_FLAG = 3;

		  /** Used as references for various `Number` constants. */
		  var INFINITY = 1 / 0,
		      MAX_SAFE_INTEGER = 9007199254740991,
		      MAX_INTEGER = 1.7976931348623157e+308,
		      NAN = 0 / 0;

		  /** Used as references for the maximum length and index of an array. */
		  var MAX_ARRAY_LENGTH = 4294967295,
		      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
		      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

		  /** Used to associate wrap methods with their bit flags. */
		  var wrapFlags = [
		    ['ary', WRAP_ARY_FLAG],
		    ['bind', WRAP_BIND_FLAG],
		    ['bindKey', WRAP_BIND_KEY_FLAG],
		    ['curry', WRAP_CURRY_FLAG],
		    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
		    ['flip', WRAP_FLIP_FLAG],
		    ['partial', WRAP_PARTIAL_FLAG],
		    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
		    ['rearg', WRAP_REARG_FLAG]
		  ];

		  /** `Object#toString` result references. */
		  var argsTag = '[object Arguments]',
		      arrayTag = '[object Array]',
		      asyncTag = '[object AsyncFunction]',
		      boolTag = '[object Boolean]',
		      dateTag = '[object Date]',
		      domExcTag = '[object DOMException]',
		      errorTag = '[object Error]',
		      funcTag = '[object Function]',
		      genTag = '[object GeneratorFunction]',
		      mapTag = '[object Map]',
		      numberTag = '[object Number]',
		      nullTag = '[object Null]',
		      objectTag = '[object Object]',
		      promiseTag = '[object Promise]',
		      proxyTag = '[object Proxy]',
		      regexpTag = '[object RegExp]',
		      setTag = '[object Set]',
		      stringTag = '[object String]',
		      symbolTag = '[object Symbol]',
		      undefinedTag = '[object Undefined]',
		      weakMapTag = '[object WeakMap]',
		      weakSetTag = '[object WeakSet]';

		  var arrayBufferTag = '[object ArrayBuffer]',
		      dataViewTag = '[object DataView]',
		      float32Tag = '[object Float32Array]',
		      float64Tag = '[object Float64Array]',
		      int8Tag = '[object Int8Array]',
		      int16Tag = '[object Int16Array]',
		      int32Tag = '[object Int32Array]',
		      uint8Tag = '[object Uint8Array]',
		      uint8ClampedTag = '[object Uint8ClampedArray]',
		      uint16Tag = '[object Uint16Array]',
		      uint32Tag = '[object Uint32Array]';

		  /** Used to match empty string literals in compiled template source. */
		  var reEmptyStringLeading = /\b__p \+= '';/g,
		      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
		      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

		  /** Used to match HTML entities and HTML characters. */
		  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
		      reUnescapedHtml = /[&<>"']/g,
		      reHasEscapedHtml = RegExp(reEscapedHtml.source),
		      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

		  /** Used to match template delimiters. */
		  var reEscape = /<%-([\s\S]+?)%>/g,
		      reEvaluate = /<%([\s\S]+?)%>/g,
		      reInterpolate = /<%=([\s\S]+?)%>/g;

		  /** Used to match property names within property paths. */
		  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
		      reIsPlainProp = /^\w*$/,
		      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

		  /**
		   * Used to match `RegExp`
		   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
		   */
		  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
		      reHasRegExpChar = RegExp(reRegExpChar.source);

		  /** Used to match leading whitespace. */
		  var reTrimStart = /^\s+/;

		  /** Used to match a single whitespace character. */
		  var reWhitespace = /\s/;

		  /** Used to match wrap detail comments. */
		  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
		      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
		      reSplitDetails = /,? & /;

		  /** Used to match words composed of alphanumeric characters. */
		  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

		  /**
		   * Used to validate the `validate` option in `_.template` variable.
		   *
		   * Forbids characters which could potentially change the meaning of the function argument definition:
		   * - "()," (modification of function parameters)
		   * - "=" (default value)
		   * - "[]{}" (destructuring of function parameters)
		   * - "/" (beginning of a comment)
		   * - whitespace
		   */
		  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

		  /** Used to match backslashes in property paths. */
		  var reEscapeChar = /\\(\\)?/g;

		  /**
		   * Used to match
		   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
		   */
		  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

		  /** Used to match `RegExp` flags from their coerced string values. */
		  var reFlags = /\w*$/;

		  /** Used to detect bad signed hexadecimal string values. */
		  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

		  /** Used to detect binary string values. */
		  var reIsBinary = /^0b[01]+$/i;

		  /** Used to detect host constructors (Safari). */
		  var reIsHostCtor = /^\[object .+?Constructor\]$/;

		  /** Used to detect octal string values. */
		  var reIsOctal = /^0o[0-7]+$/i;

		  /** Used to detect unsigned integer values. */
		  var reIsUint = /^(?:0|[1-9]\d*)$/;

		  /** Used to match Latin Unicode letters (excluding mathematical operators). */
		  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

		  /** Used to ensure capturing order of template delimiters. */
		  var reNoMatch = /($^)/;

		  /** Used to match unescaped characters in compiled string literals. */
		  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

		  /** Used to compose unicode character classes. */
		  var rsAstralRange = '\\ud800-\\udfff',
		      rsComboMarksRange = '\\u0300-\\u036f',
		      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
		      rsComboSymbolsRange = '\\u20d0-\\u20ff',
		      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
		      rsDingbatRange = '\\u2700-\\u27bf',
		      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
		      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
		      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
		      rsPunctuationRange = '\\u2000-\\u206f',
		      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
		      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
		      rsVarRange = '\\ufe0e\\ufe0f',
		      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

		  /** Used to compose unicode capture groups. */
		  var rsApos = "['\u2019]",
		      rsAstral = '[' + rsAstralRange + ']',
		      rsBreak = '[' + rsBreakRange + ']',
		      rsCombo = '[' + rsComboRange + ']',
		      rsDigits = '\\d+',
		      rsDingbat = '[' + rsDingbatRange + ']',
		      rsLower = '[' + rsLowerRange + ']',
		      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
		      rsFitz = '\\ud83c[\\udffb-\\udfff]',
		      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
		      rsNonAstral = '[^' + rsAstralRange + ']',
		      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
		      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
		      rsUpper = '[' + rsUpperRange + ']',
		      rsZWJ = '\\u200d';

		  /** Used to compose unicode regexes. */
		  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
		      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
		      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
		      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
		      reOptMod = rsModifier + '?',
		      rsOptVar = '[' + rsVarRange + ']?',
		      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
		      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
		      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
		      rsSeq = rsOptVar + reOptMod + rsOptJoin,
		      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
		      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

		  /** Used to match apostrophes. */
		  var reApos = RegExp(rsApos, 'g');

		  /**
		   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
		   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
		   */
		  var reComboMark = RegExp(rsCombo, 'g');

		  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
		  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

		  /** Used to match complex or compound words. */
		  var reUnicodeWord = RegExp([
		    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
		    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
		    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
		    rsUpper + '+' + rsOptContrUpper,
		    rsOrdUpper,
		    rsOrdLower,
		    rsDigits,
		    rsEmoji
		  ].join('|'), 'g');

		  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
		  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

		  /** Used to detect strings that need a more robust regexp to match words. */
		  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

		  /** Used to assign default `context` object properties. */
		  var contextProps = [
		    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
		    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
		    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
		    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
		    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
		  ];

		  /** Used to make template sourceURLs easier to identify. */
		  var templateCounter = -1;

		  /** Used to identify `toStringTag` values of typed arrays. */
		  var typedArrayTags = {};
		  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
		  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
		  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
		  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
		  typedArrayTags[uint32Tag] = true;
		  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
		  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
		  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
		  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
		  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
		  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
		  typedArrayTags[setTag] = typedArrayTags[stringTag] =
		  typedArrayTags[weakMapTag] = false;

		  /** Used to identify `toStringTag` values supported by `_.clone`. */
		  var cloneableTags = {};
		  cloneableTags[argsTag] = cloneableTags[arrayTag] =
		  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
		  cloneableTags[boolTag] = cloneableTags[dateTag] =
		  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
		  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
		  cloneableTags[int32Tag] = cloneableTags[mapTag] =
		  cloneableTags[numberTag] = cloneableTags[objectTag] =
		  cloneableTags[regexpTag] = cloneableTags[setTag] =
		  cloneableTags[stringTag] = cloneableTags[symbolTag] =
		  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
		  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
		  cloneableTags[errorTag] = cloneableTags[funcTag] =
		  cloneableTags[weakMapTag] = false;

		  /** Used to map Latin Unicode letters to basic Latin letters. */
		  var deburredLetters = {
		    // Latin-1 Supplement block.
		    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
		    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
		    '\xc7': 'C',  '\xe7': 'c',
		    '\xd0': 'D',  '\xf0': 'd',
		    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
		    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
		    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
		    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
		    '\xd1': 'N',  '\xf1': 'n',
		    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
		    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
		    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
		    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
		    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
		    '\xc6': 'Ae', '\xe6': 'ae',
		    '\xde': 'Th', '\xfe': 'th',
		    '\xdf': 'ss',
		    // Latin Extended-A block.
		    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
		    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
		    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
		    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
		    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
		    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
		    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
		    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
		    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
		    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
		    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
		    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
		    '\u0134': 'J',  '\u0135': 'j',
		    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
		    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
		    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
		    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
		    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
		    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
		    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
		    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
		    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
		    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
		    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
		    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
		    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
		    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
		    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
		    '\u0174': 'W',  '\u0175': 'w',
		    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
		    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
		    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
		    '\u0132': 'IJ', '\u0133': 'ij',
		    '\u0152': 'Oe', '\u0153': 'oe',
		    '\u0149': "'n", '\u017f': 's'
		  };

		  /** Used to map characters to HTML entities. */
		  var htmlEscapes = {
		    '&': '&amp;',
		    '<': '&lt;',
		    '>': '&gt;',
		    '"': '&quot;',
		    "'": '&#39;'
		  };

		  /** Used to map HTML entities to characters. */
		  var htmlUnescapes = {
		    '&amp;': '&',
		    '&lt;': '<',
		    '&gt;': '>',
		    '&quot;': '"',
		    '&#39;': "'"
		  };

		  /** Used to escape characters for inclusion in compiled string literals. */
		  var stringEscapes = {
		    '\\': '\\',
		    "'": "'",
		    '\n': 'n',
		    '\r': 'r',
		    '\u2028': 'u2028',
		    '\u2029': 'u2029'
		  };

		  /** Built-in method references without a dependency on `root`. */
		  var freeParseFloat = parseFloat,
		      freeParseInt = parseInt;

		  /** Detect free variable `global` from Node.js. */
		  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

		  /** Detect free variable `self`. */
		  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

		  /** Used as a reference to the global object. */
		  var root = freeGlobal || freeSelf || Function('return this')();

		  /** Detect free variable `exports`. */
		  var freeExports = exports$1 && !exports$1.nodeType && exports$1;

		  /** Detect free variable `module`. */
		  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		  /** Detect the popular CommonJS extension `module.exports`. */
		  var moduleExports = freeModule && freeModule.exports === freeExports;

		  /** Detect free variable `process` from Node.js. */
		  var freeProcess = moduleExports && freeGlobal.process;

		  /** Used to access faster Node.js helpers. */
		  var nodeUtil = (function() {
		    try {
		      // Use `util.types` for Node.js 10+.
		      var types = freeModule && freeModule.require && freeModule.require('util').types;

		      if (types) {
		        return types;
		      }

		      // Legacy `process.binding('util')` for Node.js < 10.
		      return freeProcess && freeProcess.binding && freeProcess.binding('util');
		    } catch (e) {}
		  }());

		  /* Node.js helper references. */
		  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
		      nodeIsDate = nodeUtil && nodeUtil.isDate,
		      nodeIsMap = nodeUtil && nodeUtil.isMap,
		      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
		      nodeIsSet = nodeUtil && nodeUtil.isSet,
		      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

		  /*--------------------------------------------------------------------------*/

		  /**
		   * A faster alternative to `Function#apply`, this function invokes `func`
		   * with the `this` binding of `thisArg` and the arguments of `args`.
		   *
		   * @private
		   * @param {Function} func The function to invoke.
		   * @param {*} thisArg The `this` binding of `func`.
		   * @param {Array} args The arguments to invoke `func` with.
		   * @returns {*} Returns the result of `func`.
		   */
		  function apply(func, thisArg, args) {
		    switch (args.length) {
		      case 0: return func.call(thisArg);
		      case 1: return func.call(thisArg, args[0]);
		      case 2: return func.call(thisArg, args[0], args[1]);
		      case 3: return func.call(thisArg, args[0], args[1], args[2]);
		    }
		    return func.apply(thisArg, args);
		  }

		  /**
		   * A specialized version of `baseAggregator` for arrays.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} setter The function to set `accumulator` values.
		   * @param {Function} iteratee The iteratee to transform keys.
		   * @param {Object} accumulator The initial aggregated object.
		   * @returns {Function} Returns `accumulator`.
		   */
		  function arrayAggregator(array, setter, iteratee, accumulator) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      var value = array[index];
		      setter(accumulator, value, iteratee(value), array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.forEach` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayEach(array, iteratee) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (iteratee(array[index], index, array) === false) {
		        break;
		      }
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.forEachRight` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayEachRight(array, iteratee) {
		    var length = array == null ? 0 : array.length;

		    while (length--) {
		      if (iteratee(array[length], length, array) === false) {
		        break;
		      }
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.every` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {boolean} Returns `true` if all elements pass the predicate check,
		   *  else `false`.
		   */
		  function arrayEvery(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (!predicate(array[index], index, array)) {
		        return false;
		      }
		    }
		    return true;
		  }

		  /**
		   * A specialized version of `_.filter` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {Array} Returns the new filtered array.
		   */
		  function arrayFilter(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length,
		        resIndex = 0,
		        result = [];

		    while (++index < length) {
		      var value = array[index];
		      if (predicate(value, index, array)) {
		        result[resIndex++] = value;
		      }
		    }
		    return result;
		  }

		  /**
		   * A specialized version of `_.includes` for arrays without support for
		   * specifying an index to search from.
		   *
		   * @private
		   * @param {Array} [array] The array to inspect.
		   * @param {*} target The value to search for.
		   * @returns {boolean} Returns `true` if `target` is found, else `false`.
		   */
		  function arrayIncludes(array, value) {
		    var length = array == null ? 0 : array.length;
		    return !!length && baseIndexOf(array, value, 0) > -1;
		  }

		  /**
		   * This function is like `arrayIncludes` except that it accepts a comparator.
		   *
		   * @private
		   * @param {Array} [array] The array to inspect.
		   * @param {*} target The value to search for.
		   * @param {Function} comparator The comparator invoked per element.
		   * @returns {boolean} Returns `true` if `target` is found, else `false`.
		   */
		  function arrayIncludesWith(array, value, comparator) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (comparator(value, array[index])) {
		        return true;
		      }
		    }
		    return false;
		  }

		  /**
		   * A specialized version of `_.map` for arrays without support for iteratee
		   * shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns the new mapped array.
		   */
		  function arrayMap(array, iteratee) {
		    var index = -1,
		        length = array == null ? 0 : array.length,
		        result = Array(length);

		    while (++index < length) {
		      result[index] = iteratee(array[index], index, array);
		    }
		    return result;
		  }

		  /**
		   * Appends the elements of `values` to `array`.
		   *
		   * @private
		   * @param {Array} array The array to modify.
		   * @param {Array} values The values to append.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayPush(array, values) {
		    var index = -1,
		        length = values.length,
		        offset = array.length;

		    while (++index < length) {
		      array[offset + index] = values[index];
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.reduce` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} [accumulator] The initial value.
		   * @param {boolean} [initAccum] Specify using the first element of `array` as
		   *  the initial value.
		   * @returns {*} Returns the accumulated value.
		   */
		  function arrayReduce(array, iteratee, accumulator, initAccum) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    if (initAccum && length) {
		      accumulator = array[++index];
		    }
		    while (++index < length) {
		      accumulator = iteratee(accumulator, array[index], index, array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.reduceRight` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} [accumulator] The initial value.
		   * @param {boolean} [initAccum] Specify using the last element of `array` as
		   *  the initial value.
		   * @returns {*} Returns the accumulated value.
		   */
		  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
		    var length = array == null ? 0 : array.length;
		    if (initAccum && length) {
		      accumulator = array[--length];
		    }
		    while (length--) {
		      accumulator = iteratee(accumulator, array[length], length, array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.some` for arrays without support for iteratee
		   * shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {boolean} Returns `true` if any element passes the predicate check,
		   *  else `false`.
		   */
		  function arraySome(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (predicate(array[index], index, array)) {
		        return true;
		      }
		    }
		    return false;
		  }

		  /**
		   * Gets the size of an ASCII `string`.
		   *
		   * @private
		   * @param {string} string The string inspect.
		   * @returns {number} Returns the string size.
		   */
		  var asciiSize = baseProperty('length');

		  /**
		   * Converts an ASCII `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function asciiToArray(string) {
		    return string.split('');
		  }

		  /**
		   * Splits an ASCII `string` into an array of its words.
		   *
		   * @private
		   * @param {string} The string to inspect.
		   * @returns {Array} Returns the words of `string`.
		   */
		  function asciiWords(string) {
		    return string.match(reAsciiWord) || [];
		  }

		  /**
		   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
		   * without support for iteratee shorthands, which iterates over `collection`
		   * using `eachFunc`.
		   *
		   * @private
		   * @param {Array|Object} collection The collection to inspect.
		   * @param {Function} predicate The function invoked per iteration.
		   * @param {Function} eachFunc The function to iterate over `collection`.
		   * @returns {*} Returns the found element or its key, else `undefined`.
		   */
		  function baseFindKey(collection, predicate, eachFunc) {
		    var result;
		    eachFunc(collection, function(value, key, collection) {
		      if (predicate(value, key, collection)) {
		        result = key;
		        return false;
		      }
		    });
		    return result;
		  }

		  /**
		   * The base implementation of `_.findIndex` and `_.findLastIndex` without
		   * support for iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {Function} predicate The function invoked per iteration.
		   * @param {number} fromIndex The index to search from.
		   * @param {boolean} [fromRight] Specify iterating from right to left.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseFindIndex(array, predicate, fromIndex, fromRight) {
		    var length = array.length,
		        index = fromIndex + (fromRight ? 1 : -1);

		    while ((fromRight ? index-- : ++index < length)) {
		      if (predicate(array[index], index, array)) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseIndexOf(array, value, fromIndex) {
		    return value === value
		      ? strictIndexOf(array, value, fromIndex)
		      : baseFindIndex(array, baseIsNaN, fromIndex);
		  }

		  /**
		   * This function is like `baseIndexOf` except that it accepts a comparator.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @param {Function} comparator The comparator invoked per element.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseIndexOfWith(array, value, fromIndex, comparator) {
		    var index = fromIndex - 1,
		        length = array.length;

		    while (++index < length) {
		      if (comparator(array[index], value)) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * The base implementation of `_.isNaN` without support for number objects.
		   *
		   * @private
		   * @param {*} value The value to check.
		   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
		   */
		  function baseIsNaN(value) {
		    return value !== value;
		  }

		  /**
		   * The base implementation of `_.mean` and `_.meanBy` without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {number} Returns the mean.
		   */
		  function baseMean(array, iteratee) {
		    var length = array == null ? 0 : array.length;
		    return length ? (baseSum(array, iteratee) / length) : NAN;
		  }

		  /**
		   * The base implementation of `_.property` without support for deep paths.
		   *
		   * @private
		   * @param {string} key The key of the property to get.
		   * @returns {Function} Returns the new accessor function.
		   */
		  function baseProperty(key) {
		    return function(object) {
		      return object == null ? undefined$1 : object[key];
		    };
		  }

		  /**
		   * The base implementation of `_.propertyOf` without support for deep paths.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @returns {Function} Returns the new accessor function.
		   */
		  function basePropertyOf(object) {
		    return function(key) {
		      return object == null ? undefined$1 : object[key];
		    };
		  }

		  /**
		   * The base implementation of `_.reduce` and `_.reduceRight`, without support
		   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
		   *
		   * @private
		   * @param {Array|Object} collection The collection to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} accumulator The initial value.
		   * @param {boolean} initAccum Specify using the first or last element of
		   *  `collection` as the initial value.
		   * @param {Function} eachFunc The function to iterate over `collection`.
		   * @returns {*} Returns the accumulated value.
		   */
		  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
		    eachFunc(collection, function(value, index, collection) {
		      accumulator = initAccum
		        ? (initAccum = false, value)
		        : iteratee(accumulator, value, index, collection);
		    });
		    return accumulator;
		  }

		  /**
		   * The base implementation of `_.sortBy` which uses `comparer` to define the
		   * sort order of `array` and replaces criteria objects with their corresponding
		   * values.
		   *
		   * @private
		   * @param {Array} array The array to sort.
		   * @param {Function} comparer The function to define sort order.
		   * @returns {Array} Returns `array`.
		   */
		  function baseSortBy(array, comparer) {
		    var length = array.length;

		    array.sort(comparer);
		    while (length--) {
		      array[length] = array[length].value;
		    }
		    return array;
		  }

		  /**
		   * The base implementation of `_.sum` and `_.sumBy` without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {number} Returns the sum.
		   */
		  function baseSum(array, iteratee) {
		    var result,
		        index = -1,
		        length = array.length;

		    while (++index < length) {
		      var current = iteratee(array[index]);
		      if (current !== undefined$1) {
		        result = result === undefined$1 ? current : (result + current);
		      }
		    }
		    return result;
		  }

		  /**
		   * The base implementation of `_.times` without support for iteratee shorthands
		   * or max array length checks.
		   *
		   * @private
		   * @param {number} n The number of times to invoke `iteratee`.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns the array of results.
		   */
		  function baseTimes(n, iteratee) {
		    var index = -1,
		        result = Array(n);

		    while (++index < n) {
		      result[index] = iteratee(index);
		    }
		    return result;
		  }

		  /**
		   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
		   * of key-value pairs for `object` corresponding to the property names of `props`.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @param {Array} props The property names to get values for.
		   * @returns {Object} Returns the key-value pairs.
		   */
		  function baseToPairs(object, props) {
		    return arrayMap(props, function(key) {
		      return [key, object[key]];
		    });
		  }

		  /**
		   * The base implementation of `_.trim`.
		   *
		   * @private
		   * @param {string} string The string to trim.
		   * @returns {string} Returns the trimmed string.
		   */
		  function baseTrim(string) {
		    return string
		      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
		      : string;
		  }

		  /**
		   * The base implementation of `_.unary` without support for storing metadata.
		   *
		   * @private
		   * @param {Function} func The function to cap arguments for.
		   * @returns {Function} Returns the new capped function.
		   */
		  function baseUnary(func) {
		    return function(value) {
		      return func(value);
		    };
		  }

		  /**
		   * The base implementation of `_.values` and `_.valuesIn` which creates an
		   * array of `object` property values corresponding to the property names
		   * of `props`.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @param {Array} props The property names to get values for.
		   * @returns {Object} Returns the array of property values.
		   */
		  function baseValues(object, props) {
		    return arrayMap(props, function(key) {
		      return object[key];
		    });
		  }

		  /**
		   * Checks if a `cache` value for `key` exists.
		   *
		   * @private
		   * @param {Object} cache The cache to query.
		   * @param {string} key The key of the entry to check.
		   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		   */
		  function cacheHas(cache, key) {
		    return cache.has(key);
		  }

		  /**
		   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
		   * that is not found in the character symbols.
		   *
		   * @private
		   * @param {Array} strSymbols The string symbols to inspect.
		   * @param {Array} chrSymbols The character symbols to find.
		   * @returns {number} Returns the index of the first unmatched string symbol.
		   */
		  function charsStartIndex(strSymbols, chrSymbols) {
		    var index = -1,
		        length = strSymbols.length;

		    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		    return index;
		  }

		  /**
		   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
		   * that is not found in the character symbols.
		   *
		   * @private
		   * @param {Array} strSymbols The string symbols to inspect.
		   * @param {Array} chrSymbols The character symbols to find.
		   * @returns {number} Returns the index of the last unmatched string symbol.
		   */
		  function charsEndIndex(strSymbols, chrSymbols) {
		    var index = strSymbols.length;

		    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		    return index;
		  }

		  /**
		   * Gets the number of `placeholder` occurrences in `array`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} placeholder The placeholder to search for.
		   * @returns {number} Returns the placeholder count.
		   */
		  function countHolders(array, placeholder) {
		    var length = array.length,
		        result = 0;

		    while (length--) {
		      if (array[length] === placeholder) {
		        ++result;
		      }
		    }
		    return result;
		  }

		  /**
		   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
		   * letters to basic Latin letters.
		   *
		   * @private
		   * @param {string} letter The matched letter to deburr.
		   * @returns {string} Returns the deburred letter.
		   */
		  var deburrLetter = basePropertyOf(deburredLetters);

		  /**
		   * Used by `_.escape` to convert characters to HTML entities.
		   *
		   * @private
		   * @param {string} chr The matched character to escape.
		   * @returns {string} Returns the escaped character.
		   */
		  var escapeHtmlChar = basePropertyOf(htmlEscapes);

		  /**
		   * Used by `_.template` to escape characters for inclusion in compiled string literals.
		   *
		   * @private
		   * @param {string} chr The matched character to escape.
		   * @returns {string} Returns the escaped character.
		   */
		  function escapeStringChar(chr) {
		    return '\\' + stringEscapes[chr];
		  }

		  /**
		   * Gets the value at `key` of `object`.
		   *
		   * @private
		   * @param {Object} [object] The object to query.
		   * @param {string} key The key of the property to get.
		   * @returns {*} Returns the property value.
		   */
		  function getValue(object, key) {
		    return object == null ? undefined$1 : object[key];
		  }

		  /**
		   * Checks if `string` contains Unicode symbols.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
		   */
		  function hasUnicode(string) {
		    return reHasUnicode.test(string);
		  }

		  /**
		   * Checks if `string` contains a word composed of Unicode symbols.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {boolean} Returns `true` if a word is found, else `false`.
		   */
		  function hasUnicodeWord(string) {
		    return reHasUnicodeWord.test(string);
		  }

		  /**
		   * Converts `iterator` to an array.
		   *
		   * @private
		   * @param {Object} iterator The iterator to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function iteratorToArray(iterator) {
		    var data,
		        result = [];

		    while (!(data = iterator.next()).done) {
		      result.push(data.value);
		    }
		    return result;
		  }

		  /**
		   * Converts `map` to its key-value pairs.
		   *
		   * @private
		   * @param {Object} map The map to convert.
		   * @returns {Array} Returns the key-value pairs.
		   */
		  function mapToArray(map) {
		    var index = -1,
		        result = Array(map.size);

		    map.forEach(function(value, key) {
		      result[++index] = [key, value];
		    });
		    return result;
		  }

		  /**
		   * Creates a unary function that invokes `func` with its argument transformed.
		   *
		   * @private
		   * @param {Function} func The function to wrap.
		   * @param {Function} transform The argument transform.
		   * @returns {Function} Returns the new function.
		   */
		  function overArg(func, transform) {
		    return function(arg) {
		      return func(transform(arg));
		    };
		  }

		  /**
		   * Replaces all `placeholder` elements in `array` with an internal placeholder
		   * and returns an array of their indexes.
		   *
		   * @private
		   * @param {Array} array The array to modify.
		   * @param {*} placeholder The placeholder to replace.
		   * @returns {Array} Returns the new array of placeholder indexes.
		   */
		  function replaceHolders(array, placeholder) {
		    var index = -1,
		        length = array.length,
		        resIndex = 0,
		        result = [];

		    while (++index < length) {
		      var value = array[index];
		      if (value === placeholder || value === PLACEHOLDER) {
		        array[index] = PLACEHOLDER;
		        result[resIndex++] = index;
		      }
		    }
		    return result;
		  }

		  /**
		   * Converts `set` to an array of its values.
		   *
		   * @private
		   * @param {Object} set The set to convert.
		   * @returns {Array} Returns the values.
		   */
		  function setToArray(set) {
		    var index = -1,
		        result = Array(set.size);

		    set.forEach(function(value) {
		      result[++index] = value;
		    });
		    return result;
		  }

		  /**
		   * Converts `set` to its value-value pairs.
		   *
		   * @private
		   * @param {Object} set The set to convert.
		   * @returns {Array} Returns the value-value pairs.
		   */
		  function setToPairs(set) {
		    var index = -1,
		        result = Array(set.size);

		    set.forEach(function(value) {
		      result[++index] = [value, value];
		    });
		    return result;
		  }

		  /**
		   * A specialized version of `_.indexOf` which performs strict equality
		   * comparisons of values, i.e. `===`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function strictIndexOf(array, value, fromIndex) {
		    var index = fromIndex - 1,
		        length = array.length;

		    while (++index < length) {
		      if (array[index] === value) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * A specialized version of `_.lastIndexOf` which performs strict equality
		   * comparisons of values, i.e. `===`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function strictLastIndexOf(array, value, fromIndex) {
		    var index = fromIndex + 1;
		    while (index--) {
		      if (array[index] === value) {
		        return index;
		      }
		    }
		    return index;
		  }

		  /**
		   * Gets the number of symbols in `string`.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {number} Returns the string size.
		   */
		  function stringSize(string) {
		    return hasUnicode(string)
		      ? unicodeSize(string)
		      : asciiSize(string);
		  }

		  /**
		   * Converts `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function stringToArray(string) {
		    return hasUnicode(string)
		      ? unicodeToArray(string)
		      : asciiToArray(string);
		  }

		  /**
		   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
		   * character of `string`.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {number} Returns the index of the last non-whitespace character.
		   */
		  function trimmedEndIndex(string) {
		    var index = string.length;

		    while (index-- && reWhitespace.test(string.charAt(index))) {}
		    return index;
		  }

		  /**
		   * Used by `_.unescape` to convert HTML entities to characters.
		   *
		   * @private
		   * @param {string} chr The matched character to unescape.
		   * @returns {string} Returns the unescaped character.
		   */
		  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

		  /**
		   * Gets the size of a Unicode `string`.
		   *
		   * @private
		   * @param {string} string The string inspect.
		   * @returns {number} Returns the string size.
		   */
		  function unicodeSize(string) {
		    var result = reUnicode.lastIndex = 0;
		    while (reUnicode.test(string)) {
		      ++result;
		    }
		    return result;
		  }

		  /**
		   * Converts a Unicode `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function unicodeToArray(string) {
		    return string.match(reUnicode) || [];
		  }

		  /**
		   * Splits a Unicode `string` into an array of its words.
		   *
		   * @private
		   * @param {string} The string to inspect.
		   * @returns {Array} Returns the words of `string`.
		   */
		  function unicodeWords(string) {
		    return string.match(reUnicodeWord) || [];
		  }

		  /*--------------------------------------------------------------------------*/

		  /**
		   * Create a new pristine `lodash` function using the `context` object.
		   *
		   * @static
		   * @memberOf _
		   * @since 1.1.0
		   * @category Util
		   * @param {Object} [context=root] The context object.
		   * @returns {Function} Returns a new `lodash` function.
		   * @example
		   *
		   * _.mixin({ 'foo': _.constant('foo') });
		   *
		   * var lodash = _.runInContext();
		   * lodash.mixin({ 'bar': lodash.constant('bar') });
		   *
		   * _.isFunction(_.foo);
		   * // => true
		   * _.isFunction(_.bar);
		   * // => false
		   *
		   * lodash.isFunction(lodash.foo);
		   * // => false
		   * lodash.isFunction(lodash.bar);
		   * // => true
		   *
		   * // Create a suped-up `defer` in Node.js.
		   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
		   */
		  var runInContext = (function runInContext(context) {
		    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

		    /** Built-in constructor references. */
		    var Array = context.Array,
		        Date = context.Date,
		        Error = context.Error,
		        Function = context.Function,
		        Math = context.Math,
		        Object = context.Object,
		        RegExp = context.RegExp,
		        String = context.String,
		        TypeError = context.TypeError;

		    /** Used for built-in method references. */
		    var arrayProto = Array.prototype,
		        funcProto = Function.prototype,
		        objectProto = Object.prototype;

		    /** Used to detect overreaching core-js shims. */
		    var coreJsData = context['__core-js_shared__'];

		    /** Used to resolve the decompiled source of functions. */
		    var funcToString = funcProto.toString;

		    /** Used to check objects for own properties. */
		    var hasOwnProperty = objectProto.hasOwnProperty;

		    /** Used to generate unique IDs. */
		    var idCounter = 0;

		    /** Used to detect methods masquerading as native. */
		    var maskSrcKey = (function() {
		      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
		      return uid ? ('Symbol(src)_1.' + uid) : '';
		    }());

		    /**
		     * Used to resolve the
		     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
		     * of values.
		     */
		    var nativeObjectToString = objectProto.toString;

		    /** Used to infer the `Object` constructor. */
		    var objectCtorString = funcToString.call(Object);

		    /** Used to restore the original `_` reference in `_.noConflict`. */
		    var oldDash = root._;

		    /** Used to detect if a method is native. */
		    var reIsNative = RegExp('^' +
		      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
		      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
		    );

		    /** Built-in value references. */
		    var Buffer = moduleExports ? context.Buffer : undefined$1,
		        Symbol = context.Symbol,
		        Uint8Array = context.Uint8Array,
		        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
		        getPrototype = overArg(Object.getPrototypeOf, Object),
		        objectCreate = Object.create,
		        propertyIsEnumerable = objectProto.propertyIsEnumerable,
		        splice = arrayProto.splice,
		        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
		        symIterator = Symbol ? Symbol.iterator : undefined$1,
		        symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

		    var defineProperty = (function() {
		      try {
		        var func = getNative(Object, 'defineProperty');
		        func({}, '', {});
		        return func;
		      } catch (e) {}
		    }());

		    /** Mocked built-ins. */
		    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
		        ctxNow = Date && Date.now !== root.Date.now && Date.now,
		        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

		    /* Built-in method references for those with the same name as other `lodash` methods. */
		    var nativeCeil = Math.ceil,
		        nativeFloor = Math.floor,
		        nativeGetSymbols = Object.getOwnPropertySymbols,
		        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
		        nativeIsFinite = context.isFinite,
		        nativeJoin = arrayProto.join,
		        nativeKeys = overArg(Object.keys, Object),
		        nativeMax = Math.max,
		        nativeMin = Math.min,
		        nativeNow = Date.now,
		        nativeParseInt = context.parseInt,
		        nativeRandom = Math.random,
		        nativeReverse = arrayProto.reverse;

		    /* Built-in method references that are verified to be native. */
		    var DataView = getNative(context, 'DataView'),
		        Map = getNative(context, 'Map'),
		        Promise = getNative(context, 'Promise'),
		        Set = getNative(context, 'Set'),
		        WeakMap = getNative(context, 'WeakMap'),
		        nativeCreate = getNative(Object, 'create');

		    /** Used to store function metadata. */
		    var metaMap = WeakMap && new WeakMap;

		    /** Used to lookup unminified function names. */
		    var realNames = {};

		    /** Used to detect maps, sets, and weakmaps. */
		    var dataViewCtorString = toSource(DataView),
		        mapCtorString = toSource(Map),
		        promiseCtorString = toSource(Promise),
		        setCtorString = toSource(Set),
		        weakMapCtorString = toSource(WeakMap);

		    /** Used to convert symbols to primitives and strings. */
		    var symbolProto = Symbol ? Symbol.prototype : undefined$1,
		        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
		        symbolToString = symbolProto ? symbolProto.toString : undefined$1;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a `lodash` object which wraps `value` to enable implicit method
		     * chain sequences. Methods that operate on and return arrays, collections,
		     * and functions can be chained together. Methods that retrieve a single value
		     * or may return a primitive value will automatically end the chain sequence
		     * and return the unwrapped value. Otherwise, the value must be unwrapped
		     * with `_#value`.
		     *
		     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
		     * enabled using `_.chain`.
		     *
		     * The execution of chained methods is lazy, that is, it's deferred until
		     * `_#value` is implicitly or explicitly called.
		     *
		     * Lazy evaluation allows several methods to support shortcut fusion.
		     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
		     * the creation of intermediate arrays and can greatly reduce the number of
		     * iteratee executions. Sections of a chain sequence qualify for shortcut
		     * fusion if the section is applied to an array and iteratees accept only
		     * one argument. The heuristic for whether a section qualifies for shortcut
		     * fusion is subject to change.
		     *
		     * Chaining is supported in custom builds as long as the `_#value` method is
		     * directly or indirectly included in the build.
		     *
		     * In addition to lodash methods, wrappers have `Array` and `String` methods.
		     *
		     * The wrapper `Array` methods are:
		     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
		     *
		     * The wrapper `String` methods are:
		     * `replace` and `split`
		     *
		     * The wrapper methods that support shortcut fusion are:
		     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
		     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
		     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
		     *
		     * The chainable wrapper methods are:
		     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
		     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
		     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
		     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
		     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
		     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
		     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
		     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
		     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
		     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
		     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
		     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
		     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
		     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
		     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
		     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
		     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
		     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
		     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
		     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
		     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
		     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
		     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
		     * `zipObject`, `zipObjectDeep`, and `zipWith`
		     *
		     * The wrapper methods that are **not** chainable by default are:
		     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
		     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
		     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
		     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
		     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
		     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
		     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
		     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
		     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
		     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
		     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
		     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
		     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
		     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
		     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
		     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
		     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
		     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
		     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
		     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
		     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
		     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
		     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
		     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
		     * `upperFirst`, `value`, and `words`
		     *
		     * @name _
		     * @constructor
		     * @category Seq
		     * @param {*} value The value to wrap in a `lodash` instance.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var wrapped = _([1, 2, 3]);
		     *
		     * // Returns an unwrapped value.
		     * wrapped.reduce(_.add);
		     * // => 6
		     *
		     * // Returns a wrapped value.
		     * var squares = wrapped.map(square);
		     *
		     * _.isArray(squares);
		     * // => false
		     *
		     * _.isArray(squares.value());
		     * // => true
		     */
		    function lodash(value) {
		      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
		        if (value instanceof LodashWrapper) {
		          return value;
		        }
		        if (hasOwnProperty.call(value, '__wrapped__')) {
		          return wrapperClone(value);
		        }
		      }
		      return new LodashWrapper(value);
		    }

		    /**
		     * The base implementation of `_.create` without support for assigning
		     * properties to the created object.
		     *
		     * @private
		     * @param {Object} proto The object to inherit from.
		     * @returns {Object} Returns the new object.
		     */
		    var baseCreate = (function() {
		      function object() {}
		      return function(proto) {
		        if (!isObject(proto)) {
		          return {};
		        }
		        if (objectCreate) {
		          return objectCreate(proto);
		        }
		        object.prototype = proto;
		        var result = new object;
		        object.prototype = undefined$1;
		        return result;
		      };
		    }());

		    /**
		     * The function whose prototype chain sequence wrappers inherit from.
		     *
		     * @private
		     */
		    function baseLodash() {
		      // No operation performed.
		    }

		    /**
		     * The base constructor for creating `lodash` wrapper objects.
		     *
		     * @private
		     * @param {*} value The value to wrap.
		     * @param {boolean} [chainAll] Enable explicit method chain sequences.
		     */
		    function LodashWrapper(value, chainAll) {
		      this.__wrapped__ = value;
		      this.__actions__ = [];
		      this.__chain__ = !!chainAll;
		      this.__index__ = 0;
		      this.__values__ = undefined$1;
		    }

		    /**
		     * By default, the template delimiters used by lodash are like those in
		     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
		     * following template settings to use alternative delimiters.
		     *
		     * @static
		     * @memberOf _
		     * @type {Object}
		     */
		    lodash.templateSettings = {

		      /**
		       * Used to detect `data` property values to be HTML-escaped.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'escape': reEscape,

		      /**
		       * Used to detect code to be evaluated.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'evaluate': reEvaluate,

		      /**
		       * Used to detect `data` property values to inject.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'interpolate': reInterpolate,

		      /**
		       * Used to reference the data object in the template text.
		       *
		       * @memberOf _.templateSettings
		       * @type {string}
		       */
		      'variable': '',

		      /**
		       * Used to import variables into the compiled template.
		       *
		       * @memberOf _.templateSettings
		       * @type {Object}
		       */
		      'imports': {

		        /**
		         * A reference to the `lodash` function.
		         *
		         * @memberOf _.templateSettings.imports
		         * @type {Function}
		         */
		        '_': lodash
		      }
		    };

		    // Ensure wrappers are instances of `baseLodash`.
		    lodash.prototype = baseLodash.prototype;
		    lodash.prototype.constructor = lodash;

		    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
		    LodashWrapper.prototype.constructor = LodashWrapper;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
		     *
		     * @private
		     * @constructor
		     * @param {*} value The value to wrap.
		     */
		    function LazyWrapper(value) {
		      this.__wrapped__ = value;
		      this.__actions__ = [];
		      this.__dir__ = 1;
		      this.__filtered__ = false;
		      this.__iteratees__ = [];
		      this.__takeCount__ = MAX_ARRAY_LENGTH;
		      this.__views__ = [];
		    }

		    /**
		     * Creates a clone of the lazy wrapper object.
		     *
		     * @private
		     * @name clone
		     * @memberOf LazyWrapper
		     * @returns {Object} Returns the cloned `LazyWrapper` object.
		     */
		    function lazyClone() {
		      var result = new LazyWrapper(this.__wrapped__);
		      result.__actions__ = copyArray(this.__actions__);
		      result.__dir__ = this.__dir__;
		      result.__filtered__ = this.__filtered__;
		      result.__iteratees__ = copyArray(this.__iteratees__);
		      result.__takeCount__ = this.__takeCount__;
		      result.__views__ = copyArray(this.__views__);
		      return result;
		    }

		    /**
		     * Reverses the direction of lazy iteration.
		     *
		     * @private
		     * @name reverse
		     * @memberOf LazyWrapper
		     * @returns {Object} Returns the new reversed `LazyWrapper` object.
		     */
		    function lazyReverse() {
		      if (this.__filtered__) {
		        var result = new LazyWrapper(this);
		        result.__dir__ = -1;
		        result.__filtered__ = true;
		      } else {
		        result = this.clone();
		        result.__dir__ *= -1;
		      }
		      return result;
		    }

		    /**
		     * Extracts the unwrapped value from its lazy wrapper.
		     *
		     * @private
		     * @name value
		     * @memberOf LazyWrapper
		     * @returns {*} Returns the unwrapped value.
		     */
		    function lazyValue() {
		      var array = this.__wrapped__.value(),
		          dir = this.__dir__,
		          isArr = isArray(array),
		          isRight = dir < 0,
		          arrLength = isArr ? array.length : 0,
		          view = getView(0, arrLength, this.__views__),
		          start = view.start,
		          end = view.end,
		          length = end - start,
		          index = isRight ? end : (start - 1),
		          iteratees = this.__iteratees__,
		          iterLength = iteratees.length,
		          resIndex = 0,
		          takeCount = nativeMin(length, this.__takeCount__);

		      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
		        return baseWrapperValue(array, this.__actions__);
		      }
		      var result = [];

		      outer:
		      while (length-- && resIndex < takeCount) {
		        index += dir;

		        var iterIndex = -1,
		            value = array[index];

		        while (++iterIndex < iterLength) {
		          var data = iteratees[iterIndex],
		              iteratee = data.iteratee,
		              type = data.type,
		              computed = iteratee(value);

		          if (type == LAZY_MAP_FLAG) {
		            value = computed;
		          } else if (!computed) {
		            if (type == LAZY_FILTER_FLAG) {
		              continue outer;
		            } else {
		              break outer;
		            }
		          }
		        }
		        result[resIndex++] = value;
		      }
		      return result;
		    }

		    // Ensure `LazyWrapper` is an instance of `baseLodash`.
		    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
		    LazyWrapper.prototype.constructor = LazyWrapper;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a hash object.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function Hash(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the hash.
		     *
		     * @private
		     * @name clear
		     * @memberOf Hash
		     */
		    function hashClear() {
		      this.__data__ = nativeCreate ? nativeCreate(null) : {};
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the hash.
		     *
		     * @private
		     * @name delete
		     * @memberOf Hash
		     * @param {Object} hash The hash to modify.
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function hashDelete(key) {
		      var result = this.has(key) && delete this.__data__[key];
		      this.size -= result ? 1 : 0;
		      return result;
		    }

		    /**
		     * Gets the hash value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf Hash
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function hashGet(key) {
		      var data = this.__data__;
		      if (nativeCreate) {
		        var result = data[key];
		        return result === HASH_UNDEFINED ? undefined$1 : result;
		      }
		      return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
		    }

		    /**
		     * Checks if a hash value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf Hash
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function hashHas(key) {
		      var data = this.__data__;
		      return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
		    }

		    /**
		     * Sets the hash `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf Hash
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the hash instance.
		     */
		    function hashSet(key, value) {
		      var data = this.__data__;
		      this.size += this.has(key) ? 0 : 1;
		      data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
		      return this;
		    }

		    // Add methods to `Hash`.
		    Hash.prototype.clear = hashClear;
		    Hash.prototype['delete'] = hashDelete;
		    Hash.prototype.get = hashGet;
		    Hash.prototype.has = hashHas;
		    Hash.prototype.set = hashSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an list cache object.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function ListCache(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the list cache.
		     *
		     * @private
		     * @name clear
		     * @memberOf ListCache
		     */
		    function listCacheClear() {
		      this.__data__ = [];
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the list cache.
		     *
		     * @private
		     * @name delete
		     * @memberOf ListCache
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function listCacheDelete(key) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      if (index < 0) {
		        return false;
		      }
		      var lastIndex = data.length - 1;
		      if (index == lastIndex) {
		        data.pop();
		      } else {
		        splice.call(data, index, 1);
		      }
		      --this.size;
		      return true;
		    }

		    /**
		     * Gets the list cache value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf ListCache
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function listCacheGet(key) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      return index < 0 ? undefined$1 : data[index][1];
		    }

		    /**
		     * Checks if a list cache value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf ListCache
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function listCacheHas(key) {
		      return assocIndexOf(this.__data__, key) > -1;
		    }

		    /**
		     * Sets the list cache `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf ListCache
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the list cache instance.
		     */
		    function listCacheSet(key, value) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      if (index < 0) {
		        ++this.size;
		        data.push([key, value]);
		      } else {
		        data[index][1] = value;
		      }
		      return this;
		    }

		    // Add methods to `ListCache`.
		    ListCache.prototype.clear = listCacheClear;
		    ListCache.prototype['delete'] = listCacheDelete;
		    ListCache.prototype.get = listCacheGet;
		    ListCache.prototype.has = listCacheHas;
		    ListCache.prototype.set = listCacheSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a map cache object to store key-value pairs.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function MapCache(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the map.
		     *
		     * @private
		     * @name clear
		     * @memberOf MapCache
		     */
		    function mapCacheClear() {
		      this.size = 0;
		      this.__data__ = {
		        'hash': new Hash,
		        'map': new (Map || ListCache),
		        'string': new Hash
		      };
		    }

		    /**
		     * Removes `key` and its value from the map.
		     *
		     * @private
		     * @name delete
		     * @memberOf MapCache
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function mapCacheDelete(key) {
		      var result = getMapData(this, key)['delete'](key);
		      this.size -= result ? 1 : 0;
		      return result;
		    }

		    /**
		     * Gets the map value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf MapCache
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function mapCacheGet(key) {
		      return getMapData(this, key).get(key);
		    }

		    /**
		     * Checks if a map value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf MapCache
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function mapCacheHas(key) {
		      return getMapData(this, key).has(key);
		    }

		    /**
		     * Sets the map `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf MapCache
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the map cache instance.
		     */
		    function mapCacheSet(key, value) {
		      var data = getMapData(this, key),
		          size = data.size;

		      data.set(key, value);
		      this.size += data.size == size ? 0 : 1;
		      return this;
		    }

		    // Add methods to `MapCache`.
		    MapCache.prototype.clear = mapCacheClear;
		    MapCache.prototype['delete'] = mapCacheDelete;
		    MapCache.prototype.get = mapCacheGet;
		    MapCache.prototype.has = mapCacheHas;
		    MapCache.prototype.set = mapCacheSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     *
		     * Creates an array cache object to store unique values.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [values] The values to cache.
		     */
		    function SetCache(values) {
		      var index = -1,
		          length = values == null ? 0 : values.length;

		      this.__data__ = new MapCache;
		      while (++index < length) {
		        this.add(values[index]);
		      }
		    }

		    /**
		     * Adds `value` to the array cache.
		     *
		     * @private
		     * @name add
		     * @memberOf SetCache
		     * @alias push
		     * @param {*} value The value to cache.
		     * @returns {Object} Returns the cache instance.
		     */
		    function setCacheAdd(value) {
		      this.__data__.set(value, HASH_UNDEFINED);
		      return this;
		    }

		    /**
		     * Checks if `value` is in the array cache.
		     *
		     * @private
		     * @name has
		     * @memberOf SetCache
		     * @param {*} value The value to search for.
		     * @returns {number} Returns `true` if `value` is found, else `false`.
		     */
		    function setCacheHas(value) {
		      return this.__data__.has(value);
		    }

		    // Add methods to `SetCache`.
		    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
		    SetCache.prototype.has = setCacheHas;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a stack cache object to store key-value pairs.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function Stack(entries) {
		      var data = this.__data__ = new ListCache(entries);
		      this.size = data.size;
		    }

		    /**
		     * Removes all key-value entries from the stack.
		     *
		     * @private
		     * @name clear
		     * @memberOf Stack
		     */
		    function stackClear() {
		      this.__data__ = new ListCache;
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the stack.
		     *
		     * @private
		     * @name delete
		     * @memberOf Stack
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function stackDelete(key) {
		      var data = this.__data__,
		          result = data['delete'](key);

		      this.size = data.size;
		      return result;
		    }

		    /**
		     * Gets the stack value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf Stack
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function stackGet(key) {
		      return this.__data__.get(key);
		    }

		    /**
		     * Checks if a stack value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf Stack
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function stackHas(key) {
		      return this.__data__.has(key);
		    }

		    /**
		     * Sets the stack `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf Stack
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the stack cache instance.
		     */
		    function stackSet(key, value) {
		      var data = this.__data__;
		      if (data instanceof ListCache) {
		        var pairs = data.__data__;
		        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
		          pairs.push([key, value]);
		          this.size = ++data.size;
		          return this;
		        }
		        data = this.__data__ = new MapCache(pairs);
		      }
		      data.set(key, value);
		      this.size = data.size;
		      return this;
		    }

		    // Add methods to `Stack`.
		    Stack.prototype.clear = stackClear;
		    Stack.prototype['delete'] = stackDelete;
		    Stack.prototype.get = stackGet;
		    Stack.prototype.has = stackHas;
		    Stack.prototype.set = stackSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an array of the enumerable property names of the array-like `value`.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @param {boolean} inherited Specify returning inherited property names.
		     * @returns {Array} Returns the array of property names.
		     */
		    function arrayLikeKeys(value, inherited) {
		      var isArr = isArray(value),
		          isArg = !isArr && isArguments(value),
		          isBuff = !isArr && !isArg && isBuffer(value),
		          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
		          skipIndexes = isArr || isArg || isBuff || isType,
		          result = skipIndexes ? baseTimes(value.length, String) : [],
		          length = result.length;

		      for (var key in value) {
		        if ((inherited || hasOwnProperty.call(value, key)) &&
		            !(skipIndexes && (
		               // Safari 9 has enumerable `arguments.length` in strict mode.
		               key == 'length' ||
		               // Node.js 0.10 has enumerable non-index properties on buffers.
		               (isBuff && (key == 'offset' || key == 'parent')) ||
		               // PhantomJS 2 has enumerable non-index properties on typed arrays.
		               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
		               // Skip index properties.
		               isIndex(key, length)
		            ))) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * A specialized version of `_.sample` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to sample.
		     * @returns {*} Returns the random element.
		     */
		    function arraySample(array) {
		      var length = array.length;
		      return length ? array[baseRandom(0, length - 1)] : undefined$1;
		    }

		    /**
		     * A specialized version of `_.sampleSize` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to sample.
		     * @param {number} n The number of elements to sample.
		     * @returns {Array} Returns the random elements.
		     */
		    function arraySampleSize(array, n) {
		      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
		    }

		    /**
		     * A specialized version of `_.shuffle` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     */
		    function arrayShuffle(array) {
		      return shuffleSelf(copyArray(array));
		    }

		    /**
		     * This function is like `assignValue` except that it doesn't assign
		     * `undefined` values.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function assignMergeValue(object, key, value) {
		      if ((value !== undefined$1 && !eq(object[key], value)) ||
		          (value === undefined$1 && !(key in object))) {
		        baseAssignValue(object, key, value);
		      }
		    }

		    /**
		     * Assigns `value` to `key` of `object` if the existing value is not equivalent
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function assignValue(object, key, value) {
		      var objValue = object[key];
		      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
		          (value === undefined$1 && !(key in object))) {
		        baseAssignValue(object, key, value);
		      }
		    }

		    /**
		     * Gets the index at which the `key` is found in `array` of key-value pairs.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {*} key The key to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     */
		    function assocIndexOf(array, key) {
		      var length = array.length;
		      while (length--) {
		        if (eq(array[length][0], key)) {
		          return length;
		        }
		      }
		      return -1;
		    }

		    /**
		     * Aggregates elements of `collection` on `accumulator` with keys transformed
		     * by `iteratee` and values set by `setter`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} setter The function to set `accumulator` values.
		     * @param {Function} iteratee The iteratee to transform keys.
		     * @param {Object} accumulator The initial aggregated object.
		     * @returns {Function} Returns `accumulator`.
		     */
		    function baseAggregator(collection, setter, iteratee, accumulator) {
		      baseEach(collection, function(value, key, collection) {
		        setter(accumulator, value, iteratee(value), collection);
		      });
		      return accumulator;
		    }

		    /**
		     * The base implementation of `_.assign` without support for multiple sources
		     * or `customizer` functions.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @returns {Object} Returns `object`.
		     */
		    function baseAssign(object, source) {
		      return object && copyObject(source, keys(source), object);
		    }

		    /**
		     * The base implementation of `_.assignIn` without support for multiple sources
		     * or `customizer` functions.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @returns {Object} Returns `object`.
		     */
		    function baseAssignIn(object, source) {
		      return object && copyObject(source, keysIn(source), object);
		    }

		    /**
		     * The base implementation of `assignValue` and `assignMergeValue` without
		     * value checks.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function baseAssignValue(object, key, value) {
		      if (key == '__proto__' && defineProperty) {
		        defineProperty(object, key, {
		          'configurable': true,
		          'enumerable': true,
		          'value': value,
		          'writable': true
		        });
		      } else {
		        object[key] = value;
		      }
		    }

		    /**
		     * The base implementation of `_.at` without support for individual paths.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {string[]} paths The property paths to pick.
		     * @returns {Array} Returns the picked elements.
		     */
		    function baseAt(object, paths) {
		      var index = -1,
		          length = paths.length,
		          result = Array(length),
		          skip = object == null;

		      while (++index < length) {
		        result[index] = skip ? undefined$1 : get(object, paths[index]);
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.clamp` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {number} number The number to clamp.
		     * @param {number} [lower] The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the clamped number.
		     */
		    function baseClamp(number, lower, upper) {
		      if (number === number) {
		        if (upper !== undefined$1) {
		          number = number <= upper ? number : upper;
		        }
		        if (lower !== undefined$1) {
		          number = number >= lower ? number : lower;
		        }
		      }
		      return number;
		    }

		    /**
		     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
		     * traversed objects.
		     *
		     * @private
		     * @param {*} value The value to clone.
		     * @param {boolean} bitmask The bitmask flags.
		     *  1 - Deep clone
		     *  2 - Flatten inherited properties
		     *  4 - Clone symbols
		     * @param {Function} [customizer] The function to customize cloning.
		     * @param {string} [key] The key of `value`.
		     * @param {Object} [object] The parent object of `value`.
		     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
		     * @returns {*} Returns the cloned value.
		     */
		    function baseClone(value, bitmask, customizer, key, object, stack) {
		      var result,
		          isDeep = bitmask & CLONE_DEEP_FLAG,
		          isFlat = bitmask & CLONE_FLAT_FLAG,
		          isFull = bitmask & CLONE_SYMBOLS_FLAG;

		      if (customizer) {
		        result = object ? customizer(value, key, object, stack) : customizer(value);
		      }
		      if (result !== undefined$1) {
		        return result;
		      }
		      if (!isObject(value)) {
		        return value;
		      }
		      var isArr = isArray(value);
		      if (isArr) {
		        result = initCloneArray(value);
		        if (!isDeep) {
		          return copyArray(value, result);
		        }
		      } else {
		        var tag = getTag(value),
		            isFunc = tag == funcTag || tag == genTag;

		        if (isBuffer(value)) {
		          return cloneBuffer(value, isDeep);
		        }
		        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
		          result = (isFlat || isFunc) ? {} : initCloneObject(value);
		          if (!isDeep) {
		            return isFlat
		              ? copySymbolsIn(value, baseAssignIn(result, value))
		              : copySymbols(value, baseAssign(result, value));
		          }
		        } else {
		          if (!cloneableTags[tag]) {
		            return object ? value : {};
		          }
		          result = initCloneByTag(value, tag, isDeep);
		        }
		      }
		      // Check for circular references and return its corresponding clone.
		      stack || (stack = new Stack);
		      var stacked = stack.get(value);
		      if (stacked) {
		        return stacked;
		      }
		      stack.set(value, result);

		      if (isSet(value)) {
		        value.forEach(function(subValue) {
		          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
		        });
		      } else if (isMap(value)) {
		        value.forEach(function(subValue, key) {
		          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
		        });
		      }

		      var keysFunc = isFull
		        ? (isFlat ? getAllKeysIn : getAllKeys)
		        : (isFlat ? keysIn : keys);

		      var props = isArr ? undefined$1 : keysFunc(value);
		      arrayEach(props || value, function(subValue, key) {
		        if (props) {
		          key = subValue;
		          subValue = value[key];
		        }
		        // Recursively populate clone (susceptible to call stack limits).
		        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.conforms` which doesn't clone `source`.
		     *
		     * @private
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseConforms(source) {
		      var props = keys(source);
		      return function(object) {
		        return baseConformsTo(object, source, props);
		      };
		    }

		    /**
		     * The base implementation of `_.conformsTo` which accepts `props` to check.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
		     */
		    function baseConformsTo(object, source, props) {
		      var length = props.length;
		      if (object == null) {
		        return !length;
		      }
		      object = Object(object);
		      while (length--) {
		        var key = props[length],
		            predicate = source[key],
		            value = object[key];

		        if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
		          return false;
		        }
		      }
		      return true;
		    }

		    /**
		     * The base implementation of `_.delay` and `_.defer` which accepts `args`
		     * to provide to `func`.
		     *
		     * @private
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @param {Array} args The arguments to provide to `func`.
		     * @returns {number|Object} Returns the timer id or timeout object.
		     */
		    function baseDelay(func, wait, args) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      return setTimeout(function() { func.apply(undefined$1, args); }, wait);
		    }

		    /**
		     * The base implementation of methods like `_.difference` without support
		     * for excluding multiple arrays or iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Array} values The values to exclude.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     */
		    function baseDifference(array, values, iteratee, comparator) {
		      var index = -1,
		          includes = arrayIncludes,
		          isCommon = true,
		          length = array.length,
		          result = [],
		          valuesLength = values.length;

		      if (!length) {
		        return result;
		      }
		      if (iteratee) {
		        values = arrayMap(values, baseUnary(iteratee));
		      }
		      if (comparator) {
		        includes = arrayIncludesWith;
		        isCommon = false;
		      }
		      else if (values.length >= LARGE_ARRAY_SIZE) {
		        includes = cacheHas;
		        isCommon = false;
		        values = new SetCache(values);
		      }
		      outer:
		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee == null ? value : iteratee(value);

		        value = (comparator || value !== 0) ? value : 0;
		        if (isCommon && computed === computed) {
		          var valuesIndex = valuesLength;
		          while (valuesIndex--) {
		            if (values[valuesIndex] === computed) {
		              continue outer;
		            }
		          }
		          result.push(value);
		        }
		        else if (!includes(values, computed, comparator)) {
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.forEach` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     */
		    var baseEach = createBaseEach(baseForOwn);

		    /**
		     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     */
		    var baseEachRight = createBaseEach(baseForOwnRight, true);

		    /**
		     * The base implementation of `_.every` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {boolean} Returns `true` if all elements pass the predicate check,
		     *  else `false`
		     */
		    function baseEvery(collection, predicate) {
		      var result = true;
		      baseEach(collection, function(value, index, collection) {
		        result = !!predicate(value, index, collection);
		        return result;
		      });
		      return result;
		    }

		    /**
		     * The base implementation of methods like `_.max` and `_.min` which accepts a
		     * `comparator` to determine the extremum value.
		     *
		     * @private
		     * @param {Array} array The array to iterate over.
		     * @param {Function} iteratee The iteratee invoked per iteration.
		     * @param {Function} comparator The comparator used to compare values.
		     * @returns {*} Returns the extremum value.
		     */
		    function baseExtremum(array, iteratee, comparator) {
		      var index = -1,
		          length = array.length;

		      while (++index < length) {
		        var value = array[index],
		            current = iteratee(value);

		        if (current != null && (computed === undefined$1
		              ? (current === current && !isSymbol(current))
		              : comparator(current, computed)
		            )) {
		          var computed = current,
		              result = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.fill` without an iteratee call guard.
		     *
		     * @private
		     * @param {Array} array The array to fill.
		     * @param {*} value The value to fill `array` with.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns `array`.
		     */
		    function baseFill(array, value, start, end) {
		      var length = array.length;

		      start = toInteger(start);
		      if (start < 0) {
		        start = -start > length ? 0 : (length + start);
		      }
		      end = (end === undefined$1 || end > length) ? length : toInteger(end);
		      if (end < 0) {
		        end += length;
		      }
		      end = start > end ? 0 : toLength(end);
		      while (start < end) {
		        array[start++] = value;
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.filter` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     */
		    function baseFilter(collection, predicate) {
		      var result = [];
		      baseEach(collection, function(value, index, collection) {
		        if (predicate(value, index, collection)) {
		          result.push(value);
		        }
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.flatten` with support for restricting flattening.
		     *
		     * @private
		     * @param {Array} array The array to flatten.
		     * @param {number} depth The maximum recursion depth.
		     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
		     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
		     * @param {Array} [result=[]] The initial result value.
		     * @returns {Array} Returns the new flattened array.
		     */
		    function baseFlatten(array, depth, predicate, isStrict, result) {
		      var index = -1,
		          length = array.length;

		      predicate || (predicate = isFlattenable);
		      result || (result = []);

		      while (++index < length) {
		        var value = array[index];
		        if (depth > 0 && predicate(value)) {
		          if (depth > 1) {
		            // Recursively flatten arrays (susceptible to call stack limits).
		            baseFlatten(value, depth - 1, predicate, isStrict, result);
		          } else {
		            arrayPush(result, value);
		          }
		        } else if (!isStrict) {
		          result[result.length] = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `baseForOwn` which iterates over `object`
		     * properties returned by `keysFunc` and invokes `iteratee` for each property.
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @returns {Object} Returns `object`.
		     */
		    var baseFor = createBaseFor();

		    /**
		     * This function is like `baseFor` except that it iterates over properties
		     * in the opposite order.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @returns {Object} Returns `object`.
		     */
		    var baseForRight = createBaseFor(true);

		    /**
		     * The base implementation of `_.forOwn` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     */
		    function baseForOwn(object, iteratee) {
		      return object && baseFor(object, iteratee, keys);
		    }

		    /**
		     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     */
		    function baseForOwnRight(object, iteratee) {
		      return object && baseForRight(object, iteratee, keys);
		    }

		    /**
		     * The base implementation of `_.functions` which creates an array of
		     * `object` function property names filtered from `props`.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Array} props The property names to filter.
		     * @returns {Array} Returns the function names.
		     */
		    function baseFunctions(object, props) {
		      return arrayFilter(props, function(key) {
		        return isFunction(object[key]);
		      });
		    }

		    /**
		     * The base implementation of `_.get` without support for default values.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to get.
		     * @returns {*} Returns the resolved value.
		     */
		    function baseGet(object, path) {
		      path = castPath(path, object);

		      var index = 0,
		          length = path.length;

		      while (object != null && index < length) {
		        object = object[toKey(path[index++])];
		      }
		      return (index && index == length) ? object : undefined$1;
		    }

		    /**
		     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
		     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
		     * symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @param {Function} symbolsFunc The function to get the symbols of `object`.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
		      var result = keysFunc(object);
		      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
		    }

		    /**
		     * The base implementation of `getTag` without fallbacks for buggy environments.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the `toStringTag`.
		     */
		    function baseGetTag(value) {
		      if (value == null) {
		        return value === undefined$1 ? undefinedTag : nullTag;
		      }
		      return (symToStringTag && symToStringTag in Object(value))
		        ? getRawTag(value)
		        : objectToString(value);
		    }

		    /**
		     * The base implementation of `_.gt` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than `other`,
		     *  else `false`.
		     */
		    function baseGt(value, other) {
		      return value > other;
		    }

		    /**
		     * The base implementation of `_.has` without support for deep paths.
		     *
		     * @private
		     * @param {Object} [object] The object to query.
		     * @param {Array|string} key The key to check.
		     * @returns {boolean} Returns `true` if `key` exists, else `false`.
		     */
		    function baseHas(object, key) {
		      return object != null && hasOwnProperty.call(object, key);
		    }

		    /**
		     * The base implementation of `_.hasIn` without support for deep paths.
		     *
		     * @private
		     * @param {Object} [object] The object to query.
		     * @param {Array|string} key The key to check.
		     * @returns {boolean} Returns `true` if `key` exists, else `false`.
		     */
		    function baseHasIn(object, key) {
		      return object != null && key in Object(object);
		    }

		    /**
		     * The base implementation of `_.inRange` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {number} number The number to check.
		     * @param {number} start The start of the range.
		     * @param {number} end The end of the range.
		     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
		     */
		    function baseInRange(number, start, end) {
		      return number >= nativeMin(start, end) && number < nativeMax(start, end);
		    }

		    /**
		     * The base implementation of methods like `_.intersection`, without support
		     * for iteratee shorthands, that accepts an array of arrays to inspect.
		     *
		     * @private
		     * @param {Array} arrays The arrays to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of shared values.
		     */
		    function baseIntersection(arrays, iteratee, comparator) {
		      var includes = comparator ? arrayIncludesWith : arrayIncludes,
		          length = arrays[0].length,
		          othLength = arrays.length,
		          othIndex = othLength,
		          caches = Array(othLength),
		          maxLength = Infinity,
		          result = [];

		      while (othIndex--) {
		        var array = arrays[othIndex];
		        if (othIndex && iteratee) {
		          array = arrayMap(array, baseUnary(iteratee));
		        }
		        maxLength = nativeMin(array.length, maxLength);
		        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
		          ? new SetCache(othIndex && array)
		          : undefined$1;
		      }
		      array = arrays[0];

		      var index = -1,
		          seen = caches[0];

		      outer:
		      while (++index < length && result.length < maxLength) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        value = (comparator || value !== 0) ? value : 0;
		        if (!(seen
		              ? cacheHas(seen, computed)
		              : includes(result, computed, comparator)
		            )) {
		          othIndex = othLength;
		          while (--othIndex) {
		            var cache = caches[othIndex];
		            if (!(cache
		                  ? cacheHas(cache, computed)
		                  : includes(arrays[othIndex], computed, comparator))
		                ) {
		              continue outer;
		            }
		          }
		          if (seen) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.invert` and `_.invertBy` which inverts
		     * `object` with values transformed by `iteratee` and set by `setter`.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} setter The function to set `accumulator` values.
		     * @param {Function} iteratee The iteratee to transform values.
		     * @param {Object} accumulator The initial inverted object.
		     * @returns {Function} Returns `accumulator`.
		     */
		    function baseInverter(object, setter, iteratee, accumulator) {
		      baseForOwn(object, function(value, key, object) {
		        setter(accumulator, iteratee(value), key, object);
		      });
		      return accumulator;
		    }

		    /**
		     * The base implementation of `_.invoke` without support for individual
		     * method arguments.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {Array} args The arguments to invoke the method with.
		     * @returns {*} Returns the result of the invoked method.
		     */
		    function baseInvoke(object, path, args) {
		      path = castPath(path, object);
		      object = parent(object, path);
		      var func = object == null ? object : object[toKey(last(path))];
		      return func == null ? undefined$1 : apply(func, object, args);
		    }

		    /**
		     * The base implementation of `_.isArguments`.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
		     */
		    function baseIsArguments(value) {
		      return isObjectLike(value) && baseGetTag(value) == argsTag;
		    }

		    /**
		     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
		     */
		    function baseIsArrayBuffer(value) {
		      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
		    }

		    /**
		     * The base implementation of `_.isDate` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
		     */
		    function baseIsDate(value) {
		      return isObjectLike(value) && baseGetTag(value) == dateTag;
		    }

		    /**
		     * The base implementation of `_.isEqual` which supports partial comparisons
		     * and tracks traversed objects.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @param {boolean} bitmask The bitmask flags.
		     *  1 - Unordered comparison
		     *  2 - Partial comparison
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     */
		    function baseIsEqual(value, other, bitmask, customizer, stack) {
		      if (value === other) {
		        return true;
		      }
		      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
		        return value !== value && other !== other;
		      }
		      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
		    }

		    /**
		     * A specialized version of `baseIsEqual` for arrays and objects which performs
		     * deep comparisons and tracks traversed objects enabling objects with circular
		     * references to be compared.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
		      var objIsArr = isArray(object),
		          othIsArr = isArray(other),
		          objTag = objIsArr ? arrayTag : getTag(object),
		          othTag = othIsArr ? arrayTag : getTag(other);

		      objTag = objTag == argsTag ? objectTag : objTag;
		      othTag = othTag == argsTag ? objectTag : othTag;

		      var objIsObj = objTag == objectTag,
		          othIsObj = othTag == objectTag,
		          isSameTag = objTag == othTag;

		      if (isSameTag && isBuffer(object)) {
		        if (!isBuffer(other)) {
		          return false;
		        }
		        objIsArr = true;
		        objIsObj = false;
		      }
		      if (isSameTag && !objIsObj) {
		        stack || (stack = new Stack);
		        return (objIsArr || isTypedArray(object))
		          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
		          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
		      }
		      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
		        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
		            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

		        if (objIsWrapped || othIsWrapped) {
		          var objUnwrapped = objIsWrapped ? object.value() : object,
		              othUnwrapped = othIsWrapped ? other.value() : other;

		          stack || (stack = new Stack);
		          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
		        }
		      }
		      if (!isSameTag) {
		        return false;
		      }
		      stack || (stack = new Stack);
		      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
		    }

		    /**
		     * The base implementation of `_.isMap` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
		     */
		    function baseIsMap(value) {
		      return isObjectLike(value) && getTag(value) == mapTag;
		    }

		    /**
		     * The base implementation of `_.isMatch` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @param {Array} matchData The property names, values, and compare flags to match.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     */
		    function baseIsMatch(object, source, matchData, customizer) {
		      var index = matchData.length,
		          length = index,
		          noCustomizer = !customizer;

		      if (object == null) {
		        return !length;
		      }
		      object = Object(object);
		      while (index--) {
		        var data = matchData[index];
		        if ((noCustomizer && data[2])
		              ? data[1] !== object[data[0]]
		              : !(data[0] in object)
		            ) {
		          return false;
		        }
		      }
		      while (++index < length) {
		        data = matchData[index];
		        var key = data[0],
		            objValue = object[key],
		            srcValue = data[1];

		        if (noCustomizer && data[2]) {
		          if (objValue === undefined$1 && !(key in object)) {
		            return false;
		          }
		        } else {
		          var stack = new Stack;
		          if (customizer) {
		            var result = customizer(objValue, srcValue, key, object, source, stack);
		          }
		          if (!(result === undefined$1
		                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
		                : result
		              )) {
		            return false;
		          }
		        }
		      }
		      return true;
		    }

		    /**
		     * The base implementation of `_.isNative` without bad shim checks.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a native function,
		     *  else `false`.
		     */
		    function baseIsNative(value) {
		      if (!isObject(value) || isMasked(value)) {
		        return false;
		      }
		      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
		      return pattern.test(toSource(value));
		    }

		    /**
		     * The base implementation of `_.isRegExp` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
		     */
		    function baseIsRegExp(value) {
		      return isObjectLike(value) && baseGetTag(value) == regexpTag;
		    }

		    /**
		     * The base implementation of `_.isSet` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
		     */
		    function baseIsSet(value) {
		      return isObjectLike(value) && getTag(value) == setTag;
		    }

		    /**
		     * The base implementation of `_.isTypedArray` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
		     */
		    function baseIsTypedArray(value) {
		      return isObjectLike(value) &&
		        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
		    }

		    /**
		     * The base implementation of `_.iteratee`.
		     *
		     * @private
		     * @param {*} [value=_.identity] The value to convert to an iteratee.
		     * @returns {Function} Returns the iteratee.
		     */
		    function baseIteratee(value) {
		      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
		      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
		      if (typeof value == 'function') {
		        return value;
		      }
		      if (value == null) {
		        return identity;
		      }
		      if (typeof value == 'object') {
		        return isArray(value)
		          ? baseMatchesProperty(value[0], value[1])
		          : baseMatches(value);
		      }
		      return property(value);
		    }

		    /**
		     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function baseKeys(object) {
		      if (!isPrototype(object)) {
		        return nativeKeys(object);
		      }
		      var result = [];
		      for (var key in Object(object)) {
		        if (hasOwnProperty.call(object, key) && key != 'constructor') {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function baseKeysIn(object) {
		      if (!isObject(object)) {
		        return nativeKeysIn(object);
		      }
		      var isProto = isPrototype(object),
		          result = [];

		      for (var key in object) {
		        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.lt` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than `other`,
		     *  else `false`.
		     */
		    function baseLt(value, other) {
		      return value < other;
		    }

		    /**
		     * The base implementation of `_.map` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array} Returns the new mapped array.
		     */
		    function baseMap(collection, iteratee) {
		      var index = -1,
		          result = isArrayLike(collection) ? Array(collection.length) : [];

		      baseEach(collection, function(value, key, collection) {
		        result[++index] = iteratee(value, key, collection);
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.matches` which doesn't clone `source`.
		     *
		     * @private
		     * @param {Object} source The object of property values to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseMatches(source) {
		      var matchData = getMatchData(source);
		      if (matchData.length == 1 && matchData[0][2]) {
		        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
		      }
		      return function(object) {
		        return object === source || baseIsMatch(object, source, matchData);
		      };
		    }

		    /**
		     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
		     *
		     * @private
		     * @param {string} path The path of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseMatchesProperty(path, srcValue) {
		      if (isKey(path) && isStrictComparable(srcValue)) {
		        return matchesStrictComparable(toKey(path), srcValue);
		      }
		      return function(object) {
		        var objValue = get(object, path);
		        return (objValue === undefined$1 && objValue === srcValue)
		          ? hasIn(object, path)
		          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
		      };
		    }

		    /**
		     * The base implementation of `_.merge` without support for multiple sources.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @param {number} srcIndex The index of `source`.
		     * @param {Function} [customizer] The function to customize merged values.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     */
		    function baseMerge(object, source, srcIndex, customizer, stack) {
		      if (object === source) {
		        return;
		      }
		      baseFor(source, function(srcValue, key) {
		        stack || (stack = new Stack);
		        if (isObject(srcValue)) {
		          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
		        }
		        else {
		          var newValue = customizer
		            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
		            : undefined$1;

		          if (newValue === undefined$1) {
		            newValue = srcValue;
		          }
		          assignMergeValue(object, key, newValue);
		        }
		      }, keysIn);
		    }

		    /**
		     * A specialized version of `baseMerge` for arrays and objects which performs
		     * deep merges and tracks traversed objects enabling objects with circular
		     * references to be merged.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @param {string} key The key of the value to merge.
		     * @param {number} srcIndex The index of `source`.
		     * @param {Function} mergeFunc The function to merge values.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     */
		    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
		      var objValue = safeGet(object, key),
		          srcValue = safeGet(source, key),
		          stacked = stack.get(srcValue);

		      if (stacked) {
		        assignMergeValue(object, key, stacked);
		        return;
		      }
		      var newValue = customizer
		        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
		        : undefined$1;

		      var isCommon = newValue === undefined$1;

		      if (isCommon) {
		        var isArr = isArray(srcValue),
		            isBuff = !isArr && isBuffer(srcValue),
		            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

		        newValue = srcValue;
		        if (isArr || isBuff || isTyped) {
		          if (isArray(objValue)) {
		            newValue = objValue;
		          }
		          else if (isArrayLikeObject(objValue)) {
		            newValue = copyArray(objValue);
		          }
		          else if (isBuff) {
		            isCommon = false;
		            newValue = cloneBuffer(srcValue, true);
		          }
		          else if (isTyped) {
		            isCommon = false;
		            newValue = cloneTypedArray(srcValue, true);
		          }
		          else {
		            newValue = [];
		          }
		        }
		        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
		          newValue = objValue;
		          if (isArguments(objValue)) {
		            newValue = toPlainObject(objValue);
		          }
		          else if (!isObject(objValue) || isFunction(objValue)) {
		            newValue = initCloneObject(srcValue);
		          }
		        }
		        else {
		          isCommon = false;
		        }
		      }
		      if (isCommon) {
		        // Recursively merge objects and arrays (susceptible to call stack limits).
		        stack.set(srcValue, newValue);
		        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
		        stack['delete'](srcValue);
		      }
		      assignMergeValue(object, key, newValue);
		    }

		    /**
		     * The base implementation of `_.nth` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {Array} array The array to query.
		     * @param {number} n The index of the element to return.
		     * @returns {*} Returns the nth element of `array`.
		     */
		    function baseNth(array, n) {
		      var length = array.length;
		      if (!length) {
		        return;
		      }
		      n += n < 0 ? length : 0;
		      return isIndex(n, length) ? array[n] : undefined$1;
		    }

		    /**
		     * The base implementation of `_.orderBy` without param guards.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
		     * @param {string[]} orders The sort orders of `iteratees`.
		     * @returns {Array} Returns the new sorted array.
		     */
		    function baseOrderBy(collection, iteratees, orders) {
		      if (iteratees.length) {
		        iteratees = arrayMap(iteratees, function(iteratee) {
		          if (isArray(iteratee)) {
		            return function(value) {
		              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
		            };
		          }
		          return iteratee;
		        });
		      } else {
		        iteratees = [identity];
		      }

		      var index = -1;
		      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

		      var result = baseMap(collection, function(value, key, collection) {
		        var criteria = arrayMap(iteratees, function(iteratee) {
		          return iteratee(value);
		        });
		        return { 'criteria': criteria, 'index': ++index, 'value': value };
		      });

		      return baseSortBy(result, function(object, other) {
		        return compareMultiple(object, other, orders);
		      });
		    }

		    /**
		     * The base implementation of `_.pick` without support for individual
		     * property identifiers.
		     *
		     * @private
		     * @param {Object} object The source object.
		     * @param {string[]} paths The property paths to pick.
		     * @returns {Object} Returns the new object.
		     */
		    function basePick(object, paths) {
		      return basePickBy(object, paths, function(value, path) {
		        return hasIn(object, path);
		      });
		    }

		    /**
		     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The source object.
		     * @param {string[]} paths The property paths to pick.
		     * @param {Function} predicate The function invoked per property.
		     * @returns {Object} Returns the new object.
		     */
		    function basePickBy(object, paths, predicate) {
		      var index = -1,
		          length = paths.length,
		          result = {};

		      while (++index < length) {
		        var path = paths[index],
		            value = baseGet(object, path);

		        if (predicate(value, path)) {
		          baseSet(result, castPath(path, object), value);
		        }
		      }
		      return result;
		    }

		    /**
		     * A specialized version of `baseProperty` which supports deep paths.
		     *
		     * @private
		     * @param {Array|string} path The path of the property to get.
		     * @returns {Function} Returns the new accessor function.
		     */
		    function basePropertyDeep(path) {
		      return function(object) {
		        return baseGet(object, path);
		      };
		    }

		    /**
		     * The base implementation of `_.pullAllBy` without support for iteratee
		     * shorthands.
		     *
		     * @private
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns `array`.
		     */
		    function basePullAll(array, values, iteratee, comparator) {
		      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
		          index = -1,
		          length = values.length,
		          seen = array;

		      if (array === values) {
		        values = copyArray(values);
		      }
		      if (iteratee) {
		        seen = arrayMap(array, baseUnary(iteratee));
		      }
		      while (++index < length) {
		        var fromIndex = 0,
		            value = values[index],
		            computed = iteratee ? iteratee(value) : value;

		        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
		          if (seen !== array) {
		            splice.call(seen, fromIndex, 1);
		          }
		          splice.call(array, fromIndex, 1);
		        }
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.pullAt` without support for individual
		     * indexes or capturing the removed elements.
		     *
		     * @private
		     * @param {Array} array The array to modify.
		     * @param {number[]} indexes The indexes of elements to remove.
		     * @returns {Array} Returns `array`.
		     */
		    function basePullAt(array, indexes) {
		      var length = array ? indexes.length : 0,
		          lastIndex = length - 1;

		      while (length--) {
		        var index = indexes[length];
		        if (length == lastIndex || index !== previous) {
		          var previous = index;
		          if (isIndex(index)) {
		            splice.call(array, index, 1);
		          } else {
		            baseUnset(array, index);
		          }
		        }
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.random` without support for returning
		     * floating-point numbers.
		     *
		     * @private
		     * @param {number} lower The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the random number.
		     */
		    function baseRandom(lower, upper) {
		      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
		    }

		    /**
		     * The base implementation of `_.range` and `_.rangeRight` which doesn't
		     * coerce arguments.
		     *
		     * @private
		     * @param {number} start The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} step The value to increment or decrement by.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Array} Returns the range of numbers.
		     */
		    function baseRange(start, end, step, fromRight) {
		      var index = -1,
		          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
		          result = Array(length);

		      while (length--) {
		        result[fromRight ? length : ++index] = start;
		        start += step;
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.repeat` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {string} string The string to repeat.
		     * @param {number} n The number of times to repeat the string.
		     * @returns {string} Returns the repeated string.
		     */
		    function baseRepeat(string, n) {
		      var result = '';
		      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
		        return result;
		      }
		      // Leverage the exponentiation by squaring algorithm for a faster repeat.
		      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
		      do {
		        if (n % 2) {
		          result += string;
		        }
		        n = nativeFloor(n / 2);
		        if (n) {
		          string += string;
		        }
		      } while (n);

		      return result;
		    }

		    /**
		     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @returns {Function} Returns the new function.
		     */
		    function baseRest(func, start) {
		      return setToString(overRest(func, start, identity), func + '');
		    }

		    /**
		     * The base implementation of `_.sample`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to sample.
		     * @returns {*} Returns the random element.
		     */
		    function baseSample(collection) {
		      return arraySample(values(collection));
		    }

		    /**
		     * The base implementation of `_.sampleSize` without param guards.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to sample.
		     * @param {number} n The number of elements to sample.
		     * @returns {Array} Returns the random elements.
		     */
		    function baseSampleSize(collection, n) {
		      var array = values(collection);
		      return shuffleSelf(array, baseClamp(n, 0, array.length));
		    }

		    /**
		     * The base implementation of `_.set`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @param {Function} [customizer] The function to customize path creation.
		     * @returns {Object} Returns `object`.
		     */
		    function baseSet(object, path, value, customizer) {
		      if (!isObject(object)) {
		        return object;
		      }
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length,
		          lastIndex = length - 1,
		          nested = object;

		      while (nested != null && ++index < length) {
		        var key = toKey(path[index]),
		            newValue = value;

		        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
		          return object;
		        }

		        if (index != lastIndex) {
		          var objValue = nested[key];
		          newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
		          if (newValue === undefined$1) {
		            newValue = isObject(objValue)
		              ? objValue
		              : (isIndex(path[index + 1]) ? [] : {});
		          }
		        }
		        assignValue(nested, key, newValue);
		        nested = nested[key];
		      }
		      return object;
		    }

		    /**
		     * The base implementation of `setData` without support for hot loop shorting.
		     *
		     * @private
		     * @param {Function} func The function to associate metadata with.
		     * @param {*} data The metadata.
		     * @returns {Function} Returns `func`.
		     */
		    var baseSetData = !metaMap ? identity : function(func, data) {
		      metaMap.set(func, data);
		      return func;
		    };

		    /**
		     * The base implementation of `setToString` without support for hot loop shorting.
		     *
		     * @private
		     * @param {Function} func The function to modify.
		     * @param {Function} string The `toString` result.
		     * @returns {Function} Returns `func`.
		     */
		    var baseSetToString = !defineProperty ? identity : function(func, string) {
		      return defineProperty(func, 'toString', {
		        'configurable': true,
		        'enumerable': false,
		        'value': constant(string),
		        'writable': true
		      });
		    };

		    /**
		     * The base implementation of `_.shuffle`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     */
		    function baseShuffle(collection) {
		      return shuffleSelf(values(collection));
		    }

		    /**
		     * The base implementation of `_.slice` without an iteratee call guard.
		     *
		     * @private
		     * @param {Array} array The array to slice.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function baseSlice(array, start, end) {
		      var index = -1,
		          length = array.length;

		      if (start < 0) {
		        start = -start > length ? 0 : (length + start);
		      }
		      end = end > length ? length : end;
		      if (end < 0) {
		        end += length;
		      }
		      length = start > end ? 0 : ((end - start) >>> 0);
		      start >>>= 0;

		      var result = Array(length);
		      while (++index < length) {
		        result[index] = array[index + start];
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.some` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {boolean} Returns `true` if any element passes the predicate check,
		     *  else `false`.
		     */
		    function baseSome(collection, predicate) {
		      var result;

		      baseEach(collection, function(value, index, collection) {
		        result = predicate(value, index, collection);
		        return !result;
		      });
		      return !!result;
		    }

		    /**
		     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
		     * performs a binary search of `array` to determine the index at which `value`
		     * should be inserted into `array` in order to maintain its sort order.
		     *
		     * @private
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {boolean} [retHighest] Specify returning the highest qualified index.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     */
		    function baseSortedIndex(array, value, retHighest) {
		      var low = 0,
		          high = array == null ? low : array.length;

		      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
		        while (low < high) {
		          var mid = (low + high) >>> 1,
		              computed = array[mid];

		          if (computed !== null && !isSymbol(computed) &&
		              (retHighest ? (computed <= value) : (computed < value))) {
		            low = mid + 1;
		          } else {
		            high = mid;
		          }
		        }
		        return high;
		      }
		      return baseSortedIndexBy(array, value, identity, retHighest);
		    }

		    /**
		     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
		     * which invokes `iteratee` for `value` and each element of `array` to compute
		     * their sort ranking. The iteratee is invoked with one argument; (value).
		     *
		     * @private
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} iteratee The iteratee invoked per element.
		     * @param {boolean} [retHighest] Specify returning the highest qualified index.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     */
		    function baseSortedIndexBy(array, value, iteratee, retHighest) {
		      var low = 0,
		          high = array == null ? 0 : array.length;
		      if (high === 0) {
		        return 0;
		      }

		      value = iteratee(value);
		      var valIsNaN = value !== value,
		          valIsNull = value === null,
		          valIsSymbol = isSymbol(value),
		          valIsUndefined = value === undefined$1;

		      while (low < high) {
		        var mid = nativeFloor((low + high) / 2),
		            computed = iteratee(array[mid]),
		            othIsDefined = computed !== undefined$1,
		            othIsNull = computed === null,
		            othIsReflexive = computed === computed,
		            othIsSymbol = isSymbol(computed);

		        if (valIsNaN) {
		          var setLow = retHighest || othIsReflexive;
		        } else if (valIsUndefined) {
		          setLow = othIsReflexive && (retHighest || othIsDefined);
		        } else if (valIsNull) {
		          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
		        } else if (valIsSymbol) {
		          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
		        } else if (othIsNull || othIsSymbol) {
		          setLow = false;
		        } else {
		          setLow = retHighest ? (computed <= value) : (computed < value);
		        }
		        if (setLow) {
		          low = mid + 1;
		        } else {
		          high = mid;
		        }
		      }
		      return nativeMin(high, MAX_ARRAY_INDEX);
		    }

		    /**
		     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
		     * support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     */
		    function baseSortedUniq(array, iteratee) {
		      var index = -1,
		          length = array.length,
		          resIndex = 0,
		          result = [];

		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        if (!index || !eq(computed, seen)) {
		          var seen = computed;
		          result[resIndex++] = value === 0 ? 0 : value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.toNumber` which doesn't ensure correct
		     * conversions of binary, hexadecimal, or octal string values.
		     *
		     * @private
		     * @param {*} value The value to process.
		     * @returns {number} Returns the number.
		     */
		    function baseToNumber(value) {
		      if (typeof value == 'number') {
		        return value;
		      }
		      if (isSymbol(value)) {
		        return NAN;
		      }
		      return +value;
		    }

		    /**
		     * The base implementation of `_.toString` which doesn't convert nullish
		     * values to empty strings.
		     *
		     * @private
		     * @param {*} value The value to process.
		     * @returns {string} Returns the string.
		     */
		    function baseToString(value) {
		      // Exit early for strings to avoid a performance hit in some environments.
		      if (typeof value == 'string') {
		        return value;
		      }
		      if (isArray(value)) {
		        // Recursively convert values (susceptible to call stack limits).
		        return arrayMap(value, baseToString) + '';
		      }
		      if (isSymbol(value)) {
		        return symbolToString ? symbolToString.call(value) : '';
		      }
		      var result = (value + '');
		      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		    }

		    /**
		     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     */
		    function baseUniq(array, iteratee, comparator) {
		      var index = -1,
		          includes = arrayIncludes,
		          length = array.length,
		          isCommon = true,
		          result = [],
		          seen = result;

		      if (comparator) {
		        isCommon = false;
		        includes = arrayIncludesWith;
		      }
		      else if (length >= LARGE_ARRAY_SIZE) {
		        var set = iteratee ? null : createSet(array);
		        if (set) {
		          return setToArray(set);
		        }
		        isCommon = false;
		        includes = cacheHas;
		        seen = new SetCache;
		      }
		      else {
		        seen = iteratee ? [] : result;
		      }
		      outer:
		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        value = (comparator || value !== 0) ? value : 0;
		        if (isCommon && computed === computed) {
		          var seenIndex = seen.length;
		          while (seenIndex--) {
		            if (seen[seenIndex] === computed) {
		              continue outer;
		            }
		          }
		          if (iteratee) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		        else if (!includes(seen, computed, comparator)) {
		          if (seen !== result) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.unset`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The property path to unset.
		     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
		     */
		    function baseUnset(object, path) {
		      path = castPath(path, object);

		      // Prevent prototype pollution, see: https://github.com/lodash/lodash/security/advisories/GHSA-xxjr-mmjv-4gpg
		      var index = -1,
		          length = path.length;

		      if (!length) {
		        return true;
		      }

		      var isRootPrimitive = object == null || (typeof object !== 'object' && typeof object !== 'function');

		      while (++index < length) {
		        var key = path[index];

		        // skip non-string keys (e.g., Symbols, numbers)
		        if (typeof key !== 'string') {
		          continue;
		        }

		        // Always block "__proto__" anywhere in the path if it's not expected
		        if (key === '__proto__' && !hasOwnProperty.call(object, '__proto__')) {
		          return false;
		        }

		        // Block "constructor.prototype" chains
		        if (key === 'constructor' &&
		            (index + 1) < length &&
		            typeof path[index + 1] === 'string' &&
		            path[index + 1] === 'prototype') {

		          // Allow ONLY when the path starts at a primitive root, e.g., _.unset(0, 'constructor.prototype.a')
		          if (isRootPrimitive && index === 0) {
		            continue;
		          }

		          return false;
		        }
		      }

		      var obj = parent(object, path);
		      return obj == null || delete obj[toKey(last(path))];
		    }

		    /**
		     * The base implementation of `_.update`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to update.
		     * @param {Function} updater The function to produce the updated value.
		     * @param {Function} [customizer] The function to customize path creation.
		     * @returns {Object} Returns `object`.
		     */
		    function baseUpdate(object, path, updater, customizer) {
		      return baseSet(object, path, updater(baseGet(object, path)), customizer);
		    }

		    /**
		     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
		     * without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to query.
		     * @param {Function} predicate The function invoked per iteration.
		     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function baseWhile(array, predicate, isDrop, fromRight) {
		      var length = array.length,
		          index = fromRight ? length : -1;

		      while ((fromRight ? index-- : ++index < length) &&
		        predicate(array[index], index, array)) {}

		      return isDrop
		        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
		        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
		    }

		    /**
		     * The base implementation of `wrapperValue` which returns the result of
		     * performing a sequence of actions on the unwrapped `value`, where each
		     * successive action is supplied the return value of the previous.
		     *
		     * @private
		     * @param {*} value The unwrapped value.
		     * @param {Array} actions Actions to perform to resolve the unwrapped value.
		     * @returns {*} Returns the resolved value.
		     */
		    function baseWrapperValue(value, actions) {
		      var result = value;
		      if (result instanceof LazyWrapper) {
		        result = result.value();
		      }
		      return arrayReduce(actions, function(result, action) {
		        return action.func.apply(action.thisArg, arrayPush([result], action.args));
		      }, result);
		    }

		    /**
		     * The base implementation of methods like `_.xor`, without support for
		     * iteratee shorthands, that accepts an array of arrays to inspect.
		     *
		     * @private
		     * @param {Array} arrays The arrays to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of values.
		     */
		    function baseXor(arrays, iteratee, comparator) {
		      var length = arrays.length;
		      if (length < 2) {
		        return length ? baseUniq(arrays[0]) : [];
		      }
		      var index = -1,
		          result = Array(length);

		      while (++index < length) {
		        var array = arrays[index],
		            othIndex = -1;

		        while (++othIndex < length) {
		          if (othIndex != index) {
		            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
		          }
		        }
		      }
		      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
		    }

		    /**
		     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
		     *
		     * @private
		     * @param {Array} props The property identifiers.
		     * @param {Array} values The property values.
		     * @param {Function} assignFunc The function to assign values.
		     * @returns {Object} Returns the new object.
		     */
		    function baseZipObject(props, values, assignFunc) {
		      var index = -1,
		          length = props.length,
		          valsLength = values.length,
		          result = {};

		      while (++index < length) {
		        var value = index < valsLength ? values[index] : undefined$1;
		        assignFunc(result, props[index], value);
		      }
		      return result;
		    }

		    /**
		     * Casts `value` to an empty array if it's not an array like object.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {Array|Object} Returns the cast array-like object.
		     */
		    function castArrayLikeObject(value) {
		      return isArrayLikeObject(value) ? value : [];
		    }

		    /**
		     * Casts `value` to `identity` if it's not a function.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {Function} Returns cast function.
		     */
		    function castFunction(value) {
		      return typeof value == 'function' ? value : identity;
		    }

		    /**
		     * Casts `value` to a path array if it's not one.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @param {Object} [object] The object to query keys on.
		     * @returns {Array} Returns the cast property path array.
		     */
		    function castPath(value, object) {
		      if (isArray(value)) {
		        return value;
		      }
		      return isKey(value, object) ? [value] : stringToPath(toString(value));
		    }

		    /**
		     * A `baseRest` alias which can be replaced with `identity` by module
		     * replacement plugins.
		     *
		     * @private
		     * @type {Function}
		     * @param {Function} func The function to apply a rest parameter to.
		     * @returns {Function} Returns the new function.
		     */
		    var castRest = baseRest;

		    /**
		     * Casts `array` to a slice if it's needed.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {number} start The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the cast slice.
		     */
		    function castSlice(array, start, end) {
		      var length = array.length;
		      end = end === undefined$1 ? length : end;
		      return (!start && end >= length) ? array : baseSlice(array, start, end);
		    }

		    /**
		     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
		     *
		     * @private
		     * @param {number|Object} id The timer id or timeout object of the timer to clear.
		     */
		    var clearTimeout = ctxClearTimeout || function(id) {
		      return root.clearTimeout(id);
		    };

		    /**
		     * Creates a clone of  `buffer`.
		     *
		     * @private
		     * @param {Buffer} buffer The buffer to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Buffer} Returns the cloned buffer.
		     */
		    function cloneBuffer(buffer, isDeep) {
		      if (isDeep) {
		        return buffer.slice();
		      }
		      var length = buffer.length,
		          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

		      buffer.copy(result);
		      return result;
		    }

		    /**
		     * Creates a clone of `arrayBuffer`.
		     *
		     * @private
		     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
		     * @returns {ArrayBuffer} Returns the cloned array buffer.
		     */
		    function cloneArrayBuffer(arrayBuffer) {
		      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
		      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
		      return result;
		    }

		    /**
		     * Creates a clone of `dataView`.
		     *
		     * @private
		     * @param {Object} dataView The data view to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the cloned data view.
		     */
		    function cloneDataView(dataView, isDeep) {
		      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
		      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
		    }

		    /**
		     * Creates a clone of `regexp`.
		     *
		     * @private
		     * @param {Object} regexp The regexp to clone.
		     * @returns {Object} Returns the cloned regexp.
		     */
		    function cloneRegExp(regexp) {
		      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
		      result.lastIndex = regexp.lastIndex;
		      return result;
		    }

		    /**
		     * Creates a clone of the `symbol` object.
		     *
		     * @private
		     * @param {Object} symbol The symbol object to clone.
		     * @returns {Object} Returns the cloned symbol object.
		     */
		    function cloneSymbol(symbol) {
		      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
		    }

		    /**
		     * Creates a clone of `typedArray`.
		     *
		     * @private
		     * @param {Object} typedArray The typed array to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the cloned typed array.
		     */
		    function cloneTypedArray(typedArray, isDeep) {
		      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
		      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
		    }

		    /**
		     * Compares values to sort them in ascending order.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {number} Returns the sort order indicator for `value`.
		     */
		    function compareAscending(value, other) {
		      if (value !== other) {
		        var valIsDefined = value !== undefined$1,
		            valIsNull = value === null,
		            valIsReflexive = value === value,
		            valIsSymbol = isSymbol(value);

		        var othIsDefined = other !== undefined$1,
		            othIsNull = other === null,
		            othIsReflexive = other === other,
		            othIsSymbol = isSymbol(other);

		        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
		            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
		            (valIsNull && othIsDefined && othIsReflexive) ||
		            (!valIsDefined && othIsReflexive) ||
		            !valIsReflexive) {
		          return 1;
		        }
		        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
		            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
		            (othIsNull && valIsDefined && valIsReflexive) ||
		            (!othIsDefined && valIsReflexive) ||
		            !othIsReflexive) {
		          return -1;
		        }
		      }
		      return 0;
		    }

		    /**
		     * Used by `_.orderBy` to compare multiple properties of a value to another
		     * and stable sort them.
		     *
		     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
		     * specify an order of "desc" for descending or "asc" for ascending sort order
		     * of corresponding values.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {boolean[]|string[]} orders The order to sort by for each property.
		     * @returns {number} Returns the sort order indicator for `object`.
		     */
		    function compareMultiple(object, other, orders) {
		      var index = -1,
		          objCriteria = object.criteria,
		          othCriteria = other.criteria,
		          length = objCriteria.length,
		          ordersLength = orders.length;

		      while (++index < length) {
		        var result = compareAscending(objCriteria[index], othCriteria[index]);
		        if (result) {
		          if (index >= ordersLength) {
		            return result;
		          }
		          var order = orders[index];
		          return result * (order == 'desc' ? -1 : 1);
		        }
		      }
		      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
		      // that causes it, under certain circumstances, to provide the same value for
		      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
		      // for more details.
		      //
		      // This also ensures a stable sort in V8 and other engines.
		      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
		      return object.index - other.index;
		    }

		    /**
		     * Creates an array that is the composition of partially applied arguments,
		     * placeholders, and provided arguments into a single array of arguments.
		     *
		     * @private
		     * @param {Array} args The provided arguments.
		     * @param {Array} partials The arguments to prepend to those provided.
		     * @param {Array} holders The `partials` placeholder indexes.
		     * @params {boolean} [isCurried] Specify composing for a curried function.
		     * @returns {Array} Returns the new array of composed arguments.
		     */
		    function composeArgs(args, partials, holders, isCurried) {
		      var argsIndex = -1,
		          argsLength = args.length,
		          holdersLength = holders.length,
		          leftIndex = -1,
		          leftLength = partials.length,
		          rangeLength = nativeMax(argsLength - holdersLength, 0),
		          result = Array(leftLength + rangeLength),
		          isUncurried = !isCurried;

		      while (++leftIndex < leftLength) {
		        result[leftIndex] = partials[leftIndex];
		      }
		      while (++argsIndex < holdersLength) {
		        if (isUncurried || argsIndex < argsLength) {
		          result[holders[argsIndex]] = args[argsIndex];
		        }
		      }
		      while (rangeLength--) {
		        result[leftIndex++] = args[argsIndex++];
		      }
		      return result;
		    }

		    /**
		     * This function is like `composeArgs` except that the arguments composition
		     * is tailored for `_.partialRight`.
		     *
		     * @private
		     * @param {Array} args The provided arguments.
		     * @param {Array} partials The arguments to append to those provided.
		     * @param {Array} holders The `partials` placeholder indexes.
		     * @params {boolean} [isCurried] Specify composing for a curried function.
		     * @returns {Array} Returns the new array of composed arguments.
		     */
		    function composeArgsRight(args, partials, holders, isCurried) {
		      var argsIndex = -1,
		          argsLength = args.length,
		          holdersIndex = -1,
		          holdersLength = holders.length,
		          rightIndex = -1,
		          rightLength = partials.length,
		          rangeLength = nativeMax(argsLength - holdersLength, 0),
		          result = Array(rangeLength + rightLength),
		          isUncurried = !isCurried;

		      while (++argsIndex < rangeLength) {
		        result[argsIndex] = args[argsIndex];
		      }
		      var offset = argsIndex;
		      while (++rightIndex < rightLength) {
		        result[offset + rightIndex] = partials[rightIndex];
		      }
		      while (++holdersIndex < holdersLength) {
		        if (isUncurried || argsIndex < argsLength) {
		          result[offset + holders[holdersIndex]] = args[argsIndex++];
		        }
		      }
		      return result;
		    }

		    /**
		     * Copies the values of `source` to `array`.
		     *
		     * @private
		     * @param {Array} source The array to copy values from.
		     * @param {Array} [array=[]] The array to copy values to.
		     * @returns {Array} Returns `array`.
		     */
		    function copyArray(source, array) {
		      var index = -1,
		          length = source.length;

		      array || (array = Array(length));
		      while (++index < length) {
		        array[index] = source[index];
		      }
		      return array;
		    }

		    /**
		     * Copies properties of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy properties from.
		     * @param {Array} props The property identifiers to copy.
		     * @param {Object} [object={}] The object to copy properties to.
		     * @param {Function} [customizer] The function to customize copied values.
		     * @returns {Object} Returns `object`.
		     */
		    function copyObject(source, props, object, customizer) {
		      var isNew = !object;
		      object || (object = {});

		      var index = -1,
		          length = props.length;

		      while (++index < length) {
		        var key = props[index];

		        var newValue = customizer
		          ? customizer(object[key], source[key], key, object, source)
		          : undefined$1;

		        if (newValue === undefined$1) {
		          newValue = source[key];
		        }
		        if (isNew) {
		          baseAssignValue(object, key, newValue);
		        } else {
		          assignValue(object, key, newValue);
		        }
		      }
		      return object;
		    }

		    /**
		     * Copies own symbols of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy symbols from.
		     * @param {Object} [object={}] The object to copy symbols to.
		     * @returns {Object} Returns `object`.
		     */
		    function copySymbols(source, object) {
		      return copyObject(source, getSymbols(source), object);
		    }

		    /**
		     * Copies own and inherited symbols of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy symbols from.
		     * @param {Object} [object={}] The object to copy symbols to.
		     * @returns {Object} Returns `object`.
		     */
		    function copySymbolsIn(source, object) {
		      return copyObject(source, getSymbolsIn(source), object);
		    }

		    /**
		     * Creates a function like `_.groupBy`.
		     *
		     * @private
		     * @param {Function} setter The function to set accumulator values.
		     * @param {Function} [initializer] The accumulator object initializer.
		     * @returns {Function} Returns the new aggregator function.
		     */
		    function createAggregator(setter, initializer) {
		      return function(collection, iteratee) {
		        var func = isArray(collection) ? arrayAggregator : baseAggregator,
		            accumulator = initializer ? initializer() : {};

		        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
		      };
		    }

		    /**
		     * Creates a function like `_.assign`.
		     *
		     * @private
		     * @param {Function} assigner The function to assign values.
		     * @returns {Function} Returns the new assigner function.
		     */
		    function createAssigner(assigner) {
		      return baseRest(function(object, sources) {
		        var index = -1,
		            length = sources.length,
		            customizer = length > 1 ? sources[length - 1] : undefined$1,
		            guard = length > 2 ? sources[2] : undefined$1;

		        customizer = (assigner.length > 3 && typeof customizer == 'function')
		          ? (length--, customizer)
		          : undefined$1;

		        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
		          customizer = length < 3 ? undefined$1 : customizer;
		          length = 1;
		        }
		        object = Object(object);
		        while (++index < length) {
		          var source = sources[index];
		          if (source) {
		            assigner(object, source, index, customizer);
		          }
		        }
		        return object;
		      });
		    }

		    /**
		     * Creates a `baseEach` or `baseEachRight` function.
		     *
		     * @private
		     * @param {Function} eachFunc The function to iterate over a collection.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new base function.
		     */
		    function createBaseEach(eachFunc, fromRight) {
		      return function(collection, iteratee) {
		        if (collection == null) {
		          return collection;
		        }
		        if (!isArrayLike(collection)) {
		          return eachFunc(collection, iteratee);
		        }
		        var length = collection.length,
		            index = fromRight ? length : -1,
		            iterable = Object(collection);

		        while ((fromRight ? index-- : ++index < length)) {
		          if (iteratee(iterable[index], index, iterable) === false) {
		            break;
		          }
		        }
		        return collection;
		      };
		    }

		    /**
		     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new base function.
		     */
		    function createBaseFor(fromRight) {
		      return function(object, iteratee, keysFunc) {
		        var index = -1,
		            iterable = Object(object),
		            props = keysFunc(object),
		            length = props.length;

		        while (length--) {
		          var key = props[fromRight ? length : ++index];
		          if (iteratee(iterable[key], key, iterable) === false) {
		            break;
		          }
		        }
		        return object;
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with the optional `this`
		     * binding of `thisArg`.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createBind(func, bitmask, thisArg) {
		      var isBind = bitmask & WRAP_BIND_FLAG,
		          Ctor = createCtor(func);

		      function wrapper() {
		        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
		        return fn.apply(isBind ? thisArg : this, arguments);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a function like `_.lowerFirst`.
		     *
		     * @private
		     * @param {string} methodName The name of the `String` case method to use.
		     * @returns {Function} Returns the new case function.
		     */
		    function createCaseFirst(methodName) {
		      return function(string) {
		        string = toString(string);

		        var strSymbols = hasUnicode(string)
		          ? stringToArray(string)
		          : undefined$1;

		        var chr = strSymbols
		          ? strSymbols[0]
		          : string.charAt(0);

		        var trailing = strSymbols
		          ? castSlice(strSymbols, 1).join('')
		          : string.slice(1);

		        return chr[methodName]() + trailing;
		      };
		    }

		    /**
		     * Creates a function like `_.camelCase`.
		     *
		     * @private
		     * @param {Function} callback The function to combine each word.
		     * @returns {Function} Returns the new compounder function.
		     */
		    function createCompounder(callback) {
		      return function(string) {
		        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
		      };
		    }

		    /**
		     * Creates a function that produces an instance of `Ctor` regardless of
		     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
		     *
		     * @private
		     * @param {Function} Ctor The constructor to wrap.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createCtor(Ctor) {
		      return function() {
		        // Use a `switch` statement to work with class constructors. See
		        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
		        // for more details.
		        var args = arguments;
		        switch (args.length) {
		          case 0: return new Ctor;
		          case 1: return new Ctor(args[0]);
		          case 2: return new Ctor(args[0], args[1]);
		          case 3: return new Ctor(args[0], args[1], args[2]);
		          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
		          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
		          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
		          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
		        }
		        var thisBinding = baseCreate(Ctor.prototype),
		            result = Ctor.apply(thisBinding, args);

		        // Mimic the constructor's `return` behavior.
		        // See https://es5.github.io/#x13.2.2 for more details.
		        return isObject(result) ? result : thisBinding;
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to enable currying.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {number} arity The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createCurry(func, bitmask, arity) {
		      var Ctor = createCtor(func);

		      function wrapper() {
		        var length = arguments.length,
		            args = Array(length),
		            index = length,
		            placeholder = getHolder(wrapper);

		        while (index--) {
		          args[index] = arguments[index];
		        }
		        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
		          ? []
		          : replaceHolders(args, placeholder);

		        length -= holders.length;
		        if (length < arity) {
		          return createRecurry(
		            func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
		            args, holders, undefined$1, undefined$1, arity - length);
		        }
		        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
		        return apply(fn, this, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a `_.find` or `_.findLast` function.
		     *
		     * @private
		     * @param {Function} findIndexFunc The function to find the collection index.
		     * @returns {Function} Returns the new find function.
		     */
		    function createFind(findIndexFunc) {
		      return function(collection, predicate, fromIndex) {
		        var iterable = Object(collection);
		        if (!isArrayLike(collection)) {
		          var iteratee = getIteratee(predicate, 3);
		          collection = keys(collection);
		          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
		        }
		        var index = findIndexFunc(collection, predicate, fromIndex);
		        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
		      };
		    }

		    /**
		     * Creates a `_.flow` or `_.flowRight` function.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new flow function.
		     */
		    function createFlow(fromRight) {
		      return flatRest(function(funcs) {
		        var length = funcs.length,
		            index = length,
		            prereq = LodashWrapper.prototype.thru;

		        if (fromRight) {
		          funcs.reverse();
		        }
		        while (index--) {
		          var func = funcs[index];
		          if (typeof func != 'function') {
		            throw new TypeError(FUNC_ERROR_TEXT);
		          }
		          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
		            var wrapper = new LodashWrapper([], true);
		          }
		        }
		        index = wrapper ? index : length;
		        while (++index < length) {
		          func = funcs[index];

		          var funcName = getFuncName(func),
		              data = funcName == 'wrapper' ? getData(func) : undefined$1;

		          if (data && isLaziable(data[0]) &&
		                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
		                !data[4].length && data[9] == 1
		              ) {
		            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
		          } else {
		            wrapper = (func.length == 1 && isLaziable(func))
		              ? wrapper[funcName]()
		              : wrapper.thru(func);
		          }
		        }
		        return function() {
		          var args = arguments,
		              value = args[0];

		          if (wrapper && args.length == 1 && isArray(value)) {
		            return wrapper.plant(value).value();
		          }
		          var index = 0,
		              result = length ? funcs[index].apply(this, args) : value;

		          while (++index < length) {
		            result = funcs[index].call(this, result);
		          }
		          return result;
		        };
		      });
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with optional `this`
		     * binding of `thisArg`, partial application, and currying.
		     *
		     * @private
		     * @param {Function|string} func The function or method name to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to prepend to those provided to
		     *  the new function.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [partialsRight] The arguments to append to those provided
		     *  to the new function.
		     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
		      var isAry = bitmask & WRAP_ARY_FLAG,
		          isBind = bitmask & WRAP_BIND_FLAG,
		          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
		          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
		          isFlip = bitmask & WRAP_FLIP_FLAG,
		          Ctor = isBindKey ? undefined$1 : createCtor(func);

		      function wrapper() {
		        var length = arguments.length,
		            args = Array(length),
		            index = length;

		        while (index--) {
		          args[index] = arguments[index];
		        }
		        if (isCurried) {
		          var placeholder = getHolder(wrapper),
		              holdersCount = countHolders(args, placeholder);
		        }
		        if (partials) {
		          args = composeArgs(args, partials, holders, isCurried);
		        }
		        if (partialsRight) {
		          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
		        }
		        length -= holdersCount;
		        if (isCurried && length < arity) {
		          var newHolders = replaceHolders(args, placeholder);
		          return createRecurry(
		            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
		            args, newHolders, argPos, ary, arity - length
		          );
		        }
		        var thisBinding = isBind ? thisArg : this,
		            fn = isBindKey ? thisBinding[func] : func;

		        length = args.length;
		        if (argPos) {
		          args = reorder(args, argPos);
		        } else if (isFlip && length > 1) {
		          args.reverse();
		        }
		        if (isAry && ary < length) {
		          args.length = ary;
		        }
		        if (this && this !== root && this instanceof wrapper) {
		          fn = Ctor || createCtor(fn);
		        }
		        return fn.apply(thisBinding, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a function like `_.invertBy`.
		     *
		     * @private
		     * @param {Function} setter The function to set accumulator values.
		     * @param {Function} toIteratee The function to resolve iteratees.
		     * @returns {Function} Returns the new inverter function.
		     */
		    function createInverter(setter, toIteratee) {
		      return function(object, iteratee) {
		        return baseInverter(object, setter, toIteratee(iteratee), {});
		      };
		    }

		    /**
		     * Creates a function that performs a mathematical operation on two values.
		     *
		     * @private
		     * @param {Function} operator The function to perform the operation.
		     * @param {number} [defaultValue] The value used for `undefined` arguments.
		     * @returns {Function} Returns the new mathematical operation function.
		     */
		    function createMathOperation(operator, defaultValue) {
		      return function(value, other) {
		        var result;
		        if (value === undefined$1 && other === undefined$1) {
		          return defaultValue;
		        }
		        if (value !== undefined$1) {
		          result = value;
		        }
		        if (other !== undefined$1) {
		          if (result === undefined$1) {
		            return other;
		          }
		          if (typeof value == 'string' || typeof other == 'string') {
		            value = baseToString(value);
		            other = baseToString(other);
		          } else {
		            value = baseToNumber(value);
		            other = baseToNumber(other);
		          }
		          result = operator(value, other);
		        }
		        return result;
		      };
		    }

		    /**
		     * Creates a function like `_.over`.
		     *
		     * @private
		     * @param {Function} arrayFunc The function to iterate over iteratees.
		     * @returns {Function} Returns the new over function.
		     */
		    function createOver(arrayFunc) {
		      return flatRest(function(iteratees) {
		        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
		        return baseRest(function(args) {
		          var thisArg = this;
		          return arrayFunc(iteratees, function(iteratee) {
		            return apply(iteratee, thisArg, args);
		          });
		        });
		      });
		    }

		    /**
		     * Creates the padding for `string` based on `length`. The `chars` string
		     * is truncated if the number of characters exceeds `length`.
		     *
		     * @private
		     * @param {number} length The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padding for `string`.
		     */
		    function createPadding(length, chars) {
		      chars = chars === undefined$1 ? ' ' : baseToString(chars);

		      var charsLength = chars.length;
		      if (charsLength < 2) {
		        return charsLength ? baseRepeat(chars, length) : chars;
		      }
		      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
		      return hasUnicode(chars)
		        ? castSlice(stringToArray(result), 0, length).join('')
		        : result.slice(0, length);
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with the `this` binding
		     * of `thisArg` and `partials` prepended to the arguments it receives.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} thisArg The `this` binding of `func`.
		     * @param {Array} partials The arguments to prepend to those provided to
		     *  the new function.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createPartial(func, bitmask, thisArg, partials) {
		      var isBind = bitmask & WRAP_BIND_FLAG,
		          Ctor = createCtor(func);

		      function wrapper() {
		        var argsIndex = -1,
		            argsLength = arguments.length,
		            leftIndex = -1,
		            leftLength = partials.length,
		            args = Array(leftLength + argsLength),
		            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

		        while (++leftIndex < leftLength) {
		          args[leftIndex] = partials[leftIndex];
		        }
		        while (argsLength--) {
		          args[leftIndex++] = arguments[++argsIndex];
		        }
		        return apply(fn, isBind ? thisArg : this, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a `_.range` or `_.rangeRight` function.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new range function.
		     */
		    function createRange(fromRight) {
		      return function(start, end, step) {
		        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
		          end = step = undefined$1;
		        }
		        // Ensure the sign of `-0` is preserved.
		        start = toFinite(start);
		        if (end === undefined$1) {
		          end = start;
		          start = 0;
		        } else {
		          end = toFinite(end);
		        }
		        step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
		        return baseRange(start, end, step, fromRight);
		      };
		    }

		    /**
		     * Creates a function that performs a relational operation on two values.
		     *
		     * @private
		     * @param {Function} operator The function to perform the operation.
		     * @returns {Function} Returns the new relational operation function.
		     */
		    function createRelationalOperation(operator) {
		      return function(value, other) {
		        if (!(typeof value == 'string' && typeof other == 'string')) {
		          value = toNumber(value);
		          other = toNumber(other);
		        }
		        return operator(value, other);
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to continue currying.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {Function} wrapFunc The function to create the `func` wrapper.
		     * @param {*} placeholder The placeholder value.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to prepend to those provided to
		     *  the new function.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
		      var isCurry = bitmask & WRAP_CURRY_FLAG,
		          newHolders = isCurry ? holders : undefined$1,
		          newHoldersRight = isCurry ? undefined$1 : holders,
		          newPartials = isCurry ? partials : undefined$1,
		          newPartialsRight = isCurry ? undefined$1 : partials;

		      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
		      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

		      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
		        bitmask &= -4;
		      }
		      var newData = [
		        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
		        newHoldersRight, argPos, ary, arity
		      ];

		      var result = wrapFunc.apply(undefined$1, newData);
		      if (isLaziable(func)) {
		        setData(result, newData);
		      }
		      result.placeholder = placeholder;
		      return setWrapToString(result, func, bitmask);
		    }

		    /**
		     * Creates a function like `_.round`.
		     *
		     * @private
		     * @param {string} methodName The name of the `Math` method to use when rounding.
		     * @returns {Function} Returns the new round function.
		     */
		    function createRound(methodName) {
		      var func = Math[methodName];
		      return function(number, precision) {
		        number = toNumber(number);
		        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
		        if (precision && nativeIsFinite(number)) {
		          // Shift with exponential notation to avoid floating-point issues.
		          // See [MDN](https://mdn.io/round#Examples) for more details.
		          var pair = (toString(number) + 'e').split('e'),
		              value = func(pair[0] + 'e' + (+pair[1] + precision));

		          pair = (toString(value) + 'e').split('e');
		          return +(pair[0] + 'e' + (+pair[1] - precision));
		        }
		        return func(number);
		      };
		    }

		    /**
		     * Creates a set object of `values`.
		     *
		     * @private
		     * @param {Array} values The values to add to the set.
		     * @returns {Object} Returns the new set.
		     */
		    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
		      return new Set(values);
		    };

		    /**
		     * Creates a `_.toPairs` or `_.toPairsIn` function.
		     *
		     * @private
		     * @param {Function} keysFunc The function to get the keys of a given object.
		     * @returns {Function} Returns the new pairs function.
		     */
		    function createToPairs(keysFunc) {
		      return function(object) {
		        var tag = getTag(object);
		        if (tag == mapTag) {
		          return mapToArray(object);
		        }
		        if (tag == setTag) {
		          return setToPairs(object);
		        }
		        return baseToPairs(object, keysFunc(object));
		      };
		    }

		    /**
		     * Creates a function that either curries or invokes `func` with optional
		     * `this` binding and partially applied arguments.
		     *
		     * @private
		     * @param {Function|string} func The function or method name to wrap.
		     * @param {number} bitmask The bitmask flags.
		     *    1 - `_.bind`
		     *    2 - `_.bindKey`
		     *    4 - `_.curry` or `_.curryRight` of a bound function
		     *    8 - `_.curry`
		     *   16 - `_.curryRight`
		     *   32 - `_.partial`
		     *   64 - `_.partialRight`
		     *  128 - `_.rearg`
		     *  256 - `_.ary`
		     *  512 - `_.flip`
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to be partially applied.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
		      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
		      if (!isBindKey && typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      var length = partials ? partials.length : 0;
		      if (!length) {
		        bitmask &= -97;
		        partials = holders = undefined$1;
		      }
		      ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
		      arity = arity === undefined$1 ? arity : toInteger(arity);
		      length -= holders ? holders.length : 0;

		      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
		        var partialsRight = partials,
		            holdersRight = holders;

		        partials = holders = undefined$1;
		      }
		      var data = isBindKey ? undefined$1 : getData(func);

		      var newData = [
		        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
		        argPos, ary, arity
		      ];

		      if (data) {
		        mergeData(newData, data);
		      }
		      func = newData[0];
		      bitmask = newData[1];
		      thisArg = newData[2];
		      partials = newData[3];
		      holders = newData[4];
		      arity = newData[9] = newData[9] === undefined$1
		        ? (isBindKey ? 0 : func.length)
		        : nativeMax(newData[9] - length, 0);

		      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
		        bitmask &= -25;
		      }
		      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
		        var result = createBind(func, bitmask, thisArg);
		      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
		        result = createCurry(func, bitmask, arity);
		      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
		        result = createPartial(func, bitmask, thisArg, partials);
		      } else {
		        result = createHybrid.apply(undefined$1, newData);
		      }
		      var setter = data ? baseSetData : setData;
		      return setWrapToString(setter(result, newData), func, bitmask);
		    }

		    /**
		     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
		     * of source objects to the destination object for all destination properties
		     * that resolve to `undefined`.
		     *
		     * @private
		     * @param {*} objValue The destination value.
		     * @param {*} srcValue The source value.
		     * @param {string} key The key of the property to assign.
		     * @param {Object} object The parent object of `objValue`.
		     * @returns {*} Returns the value to assign.
		     */
		    function customDefaultsAssignIn(objValue, srcValue, key, object) {
		      if (objValue === undefined$1 ||
		          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
		        return srcValue;
		      }
		      return objValue;
		    }

		    /**
		     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
		     * objects into destination objects that are passed thru.
		     *
		     * @private
		     * @param {*} objValue The destination value.
		     * @param {*} srcValue The source value.
		     * @param {string} key The key of the property to merge.
		     * @param {Object} object The parent object of `objValue`.
		     * @param {Object} source The parent object of `srcValue`.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     * @returns {*} Returns the value to assign.
		     */
		    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
		      if (isObject(objValue) && isObject(srcValue)) {
		        // Recursively merge objects and arrays (susceptible to call stack limits).
		        stack.set(srcValue, objValue);
		        baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
		        stack['delete'](srcValue);
		      }
		      return objValue;
		    }

		    /**
		     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
		     * objects.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @param {string} key The key of the property to inspect.
		     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
		     */
		    function customOmitClone(value) {
		      return isPlainObject(value) ? undefined$1 : value;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for arrays with support for
		     * partial deep comparisons.
		     *
		     * @private
		     * @param {Array} array The array to compare.
		     * @param {Array} other The other array to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `array` and `other` objects.
		     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
		     */
		    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
		      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
		          arrLength = array.length,
		          othLength = other.length;

		      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
		        return false;
		      }
		      // Check that cyclic values are equal.
		      var arrStacked = stack.get(array);
		      var othStacked = stack.get(other);
		      if (arrStacked && othStacked) {
		        return arrStacked == other && othStacked == array;
		      }
		      var index = -1,
		          result = true,
		          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

		      stack.set(array, other);
		      stack.set(other, array);

		      // Ignore non-index properties.
		      while (++index < arrLength) {
		        var arrValue = array[index],
		            othValue = other[index];

		        if (customizer) {
		          var compared = isPartial
		            ? customizer(othValue, arrValue, index, other, array, stack)
		            : customizer(arrValue, othValue, index, array, other, stack);
		        }
		        if (compared !== undefined$1) {
		          if (compared) {
		            continue;
		          }
		          result = false;
		          break;
		        }
		        // Recursively compare arrays (susceptible to call stack limits).
		        if (seen) {
		          if (!arraySome(other, function(othValue, othIndex) {
		                if (!cacheHas(seen, othIndex) &&
		                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
		                  return seen.push(othIndex);
		                }
		              })) {
		            result = false;
		            break;
		          }
		        } else if (!(
		              arrValue === othValue ||
		                equalFunc(arrValue, othValue, bitmask, customizer, stack)
		            )) {
		          result = false;
		          break;
		        }
		      }
		      stack['delete'](array);
		      stack['delete'](other);
		      return result;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for comparing objects of
		     * the same `toStringTag`.
		     *
		     * **Note:** This function only supports comparing values with tags of
		     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {string} tag The `toStringTag` of the objects to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
		      switch (tag) {
		        case dataViewTag:
		          if ((object.byteLength != other.byteLength) ||
		              (object.byteOffset != other.byteOffset)) {
		            return false;
		          }
		          object = object.buffer;
		          other = other.buffer;

		        case arrayBufferTag:
		          if ((object.byteLength != other.byteLength) ||
		              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
		            return false;
		          }
		          return true;

		        case boolTag:
		        case dateTag:
		        case numberTag:
		          // Coerce booleans to `1` or `0` and dates to milliseconds.
		          // Invalid dates are coerced to `NaN`.
		          return eq(+object, +other);

		        case errorTag:
		          return object.name == other.name && object.message == other.message;

		        case regexpTag:
		        case stringTag:
		          // Coerce regexes to strings and treat strings, primitives and objects,
		          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
		          // for more details.
		          return object == (other + '');

		        case mapTag:
		          var convert = mapToArray;

		        case setTag:
		          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
		          convert || (convert = setToArray);

		          if (object.size != other.size && !isPartial) {
		            return false;
		          }
		          // Assume cyclic values are equal.
		          var stacked = stack.get(object);
		          if (stacked) {
		            return stacked == other;
		          }
		          bitmask |= COMPARE_UNORDERED_FLAG;

		          // Recursively compare objects (susceptible to call stack limits).
		          stack.set(object, other);
		          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
		          stack['delete'](object);
		          return result;

		        case symbolTag:
		          if (symbolValueOf) {
		            return symbolValueOf.call(object) == symbolValueOf.call(other);
		          }
		      }
		      return false;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for objects with support for
		     * partial deep comparisons.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
		      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
		          objProps = getAllKeys(object),
		          objLength = objProps.length,
		          othProps = getAllKeys(other),
		          othLength = othProps.length;

		      if (objLength != othLength && !isPartial) {
		        return false;
		      }
		      var index = objLength;
		      while (index--) {
		        var key = objProps[index];
		        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
		          return false;
		        }
		      }
		      // Check that cyclic values are equal.
		      var objStacked = stack.get(object);
		      var othStacked = stack.get(other);
		      if (objStacked && othStacked) {
		        return objStacked == other && othStacked == object;
		      }
		      var result = true;
		      stack.set(object, other);
		      stack.set(other, object);

		      var skipCtor = isPartial;
		      while (++index < objLength) {
		        key = objProps[index];
		        var objValue = object[key],
		            othValue = other[key];

		        if (customizer) {
		          var compared = isPartial
		            ? customizer(othValue, objValue, key, other, object, stack)
		            : customizer(objValue, othValue, key, object, other, stack);
		        }
		        // Recursively compare objects (susceptible to call stack limits).
		        if (!(compared === undefined$1
		              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
		              : compared
		            )) {
		          result = false;
		          break;
		        }
		        skipCtor || (skipCtor = key == 'constructor');
		      }
		      if (result && !skipCtor) {
		        var objCtor = object.constructor,
		            othCtor = other.constructor;

		        // Non `Object` object instances with different constructors are not equal.
		        if (objCtor != othCtor &&
		            ('constructor' in object && 'constructor' in other) &&
		            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
		              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
		          result = false;
		        }
		      }
		      stack['delete'](object);
		      stack['delete'](other);
		      return result;
		    }

		    /**
		     * A specialized version of `baseRest` which flattens the rest array.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @returns {Function} Returns the new function.
		     */
		    function flatRest(func) {
		      return setToString(overRest(func, undefined$1, flatten), func + '');
		    }

		    /**
		     * Creates an array of own enumerable property names and symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function getAllKeys(object) {
		      return baseGetAllKeys(object, keys, getSymbols);
		    }

		    /**
		     * Creates an array of own and inherited enumerable property names and
		     * symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function getAllKeysIn(object) {
		      return baseGetAllKeys(object, keysIn, getSymbolsIn);
		    }

		    /**
		     * Gets metadata for `func`.
		     *
		     * @private
		     * @param {Function} func The function to query.
		     * @returns {*} Returns the metadata for `func`.
		     */
		    var getData = !metaMap ? noop : function(func) {
		      return metaMap.get(func);
		    };

		    /**
		     * Gets the name of `func`.
		     *
		     * @private
		     * @param {Function} func The function to query.
		     * @returns {string} Returns the function name.
		     */
		    function getFuncName(func) {
		      var result = (func.name + ''),
		          array = realNames[result],
		          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

		      while (length--) {
		        var data = array[length],
		            otherFunc = data.func;
		        if (otherFunc == null || otherFunc == func) {
		          return data.name;
		        }
		      }
		      return result;
		    }

		    /**
		     * Gets the argument placeholder value for `func`.
		     *
		     * @private
		     * @param {Function} func The function to inspect.
		     * @returns {*} Returns the placeholder value.
		     */
		    function getHolder(func) {
		      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
		      return object.placeholder;
		    }

		    /**
		     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
		     * this function returns the custom method, otherwise it returns `baseIteratee`.
		     * If arguments are provided, the chosen function is invoked with them and
		     * its result is returned.
		     *
		     * @private
		     * @param {*} [value] The value to convert to an iteratee.
		     * @param {number} [arity] The arity of the created iteratee.
		     * @returns {Function} Returns the chosen function or its result.
		     */
		    function getIteratee() {
		      var result = lodash.iteratee || iteratee;
		      result = result === iteratee ? baseIteratee : result;
		      return arguments.length ? result(arguments[0], arguments[1]) : result;
		    }

		    /**
		     * Gets the data for `map`.
		     *
		     * @private
		     * @param {Object} map The map to query.
		     * @param {string} key The reference key.
		     * @returns {*} Returns the map data.
		     */
		    function getMapData(map, key) {
		      var data = map.__data__;
		      return isKeyable(key)
		        ? data[typeof key == 'string' ? 'string' : 'hash']
		        : data.map;
		    }

		    /**
		     * Gets the property names, values, and compare flags of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the match data of `object`.
		     */
		    function getMatchData(object) {
		      var result = keys(object),
		          length = result.length;

		      while (length--) {
		        var key = result[length],
		            value = object[key];

		        result[length] = [key, value, isStrictComparable(value)];
		      }
		      return result;
		    }

		    /**
		     * Gets the native function at `key` of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {string} key The key of the method to get.
		     * @returns {*} Returns the function if it's native, else `undefined`.
		     */
		    function getNative(object, key) {
		      var value = getValue(object, key);
		      return baseIsNative(value) ? value : undefined$1;
		    }

		    /**
		     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the raw `toStringTag`.
		     */
		    function getRawTag(value) {
		      var isOwn = hasOwnProperty.call(value, symToStringTag),
		          tag = value[symToStringTag];

		      try {
		        value[symToStringTag] = undefined$1;
		        var unmasked = true;
		      } catch (e) {}

		      var result = nativeObjectToString.call(value);
		      if (unmasked) {
		        if (isOwn) {
		          value[symToStringTag] = tag;
		        } else {
		          delete value[symToStringTag];
		        }
		      }
		      return result;
		    }

		    /**
		     * Creates an array of the own enumerable symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of symbols.
		     */
		    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
		      if (object == null) {
		        return [];
		      }
		      object = Object(object);
		      return arrayFilter(nativeGetSymbols(object), function(symbol) {
		        return propertyIsEnumerable.call(object, symbol);
		      });
		    };

		    /**
		     * Creates an array of the own and inherited enumerable symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of symbols.
		     */
		    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
		      var result = [];
		      while (object) {
		        arrayPush(result, getSymbols(object));
		        object = getPrototype(object);
		      }
		      return result;
		    };

		    /**
		     * Gets the `toStringTag` of `value`.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the `toStringTag`.
		     */
		    var getTag = baseGetTag;

		    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
		    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
		        (Map && getTag(new Map) != mapTag) ||
		        (Promise && getTag(Promise.resolve()) != promiseTag) ||
		        (Set && getTag(new Set) != setTag) ||
		        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
		      getTag = function(value) {
		        var result = baseGetTag(value),
		            Ctor = result == objectTag ? value.constructor : undefined$1,
		            ctorString = Ctor ? toSource(Ctor) : '';

		        if (ctorString) {
		          switch (ctorString) {
		            case dataViewCtorString: return dataViewTag;
		            case mapCtorString: return mapTag;
		            case promiseCtorString: return promiseTag;
		            case setCtorString: return setTag;
		            case weakMapCtorString: return weakMapTag;
		          }
		        }
		        return result;
		      };
		    }

		    /**
		     * Gets the view, applying any `transforms` to the `start` and `end` positions.
		     *
		     * @private
		     * @param {number} start The start of the view.
		     * @param {number} end The end of the view.
		     * @param {Array} transforms The transformations to apply to the view.
		     * @returns {Object} Returns an object containing the `start` and `end`
		     *  positions of the view.
		     */
		    function getView(start, end, transforms) {
		      var index = -1,
		          length = transforms.length;

		      while (++index < length) {
		        var data = transforms[index],
		            size = data.size;

		        switch (data.type) {
		          case 'drop':      start += size; break;
		          case 'dropRight': end -= size; break;
		          case 'take':      end = nativeMin(end, start + size); break;
		          case 'takeRight': start = nativeMax(start, end - size); break;
		        }
		      }
		      return { 'start': start, 'end': end };
		    }

		    /**
		     * Extracts wrapper details from the `source` body comment.
		     *
		     * @private
		     * @param {string} source The source to inspect.
		     * @returns {Array} Returns the wrapper details.
		     */
		    function getWrapDetails(source) {
		      var match = source.match(reWrapDetails);
		      return match ? match[1].split(reSplitDetails) : [];
		    }

		    /**
		     * Checks if `path` exists on `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @param {Function} hasFunc The function to check properties.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     */
		    function hasPath(object, path, hasFunc) {
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length,
		          result = false;

		      while (++index < length) {
		        var key = toKey(path[index]);
		        if (!(result = object != null && hasFunc(object, key))) {
		          break;
		        }
		        object = object[key];
		      }
		      if (result || ++index != length) {
		        return result;
		      }
		      length = object == null ? 0 : object.length;
		      return !!length && isLength(length) && isIndex(key, length) &&
		        (isArray(object) || isArguments(object));
		    }

		    /**
		     * Initializes an array clone.
		     *
		     * @private
		     * @param {Array} array The array to clone.
		     * @returns {Array} Returns the initialized clone.
		     */
		    function initCloneArray(array) {
		      var length = array.length,
		          result = new array.constructor(length);

		      // Add properties assigned by `RegExp#exec`.
		      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
		        result.index = array.index;
		        result.input = array.input;
		      }
		      return result;
		    }

		    /**
		     * Initializes an object clone.
		     *
		     * @private
		     * @param {Object} object The object to clone.
		     * @returns {Object} Returns the initialized clone.
		     */
		    function initCloneObject(object) {
		      return (typeof object.constructor == 'function' && !isPrototype(object))
		        ? baseCreate(getPrototype(object))
		        : {};
		    }

		    /**
		     * Initializes an object clone based on its `toStringTag`.
		     *
		     * **Note:** This function only supports cloning values with tags of
		     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
		     *
		     * @private
		     * @param {Object} object The object to clone.
		     * @param {string} tag The `toStringTag` of the object to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the initialized clone.
		     */
		    function initCloneByTag(object, tag, isDeep) {
		      var Ctor = object.constructor;
		      switch (tag) {
		        case arrayBufferTag:
		          return cloneArrayBuffer(object);

		        case boolTag:
		        case dateTag:
		          return new Ctor(+object);

		        case dataViewTag:
		          return cloneDataView(object, isDeep);

		        case float32Tag: case float64Tag:
		        case int8Tag: case int16Tag: case int32Tag:
		        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
		          return cloneTypedArray(object, isDeep);

		        case mapTag:
		          return new Ctor;

		        case numberTag:
		        case stringTag:
		          return new Ctor(object);

		        case regexpTag:
		          return cloneRegExp(object);

		        case setTag:
		          return new Ctor;

		        case symbolTag:
		          return cloneSymbol(object);
		      }
		    }

		    /**
		     * Inserts wrapper `details` in a comment at the top of the `source` body.
		     *
		     * @private
		     * @param {string} source The source to modify.
		     * @returns {Array} details The details to insert.
		     * @returns {string} Returns the modified source.
		     */
		    function insertWrapDetails(source, details) {
		      var length = details.length;
		      if (!length) {
		        return source;
		      }
		      var lastIndex = length - 1;
		      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
		      details = details.join(length > 2 ? ', ' : ' ');
		      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
		    }

		    /**
		     * Checks if `value` is a flattenable `arguments` object or array.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
		     */
		    function isFlattenable(value) {
		      return isArray(value) || isArguments(value) ||
		        !!(spreadableSymbol && value && value[spreadableSymbol]);
		    }

		    /**
		     * Checks if `value` is a valid array-like index.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
		     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
		     */
		    function isIndex(value, length) {
		      var type = typeof value;
		      length = length == null ? MAX_SAFE_INTEGER : length;

		      return !!length &&
		        (type == 'number' ||
		          (type != 'symbol' && reIsUint.test(value))) &&
		            (value > -1 && value % 1 == 0 && value < length);
		    }

		    /**
		     * Checks if the given arguments are from an iteratee call.
		     *
		     * @private
		     * @param {*} value The potential iteratee value argument.
		     * @param {*} index The potential iteratee index or key argument.
		     * @param {*} object The potential iteratee object argument.
		     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
		     *  else `false`.
		     */
		    function isIterateeCall(value, index, object) {
		      if (!isObject(object)) {
		        return false;
		      }
		      var type = typeof index;
		      if (type == 'number'
		            ? (isArrayLike(object) && isIndex(index, object.length))
		            : (type == 'string' && index in object)
		          ) {
		        return eq(object[index], value);
		      }
		      return false;
		    }

		    /**
		     * Checks if `value` is a property name and not a property path.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @param {Object} [object] The object to query keys on.
		     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
		     */
		    function isKey(value, object) {
		      if (isArray(value)) {
		        return false;
		      }
		      var type = typeof value;
		      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
		          value == null || isSymbol(value)) {
		        return true;
		      }
		      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
		        (object != null && value in Object(object));
		    }

		    /**
		     * Checks if `value` is suitable for use as unique object key.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
		     */
		    function isKeyable(value) {
		      var type = typeof value;
		      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
		        ? (value !== '__proto__')
		        : (value === null);
		    }

		    /**
		     * Checks if `func` has a lazy counterpart.
		     *
		     * @private
		     * @param {Function} func The function to check.
		     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
		     *  else `false`.
		     */
		    function isLaziable(func) {
		      var funcName = getFuncName(func),
		          other = lodash[funcName];

		      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
		        return false;
		      }
		      if (func === other) {
		        return true;
		      }
		      var data = getData(other);
		      return !!data && func === data[0];
		    }

		    /**
		     * Checks if `func` has its source masked.
		     *
		     * @private
		     * @param {Function} func The function to check.
		     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
		     */
		    function isMasked(func) {
		      return !!maskSrcKey && (maskSrcKey in func);
		    }

		    /**
		     * Checks if `func` is capable of being masked.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
		     */
		    var isMaskable = coreJsData ? isFunction : stubFalse;

		    /**
		     * Checks if `value` is likely a prototype object.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
		     */
		    function isPrototype(value) {
		      var Ctor = value && value.constructor,
		          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

		      return value === proto;
		    }

		    /**
		     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` if suitable for strict
		     *  equality comparisons, else `false`.
		     */
		    function isStrictComparable(value) {
		      return value === value && !isObject(value);
		    }

		    /**
		     * A specialized version of `matchesProperty` for source values suitable
		     * for strict equality comparisons, i.e. `===`.
		     *
		     * @private
		     * @param {string} key The key of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function matchesStrictComparable(key, srcValue) {
		      return function(object) {
		        if (object == null) {
		          return false;
		        }
		        return object[key] === srcValue &&
		          (srcValue !== undefined$1 || (key in Object(object)));
		      };
		    }

		    /**
		     * A specialized version of `_.memoize` which clears the memoized function's
		     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
		     *
		     * @private
		     * @param {Function} func The function to have its output memoized.
		     * @returns {Function} Returns the new memoized function.
		     */
		    function memoizeCapped(func) {
		      var result = memoize(func, function(key) {
		        if (cache.size === MAX_MEMOIZE_SIZE) {
		          cache.clear();
		        }
		        return key;
		      });

		      var cache = result.cache;
		      return result;
		    }

		    /**
		     * Merges the function metadata of `source` into `data`.
		     *
		     * Merging metadata reduces the number of wrappers used to invoke a function.
		     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
		     * may be applied regardless of execution order. Methods like `_.ary` and
		     * `_.rearg` modify function arguments, making the order in which they are
		     * executed important, preventing the merging of metadata. However, we make
		     * an exception for a safe combined case where curried functions have `_.ary`
		     * and or `_.rearg` applied.
		     *
		     * @private
		     * @param {Array} data The destination metadata.
		     * @param {Array} source The source metadata.
		     * @returns {Array} Returns `data`.
		     */
		    function mergeData(data, source) {
		      var bitmask = data[1],
		          srcBitmask = source[1],
		          newBitmask = bitmask | srcBitmask,
		          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

		      var isCombo =
		        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
		        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
		        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

		      // Exit early if metadata can't be merged.
		      if (!(isCommon || isCombo)) {
		        return data;
		      }
		      // Use source `thisArg` if available.
		      if (srcBitmask & WRAP_BIND_FLAG) {
		        data[2] = source[2];
		        // Set when currying a bound function.
		        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
		      }
		      // Compose partial arguments.
		      var value = source[3];
		      if (value) {
		        var partials = data[3];
		        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
		        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
		      }
		      // Compose partial right arguments.
		      value = source[5];
		      if (value) {
		        partials = data[5];
		        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
		        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
		      }
		      // Use source `argPos` if available.
		      value = source[7];
		      if (value) {
		        data[7] = value;
		      }
		      // Use source `ary` if it's smaller.
		      if (srcBitmask & WRAP_ARY_FLAG) {
		        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
		      }
		      // Use source `arity` if one is not provided.
		      if (data[9] == null) {
		        data[9] = source[9];
		      }
		      // Use source `func` and merge bitmasks.
		      data[0] = source[0];
		      data[1] = newBitmask;

		      return data;
		    }

		    /**
		     * This function is like
		     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
		     * except that it includes inherited enumerable properties.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function nativeKeysIn(object) {
		      var result = [];
		      if (object != null) {
		        for (var key in Object(object)) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * Converts `value` to a string using `Object.prototype.toString`.
		     *
		     * @private
		     * @param {*} value The value to convert.
		     * @returns {string} Returns the converted string.
		     */
		    function objectToString(value) {
		      return nativeObjectToString.call(value);
		    }

		    /**
		     * A specialized version of `baseRest` which transforms the rest array.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @param {Function} transform The rest array transform.
		     * @returns {Function} Returns the new function.
		     */
		    function overRest(func, start, transform) {
		      start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
		      return function() {
		        var args = arguments,
		            index = -1,
		            length = nativeMax(args.length - start, 0),
		            array = Array(length);

		        while (++index < length) {
		          array[index] = args[start + index];
		        }
		        index = -1;
		        var otherArgs = Array(start + 1);
		        while (++index < start) {
		          otherArgs[index] = args[index];
		        }
		        otherArgs[start] = transform(array);
		        return apply(func, this, otherArgs);
		      };
		    }

		    /**
		     * Gets the parent value at `path` of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array} path The path to get the parent value of.
		     * @returns {*} Returns the parent value.
		     */
		    function parent(object, path) {
		      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
		    }

		    /**
		     * Reorder `array` according to the specified indexes where the element at
		     * the first index is assigned as the first element, the element at
		     * the second index is assigned as the second element, and so on.
		     *
		     * @private
		     * @param {Array} array The array to reorder.
		     * @param {Array} indexes The arranged array indexes.
		     * @returns {Array} Returns `array`.
		     */
		    function reorder(array, indexes) {
		      var arrLength = array.length,
		          length = nativeMin(indexes.length, arrLength),
		          oldArray = copyArray(array);

		      while (length--) {
		        var index = indexes[length];
		        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
		      }
		      return array;
		    }

		    /**
		     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {string} key The key of the property to get.
		     * @returns {*} Returns the property value.
		     */
		    function safeGet(object, key) {
		      if (key === 'constructor' && typeof object[key] === 'function') {
		        return;
		      }

		      if (key == '__proto__') {
		        return;
		      }

		      return object[key];
		    }

		    /**
		     * Sets metadata for `func`.
		     *
		     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
		     * period of time, it will trip its breaker and transition to an identity
		     * function to avoid garbage collection pauses in V8. See
		     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
		     * for more details.
		     *
		     * @private
		     * @param {Function} func The function to associate metadata with.
		     * @param {*} data The metadata.
		     * @returns {Function} Returns `func`.
		     */
		    var setData = shortOut(baseSetData);

		    /**
		     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
		     *
		     * @private
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @returns {number|Object} Returns the timer id or timeout object.
		     */
		    var setTimeout = ctxSetTimeout || function(func, wait) {
		      return root.setTimeout(func, wait);
		    };

		    /**
		     * Sets the `toString` method of `func` to return `string`.
		     *
		     * @private
		     * @param {Function} func The function to modify.
		     * @param {Function} string The `toString` result.
		     * @returns {Function} Returns `func`.
		     */
		    var setToString = shortOut(baseSetToString);

		    /**
		     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
		     * with wrapper details in a comment at the top of the source body.
		     *
		     * @private
		     * @param {Function} wrapper The function to modify.
		     * @param {Function} reference The reference function.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @returns {Function} Returns `wrapper`.
		     */
		    function setWrapToString(wrapper, reference, bitmask) {
		      var source = (reference + '');
		      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
		    }

		    /**
		     * Creates a function that'll short out and invoke `identity` instead
		     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
		     * milliseconds.
		     *
		     * @private
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new shortable function.
		     */
		    function shortOut(func) {
		      var count = 0,
		          lastCalled = 0;

		      return function() {
		        var stamp = nativeNow(),
		            remaining = HOT_SPAN - (stamp - lastCalled);

		        lastCalled = stamp;
		        if (remaining > 0) {
		          if (++count >= HOT_COUNT) {
		            return arguments[0];
		          }
		        } else {
		          count = 0;
		        }
		        return func.apply(undefined$1, arguments);
		      };
		    }

		    /**
		     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
		     *
		     * @private
		     * @param {Array} array The array to shuffle.
		     * @param {number} [size=array.length] The size of `array`.
		     * @returns {Array} Returns `array`.
		     */
		    function shuffleSelf(array, size) {
		      var index = -1,
		          length = array.length,
		          lastIndex = length - 1;

		      size = size === undefined$1 ? length : size;
		      while (++index < size) {
		        var rand = baseRandom(index, lastIndex),
		            value = array[rand];

		        array[rand] = array[index];
		        array[index] = value;
		      }
		      array.length = size;
		      return array;
		    }

		    /**
		     * Converts `string` to a property path array.
		     *
		     * @private
		     * @param {string} string The string to convert.
		     * @returns {Array} Returns the property path array.
		     */
		    var stringToPath = memoizeCapped(function(string) {
		      var result = [];
		      if (string.charCodeAt(0) === 46 /* . */) {
		        result.push('');
		      }
		      string.replace(rePropName, function(match, number, quote, subString) {
		        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
		      });
		      return result;
		    });

		    /**
		     * Converts `value` to a string key if it's not a string or symbol.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {string|symbol} Returns the key.
		     */
		    function toKey(value) {
		      if (typeof value == 'string' || isSymbol(value)) {
		        return value;
		      }
		      var result = (value + '');
		      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		    }

		    /**
		     * Converts `func` to its source code.
		     *
		     * @private
		     * @param {Function} func The function to convert.
		     * @returns {string} Returns the source code.
		     */
		    function toSource(func) {
		      if (func != null) {
		        try {
		          return funcToString.call(func);
		        } catch (e) {}
		        try {
		          return (func + '');
		        } catch (e) {}
		      }
		      return '';
		    }

		    /**
		     * Updates wrapper `details` based on `bitmask` flags.
		     *
		     * @private
		     * @returns {Array} details The details to modify.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @returns {Array} Returns `details`.
		     */
		    function updateWrapDetails(details, bitmask) {
		      arrayEach(wrapFlags, function(pair) {
		        var value = '_.' + pair[0];
		        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
		          details.push(value);
		        }
		      });
		      return details.sort();
		    }

		    /**
		     * Creates a clone of `wrapper`.
		     *
		     * @private
		     * @param {Object} wrapper The wrapper to clone.
		     * @returns {Object} Returns the cloned wrapper.
		     */
		    function wrapperClone(wrapper) {
		      if (wrapper instanceof LazyWrapper) {
		        return wrapper.clone();
		      }
		      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
		      result.__actions__ = copyArray(wrapper.__actions__);
		      result.__index__  = wrapper.__index__;
		      result.__values__ = wrapper.__values__;
		      return result;
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an array of elements split into groups the length of `size`.
		     * If `array` can't be split evenly, the final chunk will be the remaining
		     * elements.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to process.
		     * @param {number} [size=1] The length of each chunk
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the new array of chunks.
		     * @example
		     *
		     * _.chunk(['a', 'b', 'c', 'd'], 2);
		     * // => [['a', 'b'], ['c', 'd']]
		     *
		     * _.chunk(['a', 'b', 'c', 'd'], 3);
		     * // => [['a', 'b', 'c'], ['d']]
		     */
		    function chunk(array, size, guard) {
		      if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
		        size = 1;
		      } else {
		        size = nativeMax(toInteger(size), 0);
		      }
		      var length = array == null ? 0 : array.length;
		      if (!length || size < 1) {
		        return [];
		      }
		      var index = 0,
		          resIndex = 0,
		          result = Array(nativeCeil(length / size));

		      while (index < length) {
		        result[resIndex++] = baseSlice(array, index, (index += size));
		      }
		      return result;
		    }

		    /**
		     * Creates an array with all falsey values removed. The values `false`, `null`,
		     * `0`, `""`, `undefined`, and `NaN` are falsey.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to compact.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.compact([0, 1, false, 2, '', 3]);
		     * // => [1, 2, 3]
		     */
		    function compact(array) {
		      var index = -1,
		          length = array == null ? 0 : array.length,
		          resIndex = 0,
		          result = [];

		      while (++index < length) {
		        var value = array[index];
		        if (value) {
		          result[resIndex++] = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * Creates a new array concatenating `array` with any additional arrays
		     * and/or values.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to concatenate.
		     * @param {...*} [values] The values to concatenate.
		     * @returns {Array} Returns the new concatenated array.
		     * @example
		     *
		     * var array = [1];
		     * var other = _.concat(array, 2, [3], [[4]]);
		     *
		     * console.log(other);
		     * // => [1, 2, 3, [4]]
		     *
		     * console.log(array);
		     * // => [1]
		     */
		    function concat() {
		      var length = arguments.length;
		      if (!length) {
		        return [];
		      }
		      var args = Array(length - 1),
		          array = arguments[0],
		          index = length;

		      while (index--) {
		        args[index - 1] = arguments[index];
		      }
		      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
		    }

		    /**
		     * Creates an array of `array` values not included in the other given arrays
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. The order and references of result values are
		     * determined by the first array.
		     *
		     * **Note:** Unlike `_.pullAll`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.without, _.xor
		     * @example
		     *
		     * _.difference([2, 1], [2, 3]);
		     * // => [1]
		     */
		    var difference = baseRest(function(array, values) {
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
		        : [];
		    });

		    /**
		     * This method is like `_.difference` except that it accepts `iteratee` which
		     * is invoked for each element of `array` and `values` to generate the criterion
		     * by which they're compared. The order and references of result values are
		     * determined by the first array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
		     * // => [{ 'x': 2 }]
		     */
		    var differenceBy = baseRest(function(array, values) {
		      var iteratee = last(values);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
		        : [];
		    });

		    /**
		     * This method is like `_.difference` except that it accepts `comparator`
		     * which is invoked to compare elements of `array` to `values`. The order and
		     * references of result values are determined by the first array. The comparator
		     * is invoked with two arguments: (arrVal, othVal).
		     *
		     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     *
		     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
		     * // => [{ 'x': 2, 'y': 1 }]
		     */
		    var differenceWith = baseRest(function(array, values) {
		      var comparator = last(values);
		      if (isArrayLikeObject(comparator)) {
		        comparator = undefined$1;
		      }
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
		        : [];
		    });

		    /**
		     * Creates a slice of `array` with `n` elements dropped from the beginning.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to drop.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.drop([1, 2, 3]);
		     * // => [2, 3]
		     *
		     * _.drop([1, 2, 3], 2);
		     * // => [3]
		     *
		     * _.drop([1, 2, 3], 5);
		     * // => []
		     *
		     * _.drop([1, 2, 3], 0);
		     * // => [1, 2, 3]
		     */
		    function drop(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      return baseSlice(array, n < 0 ? 0 : n, length);
		    }

		    /**
		     * Creates a slice of `array` with `n` elements dropped from the end.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to drop.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.dropRight([1, 2, 3]);
		     * // => [1, 2]
		     *
		     * _.dropRight([1, 2, 3], 2);
		     * // => [1]
		     *
		     * _.dropRight([1, 2, 3], 5);
		     * // => []
		     *
		     * _.dropRight([1, 2, 3], 0);
		     * // => [1, 2, 3]
		     */
		    function dropRight(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      n = length - n;
		      return baseSlice(array, 0, n < 0 ? 0 : n);
		    }

		    /**
		     * Creates a slice of `array` excluding elements dropped from the end.
		     * Elements are dropped until `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.dropRightWhile(users, function(o) { return !o.active; });
		     * // => objects for ['barney']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.dropRightWhile(users, ['active', false]);
		     * // => objects for ['barney']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.dropRightWhile(users, 'active');
		     * // => objects for ['barney', 'fred', 'pebbles']
		     */
		    function dropRightWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), true, true)
		        : [];
		    }

		    /**
		     * Creates a slice of `array` excluding elements dropped from the beginning.
		     * Elements are dropped until `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.dropWhile(users, function(o) { return !o.active; });
		     * // => objects for ['pebbles']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.dropWhile(users, { 'user': 'barney', 'active': false });
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.dropWhile(users, ['active', false]);
		     * // => objects for ['pebbles']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.dropWhile(users, 'active');
		     * // => objects for ['barney', 'fred', 'pebbles']
		     */
		    function dropWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), true)
		        : [];
		    }

		    /**
		     * Fills elements of `array` with `value` from `start` up to, but not
		     * including, `end`.
		     *
		     * **Note:** This method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Array
		     * @param {Array} array The array to fill.
		     * @param {*} value The value to fill `array` with.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _.fill(array, 'a');
		     * console.log(array);
		     * // => ['a', 'a', 'a']
		     *
		     * _.fill(Array(3), 2);
		     * // => [2, 2, 2]
		     *
		     * _.fill([4, 6, 8, 10], '*', 1, 3);
		     * // => [4, '*', '*', 10]
		     */
		    function fill(array, value, start, end) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
		        start = 0;
		        end = length;
		      }
		      return baseFill(array, value, start, end);
		    }

		    /**
		     * This method is like `_.find` except that it returns the index of the first
		     * element `predicate` returns truthy for instead of the element itself.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {number} Returns the index of the found element, else `-1`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.findIndex(users, function(o) { return o.user == 'barney'; });
		     * // => 0
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findIndex(users, { 'user': 'fred', 'active': false });
		     * // => 1
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findIndex(users, ['active', false]);
		     * // => 0
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findIndex(users, 'active');
		     * // => 2
		     */
		    function findIndex(array, predicate, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = fromIndex == null ? 0 : toInteger(fromIndex);
		      if (index < 0) {
		        index = nativeMax(length + index, 0);
		      }
		      return baseFindIndex(array, getIteratee(predicate, 3), index);
		    }

		    /**
		     * This method is like `_.findIndex` except that it iterates over elements
		     * of `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=array.length-1] The index to search from.
		     * @returns {number} Returns the index of the found element, else `-1`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
		     * // => 2
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
		     * // => 0
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findLastIndex(users, ['active', false]);
		     * // => 2
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findLastIndex(users, 'active');
		     * // => 0
		     */
		    function findLastIndex(array, predicate, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = length - 1;
		      if (fromIndex !== undefined$1) {
		        index = toInteger(fromIndex);
		        index = fromIndex < 0
		          ? nativeMax(length + index, 0)
		          : nativeMin(index, length - 1);
		      }
		      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
		    }

		    /**
		     * Flattens `array` a single level deep.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * _.flatten([1, [2, [3, [4]], 5]]);
		     * // => [1, 2, [3, [4]], 5]
		     */
		    function flatten(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseFlatten(array, 1) : [];
		    }

		    /**
		     * Recursively flattens `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * _.flattenDeep([1, [2, [3, [4]], 5]]);
		     * // => [1, 2, 3, 4, 5]
		     */
		    function flattenDeep(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseFlatten(array, INFINITY) : [];
		    }

		    /**
		     * Recursively flatten `array` up to `depth` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.4.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @param {number} [depth=1] The maximum recursion depth.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * var array = [1, [2, [3, [4]], 5]];
		     *
		     * _.flattenDepth(array, 1);
		     * // => [1, 2, [3, [4]], 5]
		     *
		     * _.flattenDepth(array, 2);
		     * // => [1, 2, 3, [4], 5]
		     */
		    function flattenDepth(array, depth) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      depth = depth === undefined$1 ? 1 : toInteger(depth);
		      return baseFlatten(array, depth);
		    }

		    /**
		     * The inverse of `_.toPairs`; this method returns an object composed
		     * from key-value `pairs`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} pairs The key-value pairs.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.fromPairs([['a', 1], ['b', 2]]);
		     * // => { 'a': 1, 'b': 2 }
		     */
		    function fromPairs(pairs) {
		      var index = -1,
		          length = pairs == null ? 0 : pairs.length,
		          result = {};

		      while (++index < length) {
		        var pair = pairs[index];
		        result[pair[0]] = pair[1];
		      }
		      return result;
		    }

		    /**
		     * Gets the first element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @alias first
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {*} Returns the first element of `array`.
		     * @example
		     *
		     * _.head([1, 2, 3]);
		     * // => 1
		     *
		     * _.head([]);
		     * // => undefined
		     */
		    function head(array) {
		      return (array && array.length) ? array[0] : undefined$1;
		    }

		    /**
		     * Gets the index at which the first occurrence of `value` is found in `array`
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. If `fromIndex` is negative, it's used as the
		     * offset from the end of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.indexOf([1, 2, 1, 2], 2);
		     * // => 1
		     *
		     * // Search from the `fromIndex`.
		     * _.indexOf([1, 2, 1, 2], 2, 2);
		     * // => 3
		     */
		    function indexOf(array, value, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = fromIndex == null ? 0 : toInteger(fromIndex);
		      if (index < 0) {
		        index = nativeMax(length + index, 0);
		      }
		      return baseIndexOf(array, value, index);
		    }

		    /**
		     * Gets all but the last element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.initial([1, 2, 3]);
		     * // => [1, 2]
		     */
		    function initial(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseSlice(array, 0, -1) : [];
		    }

		    /**
		     * Creates an array of unique values that are included in all given arrays
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. The order and references of result values are
		     * determined by the first array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * _.intersection([2, 1], [2, 3]);
		     * // => [2]
		     */
		    var intersection = baseRest(function(arrays) {
		      var mapped = arrayMap(arrays, castArrayLikeObject);
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped)
		        : [];
		    });

		    /**
		     * This method is like `_.intersection` except that it accepts `iteratee`
		     * which is invoked for each element of each `arrays` to generate the criterion
		     * by which they're compared. The order and references of result values are
		     * determined by the first array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [2.1]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }]
		     */
		    var intersectionBy = baseRest(function(arrays) {
		      var iteratee = last(arrays),
		          mapped = arrayMap(arrays, castArrayLikeObject);

		      if (iteratee === last(mapped)) {
		        iteratee = undefined$1;
		      } else {
		        mapped.pop();
		      }
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped, getIteratee(iteratee, 2))
		        : [];
		    });

		    /**
		     * This method is like `_.intersection` except that it accepts `comparator`
		     * which is invoked to compare elements of `arrays`. The order and references
		     * of result values are determined by the first array. The comparator is
		     * invoked with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.intersectionWith(objects, others, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }]
		     */
		    var intersectionWith = baseRest(function(arrays) {
		      var comparator = last(arrays),
		          mapped = arrayMap(arrays, castArrayLikeObject);

		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      if (comparator) {
		        mapped.pop();
		      }
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped, undefined$1, comparator)
		        : [];
		    });

		    /**
		     * Converts all elements in `array` into a string separated by `separator`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to convert.
		     * @param {string} [separator=','] The element separator.
		     * @returns {string} Returns the joined string.
		     * @example
		     *
		     * _.join(['a', 'b', 'c'], '~');
		     * // => 'a~b~c'
		     */
		    function join(array, separator) {
		      return array == null ? '' : nativeJoin.call(array, separator);
		    }

		    /**
		     * Gets the last element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {*} Returns the last element of `array`.
		     * @example
		     *
		     * _.last([1, 2, 3]);
		     * // => 3
		     */
		    function last(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? array[length - 1] : undefined$1;
		    }

		    /**
		     * This method is like `_.indexOf` except that it iterates over elements of
		     * `array` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=array.length-1] The index to search from.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.lastIndexOf([1, 2, 1, 2], 2);
		     * // => 3
		     *
		     * // Search from the `fromIndex`.
		     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
		     * // => 1
		     */
		    function lastIndexOf(array, value, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = length;
		      if (fromIndex !== undefined$1) {
		        index = toInteger(fromIndex);
		        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
		      }
		      return value === value
		        ? strictLastIndexOf(array, value, index)
		        : baseFindIndex(array, baseIsNaN, index, true);
		    }

		    /**
		     * Gets the element at index `n` of `array`. If `n` is negative, the nth
		     * element from the end is returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.11.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=0] The index of the element to return.
		     * @returns {*} Returns the nth element of `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'd'];
		     *
		     * _.nth(array, 1);
		     * // => 'b'
		     *
		     * _.nth(array, -2);
		     * // => 'c';
		     */
		    function nth(array, n) {
		      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
		    }

		    /**
		     * Removes all given values from `array` using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
		     * to remove elements from an array by predicate.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {...*} [values] The values to remove.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
		     *
		     * _.pull(array, 'a', 'c');
		     * console.log(array);
		     * // => ['b', 'b']
		     */
		    var pull = baseRest(pullAll);

		    /**
		     * This method is like `_.pull` except that it accepts an array of values to remove.
		     *
		     * **Note:** Unlike `_.difference`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
		     *
		     * _.pullAll(array, ['a', 'c']);
		     * console.log(array);
		     * // => ['b', 'b']
		     */
		    function pullAll(array, values) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values)
		        : array;
		    }

		    /**
		     * This method is like `_.pullAll` except that it accepts `iteratee` which is
		     * invoked for each element of `array` and `values` to generate the criterion
		     * by which they're compared. The iteratee is invoked with one argument: (value).
		     *
		     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
		     *
		     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
		     * console.log(array);
		     * // => [{ 'x': 2 }]
		     */
		    function pullAllBy(array, values, iteratee) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values, getIteratee(iteratee, 2))
		        : array;
		    }

		    /**
		     * This method is like `_.pullAll` except that it accepts `comparator` which
		     * is invoked to compare elements of `array` to `values`. The comparator is
		     * invoked with two arguments: (arrVal, othVal).
		     *
		     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
		     *
		     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
		     * console.log(array);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
		     */
		    function pullAllWith(array, values, comparator) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values, undefined$1, comparator)
		        : array;
		    }

		    /**
		     * Removes elements from `array` corresponding to `indexes` and returns an
		     * array of removed elements.
		     *
		     * **Note:** Unlike `_.at`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
		     * @returns {Array} Returns the new array of removed elements.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'd'];
		     * var pulled = _.pullAt(array, [1, 3]);
		     *
		     * console.log(array);
		     * // => ['a', 'c']
		     *
		     * console.log(pulled);
		     * // => ['b', 'd']
		     */
		    var pullAt = flatRest(function(array, indexes) {
		      var length = array == null ? 0 : array.length,
		          result = baseAt(array, indexes);

		      basePullAt(array, arrayMap(indexes, function(index) {
		        return isIndex(index, length) ? +index : index;
		      }).sort(compareAscending));

		      return result;
		    });

		    /**
		     * Removes all elements from `array` that `predicate` returns truthy for
		     * and returns an array of the removed elements. The predicate is invoked
		     * with three arguments: (value, index, array).
		     *
		     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
		     * to pull elements from an array by value.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new array of removed elements.
		     * @example
		     *
		     * var array = [1, 2, 3, 4];
		     * var evens = _.remove(array, function(n) {
		     *   return n % 2 == 0;
		     * });
		     *
		     * console.log(array);
		     * // => [1, 3]
		     *
		     * console.log(evens);
		     * // => [2, 4]
		     */
		    function remove(array, predicate) {
		      var result = [];
		      if (!(array && array.length)) {
		        return result;
		      }
		      var index = -1,
		          indexes = [],
		          length = array.length;

		      predicate = getIteratee(predicate, 3);
		      while (++index < length) {
		        var value = array[index];
		        if (predicate(value, index, array)) {
		          result.push(value);
		          indexes.push(index);
		        }
		      }
		      basePullAt(array, indexes);
		      return result;
		    }

		    /**
		     * Reverses `array` so that the first element becomes the last, the second
		     * element becomes the second to last, and so on.
		     *
		     * **Note:** This method mutates `array` and is based on
		     * [`Array#reverse`](https://mdn.io/Array/reverse).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _.reverse(array);
		     * // => [3, 2, 1]
		     *
		     * console.log(array);
		     * // => [3, 2, 1]
		     */
		    function reverse(array) {
		      return array == null ? array : nativeReverse.call(array);
		    }

		    /**
		     * Creates a slice of `array` from `start` up to, but not including, `end`.
		     *
		     * **Note:** This method is used instead of
		     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
		     * returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to slice.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function slice(array, start, end) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
		        start = 0;
		        end = length;
		      }
		      else {
		        start = start == null ? 0 : toInteger(start);
		        end = end === undefined$1 ? length : toInteger(end);
		      }
		      return baseSlice(array, start, end);
		    }

		    /**
		     * Uses a binary search to determine the lowest index at which `value`
		     * should be inserted into `array` in order to maintain its sort order.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * _.sortedIndex([30, 50], 40);
		     * // => 1
		     */
		    function sortedIndex(array, value) {
		      return baseSortedIndex(array, value);
		    }

		    /**
		     * This method is like `_.sortedIndex` except that it accepts `iteratee`
		     * which is invoked for `value` and each element of `array` to compute their
		     * sort ranking. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * var objects = [{ 'x': 4 }, { 'x': 5 }];
		     *
		     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
		     * // => 0
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
		     * // => 0
		     */
		    function sortedIndexBy(array, value, iteratee) {
		      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
		    }

		    /**
		     * This method is like `_.indexOf` except that it performs a binary
		     * search on a sorted `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
		     * // => 1
		     */
		    function sortedIndexOf(array, value) {
		      var length = array == null ? 0 : array.length;
		      if (length) {
		        var index = baseSortedIndex(array, value);
		        if (index < length && eq(array[index], value)) {
		          return index;
		        }
		      }
		      return -1;
		    }

		    /**
		     * This method is like `_.sortedIndex` except that it returns the highest
		     * index at which `value` should be inserted into `array` in order to
		     * maintain its sort order.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
		     * // => 4
		     */
		    function sortedLastIndex(array, value) {
		      return baseSortedIndex(array, value, true);
		    }

		    /**
		     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
		     * which is invoked for `value` and each element of `array` to compute their
		     * sort ranking. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * var objects = [{ 'x': 4 }, { 'x': 5 }];
		     *
		     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
		     * // => 1
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
		     * // => 1
		     */
		    function sortedLastIndexBy(array, value, iteratee) {
		      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
		    }

		    /**
		     * This method is like `_.lastIndexOf` except that it performs a binary
		     * search on a sorted `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
		     * // => 3
		     */
		    function sortedLastIndexOf(array, value) {
		      var length = array == null ? 0 : array.length;
		      if (length) {
		        var index = baseSortedIndex(array, value, true) - 1;
		        if (eq(array[index], value)) {
		          return index;
		        }
		      }
		      return -1;
		    }

		    /**
		     * This method is like `_.uniq` except that it's designed and optimized
		     * for sorted arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.sortedUniq([1, 1, 2]);
		     * // => [1, 2]
		     */
		    function sortedUniq(array) {
		      return (array && array.length)
		        ? baseSortedUniq(array)
		        : [];
		    }

		    /**
		     * This method is like `_.uniqBy` except that it's designed and optimized
		     * for sorted arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
		     * // => [1.1, 2.3]
		     */
		    function sortedUniqBy(array, iteratee) {
		      return (array && array.length)
		        ? baseSortedUniq(array, getIteratee(iteratee, 2))
		        : [];
		    }

		    /**
		     * Gets all but the first element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.tail([1, 2, 3]);
		     * // => [2, 3]
		     */
		    function tail(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseSlice(array, 1, length) : [];
		    }

		    /**
		     * Creates a slice of `array` with `n` elements taken from the beginning.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to take.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.take([1, 2, 3]);
		     * // => [1]
		     *
		     * _.take([1, 2, 3], 2);
		     * // => [1, 2]
		     *
		     * _.take([1, 2, 3], 5);
		     * // => [1, 2, 3]
		     *
		     * _.take([1, 2, 3], 0);
		     * // => []
		     */
		    function take(array, n, guard) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      return baseSlice(array, 0, n < 0 ? 0 : n);
		    }

		    /**
		     * Creates a slice of `array` with `n` elements taken from the end.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to take.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.takeRight([1, 2, 3]);
		     * // => [3]
		     *
		     * _.takeRight([1, 2, 3], 2);
		     * // => [2, 3]
		     *
		     * _.takeRight([1, 2, 3], 5);
		     * // => [1, 2, 3]
		     *
		     * _.takeRight([1, 2, 3], 0);
		     * // => []
		     */
		    function takeRight(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      n = length - n;
		      return baseSlice(array, n < 0 ? 0 : n, length);
		    }

		    /**
		     * Creates a slice of `array` with elements taken from the end. Elements are
		     * taken until `predicate` returns falsey. The predicate is invoked with
		     * three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.takeRightWhile(users, function(o) { return !o.active; });
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
		     * // => objects for ['pebbles']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.takeRightWhile(users, ['active', false]);
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.takeRightWhile(users, 'active');
		     * // => []
		     */
		    function takeRightWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), false, true)
		        : [];
		    }

		    /**
		     * Creates a slice of `array` with elements taken from the beginning. Elements
		     * are taken until `predicate` returns falsey. The predicate is invoked with
		     * three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.takeWhile(users, function(o) { return !o.active; });
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.takeWhile(users, { 'user': 'barney', 'active': false });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.takeWhile(users, ['active', false]);
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.takeWhile(users, 'active');
		     * // => []
		     */
		    function takeWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3))
		        : [];
		    }

		    /**
		     * Creates an array of unique values, in order, from all given arrays using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * _.union([2], [1, 2]);
		     * // => [2, 1]
		     */
		    var union = baseRest(function(arrays) {
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
		    });

		    /**
		     * This method is like `_.union` except that it accepts `iteratee` which is
		     * invoked for each element of each `arrays` to generate the criterion by
		     * which uniqueness is computed. Result values are chosen from the first
		     * array in which the value occurs. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
		     * // => [2.1, 1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }, { 'x': 2 }]
		     */
		    var unionBy = baseRest(function(arrays) {
		      var iteratee = last(arrays);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
		    });

		    /**
		     * This method is like `_.union` except that it accepts `comparator` which
		     * is invoked to compare elements of `arrays`. Result values are chosen from
		     * the first array in which the value occurs. The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.unionWith(objects, others, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
		     */
		    var unionWith = baseRest(function(arrays) {
		      var comparator = last(arrays);
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
		    });

		    /**
		     * Creates a duplicate-free version of an array, using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons, in which only the first occurrence of each element
		     * is kept. The order of result values is determined by the order they occur
		     * in the array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.uniq([2, 1, 2]);
		     * // => [2, 1]
		     */
		    function uniq(array) {
		      return (array && array.length) ? baseUniq(array) : [];
		    }

		    /**
		     * This method is like `_.uniq` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * uniqueness is computed. The order of result values is determined by the
		     * order they occur in the array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
		     * // => [2.1, 1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }, { 'x': 2 }]
		     */
		    function uniqBy(array, iteratee) {
		      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
		    }

		    /**
		     * This method is like `_.uniq` except that it accepts `comparator` which
		     * is invoked to compare elements of `array`. The order of result values is
		     * determined by the order they occur in the array.The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.uniqWith(objects, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
		     */
		    function uniqWith(array, comparator) {
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
		    }

		    /**
		     * This method is like `_.zip` except that it accepts an array of grouped
		     * elements and creates an array regrouping the elements to their pre-zip
		     * configuration.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.2.0
		     * @category Array
		     * @param {Array} array The array of grouped elements to process.
		     * @returns {Array} Returns the new array of regrouped elements.
		     * @example
		     *
		     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
		     * // => [['a', 1, true], ['b', 2, false]]
		     *
		     * _.unzip(zipped);
		     * // => [['a', 'b'], [1, 2], [true, false]]
		     */
		    function unzip(array) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      var length = 0;
		      array = arrayFilter(array, function(group) {
		        if (isArrayLikeObject(group)) {
		          length = nativeMax(group.length, length);
		          return true;
		        }
		      });
		      return baseTimes(length, function(index) {
		        return arrayMap(array, baseProperty(index));
		      });
		    }

		    /**
		     * This method is like `_.unzip` except that it accepts `iteratee` to specify
		     * how regrouped values should be combined. The iteratee is invoked with the
		     * elements of each group: (...group).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Array
		     * @param {Array} array The array of grouped elements to process.
		     * @param {Function} [iteratee=_.identity] The function to combine
		     *  regrouped values.
		     * @returns {Array} Returns the new array of regrouped elements.
		     * @example
		     *
		     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
		     * // => [[1, 10, 100], [2, 20, 200]]
		     *
		     * _.unzipWith(zipped, _.add);
		     * // => [3, 30, 300]
		     */
		    function unzipWith(array, iteratee) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      var result = unzip(array);
		      if (iteratee == null) {
		        return result;
		      }
		      return arrayMap(result, function(group) {
		        return apply(iteratee, undefined$1, group);
		      });
		    }

		    /**
		     * Creates an array excluding all given values using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * **Note:** Unlike `_.pull`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...*} [values] The values to exclude.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.difference, _.xor
		     * @example
		     *
		     * _.without([2, 1, 2, 3], 1, 2);
		     * // => [3]
		     */
		    var without = baseRest(function(array, values) {
		      return isArrayLikeObject(array)
		        ? baseDifference(array, values)
		        : [];
		    });

		    /**
		     * Creates an array of unique values that is the
		     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
		     * of the given arrays. The order of result values is determined by the order
		     * they occur in the arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.difference, _.without
		     * @example
		     *
		     * _.xor([2, 1], [2, 3]);
		     * // => [1, 3]
		     */
		    var xor = baseRest(function(arrays) {
		      return baseXor(arrayFilter(arrays, isArrayLikeObject));
		    });

		    /**
		     * This method is like `_.xor` except that it accepts `iteratee` which is
		     * invoked for each element of each `arrays` to generate the criterion by
		     * which by which they're compared. The order of result values is determined
		     * by the order they occur in the arrays. The iteratee is invoked with one
		     * argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [1.2, 3.4]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 2 }]
		     */
		    var xorBy = baseRest(function(arrays) {
		      var iteratee = last(arrays);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
		    });

		    /**
		     * This method is like `_.xor` except that it accepts `comparator` which is
		     * invoked to compare elements of `arrays`. The order of result values is
		     * determined by the order they occur in the arrays. The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.xorWith(objects, others, _.isEqual);
		     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
		     */
		    var xorWith = baseRest(function(arrays) {
		      var comparator = last(arrays);
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
		    });

		    /**
		     * Creates an array of grouped elements, the first of which contains the
		     * first elements of the given arrays, the second of which contains the
		     * second elements of the given arrays, and so on.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to process.
		     * @returns {Array} Returns the new array of grouped elements.
		     * @example
		     *
		     * _.zip(['a', 'b'], [1, 2], [true, false]);
		     * // => [['a', 1, true], ['b', 2, false]]
		     */
		    var zip = baseRest(unzip);

		    /**
		     * This method is like `_.fromPairs` except that it accepts two arrays,
		     * one of property identifiers and one of corresponding values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.4.0
		     * @category Array
		     * @param {Array} [props=[]] The property identifiers.
		     * @param {Array} [values=[]] The property values.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.zipObject(['a', 'b'], [1, 2]);
		     * // => { 'a': 1, 'b': 2 }
		     */
		    function zipObject(props, values) {
		      return baseZipObject(props || [], values || [], assignValue);
		    }

		    /**
		     * This method is like `_.zipObject` except that it supports property paths.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.1.0
		     * @category Array
		     * @param {Array} [props=[]] The property identifiers.
		     * @param {Array} [values=[]] The property values.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
		     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
		     */
		    function zipObjectDeep(props, values) {
		      return baseZipObject(props || [], values || [], baseSet);
		    }

		    /**
		     * This method is like `_.zip` except that it accepts `iteratee` to specify
		     * how grouped values should be combined. The iteratee is invoked with the
		     * elements of each group: (...group).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to process.
		     * @param {Function} [iteratee=_.identity] The function to combine
		     *  grouped values.
		     * @returns {Array} Returns the new array of grouped elements.
		     * @example
		     *
		     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
		     *   return a + b + c;
		     * });
		     * // => [111, 222]
		     */
		    var zipWith = baseRest(function(arrays) {
		      var length = arrays.length,
		          iteratee = length > 1 ? arrays[length - 1] : undefined$1;

		      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
		      return unzipWith(arrays, iteratee);
		    });

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
		     * chain sequences enabled. The result of such sequences must be unwrapped
		     * with `_#value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.3.0
		     * @category Seq
		     * @param {*} value The value to wrap.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36 },
		     *   { 'user': 'fred',    'age': 40 },
		     *   { 'user': 'pebbles', 'age': 1 }
		     * ];
		     *
		     * var youngest = _
		     *   .chain(users)
		     *   .sortBy('age')
		     *   .map(function(o) {
		     *     return o.user + ' is ' + o.age;
		     *   })
		     *   .head()
		     *   .value();
		     * // => 'pebbles is 1'
		     */
		    function chain(value) {
		      var result = lodash(value);
		      result.__chain__ = true;
		      return result;
		    }

		    /**
		     * This method invokes `interceptor` and returns `value`. The interceptor
		     * is invoked with one argument; (value). The purpose of this method is to
		     * "tap into" a method chain sequence in order to modify intermediate results.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @param {*} value The value to provide to `interceptor`.
		     * @param {Function} interceptor The function to invoke.
		     * @returns {*} Returns `value`.
		     * @example
		     *
		     * _([1, 2, 3])
		     *  .tap(function(array) {
		     *    // Mutate input array.
		     *    array.pop();
		     *  })
		     *  .reverse()
		     *  .value();
		     * // => [2, 1]
		     */
		    function tap(value, interceptor) {
		      interceptor(value);
		      return value;
		    }

		    /**
		     * This method is like `_.tap` except that it returns the result of `interceptor`.
		     * The purpose of this method is to "pass thru" values replacing intermediate
		     * results in a method chain sequence.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Seq
		     * @param {*} value The value to provide to `interceptor`.
		     * @param {Function} interceptor The function to invoke.
		     * @returns {*} Returns the result of `interceptor`.
		     * @example
		     *
		     * _('  abc  ')
		     *  .chain()
		     *  .trim()
		     *  .thru(function(value) {
		     *    return [value];
		     *  })
		     *  .value();
		     * // => ['abc']
		     */
		    function thru(value, interceptor) {
		      return interceptor(value);
		    }

		    /**
		     * This method is the wrapper version of `_.at`.
		     *
		     * @name at
		     * @memberOf _
		     * @since 1.0.0
		     * @category Seq
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
		     *
		     * _(object).at(['a[0].b.c', 'a[1]']).value();
		     * // => [3, 4]
		     */
		    var wrapperAt = flatRest(function(paths) {
		      var length = paths.length,
		          start = length ? paths[0] : 0,
		          value = this.__wrapped__,
		          interceptor = function(object) { return baseAt(object, paths); };

		      if (length > 1 || this.__actions__.length ||
		          !(value instanceof LazyWrapper) || !isIndex(start)) {
		        return this.thru(interceptor);
		      }
		      value = value.slice(start, +start + (length ? 1 : 0));
		      value.__actions__.push({
		        'func': thru,
		        'args': [interceptor],
		        'thisArg': undefined$1
		      });
		      return new LodashWrapper(value, this.__chain__).thru(function(array) {
		        if (length && !array.length) {
		          array.push(undefined$1);
		        }
		        return array;
		      });
		    });

		    /**
		     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
		     *
		     * @name chain
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36 },
		     *   { 'user': 'fred',   'age': 40 }
		     * ];
		     *
		     * // A sequence without explicit chaining.
		     * _(users).head();
		     * // => { 'user': 'barney', 'age': 36 }
		     *
		     * // A sequence with explicit chaining.
		     * _(users)
		     *   .chain()
		     *   .head()
		     *   .pick('user')
		     *   .value();
		     * // => { 'user': 'barney' }
		     */
		    function wrapperChain() {
		      return chain(this);
		    }

		    /**
		     * Executes the chain sequence and returns the wrapped result.
		     *
		     * @name commit
		     * @memberOf _
		     * @since 3.2.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var array = [1, 2];
		     * var wrapped = _(array).push(3);
		     *
		     * console.log(array);
		     * // => [1, 2]
		     *
		     * wrapped = wrapped.commit();
		     * console.log(array);
		     * // => [1, 2, 3]
		     *
		     * wrapped.last();
		     * // => 3
		     *
		     * console.log(array);
		     * // => [1, 2, 3]
		     */
		    function wrapperCommit() {
		      return new LodashWrapper(this.value(), this.__chain__);
		    }

		    /**
		     * Gets the next value on a wrapped object following the
		     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
		     *
		     * @name next
		     * @memberOf _
		     * @since 4.0.0
		     * @category Seq
		     * @returns {Object} Returns the next iterator value.
		     * @example
		     *
		     * var wrapped = _([1, 2]);
		     *
		     * wrapped.next();
		     * // => { 'done': false, 'value': 1 }
		     *
		     * wrapped.next();
		     * // => { 'done': false, 'value': 2 }
		     *
		     * wrapped.next();
		     * // => { 'done': true, 'value': undefined }
		     */
		    function wrapperNext() {
		      if (this.__values__ === undefined$1) {
		        this.__values__ = toArray(this.value());
		      }
		      var done = this.__index__ >= this.__values__.length,
		          value = done ? undefined$1 : this.__values__[this.__index__++];

		      return { 'done': done, 'value': value };
		    }

		    /**
		     * Enables the wrapper to be iterable.
		     *
		     * @name Symbol.iterator
		     * @memberOf _
		     * @since 4.0.0
		     * @category Seq
		     * @returns {Object} Returns the wrapper object.
		     * @example
		     *
		     * var wrapped = _([1, 2]);
		     *
		     * wrapped[Symbol.iterator]() === wrapped;
		     * // => true
		     *
		     * Array.from(wrapped);
		     * // => [1, 2]
		     */
		    function wrapperToIterator() {
		      return this;
		    }

		    /**
		     * Creates a clone of the chain sequence planting `value` as the wrapped value.
		     *
		     * @name plant
		     * @memberOf _
		     * @since 3.2.0
		     * @category Seq
		     * @param {*} value The value to plant.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var wrapped = _([1, 2]).map(square);
		     * var other = wrapped.plant([3, 4]);
		     *
		     * other.value();
		     * // => [9, 16]
		     *
		     * wrapped.value();
		     * // => [1, 4]
		     */
		    function wrapperPlant(value) {
		      var result,
		          parent = this;

		      while (parent instanceof baseLodash) {
		        var clone = wrapperClone(parent);
		        clone.__index__ = 0;
		        clone.__values__ = undefined$1;
		        if (result) {
		          previous.__wrapped__ = clone;
		        } else {
		          result = clone;
		        }
		        var previous = clone;
		        parent = parent.__wrapped__;
		      }
		      previous.__wrapped__ = value;
		      return result;
		    }

		    /**
		     * This method is the wrapper version of `_.reverse`.
		     *
		     * **Note:** This method mutates the wrapped array.
		     *
		     * @name reverse
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _(array).reverse().value()
		     * // => [3, 2, 1]
		     *
		     * console.log(array);
		     * // => [3, 2, 1]
		     */
		    function wrapperReverse() {
		      var value = this.__wrapped__;
		      if (value instanceof LazyWrapper) {
		        var wrapped = value;
		        if (this.__actions__.length) {
		          wrapped = new LazyWrapper(this);
		        }
		        wrapped = wrapped.reverse();
		        wrapped.__actions__.push({
		          'func': thru,
		          'args': [reverse],
		          'thisArg': undefined$1
		        });
		        return new LodashWrapper(wrapped, this.__chain__);
		      }
		      return this.thru(reverse);
		    }

		    /**
		     * Executes the chain sequence to resolve the unwrapped value.
		     *
		     * @name value
		     * @memberOf _
		     * @since 0.1.0
		     * @alias toJSON, valueOf
		     * @category Seq
		     * @returns {*} Returns the resolved unwrapped value.
		     * @example
		     *
		     * _([1, 2, 3]).value();
		     * // => [1, 2, 3]
		     */
		    function wrapperValue() {
		      return baseWrapperValue(this.__wrapped__, this.__actions__);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The corresponding value of
		     * each key is the number of times the key was returned by `iteratee`. The
		     * iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * _.countBy([6.1, 4.2, 6.3], Math.floor);
		     * // => { '4': 1, '6': 2 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.countBy(['one', 'two', 'three'], 'length');
		     * // => { '3': 2, '5': 1 }
		     */
		    var countBy = createAggregator(function(result, value, key) {
		      if (hasOwnProperty.call(result, key)) {
		        ++result[key];
		      } else {
		        baseAssignValue(result, key, 1);
		      }
		    });

		    /**
		     * Checks if `predicate` returns truthy for **all** elements of `collection`.
		     * Iteration is stopped once `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index|key, collection).
		     *
		     * **Note:** This method returns `true` for
		     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
		     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
		     * elements of empty collections.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {boolean} Returns `true` if all elements pass the predicate check,
		     *  else `false`.
		     * @example
		     *
		     * _.every([true, 1, null, 'yes'], Boolean);
		     * // => false
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': false },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.every(users, { 'user': 'barney', 'active': false });
		     * // => false
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.every(users, ['active', false]);
		     * // => true
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.every(users, 'active');
		     * // => false
		     */
		    function every(collection, predicate, guard) {
		      var func = isArray(collection) ? arrayEvery : baseEvery;
		      if (guard && isIterateeCall(collection, predicate, guard)) {
		        predicate = undefined$1;
		      }
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Iterates over elements of `collection`, returning an array of all elements
		     * `predicate` returns truthy for. The predicate is invoked with three
		     * arguments: (value, index|key, collection).
		     *
		     * **Note:** Unlike `_.remove`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     * @see _.reject
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': true },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * _.filter(users, function(o) { return !o.active; });
		     * // => objects for ['fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.filter(users, { 'age': 36, 'active': true });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.filter(users, ['active', false]);
		     * // => objects for ['fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.filter(users, 'active');
		     * // => objects for ['barney']
		     *
		     * // Combining several predicates using `_.overEvery` or `_.overSome`.
		     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
		     * // => objects for ['fred', 'barney']
		     */
		    function filter(collection, predicate) {
		      var func = isArray(collection) ? arrayFilter : baseFilter;
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Iterates over elements of `collection`, returning the first element
		     * `predicate` returns truthy for. The predicate is invoked with three
		     * arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {*} Returns the matched element, else `undefined`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36, 'active': true },
		     *   { 'user': 'fred',    'age': 40, 'active': false },
		     *   { 'user': 'pebbles', 'age': 1,  'active': true }
		     * ];
		     *
		     * _.find(users, function(o) { return o.age < 40; });
		     * // => object for 'barney'
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.find(users, { 'age': 1, 'active': true });
		     * // => object for 'pebbles'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.find(users, ['active', false]);
		     * // => object for 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.find(users, 'active');
		     * // => object for 'barney'
		     */
		    var find = createFind(findIndex);

		    /**
		     * This method is like `_.find` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=collection.length-1] The index to search from.
		     * @returns {*} Returns the matched element, else `undefined`.
		     * @example
		     *
		     * _.findLast([1, 2, 3, 4], function(n) {
		     *   return n % 2 == 1;
		     * });
		     * // => 3
		     */
		    var findLast = createFind(findLastIndex);

		    /**
		     * Creates a flattened array of values by running each element in `collection`
		     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
		     * with three arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [n, n];
		     * }
		     *
		     * _.flatMap([1, 2], duplicate);
		     * // => [1, 1, 2, 2]
		     */
		    function flatMap(collection, iteratee) {
		      return baseFlatten(map(collection, iteratee), 1);
		    }

		    /**
		     * This method is like `_.flatMap` except that it recursively flattens the
		     * mapped results.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [[[n, n]]];
		     * }
		     *
		     * _.flatMapDeep([1, 2], duplicate);
		     * // => [1, 1, 2, 2]
		     */
		    function flatMapDeep(collection, iteratee) {
		      return baseFlatten(map(collection, iteratee), INFINITY);
		    }

		    /**
		     * This method is like `_.flatMap` except that it recursively flattens the
		     * mapped results up to `depth` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {number} [depth=1] The maximum recursion depth.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [[[n, n]]];
		     * }
		     *
		     * _.flatMapDepth([1, 2], duplicate, 2);
		     * // => [[1, 1], [2, 2]]
		     */
		    function flatMapDepth(collection, iteratee, depth) {
		      depth = depth === undefined$1 ? 1 : toInteger(depth);
		      return baseFlatten(map(collection, iteratee), depth);
		    }

		    /**
		     * Iterates over elements of `collection` and invokes `iteratee` for each element.
		     * The iteratee is invoked with three arguments: (value, index|key, collection).
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * **Note:** As with other "Collections" methods, objects with a "length"
		     * property are iterated like arrays. To avoid this behavior use `_.forIn`
		     * or `_.forOwn` for object iteration.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @alias each
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     * @see _.forEachRight
		     * @example
		     *
		     * _.forEach([1, 2], function(value) {
		     *   console.log(value);
		     * });
		     * // => Logs `1` then `2`.
		     *
		     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
		     */
		    function forEach(collection, iteratee) {
		      var func = isArray(collection) ? arrayEach : baseEach;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.forEach` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @alias eachRight
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     * @see _.forEach
		     * @example
		     *
		     * _.forEachRight([1, 2], function(value) {
		     *   console.log(value);
		     * });
		     * // => Logs `2` then `1`.
		     */
		    function forEachRight(collection, iteratee) {
		      var func = isArray(collection) ? arrayEachRight : baseEachRight;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The order of grouped values
		     * is determined by the order they occur in `collection`. The corresponding
		     * value of each key is an array of elements responsible for generating the
		     * key. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
		     * // => { '4': [4.2], '6': [6.1, 6.3] }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.groupBy(['one', 'two', 'three'], 'length');
		     * // => { '3': ['one', 'two'], '5': ['three'] }
		     */
		    var groupBy = createAggregator(function(result, value, key) {
		      if (hasOwnProperty.call(result, key)) {
		        result[key].push(value);
		      } else {
		        baseAssignValue(result, key, [value]);
		      }
		    });

		    /**
		     * Checks if `value` is in `collection`. If `collection` is a string, it's
		     * checked for a substring of `value`, otherwise
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * is used for equality comparisons. If `fromIndex` is negative, it's used as
		     * the offset from the end of `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object|string} collection The collection to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
		     * @returns {boolean} Returns `true` if `value` is found, else `false`.
		     * @example
		     *
		     * _.includes([1, 2, 3], 1);
		     * // => true
		     *
		     * _.includes([1, 2, 3], 1, 2);
		     * // => false
		     *
		     * _.includes({ 'a': 1, 'b': 2 }, 1);
		     * // => true
		     *
		     * _.includes('abcd', 'bc');
		     * // => true
		     */
		    function includes(collection, value, fromIndex, guard) {
		      collection = isArrayLike(collection) ? collection : values(collection);
		      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

		      var length = collection.length;
		      if (fromIndex < 0) {
		        fromIndex = nativeMax(length + fromIndex, 0);
		      }
		      return isString(collection)
		        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
		        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
		    }

		    /**
		     * Invokes the method at `path` of each element in `collection`, returning
		     * an array of the results of each invoked method. Any additional arguments
		     * are provided to each invoked method. If `path` is a function, it's invoked
		     * for, and `this` bound to, each element in `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|string} path The path of the method to invoke or
		     *  the function invoked per iteration.
		     * @param {...*} [args] The arguments to invoke each method with.
		     * @returns {Array} Returns the array of results.
		     * @example
		     *
		     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
		     * // => [[1, 5, 7], [1, 2, 3]]
		     *
		     * _.invokeMap([123, 456], String.prototype.split, '');
		     * // => [['1', '2', '3'], ['4', '5', '6']]
		     */
		    var invokeMap = baseRest(function(collection, path, args) {
		      var index = -1,
		          isFunc = typeof path == 'function',
		          result = isArrayLike(collection) ? Array(collection.length) : [];

		      baseEach(collection, function(value) {
		        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
		      });
		      return result;
		    });

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The corresponding value of
		     * each key is the last element responsible for generating the key. The
		     * iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * var array = [
		     *   { 'dir': 'left', 'code': 97 },
		     *   { 'dir': 'right', 'code': 100 }
		     * ];
		     *
		     * _.keyBy(array, function(o) {
		     *   return String.fromCharCode(o.code);
		     * });
		     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
		     *
		     * _.keyBy(array, 'dir');
		     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
		     */
		    var keyBy = createAggregator(function(result, value, key) {
		      baseAssignValue(result, key, value);
		    });

		    /**
		     * Creates an array of values by running each element in `collection` thru
		     * `iteratee`. The iteratee is invoked with three arguments:
		     * (value, index|key, collection).
		     *
		     * Many lodash methods are guarded to work as iteratees for methods like
		     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
		     *
		     * The guarded methods are:
		     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
		     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
		     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
		     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new mapped array.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * _.map([4, 8], square);
		     * // => [16, 64]
		     *
		     * _.map({ 'a': 4, 'b': 8 }, square);
		     * // => [16, 64] (iteration order is not guaranteed)
		     *
		     * var users = [
		     *   { 'user': 'barney' },
		     *   { 'user': 'fred' }
		     * ];
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.map(users, 'user');
		     * // => ['barney', 'fred']
		     */
		    function map(collection, iteratee) {
		      var func = isArray(collection) ? arrayMap : baseMap;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.sortBy` except that it allows specifying the sort
		     * orders of the iteratees to sort by. If `orders` is unspecified, all values
		     * are sorted in ascending order. Otherwise, specify an order of "desc" for
		     * descending or "asc" for ascending sort order of corresponding values.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
		     *  The iteratees to sort by.
		     * @param {string[]} [orders] The sort orders of `iteratees`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
		     * @returns {Array} Returns the new sorted array.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'fred',   'age': 48 },
		     *   { 'user': 'barney', 'age': 34 },
		     *   { 'user': 'fred',   'age': 40 },
		     *   { 'user': 'barney', 'age': 36 }
		     * ];
		     *
		     * // Sort by `user` in ascending order and by `age` in descending order.
		     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
		     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
		     */
		    function orderBy(collection, iteratees, orders, guard) {
		      if (collection == null) {
		        return [];
		      }
		      if (!isArray(iteratees)) {
		        iteratees = iteratees == null ? [] : [iteratees];
		      }
		      orders = guard ? undefined$1 : orders;
		      if (!isArray(orders)) {
		        orders = orders == null ? [] : [orders];
		      }
		      return baseOrderBy(collection, iteratees, orders);
		    }

		    /**
		     * Creates an array of elements split into two groups, the first of which
		     * contains elements `predicate` returns truthy for, the second of which
		     * contains elements `predicate` returns falsey for. The predicate is
		     * invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the array of grouped elements.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36, 'active': false },
		     *   { 'user': 'fred',    'age': 40, 'active': true },
		     *   { 'user': 'pebbles', 'age': 1,  'active': false }
		     * ];
		     *
		     * _.partition(users, function(o) { return o.active; });
		     * // => objects for [['fred'], ['barney', 'pebbles']]
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.partition(users, { 'age': 1, 'active': false });
		     * // => objects for [['pebbles'], ['barney', 'fred']]
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.partition(users, ['active', false]);
		     * // => objects for [['barney', 'pebbles'], ['fred']]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.partition(users, 'active');
		     * // => objects for [['fred'], ['barney', 'pebbles']]
		     */
		    var partition = createAggregator(function(result, value, key) {
		      result[key ? 0 : 1].push(value);
		    }, function() { return [[], []]; });

		    /**
		     * Reduces `collection` to a value which is the accumulated result of running
		     * each element in `collection` thru `iteratee`, where each successive
		     * invocation is supplied the return value of the previous. If `accumulator`
		     * is not given, the first element of `collection` is used as the initial
		     * value. The iteratee is invoked with four arguments:
		     * (accumulator, value, index|key, collection).
		     *
		     * Many lodash methods are guarded to work as iteratees for methods like
		     * `_.reduce`, `_.reduceRight`, and `_.transform`.
		     *
		     * The guarded methods are:
		     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
		     * and `sortBy`
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The initial value.
		     * @returns {*} Returns the accumulated value.
		     * @see _.reduceRight
		     * @example
		     *
		     * _.reduce([1, 2], function(sum, n) {
		     *   return sum + n;
		     * }, 0);
		     * // => 3
		     *
		     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
		     *   (result[value] || (result[value] = [])).push(key);
		     *   return result;
		     * }, {});
		     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
		     */
		    function reduce(collection, iteratee, accumulator) {
		      var func = isArray(collection) ? arrayReduce : baseReduce,
		          initAccum = arguments.length < 3;

		      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
		    }

		    /**
		     * This method is like `_.reduce` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The initial value.
		     * @returns {*} Returns the accumulated value.
		     * @see _.reduce
		     * @example
		     *
		     * var array = [[0, 1], [2, 3], [4, 5]];
		     *
		     * _.reduceRight(array, function(flattened, other) {
		     *   return flattened.concat(other);
		     * }, []);
		     * // => [4, 5, 2, 3, 0, 1]
		     */
		    function reduceRight(collection, iteratee, accumulator) {
		      var func = isArray(collection) ? arrayReduceRight : baseReduce,
		          initAccum = arguments.length < 3;

		      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
		    }

		    /**
		     * The opposite of `_.filter`; this method returns the elements of `collection`
		     * that `predicate` does **not** return truthy for.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     * @see _.filter
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': false },
		     *   { 'user': 'fred',   'age': 40, 'active': true }
		     * ];
		     *
		     * _.reject(users, function(o) { return !o.active; });
		     * // => objects for ['fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.reject(users, { 'age': 40, 'active': true });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.reject(users, ['active', false]);
		     * // => objects for ['fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.reject(users, 'active');
		     * // => objects for ['barney']
		     */
		    function reject(collection, predicate) {
		      var func = isArray(collection) ? arrayFilter : baseFilter;
		      return func(collection, negate(getIteratee(predicate, 3)));
		    }

		    /**
		     * Gets a random element from `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to sample.
		     * @returns {*} Returns the random element.
		     * @example
		     *
		     * _.sample([1, 2, 3, 4]);
		     * // => 2
		     */
		    function sample(collection) {
		      var func = isArray(collection) ? arraySample : baseSample;
		      return func(collection);
		    }

		    /**
		     * Gets `n` random elements at unique keys from `collection` up to the
		     * size of `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to sample.
		     * @param {number} [n=1] The number of elements to sample.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the random elements.
		     * @example
		     *
		     * _.sampleSize([1, 2, 3], 2);
		     * // => [3, 1]
		     *
		     * _.sampleSize([1, 2, 3], 4);
		     * // => [2, 3, 1]
		     */
		    function sampleSize(collection, n, guard) {
		      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
		        n = 1;
		      } else {
		        n = toInteger(n);
		      }
		      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
		      return func(collection, n);
		    }

		    /**
		     * Creates an array of shuffled values, using a version of the
		     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     * @example
		     *
		     * _.shuffle([1, 2, 3, 4]);
		     * // => [4, 1, 3, 2]
		     */
		    function shuffle(collection) {
		      var func = isArray(collection) ? arrayShuffle : baseShuffle;
		      return func(collection);
		    }

		    /**
		     * Gets the size of `collection` by returning its length for array-like
		     * values or the number of own enumerable string keyed properties for objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object|string} collection The collection to inspect.
		     * @returns {number} Returns the collection size.
		     * @example
		     *
		     * _.size([1, 2, 3]);
		     * // => 3
		     *
		     * _.size({ 'a': 1, 'b': 2 });
		     * // => 2
		     *
		     * _.size('pebbles');
		     * // => 7
		     */
		    function size(collection) {
		      if (collection == null) {
		        return 0;
		      }
		      if (isArrayLike(collection)) {
		        return isString(collection) ? stringSize(collection) : collection.length;
		      }
		      var tag = getTag(collection);
		      if (tag == mapTag || tag == setTag) {
		        return collection.size;
		      }
		      return baseKeys(collection).length;
		    }

		    /**
		     * Checks if `predicate` returns truthy for **any** element of `collection`.
		     * Iteration is stopped once `predicate` returns truthy. The predicate is
		     * invoked with three arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {boolean} Returns `true` if any element passes the predicate check,
		     *  else `false`.
		     * @example
		     *
		     * _.some([null, 0, 'yes', false], Boolean);
		     * // => true
		     *
		     * var users = [
		     *   { 'user': 'barney', 'active': true },
		     *   { 'user': 'fred',   'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.some(users, { 'user': 'barney', 'active': false });
		     * // => false
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.some(users, ['active', false]);
		     * // => true
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.some(users, 'active');
		     * // => true
		     */
		    function some(collection, predicate, guard) {
		      var func = isArray(collection) ? arraySome : baseSome;
		      if (guard && isIterateeCall(collection, predicate, guard)) {
		        predicate = undefined$1;
		      }
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Creates an array of elements, sorted in ascending order by the results of
		     * running each element in a collection thru each iteratee. This method
		     * performs a stable sort, that is, it preserves the original sort order of
		     * equal elements. The iteratees are invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {...(Function|Function[])} [iteratees=[_.identity]]
		     *  The iteratees to sort by.
		     * @returns {Array} Returns the new sorted array.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'fred',   'age': 48 },
		     *   { 'user': 'barney', 'age': 36 },
		     *   { 'user': 'fred',   'age': 30 },
		     *   { 'user': 'barney', 'age': 34 }
		     * ];
		     *
		     * _.sortBy(users, [function(o) { return o.user; }]);
		     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
		     *
		     * _.sortBy(users, ['user', 'age']);
		     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
		     */
		    var sortBy = baseRest(function(collection, iteratees) {
		      if (collection == null) {
		        return [];
		      }
		      var length = iteratees.length;
		      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
		        iteratees = [];
		      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
		        iteratees = [iteratees[0]];
		      }
		      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
		    });

		    /*------------------------------------------------------------------------*/

		    /**
		     * Gets the timestamp of the number of milliseconds that have elapsed since
		     * the Unix epoch (1 January 1970 00:00:00 UTC).
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Date
		     * @returns {number} Returns the timestamp.
		     * @example
		     *
		     * _.defer(function(stamp) {
		     *   console.log(_.now() - stamp);
		     * }, _.now());
		     * // => Logs the number of milliseconds it took for the deferred invocation.
		     */
		    var now = ctxNow || function() {
		      return root.Date.now();
		    };

		    /*------------------------------------------------------------------------*/

		    /**
		     * The opposite of `_.before`; this method creates a function that invokes
		     * `func` once it's called `n` or more times.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {number} n The number of calls before `func` is invoked.
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * var saves = ['profile', 'settings'];
		     *
		     * var done = _.after(saves.length, function() {
		     *   console.log('done saving!');
		     * });
		     *
		     * _.forEach(saves, function(type) {
		     *   asyncSave({ 'type': type, 'complete': done });
		     * });
		     * // => Logs 'done saving!' after the two async saves have completed.
		     */
		    function after(n, func) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      n = toInteger(n);
		      return function() {
		        if (--n < 1) {
		          return func.apply(this, arguments);
		        }
		      };
		    }

		    /**
		     * Creates a function that invokes `func`, with up to `n` arguments,
		     * ignoring any additional arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to cap arguments for.
		     * @param {number} [n=func.length] The arity cap.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new capped function.
		     * @example
		     *
		     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
		     * // => [6, 8, 10]
		     */
		    function ary(func, n, guard) {
		      n = guard ? undefined$1 : n;
		      n = (func && n == null) ? func.length : n;
		      return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
		    }

		    /**
		     * Creates a function that invokes `func`, with the `this` binding and arguments
		     * of the created function, while it's called less than `n` times. Subsequent
		     * calls to the created function return the result of the last `func` invocation.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {number} n The number of calls at which `func` is no longer invoked.
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * jQuery(element).on('click', _.before(5, addContactToList));
		     * // => Allows adding up to 4 contacts to the list.
		     */
		    function before(n, func) {
		      var result;
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      n = toInteger(n);
		      return function() {
		        if (--n > 0) {
		          result = func.apply(this, arguments);
		        }
		        if (n <= 1) {
		          func = undefined$1;
		        }
		        return result;
		      };
		    }

		    /**
		     * Creates a function that invokes `func` with the `this` binding of `thisArg`
		     * and `partials` prepended to the arguments it receives.
		     *
		     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
		     * may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
		     * property of bound functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to bind.
		     * @param {*} thisArg The `this` binding of `func`.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new bound function.
		     * @example
		     *
		     * function greet(greeting, punctuation) {
		     *   return greeting + ' ' + this.user + punctuation;
		     * }
		     *
		     * var object = { 'user': 'fred' };
		     *
		     * var bound = _.bind(greet, object, 'hi');
		     * bound('!');
		     * // => 'hi fred!'
		     *
		     * // Bound with placeholders.
		     * var bound = _.bind(greet, object, _, '!');
		     * bound('hi');
		     * // => 'hi fred!'
		     */
		    var bind = baseRest(function(func, thisArg, partials) {
		      var bitmask = WRAP_BIND_FLAG;
		      if (partials.length) {
		        var holders = replaceHolders(partials, getHolder(bind));
		        bitmask |= WRAP_PARTIAL_FLAG;
		      }
		      return createWrap(func, bitmask, thisArg, partials, holders);
		    });

		    /**
		     * Creates a function that invokes the method at `object[key]` with `partials`
		     * prepended to the arguments it receives.
		     *
		     * This method differs from `_.bind` by allowing bound functions to reference
		     * methods that may be redefined or don't yet exist. See
		     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
		     * for more details.
		     *
		     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.10.0
		     * @category Function
		     * @param {Object} object The object to invoke the method on.
		     * @param {string} key The key of the method.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new bound function.
		     * @example
		     *
		     * var object = {
		     *   'user': 'fred',
		     *   'greet': function(greeting, punctuation) {
		     *     return greeting + ' ' + this.user + punctuation;
		     *   }
		     * };
		     *
		     * var bound = _.bindKey(object, 'greet', 'hi');
		     * bound('!');
		     * // => 'hi fred!'
		     *
		     * object.greet = function(greeting, punctuation) {
		     *   return greeting + 'ya ' + this.user + punctuation;
		     * };
		     *
		     * bound('!');
		     * // => 'hiya fred!'
		     *
		     * // Bound with placeholders.
		     * var bound = _.bindKey(object, 'greet', _, '!');
		     * bound('hi');
		     * // => 'hiya fred!'
		     */
		    var bindKey = baseRest(function(object, key, partials) {
		      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
		      if (partials.length) {
		        var holders = replaceHolders(partials, getHolder(bindKey));
		        bitmask |= WRAP_PARTIAL_FLAG;
		      }
		      return createWrap(key, bitmask, object, partials, holders);
		    });

		    /**
		     * Creates a function that accepts arguments of `func` and either invokes
		     * `func` returning its result, if at least `arity` number of arguments have
		     * been provided, or returns a function that accepts the remaining `func`
		     * arguments, and so on. The arity of `func` may be specified if `func.length`
		     * is not sufficient.
		     *
		     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
		     * may be used as a placeholder for provided arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of curried functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Function
		     * @param {Function} func The function to curry.
		     * @param {number} [arity=func.length] The arity of `func`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new curried function.
		     * @example
		     *
		     * var abc = function(a, b, c) {
		     *   return [a, b, c];
		     * };
		     *
		     * var curried = _.curry(abc);
		     *
		     * curried(1)(2)(3);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2)(3);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2, 3);
		     * // => [1, 2, 3]
		     *
		     * // Curried with placeholders.
		     * curried(1)(_, 3)(2);
		     * // => [1, 2, 3]
		     */
		    function curry(func, arity, guard) {
		      arity = guard ? undefined$1 : arity;
		      var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
		      result.placeholder = curry.placeholder;
		      return result;
		    }

		    /**
		     * This method is like `_.curry` except that arguments are applied to `func`
		     * in the manner of `_.partialRight` instead of `_.partial`.
		     *
		     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for provided arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of curried functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to curry.
		     * @param {number} [arity=func.length] The arity of `func`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new curried function.
		     * @example
		     *
		     * var abc = function(a, b, c) {
		     *   return [a, b, c];
		     * };
		     *
		     * var curried = _.curryRight(abc);
		     *
		     * curried(3)(2)(1);
		     * // => [1, 2, 3]
		     *
		     * curried(2, 3)(1);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2, 3);
		     * // => [1, 2, 3]
		     *
		     * // Curried with placeholders.
		     * curried(3)(1, _)(2);
		     * // => [1, 2, 3]
		     */
		    function curryRight(func, arity, guard) {
		      arity = guard ? undefined$1 : arity;
		      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
		      result.placeholder = curryRight.placeholder;
		      return result;
		    }

		    /**
		     * Creates a debounced function that delays invoking `func` until after `wait`
		     * milliseconds have elapsed since the last time the debounced function was
		     * invoked. The debounced function comes with a `cancel` method to cancel
		     * delayed `func` invocations and a `flush` method to immediately invoke them.
		     * Provide `options` to indicate whether `func` should be invoked on the
		     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
		     * with the last arguments provided to the debounced function. Subsequent
		     * calls to the debounced function return the result of the last `func`
		     * invocation.
		     *
		     * **Note:** If `leading` and `trailing` options are `true`, `func` is
		     * invoked on the trailing edge of the timeout only if the debounced function
		     * is invoked more than once during the `wait` timeout.
		     *
		     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
		     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
		     *
		     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
		     * for details over the differences between `_.debounce` and `_.throttle`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to debounce.
		     * @param {number} [wait=0] The number of milliseconds to delay.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.leading=false]
		     *  Specify invoking on the leading edge of the timeout.
		     * @param {number} [options.maxWait]
		     *  The maximum time `func` is allowed to be delayed before it's invoked.
		     * @param {boolean} [options.trailing=true]
		     *  Specify invoking on the trailing edge of the timeout.
		     * @returns {Function} Returns the new debounced function.
		     * @example
		     *
		     * // Avoid costly calculations while the window size is in flux.
		     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
		     *
		     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
		     * jQuery(element).on('click', _.debounce(sendMail, 300, {
		     *   'leading': true,
		     *   'trailing': false
		     * }));
		     *
		     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
		     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
		     * var source = new EventSource('/stream');
		     * jQuery(source).on('message', debounced);
		     *
		     * // Cancel the trailing debounced invocation.
		     * jQuery(window).on('popstate', debounced.cancel);
		     */
		    function debounce(func, wait, options) {
		      var lastArgs,
		          lastThis,
		          maxWait,
		          result,
		          timerId,
		          lastCallTime,
		          lastInvokeTime = 0,
		          leading = false,
		          maxing = false,
		          trailing = true;

		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      wait = toNumber(wait) || 0;
		      if (isObject(options)) {
		        leading = !!options.leading;
		        maxing = 'maxWait' in options;
		        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
		        trailing = 'trailing' in options ? !!options.trailing : trailing;
		      }

		      function invokeFunc(time) {
		        var args = lastArgs,
		            thisArg = lastThis;

		        lastArgs = lastThis = undefined$1;
		        lastInvokeTime = time;
		        result = func.apply(thisArg, args);
		        return result;
		      }

		      function leadingEdge(time) {
		        // Reset any `maxWait` timer.
		        lastInvokeTime = time;
		        // Start the timer for the trailing edge.
		        timerId = setTimeout(timerExpired, wait);
		        // Invoke the leading edge.
		        return leading ? invokeFunc(time) : result;
		      }

		      function remainingWait(time) {
		        var timeSinceLastCall = time - lastCallTime,
		            timeSinceLastInvoke = time - lastInvokeTime,
		            timeWaiting = wait - timeSinceLastCall;

		        return maxing
		          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
		          : timeWaiting;
		      }

		      function shouldInvoke(time) {
		        var timeSinceLastCall = time - lastCallTime,
		            timeSinceLastInvoke = time - lastInvokeTime;

		        // Either this is the first call, activity has stopped and we're at the
		        // trailing edge, the system time has gone backwards and we're treating
		        // it as the trailing edge, or we've hit the `maxWait` limit.
		        return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
		          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
		      }

		      function timerExpired() {
		        var time = now();
		        if (shouldInvoke(time)) {
		          return trailingEdge(time);
		        }
		        // Restart the timer.
		        timerId = setTimeout(timerExpired, remainingWait(time));
		      }

		      function trailingEdge(time) {
		        timerId = undefined$1;

		        // Only invoke if we have `lastArgs` which means `func` has been
		        // debounced at least once.
		        if (trailing && lastArgs) {
		          return invokeFunc(time);
		        }
		        lastArgs = lastThis = undefined$1;
		        return result;
		      }

		      function cancel() {
		        if (timerId !== undefined$1) {
		          clearTimeout(timerId);
		        }
		        lastInvokeTime = 0;
		        lastArgs = lastCallTime = lastThis = timerId = undefined$1;
		      }

		      function flush() {
		        return timerId === undefined$1 ? result : trailingEdge(now());
		      }

		      function debounced() {
		        var time = now(),
		            isInvoking = shouldInvoke(time);

		        lastArgs = arguments;
		        lastThis = this;
		        lastCallTime = time;

		        if (isInvoking) {
		          if (timerId === undefined$1) {
		            return leadingEdge(lastCallTime);
		          }
		          if (maxing) {
		            // Handle invocations in a tight loop.
		            clearTimeout(timerId);
		            timerId = setTimeout(timerExpired, wait);
		            return invokeFunc(lastCallTime);
		          }
		        }
		        if (timerId === undefined$1) {
		          timerId = setTimeout(timerExpired, wait);
		        }
		        return result;
		      }
		      debounced.cancel = cancel;
		      debounced.flush = flush;
		      return debounced;
		    }

		    /**
		     * Defers invoking the `func` until the current call stack has cleared. Any
		     * additional arguments are provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to defer.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {number} Returns the timer id.
		     * @example
		     *
		     * _.defer(function(text) {
		     *   console.log(text);
		     * }, 'deferred');
		     * // => Logs 'deferred' after one millisecond.
		     */
		    var defer = baseRest(function(func, args) {
		      return baseDelay(func, 1, args);
		    });

		    /**
		     * Invokes `func` after `wait` milliseconds. Any additional arguments are
		     * provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {number} Returns the timer id.
		     * @example
		     *
		     * _.delay(function(text) {
		     *   console.log(text);
		     * }, 1000, 'later');
		     * // => Logs 'later' after one second.
		     */
		    var delay = baseRest(function(func, wait, args) {
		      return baseDelay(func, toNumber(wait) || 0, args);
		    });

		    /**
		     * Creates a function that invokes `func` with arguments reversed.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to flip arguments for.
		     * @returns {Function} Returns the new flipped function.
		     * @example
		     *
		     * var flipped = _.flip(function() {
		     *   return _.toArray(arguments);
		     * });
		     *
		     * flipped('a', 'b', 'c', 'd');
		     * // => ['d', 'c', 'b', 'a']
		     */
		    function flip(func) {
		      return createWrap(func, WRAP_FLIP_FLAG);
		    }

		    /**
		     * Creates a function that memoizes the result of `func`. If `resolver` is
		     * provided, it determines the cache key for storing the result based on the
		     * arguments provided to the memoized function. By default, the first argument
		     * provided to the memoized function is used as the map cache key. The `func`
		     * is invoked with the `this` binding of the memoized function.
		     *
		     * **Note:** The cache is exposed as the `cache` property on the memoized
		     * function. Its creation may be customized by replacing the `_.memoize.Cache`
		     * constructor with one whose instances implement the
		     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
		     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to have its output memoized.
		     * @param {Function} [resolver] The function to resolve the cache key.
		     * @returns {Function} Returns the new memoized function.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     * var other = { 'c': 3, 'd': 4 };
		     *
		     * var values = _.memoize(_.values);
		     * values(object);
		     * // => [1, 2]
		     *
		     * values(other);
		     * // => [3, 4]
		     *
		     * object.a = 2;
		     * values(object);
		     * // => [1, 2]
		     *
		     * // Modify the result cache.
		     * values.cache.set(object, ['a', 'b']);
		     * values(object);
		     * // => ['a', 'b']
		     *
		     * // Replace `_.memoize.Cache`.
		     * _.memoize.Cache = WeakMap;
		     */
		    function memoize(func, resolver) {
		      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      var memoized = function() {
		        var args = arguments,
		            key = resolver ? resolver.apply(this, args) : args[0],
		            cache = memoized.cache;

		        if (cache.has(key)) {
		          return cache.get(key);
		        }
		        var result = func.apply(this, args);
		        memoized.cache = cache.set(key, result) || cache;
		        return result;
		      };
		      memoized.cache = new (memoize.Cache || MapCache);
		      return memoized;
		    }

		    // Expose `MapCache`.
		    memoize.Cache = MapCache;

		    /**
		     * Creates a function that negates the result of the predicate `func`. The
		     * `func` predicate is invoked with the `this` binding and arguments of the
		     * created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} predicate The predicate to negate.
		     * @returns {Function} Returns the new negated function.
		     * @example
		     *
		     * function isEven(n) {
		     *   return n % 2 == 0;
		     * }
		     *
		     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
		     * // => [1, 3, 5]
		     */
		    function negate(predicate) {
		      if (typeof predicate != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      return function() {
		        var args = arguments;
		        switch (args.length) {
		          case 0: return !predicate.call(this);
		          case 1: return !predicate.call(this, args[0]);
		          case 2: return !predicate.call(this, args[0], args[1]);
		          case 3: return !predicate.call(this, args[0], args[1], args[2]);
		        }
		        return !predicate.apply(this, args);
		      };
		    }

		    /**
		     * Creates a function that is restricted to invoking `func` once. Repeat calls
		     * to the function return the value of the first invocation. The `func` is
		     * invoked with the `this` binding and arguments of the created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * var initialize = _.once(createApplication);
		     * initialize();
		     * initialize();
		     * // => `createApplication` is invoked once
		     */
		    function once(func) {
		      return before(2, func);
		    }

		    /**
		     * Creates a function that invokes `func` with its arguments transformed.
		     *
		     * @static
		     * @since 4.0.0
		     * @memberOf _
		     * @category Function
		     * @param {Function} func The function to wrap.
		     * @param {...(Function|Function[])} [transforms=[_.identity]]
		     *  The argument transforms.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * function doubled(n) {
		     *   return n * 2;
		     * }
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var func = _.overArgs(function(x, y) {
		     *   return [x, y];
		     * }, [square, doubled]);
		     *
		     * func(9, 3);
		     * // => [81, 6]
		     *
		     * func(10, 5);
		     * // => [100, 10]
		     */
		    var overArgs = castRest(function(func, transforms) {
		      transforms = (transforms.length == 1 && isArray(transforms[0]))
		        ? arrayMap(transforms[0], baseUnary(getIteratee()))
		        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

		      var funcsLength = transforms.length;
		      return baseRest(function(args) {
		        var index = -1,
		            length = nativeMin(args.length, funcsLength);

		        while (++index < length) {
		          args[index] = transforms[index].call(this, args[index]);
		        }
		        return apply(func, this, args);
		      });
		    });

		    /**
		     * Creates a function that invokes `func` with `partials` prepended to the
		     * arguments it receives. This method is like `_.bind` except it does **not**
		     * alter the `this` binding.
		     *
		     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of partially
		     * applied functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.2.0
		     * @category Function
		     * @param {Function} func The function to partially apply arguments to.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new partially applied function.
		     * @example
		     *
		     * function greet(greeting, name) {
		     *   return greeting + ' ' + name;
		     * }
		     *
		     * var sayHelloTo = _.partial(greet, 'hello');
		     * sayHelloTo('fred');
		     * // => 'hello fred'
		     *
		     * // Partially applied with placeholders.
		     * var greetFred = _.partial(greet, _, 'fred');
		     * greetFred('hi');
		     * // => 'hi fred'
		     */
		    var partial = baseRest(function(func, partials) {
		      var holders = replaceHolders(partials, getHolder(partial));
		      return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
		    });

		    /**
		     * This method is like `_.partial` except that partially applied arguments
		     * are appended to the arguments it receives.
		     *
		     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of partially
		     * applied functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Function
		     * @param {Function} func The function to partially apply arguments to.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new partially applied function.
		     * @example
		     *
		     * function greet(greeting, name) {
		     *   return greeting + ' ' + name;
		     * }
		     *
		     * var greetFred = _.partialRight(greet, 'fred');
		     * greetFred('hi');
		     * // => 'hi fred'
		     *
		     * // Partially applied with placeholders.
		     * var sayHelloTo = _.partialRight(greet, 'hello', _);
		     * sayHelloTo('fred');
		     * // => 'hello fred'
		     */
		    var partialRight = baseRest(function(func, partials) {
		      var holders = replaceHolders(partials, getHolder(partialRight));
		      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
		    });

		    /**
		     * Creates a function that invokes `func` with arguments arranged according
		     * to the specified `indexes` where the argument value at the first index is
		     * provided as the first argument, the argument value at the second index is
		     * provided as the second argument, and so on.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to rearrange arguments for.
		     * @param {...(number|number[])} indexes The arranged argument indexes.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var rearged = _.rearg(function(a, b, c) {
		     *   return [a, b, c];
		     * }, [2, 0, 1]);
		     *
		     * rearged('b', 'c', 'a')
		     * // => ['a', 'b', 'c']
		     */
		    var rearg = flatRest(function(func, indexes) {
		      return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
		    });

		    /**
		     * Creates a function that invokes `func` with the `this` binding of the
		     * created function and arguments from `start` and beyond provided as
		     * an array.
		     *
		     * **Note:** This method is based on the
		     * [rest parameter](https://mdn.io/rest_parameters).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var say = _.rest(function(what, names) {
		     *   return what + ' ' + _.initial(names).join(', ') +
		     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
		     * });
		     *
		     * say('hello', 'fred', 'barney', 'pebbles');
		     * // => 'hello fred, barney, & pebbles'
		     */
		    function rest(func, start) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      start = start === undefined$1 ? start : toInteger(start);
		      return baseRest(func, start);
		    }

		    /**
		     * Creates a function that invokes `func` with the `this` binding of the
		     * create function and an array of arguments much like
		     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
		     *
		     * **Note:** This method is based on the
		     * [spread operator](https://mdn.io/spread_operator).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Function
		     * @param {Function} func The function to spread arguments over.
		     * @param {number} [start=0] The start position of the spread.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var say = _.spread(function(who, what) {
		     *   return who + ' says ' + what;
		     * });
		     *
		     * say(['fred', 'hello']);
		     * // => 'fred says hello'
		     *
		     * var numbers = Promise.all([
		     *   Promise.resolve(40),
		     *   Promise.resolve(36)
		     * ]);
		     *
		     * numbers.then(_.spread(function(x, y) {
		     *   return x + y;
		     * }));
		     * // => a Promise of 76
		     */
		    function spread(func, start) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      start = start == null ? 0 : nativeMax(toInteger(start), 0);
		      return baseRest(function(args) {
		        var array = args[start],
		            otherArgs = castSlice(args, 0, start);

		        if (array) {
		          arrayPush(otherArgs, array);
		        }
		        return apply(func, this, otherArgs);
		      });
		    }

		    /**
		     * Creates a throttled function that only invokes `func` at most once per
		     * every `wait` milliseconds. The throttled function comes with a `cancel`
		     * method to cancel delayed `func` invocations and a `flush` method to
		     * immediately invoke them. Provide `options` to indicate whether `func`
		     * should be invoked on the leading and/or trailing edge of the `wait`
		     * timeout. The `func` is invoked with the last arguments provided to the
		     * throttled function. Subsequent calls to the throttled function return the
		     * result of the last `func` invocation.
		     *
		     * **Note:** If `leading` and `trailing` options are `true`, `func` is
		     * invoked on the trailing edge of the timeout only if the throttled function
		     * is invoked more than once during the `wait` timeout.
		     *
		     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
		     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
		     *
		     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
		     * for details over the differences between `_.throttle` and `_.debounce`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to throttle.
		     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.leading=true]
		     *  Specify invoking on the leading edge of the timeout.
		     * @param {boolean} [options.trailing=true]
		     *  Specify invoking on the trailing edge of the timeout.
		     * @returns {Function} Returns the new throttled function.
		     * @example
		     *
		     * // Avoid excessively updating the position while scrolling.
		     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
		     *
		     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
		     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
		     * jQuery(element).on('click', throttled);
		     *
		     * // Cancel the trailing throttled invocation.
		     * jQuery(window).on('popstate', throttled.cancel);
		     */
		    function throttle(func, wait, options) {
		      var leading = true,
		          trailing = true;

		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      if (isObject(options)) {
		        leading = 'leading' in options ? !!options.leading : leading;
		        trailing = 'trailing' in options ? !!options.trailing : trailing;
		      }
		      return debounce(func, wait, {
		        'leading': leading,
		        'maxWait': wait,
		        'trailing': trailing
		      });
		    }

		    /**
		     * Creates a function that accepts up to one argument, ignoring any
		     * additional arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to cap arguments for.
		     * @returns {Function} Returns the new capped function.
		     * @example
		     *
		     * _.map(['6', '8', '10'], _.unary(parseInt));
		     * // => [6, 8, 10]
		     */
		    function unary(func) {
		      return ary(func, 1);
		    }

		    /**
		     * Creates a function that provides `value` to `wrapper` as its first
		     * argument. Any additional arguments provided to the function are appended
		     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
		     * binding of the created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {*} value The value to wrap.
		     * @param {Function} [wrapper=identity] The wrapper function.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var p = _.wrap(_.escape, function(func, text) {
		     *   return '<p>' + func(text) + '</p>';
		     * });
		     *
		     * p('fred, barney, & pebbles');
		     * // => '<p>fred, barney, &amp; pebbles</p>'
		     */
		    function wrap(value, wrapper) {
		      return partial(castFunction(wrapper), value);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Casts `value` as an array if it's not one.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.4.0
		     * @category Lang
		     * @param {*} value The value to inspect.
		     * @returns {Array} Returns the cast array.
		     * @example
		     *
		     * _.castArray(1);
		     * // => [1]
		     *
		     * _.castArray({ 'a': 1 });
		     * // => [{ 'a': 1 }]
		     *
		     * _.castArray('abc');
		     * // => ['abc']
		     *
		     * _.castArray(null);
		     * // => [null]
		     *
		     * _.castArray(undefined);
		     * // => [undefined]
		     *
		     * _.castArray();
		     * // => []
		     *
		     * var array = [1, 2, 3];
		     * console.log(_.castArray(array) === array);
		     * // => true
		     */
		    function castArray() {
		      if (!arguments.length) {
		        return [];
		      }
		      var value = arguments[0];
		      return isArray(value) ? value : [value];
		    }

		    /**
		     * Creates a shallow clone of `value`.
		     *
		     * **Note:** This method is loosely based on the
		     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
		     * and supports cloning arrays, array buffers, booleans, date objects, maps,
		     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
		     * arrays. The own enumerable properties of `arguments` objects are cloned
		     * as plain objects. An empty object is returned for uncloneable values such
		     * as error objects, functions, DOM nodes, and WeakMaps.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to clone.
		     * @returns {*} Returns the cloned value.
		     * @see _.cloneDeep
		     * @example
		     *
		     * var objects = [{ 'a': 1 }, { 'b': 2 }];
		     *
		     * var shallow = _.clone(objects);
		     * console.log(shallow[0] === objects[0]);
		     * // => true
		     */
		    function clone(value) {
		      return baseClone(value, CLONE_SYMBOLS_FLAG);
		    }

		    /**
		     * This method is like `_.clone` except that it accepts `customizer` which
		     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
		     * cloning is handled by the method instead. The `customizer` is invoked with
		     * up to four arguments; (value [, index|key, object, stack]).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to clone.
		     * @param {Function} [customizer] The function to customize cloning.
		     * @returns {*} Returns the cloned value.
		     * @see _.cloneDeepWith
		     * @example
		     *
		     * function customizer(value) {
		     *   if (_.isElement(value)) {
		     *     return value.cloneNode(false);
		     *   }
		     * }
		     *
		     * var el = _.cloneWith(document.body, customizer);
		     *
		     * console.log(el === document.body);
		     * // => false
		     * console.log(el.nodeName);
		     * // => 'BODY'
		     * console.log(el.childNodes.length);
		     * // => 0
		     */
		    function cloneWith(value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
		    }

		    /**
		     * This method is like `_.clone` except that it recursively clones `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Lang
		     * @param {*} value The value to recursively clone.
		     * @returns {*} Returns the deep cloned value.
		     * @see _.clone
		     * @example
		     *
		     * var objects = [{ 'a': 1 }, { 'b': 2 }];
		     *
		     * var deep = _.cloneDeep(objects);
		     * console.log(deep[0] === objects[0]);
		     * // => false
		     */
		    function cloneDeep(value) {
		      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
		    }

		    /**
		     * This method is like `_.cloneWith` except that it recursively clones `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to recursively clone.
		     * @param {Function} [customizer] The function to customize cloning.
		     * @returns {*} Returns the deep cloned value.
		     * @see _.cloneWith
		     * @example
		     *
		     * function customizer(value) {
		     *   if (_.isElement(value)) {
		     *     return value.cloneNode(true);
		     *   }
		     * }
		     *
		     * var el = _.cloneDeepWith(document.body, customizer);
		     *
		     * console.log(el === document.body);
		     * // => false
		     * console.log(el.nodeName);
		     * // => 'BODY'
		     * console.log(el.childNodes.length);
		     * // => 20
		     */
		    function cloneDeepWith(value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
		    }

		    /**
		     * Checks if `object` conforms to `source` by invoking the predicate
		     * properties of `source` with the corresponding property values of `object`.
		     *
		     * **Note:** This method is equivalent to `_.conforms` when `source` is
		     * partially applied.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.14.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     *
		     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
		     * // => true
		     *
		     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
		     * // => false
		     */
		    function conformsTo(object, source) {
		      return source == null || baseConformsTo(object, source, keys(source));
		    }

		    /**
		     * Performs a
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * comparison between two values to determine if they are equivalent.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     * var other = { 'a': 1 };
		     *
		     * _.eq(object, object);
		     * // => true
		     *
		     * _.eq(object, other);
		     * // => false
		     *
		     * _.eq('a', 'a');
		     * // => true
		     *
		     * _.eq('a', Object('a'));
		     * // => false
		     *
		     * _.eq(NaN, NaN);
		     * // => true
		     */
		    function eq(value, other) {
		      return value === other || (value !== value && other !== other);
		    }

		    /**
		     * Checks if `value` is greater than `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than `other`,
		     *  else `false`.
		     * @see _.lt
		     * @example
		     *
		     * _.gt(3, 1);
		     * // => true
		     *
		     * _.gt(3, 3);
		     * // => false
		     *
		     * _.gt(1, 3);
		     * // => false
		     */
		    var gt = createRelationalOperation(baseGt);

		    /**
		     * Checks if `value` is greater than or equal to `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than or equal to
		     *  `other`, else `false`.
		     * @see _.lte
		     * @example
		     *
		     * _.gte(3, 1);
		     * // => true
		     *
		     * _.gte(3, 3);
		     * // => true
		     *
		     * _.gte(1, 3);
		     * // => false
		     */
		    var gte = createRelationalOperation(function(value, other) {
		      return value >= other;
		    });

		    /**
		     * Checks if `value` is likely an `arguments` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
		     *  else `false`.
		     * @example
		     *
		     * _.isArguments(function() { return arguments; }());
		     * // => true
		     *
		     * _.isArguments([1, 2, 3]);
		     * // => false
		     */
		    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
		      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
		        !propertyIsEnumerable.call(value, 'callee');
		    };

		    /**
		     * Checks if `value` is classified as an `Array` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
		     * @example
		     *
		     * _.isArray([1, 2, 3]);
		     * // => true
		     *
		     * _.isArray(document.body.children);
		     * // => false
		     *
		     * _.isArray('abc');
		     * // => false
		     *
		     * _.isArray(_.noop);
		     * // => false
		     */
		    var isArray = Array.isArray;

		    /**
		     * Checks if `value` is classified as an `ArrayBuffer` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
		     * @example
		     *
		     * _.isArrayBuffer(new ArrayBuffer(2));
		     * // => true
		     *
		     * _.isArrayBuffer(new Array(2));
		     * // => false
		     */
		    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

		    /**
		     * Checks if `value` is array-like. A value is considered array-like if it's
		     * not a function and has a `value.length` that's an integer greater than or
		     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
		     * @example
		     *
		     * _.isArrayLike([1, 2, 3]);
		     * // => true
		     *
		     * _.isArrayLike(document.body.children);
		     * // => true
		     *
		     * _.isArrayLike('abc');
		     * // => true
		     *
		     * _.isArrayLike(_.noop);
		     * // => false
		     */
		    function isArrayLike(value) {
		      return value != null && isLength(value.length) && !isFunction(value);
		    }

		    /**
		     * This method is like `_.isArrayLike` except that it also checks if `value`
		     * is an object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array-like object,
		     *  else `false`.
		     * @example
		     *
		     * _.isArrayLikeObject([1, 2, 3]);
		     * // => true
		     *
		     * _.isArrayLikeObject(document.body.children);
		     * // => true
		     *
		     * _.isArrayLikeObject('abc');
		     * // => false
		     *
		     * _.isArrayLikeObject(_.noop);
		     * // => false
		     */
		    function isArrayLikeObject(value) {
		      return isObjectLike(value) && isArrayLike(value);
		    }

		    /**
		     * Checks if `value` is classified as a boolean primitive or object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
		     * @example
		     *
		     * _.isBoolean(false);
		     * // => true
		     *
		     * _.isBoolean(null);
		     * // => false
		     */
		    function isBoolean(value) {
		      return value === true || value === false ||
		        (isObjectLike(value) && baseGetTag(value) == boolTag);
		    }

		    /**
		     * Checks if `value` is a buffer.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		     * @example
		     *
		     * _.isBuffer(new Buffer(2));
		     * // => true
		     *
		     * _.isBuffer(new Uint8Array(2));
		     * // => false
		     */
		    var isBuffer = nativeIsBuffer || stubFalse;

		    /**
		     * Checks if `value` is classified as a `Date` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
		     * @example
		     *
		     * _.isDate(new Date);
		     * // => true
		     *
		     * _.isDate('Mon April 23 2012');
		     * // => false
		     */
		    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

		    /**
		     * Checks if `value` is likely a DOM element.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
		     * @example
		     *
		     * _.isElement(document.body);
		     * // => true
		     *
		     * _.isElement('<body>');
		     * // => false
		     */
		    function isElement(value) {
		      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
		    }

		    /**
		     * Checks if `value` is an empty object, collection, map, or set.
		     *
		     * Objects are considered empty if they have no own enumerable string keyed
		     * properties.
		     *
		     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
		     * jQuery-like collections are considered empty if they have a `length` of `0`.
		     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
		     * @example
		     *
		     * _.isEmpty(null);
		     * // => true
		     *
		     * _.isEmpty(true);
		     * // => true
		     *
		     * _.isEmpty(1);
		     * // => true
		     *
		     * _.isEmpty([1, 2, 3]);
		     * // => false
		     *
		     * _.isEmpty({ 'a': 1 });
		     * // => false
		     */
		    function isEmpty(value) {
		      if (value == null) {
		        return true;
		      }
		      if (isArrayLike(value) &&
		          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
		            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
		        return !value.length;
		      }
		      var tag = getTag(value);
		      if (tag == mapTag || tag == setTag) {
		        return !value.size;
		      }
		      if (isPrototype(value)) {
		        return !baseKeys(value).length;
		      }
		      for (var key in value) {
		        if (hasOwnProperty.call(value, key)) {
		          return false;
		        }
		      }
		      return true;
		    }

		    /**
		     * Performs a deep comparison between two values to determine if they are
		     * equivalent.
		     *
		     * **Note:** This method supports comparing arrays, array buffers, booleans,
		     * date objects, error objects, maps, numbers, `Object` objects, regexes,
		     * sets, strings, symbols, and typed arrays. `Object` objects are compared
		     * by their own, not inherited, enumerable properties. Functions and DOM
		     * nodes are compared by strict equality, i.e. `===`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     * var other = { 'a': 1 };
		     *
		     * _.isEqual(object, other);
		     * // => true
		     *
		     * object === other;
		     * // => false
		     */
		    function isEqual(value, other) {
		      return baseIsEqual(value, other);
		    }

		    /**
		     * This method is like `_.isEqual` except that it accepts `customizer` which
		     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
		     * are handled by the method instead. The `customizer` is invoked with up to
		     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * function isGreeting(value) {
		     *   return /^h(?:i|ello)$/.test(value);
		     * }
		     *
		     * function customizer(objValue, othValue) {
		     *   if (isGreeting(objValue) && isGreeting(othValue)) {
		     *     return true;
		     *   }
		     * }
		     *
		     * var array = ['hello', 'goodbye'];
		     * var other = ['hi', 'goodbye'];
		     *
		     * _.isEqualWith(array, other, customizer);
		     * // => true
		     */
		    function isEqualWith(value, other, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      var result = customizer ? customizer(value, other) : undefined$1;
		      return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
		    }

		    /**
		     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
		     * `SyntaxError`, `TypeError`, or `URIError` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
		     * @example
		     *
		     * _.isError(new Error);
		     * // => true
		     *
		     * _.isError(Error);
		     * // => false
		     */
		    function isError(value) {
		      if (!isObjectLike(value)) {
		        return false;
		      }
		      var tag = baseGetTag(value);
		      return tag == errorTag || tag == domExcTag ||
		        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
		    }

		    /**
		     * Checks if `value` is a finite primitive number.
		     *
		     * **Note:** This method is based on
		     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
		     * @example
		     *
		     * _.isFinite(3);
		     * // => true
		     *
		     * _.isFinite(Number.MIN_VALUE);
		     * // => true
		     *
		     * _.isFinite(Infinity);
		     * // => false
		     *
		     * _.isFinite('3');
		     * // => false
		     */
		    function isFinite(value) {
		      return typeof value == 'number' && nativeIsFinite(value);
		    }

		    /**
		     * Checks if `value` is classified as a `Function` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
		     * @example
		     *
		     * _.isFunction(_);
		     * // => true
		     *
		     * _.isFunction(/abc/);
		     * // => false
		     */
		    function isFunction(value) {
		      if (!isObject(value)) {
		        return false;
		      }
		      // The use of `Object#toString` avoids issues with the `typeof` operator
		      // in Safari 9 which returns 'object' for typed arrays and other constructors.
		      var tag = baseGetTag(value);
		      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
		    }

		    /**
		     * Checks if `value` is an integer.
		     *
		     * **Note:** This method is based on
		     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
		     * @example
		     *
		     * _.isInteger(3);
		     * // => true
		     *
		     * _.isInteger(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isInteger(Infinity);
		     * // => false
		     *
		     * _.isInteger('3');
		     * // => false
		     */
		    function isInteger(value) {
		      return typeof value == 'number' && value == toInteger(value);
		    }

		    /**
		     * Checks if `value` is a valid array-like length.
		     *
		     * **Note:** This method is loosely based on
		     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
		     * @example
		     *
		     * _.isLength(3);
		     * // => true
		     *
		     * _.isLength(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isLength(Infinity);
		     * // => false
		     *
		     * _.isLength('3');
		     * // => false
		     */
		    function isLength(value) {
		      return typeof value == 'number' &&
		        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
		    }

		    /**
		     * Checks if `value` is the
		     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
		     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
		     * @example
		     *
		     * _.isObject({});
		     * // => true
		     *
		     * _.isObject([1, 2, 3]);
		     * // => true
		     *
		     * _.isObject(_.noop);
		     * // => true
		     *
		     * _.isObject(null);
		     * // => false
		     */
		    function isObject(value) {
		      var type = typeof value;
		      return value != null && (type == 'object' || type == 'function');
		    }

		    /**
		     * Checks if `value` is object-like. A value is object-like if it's not `null`
		     * and has a `typeof` result of "object".
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
		     * @example
		     *
		     * _.isObjectLike({});
		     * // => true
		     *
		     * _.isObjectLike([1, 2, 3]);
		     * // => true
		     *
		     * _.isObjectLike(_.noop);
		     * // => false
		     *
		     * _.isObjectLike(null);
		     * // => false
		     */
		    function isObjectLike(value) {
		      return value != null && typeof value == 'object';
		    }

		    /**
		     * Checks if `value` is classified as a `Map` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
		     * @example
		     *
		     * _.isMap(new Map);
		     * // => true
		     *
		     * _.isMap(new WeakMap);
		     * // => false
		     */
		    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

		    /**
		     * Performs a partial deep comparison between `object` and `source` to
		     * determine if `object` contains equivalent property values.
		     *
		     * **Note:** This method is equivalent to `_.matches` when `source` is
		     * partially applied.
		     *
		     * Partial comparisons will match empty array and empty object `source`
		     * values against any array or object value, respectively. See `_.isEqual`
		     * for a list of supported value comparisons.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     *
		     * _.isMatch(object, { 'b': 2 });
		     * // => true
		     *
		     * _.isMatch(object, { 'b': 1 });
		     * // => false
		     */
		    function isMatch(object, source) {
		      return object === source || baseIsMatch(object, source, getMatchData(source));
		    }

		    /**
		     * This method is like `_.isMatch` except that it accepts `customizer` which
		     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
		     * are handled by the method instead. The `customizer` is invoked with five
		     * arguments: (objValue, srcValue, index|key, object, source).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     * @example
		     *
		     * function isGreeting(value) {
		     *   return /^h(?:i|ello)$/.test(value);
		     * }
		     *
		     * function customizer(objValue, srcValue) {
		     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
		     *     return true;
		     *   }
		     * }
		     *
		     * var object = { 'greeting': 'hello' };
		     * var source = { 'greeting': 'hi' };
		     *
		     * _.isMatchWith(object, source, customizer);
		     * // => true
		     */
		    function isMatchWith(object, source, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseIsMatch(object, source, getMatchData(source), customizer);
		    }

		    /**
		     * Checks if `value` is `NaN`.
		     *
		     * **Note:** This method is based on
		     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
		     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
		     * `undefined` and other non-number values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
		     * @example
		     *
		     * _.isNaN(NaN);
		     * // => true
		     *
		     * _.isNaN(new Number(NaN));
		     * // => true
		     *
		     * isNaN(undefined);
		     * // => true
		     *
		     * _.isNaN(undefined);
		     * // => false
		     */
		    function isNaN(value) {
		      // An `NaN` primitive is the only value that is not equal to itself.
		      // Perform the `toStringTag` check first to avoid errors with some
		      // ActiveX objects in IE.
		      return isNumber(value) && value != +value;
		    }

		    /**
		     * Checks if `value` is a pristine native function.
		     *
		     * **Note:** This method can't reliably detect native functions in the presence
		     * of the core-js package because core-js circumvents this kind of detection.
		     * Despite multiple requests, the core-js maintainer has made it clear: any
		     * attempt to fix the detection will be obstructed. As a result, we're left
		     * with little choice but to throw an error. Unfortunately, this also affects
		     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
		     * which rely on core-js.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a native function,
		     *  else `false`.
		     * @example
		     *
		     * _.isNative(Array.prototype.push);
		     * // => true
		     *
		     * _.isNative(_);
		     * // => false
		     */
		    function isNative(value) {
		      if (isMaskable(value)) {
		        throw new Error(CORE_ERROR_TEXT);
		      }
		      return baseIsNative(value);
		    }

		    /**
		     * Checks if `value` is `null`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
		     * @example
		     *
		     * _.isNull(null);
		     * // => true
		     *
		     * _.isNull(void 0);
		     * // => false
		     */
		    function isNull(value) {
		      return value === null;
		    }

		    /**
		     * Checks if `value` is `null` or `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
		     * @example
		     *
		     * _.isNil(null);
		     * // => true
		     *
		     * _.isNil(void 0);
		     * // => true
		     *
		     * _.isNil(NaN);
		     * // => false
		     */
		    function isNil(value) {
		      return value == null;
		    }

		    /**
		     * Checks if `value` is classified as a `Number` primitive or object.
		     *
		     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
		     * classified as numbers, use the `_.isFinite` method.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
		     * @example
		     *
		     * _.isNumber(3);
		     * // => true
		     *
		     * _.isNumber(Number.MIN_VALUE);
		     * // => true
		     *
		     * _.isNumber(Infinity);
		     * // => true
		     *
		     * _.isNumber('3');
		     * // => false
		     */
		    function isNumber(value) {
		      return typeof value == 'number' ||
		        (isObjectLike(value) && baseGetTag(value) == numberTag);
		    }

		    /**
		     * Checks if `value` is a plain object, that is, an object created by the
		     * `Object` constructor or one with a `[[Prototype]]` of `null`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.8.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * _.isPlainObject(new Foo);
		     * // => false
		     *
		     * _.isPlainObject([1, 2, 3]);
		     * // => false
		     *
		     * _.isPlainObject({ 'x': 0, 'y': 0 });
		     * // => true
		     *
		     * _.isPlainObject(Object.create(null));
		     * // => true
		     */
		    function isPlainObject(value) {
		      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
		        return false;
		      }
		      var proto = getPrototype(value);
		      if (proto === null) {
		        return true;
		      }
		      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
		      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
		        funcToString.call(Ctor) == objectCtorString;
		    }

		    /**
		     * Checks if `value` is classified as a `RegExp` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
		     * @example
		     *
		     * _.isRegExp(/abc/);
		     * // => true
		     *
		     * _.isRegExp('/abc/');
		     * // => false
		     */
		    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

		    /**
		     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
		     * double precision number which isn't the result of a rounded unsafe integer.
		     *
		     * **Note:** This method is based on
		     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
		     * @example
		     *
		     * _.isSafeInteger(3);
		     * // => true
		     *
		     * _.isSafeInteger(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isSafeInteger(Infinity);
		     * // => false
		     *
		     * _.isSafeInteger('3');
		     * // => false
		     */
		    function isSafeInteger(value) {
		      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
		    }

		    /**
		     * Checks if `value` is classified as a `Set` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
		     * @example
		     *
		     * _.isSet(new Set);
		     * // => true
		     *
		     * _.isSet(new WeakSet);
		     * // => false
		     */
		    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

		    /**
		     * Checks if `value` is classified as a `String` primitive or object.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
		     * @example
		     *
		     * _.isString('abc');
		     * // => true
		     *
		     * _.isString(1);
		     * // => false
		     */
		    function isString(value) {
		      return typeof value == 'string' ||
		        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
		    }

		    /**
		     * Checks if `value` is classified as a `Symbol` primitive or object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
		     * @example
		     *
		     * _.isSymbol(Symbol.iterator);
		     * // => true
		     *
		     * _.isSymbol('abc');
		     * // => false
		     */
		    function isSymbol(value) {
		      return typeof value == 'symbol' ||
		        (isObjectLike(value) && baseGetTag(value) == symbolTag);
		    }

		    /**
		     * Checks if `value` is classified as a typed array.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
		     * @example
		     *
		     * _.isTypedArray(new Uint8Array);
		     * // => true
		     *
		     * _.isTypedArray([]);
		     * // => false
		     */
		    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

		    /**
		     * Checks if `value` is `undefined`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
		     * @example
		     *
		     * _.isUndefined(void 0);
		     * // => true
		     *
		     * _.isUndefined(null);
		     * // => false
		     */
		    function isUndefined(value) {
		      return value === undefined$1;
		    }

		    /**
		     * Checks if `value` is classified as a `WeakMap` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
		     * @example
		     *
		     * _.isWeakMap(new WeakMap);
		     * // => true
		     *
		     * _.isWeakMap(new Map);
		     * // => false
		     */
		    function isWeakMap(value) {
		      return isObjectLike(value) && getTag(value) == weakMapTag;
		    }

		    /**
		     * Checks if `value` is classified as a `WeakSet` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
		     * @example
		     *
		     * _.isWeakSet(new WeakSet);
		     * // => true
		     *
		     * _.isWeakSet(new Set);
		     * // => false
		     */
		    function isWeakSet(value) {
		      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
		    }

		    /**
		     * Checks if `value` is less than `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than `other`,
		     *  else `false`.
		     * @see _.gt
		     * @example
		     *
		     * _.lt(1, 3);
		     * // => true
		     *
		     * _.lt(3, 3);
		     * // => false
		     *
		     * _.lt(3, 1);
		     * // => false
		     */
		    var lt = createRelationalOperation(baseLt);

		    /**
		     * Checks if `value` is less than or equal to `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than or equal to
		     *  `other`, else `false`.
		     * @see _.gte
		     * @example
		     *
		     * _.lte(1, 3);
		     * // => true
		     *
		     * _.lte(3, 3);
		     * // => true
		     *
		     * _.lte(3, 1);
		     * // => false
		     */
		    var lte = createRelationalOperation(function(value, other) {
		      return value <= other;
		    });

		    /**
		     * Converts `value` to an array.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {Array} Returns the converted array.
		     * @example
		     *
		     * _.toArray({ 'a': 1, 'b': 2 });
		     * // => [1, 2]
		     *
		     * _.toArray('abc');
		     * // => ['a', 'b', 'c']
		     *
		     * _.toArray(1);
		     * // => []
		     *
		     * _.toArray(null);
		     * // => []
		     */
		    function toArray(value) {
		      if (!value) {
		        return [];
		      }
		      if (isArrayLike(value)) {
		        return isString(value) ? stringToArray(value) : copyArray(value);
		      }
		      if (symIterator && value[symIterator]) {
		        return iteratorToArray(value[symIterator]());
		      }
		      var tag = getTag(value),
		          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

		      return func(value);
		    }

		    /**
		     * Converts `value` to a finite number.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.12.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted number.
		     * @example
		     *
		     * _.toFinite(3.2);
		     * // => 3.2
		     *
		     * _.toFinite(Number.MIN_VALUE);
		     * // => 5e-324
		     *
		     * _.toFinite(Infinity);
		     * // => 1.7976931348623157e+308
		     *
		     * _.toFinite('3.2');
		     * // => 3.2
		     */
		    function toFinite(value) {
		      if (!value) {
		        return value === 0 ? value : 0;
		      }
		      value = toNumber(value);
		      if (value === INFINITY || value === -INFINITY) {
		        var sign = (value < 0 ? -1 : 1);
		        return sign * MAX_INTEGER;
		      }
		      return value === value ? value : 0;
		    }

		    /**
		     * Converts `value` to an integer.
		     *
		     * **Note:** This method is loosely based on
		     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toInteger(3.2);
		     * // => 3
		     *
		     * _.toInteger(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toInteger(Infinity);
		     * // => 1.7976931348623157e+308
		     *
		     * _.toInteger('3.2');
		     * // => 3
		     */
		    function toInteger(value) {
		      var result = toFinite(value),
		          remainder = result % 1;

		      return result === result ? (remainder ? result - remainder : result) : 0;
		    }

		    /**
		     * Converts `value` to an integer suitable for use as the length of an
		     * array-like object.
		     *
		     * **Note:** This method is based on
		     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toLength(3.2);
		     * // => 3
		     *
		     * _.toLength(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toLength(Infinity);
		     * // => 4294967295
		     *
		     * _.toLength('3.2');
		     * // => 3
		     */
		    function toLength(value) {
		      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
		    }

		    /**
		     * Converts `value` to a number.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to process.
		     * @returns {number} Returns the number.
		     * @example
		     *
		     * _.toNumber(3.2);
		     * // => 3.2
		     *
		     * _.toNumber(Number.MIN_VALUE);
		     * // => 5e-324
		     *
		     * _.toNumber(Infinity);
		     * // => Infinity
		     *
		     * _.toNumber('3.2');
		     * // => 3.2
		     */
		    function toNumber(value) {
		      if (typeof value == 'number') {
		        return value;
		      }
		      if (isSymbol(value)) {
		        return NAN;
		      }
		      if (isObject(value)) {
		        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
		        value = isObject(other) ? (other + '') : other;
		      }
		      if (typeof value != 'string') {
		        return value === 0 ? value : +value;
		      }
		      value = baseTrim(value);
		      var isBinary = reIsBinary.test(value);
		      return (isBinary || reIsOctal.test(value))
		        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
		        : (reIsBadHex.test(value) ? NAN : +value);
		    }

		    /**
		     * Converts `value` to a plain object flattening inherited enumerable string
		     * keyed properties of `value` to own properties of the plain object.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {Object} Returns the converted plain object.
		     * @example
		     *
		     * function Foo() {
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.assign({ 'a': 1 }, new Foo);
		     * // => { 'a': 1, 'b': 2 }
		     *
		     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
		     * // => { 'a': 1, 'b': 2, 'c': 3 }
		     */
		    function toPlainObject(value) {
		      return copyObject(value, keysIn(value));
		    }

		    /**
		     * Converts `value` to a safe integer. A safe integer can be compared and
		     * represented correctly.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toSafeInteger(3.2);
		     * // => 3
		     *
		     * _.toSafeInteger(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toSafeInteger(Infinity);
		     * // => 9007199254740991
		     *
		     * _.toSafeInteger('3.2');
		     * // => 3
		     */
		    function toSafeInteger(value) {
		      return value
		        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
		        : (value === 0 ? value : 0);
		    }

		    /**
		     * Converts `value` to a string. An empty string is returned for `null`
		     * and `undefined` values. The sign of `-0` is preserved.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.toString(null);
		     * // => ''
		     *
		     * _.toString(-0);
		     * // => '-0'
		     *
		     * _.toString([1, 2, 3]);
		     * // => '1,2,3'
		     */
		    function toString(value) {
		      return value == null ? '' : baseToString(value);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Assigns own enumerable string keyed properties of source objects to the
		     * destination object. Source objects are applied from left to right.
		     * Subsequent sources overwrite property assignments of previous sources.
		     *
		     * **Note:** This method mutates `object` and is loosely based on
		     * [`Object.assign`](https://mdn.io/Object/assign).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.10.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.assignIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * function Bar() {
		     *   this.c = 3;
		     * }
		     *
		     * Foo.prototype.b = 2;
		     * Bar.prototype.d = 4;
		     *
		     * _.assign({ 'a': 0 }, new Foo, new Bar);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    var assign = createAssigner(function(object, source) {
		      if (isPrototype(source) || isArrayLike(source)) {
		        copyObject(source, keys(source), object);
		        return;
		      }
		      for (var key in source) {
		        if (hasOwnProperty.call(source, key)) {
		          assignValue(object, key, source[key]);
		        }
		      }
		    });

		    /**
		     * This method is like `_.assign` except that it iterates over own and
		     * inherited source properties.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias extend
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.assign
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * function Bar() {
		     *   this.c = 3;
		     * }
		     *
		     * Foo.prototype.b = 2;
		     * Bar.prototype.d = 4;
		     *
		     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
		     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
		     */
		    var assignIn = createAssigner(function(object, source) {
		      copyObject(source, keysIn(source), object);
		    });

		    /**
		     * This method is like `_.assignIn` except that it accepts `customizer`
		     * which is invoked to produce the assigned values. If `customizer` returns
		     * `undefined`, assignment is handled by the method instead. The `customizer`
		     * is invoked with five arguments: (objValue, srcValue, key, object, source).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias extendWith
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @see _.assignWith
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   return _.isUndefined(objValue) ? srcValue : objValue;
		     * }
		     *
		     * var defaults = _.partialRight(_.assignInWith, customizer);
		     *
		     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
		      copyObject(source, keysIn(source), object, customizer);
		    });

		    /**
		     * This method is like `_.assign` except that it accepts `customizer`
		     * which is invoked to produce the assigned values. If `customizer` returns
		     * `undefined`, assignment is handled by the method instead. The `customizer`
		     * is invoked with five arguments: (objValue, srcValue, key, object, source).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @see _.assignInWith
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   return _.isUndefined(objValue) ? srcValue : objValue;
		     * }
		     *
		     * var defaults = _.partialRight(_.assignWith, customizer);
		     *
		     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
		      copyObject(source, keys(source), object, customizer);
		    });

		    /**
		     * Creates an array of values corresponding to `paths` of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Array} Returns the picked values.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
		     *
		     * _.at(object, ['a[0].b.c', 'a[1]']);
		     * // => [3, 4]
		     */
		    var at = flatRest(baseAt);

		    /**
		     * Creates an object that inherits from the `prototype` object. If a
		     * `properties` object is given, its own enumerable string keyed properties
		     * are assigned to the created object.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.3.0
		     * @category Object
		     * @param {Object} prototype The object to inherit from.
		     * @param {Object} [properties] The properties to assign to the object.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * function Shape() {
		     *   this.x = 0;
		     *   this.y = 0;
		     * }
		     *
		     * function Circle() {
		     *   Shape.call(this);
		     * }
		     *
		     * Circle.prototype = _.create(Shape.prototype, {
		     *   'constructor': Circle
		     * });
		     *
		     * var circle = new Circle;
		     * circle instanceof Circle;
		     * // => true
		     *
		     * circle instanceof Shape;
		     * // => true
		     */
		    function create(prototype, properties) {
		      var result = baseCreate(prototype);
		      return properties == null ? result : baseAssign(result, properties);
		    }

		    /**
		     * Assigns own and inherited enumerable string keyed properties of source
		     * objects to the destination object for all destination properties that
		     * resolve to `undefined`. Source objects are applied from left to right.
		     * Once a property is set, additional values of the same property are ignored.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.defaultsDeep
		     * @example
		     *
		     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var defaults = baseRest(function(object, sources) {
		      object = Object(object);

		      var index = -1;
		      var length = sources.length;
		      var guard = length > 2 ? sources[2] : undefined$1;

		      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
		        length = 1;
		      }

		      while (++index < length) {
		        var source = sources[index];
		        var props = keysIn(source);
		        var propsIndex = -1;
		        var propsLength = props.length;

		        while (++propsIndex < propsLength) {
		          var key = props[propsIndex];
		          var value = object[key];

		          if (value === undefined$1 ||
		              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
		            object[key] = source[key];
		          }
		        }
		      }

		      return object;
		    });

		    /**
		     * This method is like `_.defaults` except that it recursively assigns
		     * default properties.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.defaults
		     * @example
		     *
		     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
		     * // => { 'a': { 'b': 2, 'c': 3 } }
		     */
		    var defaultsDeep = baseRest(function(args) {
		      args.push(undefined$1, customDefaultsMerge);
		      return apply(mergeWith, undefined$1, args);
		    });

		    /**
		     * This method is like `_.find` except that it returns the key of the first
		     * element `predicate` returns truthy for instead of the element itself.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {string|undefined} Returns the key of the matched element,
		     *  else `undefined`.
		     * @example
		     *
		     * var users = {
		     *   'barney':  { 'age': 36, 'active': true },
		     *   'fred':    { 'age': 40, 'active': false },
		     *   'pebbles': { 'age': 1,  'active': true }
		     * };
		     *
		     * _.findKey(users, function(o) { return o.age < 40; });
		     * // => 'barney' (iteration order is not guaranteed)
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findKey(users, { 'age': 1, 'active': true });
		     * // => 'pebbles'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findKey(users, ['active', false]);
		     * // => 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findKey(users, 'active');
		     * // => 'barney'
		     */
		    function findKey(object, predicate) {
		      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
		    }

		    /**
		     * This method is like `_.findKey` except that it iterates over elements of
		     * a collection in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {string|undefined} Returns the key of the matched element,
		     *  else `undefined`.
		     * @example
		     *
		     * var users = {
		     *   'barney':  { 'age': 36, 'active': true },
		     *   'fred':    { 'age': 40, 'active': false },
		     *   'pebbles': { 'age': 1,  'active': true }
		     * };
		     *
		     * _.findLastKey(users, function(o) { return o.age < 40; });
		     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findLastKey(users, { 'age': 36, 'active': true });
		     * // => 'barney'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findLastKey(users, ['active', false]);
		     * // => 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findLastKey(users, 'active');
		     * // => 'pebbles'
		     */
		    function findLastKey(object, predicate) {
		      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
		    }

		    /**
		     * Iterates over own and inherited enumerable string keyed properties of an
		     * object and invokes `iteratee` for each property. The iteratee is invoked
		     * with three arguments: (value, key, object). Iteratee functions may exit
		     * iteration early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forInRight
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forIn(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
		     */
		    function forIn(object, iteratee) {
		      return object == null
		        ? object
		        : baseFor(object, getIteratee(iteratee, 3), keysIn);
		    }

		    /**
		     * This method is like `_.forIn` except that it iterates over properties of
		     * `object` in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forInRight(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
		     */
		    function forInRight(object, iteratee) {
		      return object == null
		        ? object
		        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
		    }

		    /**
		     * Iterates over own enumerable string keyed properties of an object and
		     * invokes `iteratee` for each property. The iteratee is invoked with three
		     * arguments: (value, key, object). Iteratee functions may exit iteration
		     * early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forOwnRight
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forOwn(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
		     */
		    function forOwn(object, iteratee) {
		      return object && baseForOwn(object, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.forOwn` except that it iterates over properties of
		     * `object` in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forOwn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forOwnRight(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
		     */
		    function forOwnRight(object, iteratee) {
		      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
		    }

		    /**
		     * Creates an array of function property names from own enumerable properties
		     * of `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns the function names.
		     * @see _.functionsIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = _.constant('a');
		     *   this.b = _.constant('b');
		     * }
		     *
		     * Foo.prototype.c = _.constant('c');
		     *
		     * _.functions(new Foo);
		     * // => ['a', 'b']
		     */
		    function functions(object) {
		      return object == null ? [] : baseFunctions(object, keys(object));
		    }

		    /**
		     * Creates an array of function property names from own and inherited
		     * enumerable properties of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns the function names.
		     * @see _.functions
		     * @example
		     *
		     * function Foo() {
		     *   this.a = _.constant('a');
		     *   this.b = _.constant('b');
		     * }
		     *
		     * Foo.prototype.c = _.constant('c');
		     *
		     * _.functionsIn(new Foo);
		     * // => ['a', 'b', 'c']
		     */
		    function functionsIn(object) {
		      return object == null ? [] : baseFunctions(object, keysIn(object));
		    }

		    /**
		     * Gets the value at `path` of `object`. If the resolved value is
		     * `undefined`, the `defaultValue` is returned in its place.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to get.
		     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.get(object, 'a[0].b.c');
		     * // => 3
		     *
		     * _.get(object, ['a', '0', 'b', 'c']);
		     * // => 3
		     *
		     * _.get(object, 'a.b.c', 'default');
		     * // => 'default'
		     */
		    function get(object, path, defaultValue) {
		      var result = object == null ? undefined$1 : baseGet(object, path);
		      return result === undefined$1 ? defaultValue : result;
		    }

		    /**
		     * Checks if `path` is a direct property of `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     * @example
		     *
		     * var object = { 'a': { 'b': 2 } };
		     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
		     *
		     * _.has(object, 'a');
		     * // => true
		     *
		     * _.has(object, 'a.b');
		     * // => true
		     *
		     * _.has(object, ['a', 'b']);
		     * // => true
		     *
		     * _.has(other, 'a');
		     * // => false
		     */
		    function has(object, path) {
		      return object != null && hasPath(object, path, baseHas);
		    }

		    /**
		     * Checks if `path` is a direct or inherited property of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     * @example
		     *
		     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
		     *
		     * _.hasIn(object, 'a');
		     * // => true
		     *
		     * _.hasIn(object, 'a.b');
		     * // => true
		     *
		     * _.hasIn(object, ['a', 'b']);
		     * // => true
		     *
		     * _.hasIn(object, 'b');
		     * // => false
		     */
		    function hasIn(object, path) {
		      return object != null && hasPath(object, path, baseHasIn);
		    }

		    /**
		     * Creates an object composed of the inverted keys and values of `object`.
		     * If `object` contains duplicate values, subsequent values overwrite
		     * property assignments of previous values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.7.0
		     * @category Object
		     * @param {Object} object The object to invert.
		     * @returns {Object} Returns the new inverted object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2, 'c': 1 };
		     *
		     * _.invert(object);
		     * // => { '1': 'c', '2': 'b' }
		     */
		    var invert = createInverter(function(result, value, key) {
		      if (value != null &&
		          typeof value.toString != 'function') {
		        value = nativeObjectToString.call(value);
		      }

		      result[value] = key;
		    }, constant(identity));

		    /**
		     * This method is like `_.invert` except that the inverted object is generated
		     * from the results of running each element of `object` thru `iteratee`. The
		     * corresponding inverted value of each inverted key is an array of keys
		     * responsible for generating the inverted value. The iteratee is invoked
		     * with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.1.0
		     * @category Object
		     * @param {Object} object The object to invert.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Object} Returns the new inverted object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2, 'c': 1 };
		     *
		     * _.invertBy(object);
		     * // => { '1': ['a', 'c'], '2': ['b'] }
		     *
		     * _.invertBy(object, function(value) {
		     *   return 'group' + value;
		     * });
		     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
		     */
		    var invertBy = createInverter(function(result, value, key) {
		      if (value != null &&
		          typeof value.toString != 'function') {
		        value = nativeObjectToString.call(value);
		      }

		      if (hasOwnProperty.call(result, value)) {
		        result[value].push(key);
		      } else {
		        result[value] = [key];
		      }
		    }, getIteratee);

		    /**
		     * Invokes the method at `path` of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {*} Returns the result of the invoked method.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
		     *
		     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
		     * // => [2, 3]
		     */
		    var invoke = baseRest(baseInvoke);

		    /**
		     * Creates an array of the own enumerable property names of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects. See the
		     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
		     * for more details.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.keys(new Foo);
		     * // => ['a', 'b'] (iteration order is not guaranteed)
		     *
		     * _.keys('hi');
		     * // => ['0', '1']
		     */
		    function keys(object) {
		      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
		    }

		    /**
		     * Creates an array of the own and inherited enumerable property names of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.keysIn(new Foo);
		     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
		     */
		    function keysIn(object) {
		      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
		    }

		    /**
		     * The opposite of `_.mapValues`; this method creates an object with the
		     * same values as `object` and keys generated by running each own enumerable
		     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
		     * with three arguments: (value, key, object).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns the new mapped object.
		     * @see _.mapValues
		     * @example
		     *
		     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
		     *   return key + value;
		     * });
		     * // => { 'a1': 1, 'b2': 2 }
		     */
		    function mapKeys(object, iteratee) {
		      var result = {};
		      iteratee = getIteratee(iteratee, 3);

		      baseForOwn(object, function(value, key, object) {
		        baseAssignValue(result, iteratee(value, key, object), value);
		      });
		      return result;
		    }

		    /**
		     * Creates an object with the same keys as `object` and values generated
		     * by running each own enumerable string keyed property of `object` thru
		     * `iteratee`. The iteratee is invoked with three arguments:
		     * (value, key, object).
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns the new mapped object.
		     * @see _.mapKeys
		     * @example
		     *
		     * var users = {
		     *   'fred':    { 'user': 'fred',    'age': 40 },
		     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
		     * };
		     *
		     * _.mapValues(users, function(o) { return o.age; });
		     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.mapValues(users, 'age');
		     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
		     */
		    function mapValues(object, iteratee) {
		      var result = {};
		      iteratee = getIteratee(iteratee, 3);

		      baseForOwn(object, function(value, key, object) {
		        baseAssignValue(result, key, iteratee(value, key, object));
		      });
		      return result;
		    }

		    /**
		     * This method is like `_.assign` except that it recursively merges own and
		     * inherited enumerable string keyed properties of source objects into the
		     * destination object. Source properties that resolve to `undefined` are
		     * skipped if a destination value exists. Array and plain object properties
		     * are merged recursively. Other objects and value types are overridden by
		     * assignment. Source objects are applied from left to right. Subsequent
		     * sources overwrite property assignments of previous sources.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {
		     *   'a': [{ 'b': 2 }, { 'd': 4 }]
		     * };
		     *
		     * var other = {
		     *   'a': [{ 'c': 3 }, { 'e': 5 }]
		     * };
		     *
		     * _.merge(object, other);
		     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
		     */
		    var merge = createAssigner(function(object, source, srcIndex) {
		      baseMerge(object, source, srcIndex);
		    });

		    /**
		     * This method is like `_.merge` except that it accepts `customizer` which
		     * is invoked to produce the merged values of the destination and source
		     * properties. If `customizer` returns `undefined`, merging is handled by the
		     * method instead. The `customizer` is invoked with six arguments:
		     * (objValue, srcValue, key, object, source, stack).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} customizer The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   if (_.isArray(objValue)) {
		     *     return objValue.concat(srcValue);
		     *   }
		     * }
		     *
		     * var object = { 'a': [1], 'b': [2] };
		     * var other = { 'a': [3], 'b': [4] };
		     *
		     * _.mergeWith(object, other, customizer);
		     * // => { 'a': [1, 3], 'b': [2, 4] }
		     */
		    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
		      baseMerge(object, source, srcIndex, customizer);
		    });

		    /**
		     * The opposite of `_.pick`; this method creates an object composed of the
		     * own and inherited enumerable property paths of `object` that are not omitted.
		     *
		     * **Note:** This method is considerably slower than `_.pick`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {...(string|string[])} [paths] The property paths to omit.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.omit(object, ['a', 'c']);
		     * // => { 'b': '2' }
		     */
		    var omit = flatRest(function(object, paths) {
		      var result = {};
		      if (object == null) {
		        return result;
		      }
		      var isDeep = false;
		      paths = arrayMap(paths, function(path) {
		        path = castPath(path, object);
		        isDeep || (isDeep = path.length > 1);
		        return path;
		      });
		      copyObject(object, getAllKeysIn(object), result);
		      if (isDeep) {
		        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
		      }
		      var length = paths.length;
		      while (length--) {
		        baseUnset(result, paths[length]);
		      }
		      return result;
		    });

		    /**
		     * The opposite of `_.pickBy`; this method creates an object composed of
		     * the own and inherited enumerable string keyed properties of `object` that
		     * `predicate` doesn't return truthy for. The predicate is invoked with two
		     * arguments: (value, key).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {Function} [predicate=_.identity] The function invoked per property.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.omitBy(object, _.isNumber);
		     * // => { 'b': '2' }
		     */
		    function omitBy(object, predicate) {
		      return pickBy(object, negate(getIteratee(predicate)));
		    }

		    /**
		     * Creates an object composed of the picked `object` properties.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.pick(object, ['a', 'c']);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    var pick = flatRest(function(object, paths) {
		      return object == null ? {} : basePick(object, paths);
		    });

		    /**
		     * Creates an object composed of the `object` properties `predicate` returns
		     * truthy for. The predicate is invoked with two arguments: (value, key).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {Function} [predicate=_.identity] The function invoked per property.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.pickBy(object, _.isNumber);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    function pickBy(object, predicate) {
		      if (object == null) {
		        return {};
		      }
		      var props = arrayMap(getAllKeysIn(object), function(prop) {
		        return [prop];
		      });
		      predicate = getIteratee(predicate);
		      return basePickBy(object, props, function(value, path) {
		        return predicate(value, path[0]);
		      });
		    }

		    /**
		     * This method is like `_.get` except that if the resolved value is a
		     * function it's invoked with the `this` binding of its parent object and
		     * its result is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to resolve.
		     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
		     *
		     * _.result(object, 'a[0].b.c1');
		     * // => 3
		     *
		     * _.result(object, 'a[0].b.c2');
		     * // => 4
		     *
		     * _.result(object, 'a[0].b.c3', 'default');
		     * // => 'default'
		     *
		     * _.result(object, 'a[0].b.c3', _.constant('default'));
		     * // => 'default'
		     */
		    function result(object, path, defaultValue) {
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length;

		      // Ensure the loop is entered when path is empty.
		      if (!length) {
		        length = 1;
		        object = undefined$1;
		      }
		      while (++index < length) {
		        var value = object == null ? undefined$1 : object[toKey(path[index])];
		        if (value === undefined$1) {
		          index = length;
		          value = defaultValue;
		        }
		        object = isFunction(value) ? value.call(object) : value;
		      }
		      return object;
		    }

		    /**
		     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
		     * it's created. Arrays are created for missing index properties while objects
		     * are created for all other missing properties. Use `_.setWith` to customize
		     * `path` creation.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.set(object, 'a[0].b.c', 4);
		     * console.log(object.a[0].b.c);
		     * // => 4
		     *
		     * _.set(object, ['x', '0', 'y', 'z'], 5);
		     * console.log(object.x[0].y.z);
		     * // => 5
		     */
		    function set(object, path, value) {
		      return object == null ? object : baseSet(object, path, value);
		    }

		    /**
		     * This method is like `_.set` except that it accepts `customizer` which is
		     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
		     * path creation is handled by the method instead. The `customizer` is invoked
		     * with three arguments: (nsValue, key, nsObject).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {};
		     *
		     * _.setWith(object, '[0][1]', 'a', Object);
		     * // => { '0': { '1': 'a' } }
		     */
		    function setWith(object, path, value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return object == null ? object : baseSet(object, path, value, customizer);
		    }

		    /**
		     * Creates an array of own enumerable string keyed-value pairs for `object`
		     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
		     * entries are returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias entries
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the key-value pairs.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.toPairs(new Foo);
		     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
		     */
		    var toPairs = createToPairs(keys);

		    /**
		     * Creates an array of own and inherited enumerable string keyed-value pairs
		     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
		     * or set, its entries are returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias entriesIn
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the key-value pairs.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.toPairsIn(new Foo);
		     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
		     */
		    var toPairsIn = createToPairs(keysIn);

		    /**
		     * An alternative to `_.reduce`; this method transforms `object` to a new
		     * `accumulator` object which is the result of running each of its own
		     * enumerable string keyed properties thru `iteratee`, with each invocation
		     * potentially mutating the `accumulator` object. If `accumulator` is not
		     * provided, a new object with the same `[[Prototype]]` will be used. The
		     * iteratee is invoked with four arguments: (accumulator, value, key, object).
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The custom accumulator value.
		     * @returns {*} Returns the accumulated value.
		     * @example
		     *
		     * _.transform([2, 3, 4], function(result, n) {
		     *   result.push(n *= n);
		     *   return n % 2 == 0;
		     * }, []);
		     * // => [4, 9]
		     *
		     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
		     *   (result[value] || (result[value] = [])).push(key);
		     * }, {});
		     * // => { '1': ['a', 'c'], '2': ['b'] }
		     */
		    function transform(object, iteratee, accumulator) {
		      var isArr = isArray(object),
		          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

		      iteratee = getIteratee(iteratee, 4);
		      if (accumulator == null) {
		        var Ctor = object && object.constructor;
		        if (isArrLike) {
		          accumulator = isArr ? new Ctor : [];
		        }
		        else if (isObject(object)) {
		          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
		        }
		        else {
		          accumulator = {};
		        }
		      }
		      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
		        return iteratee(accumulator, value, index, object);
		      });
		      return accumulator;
		    }

		    /**
		     * Removes the property at `path` of `object`.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to unset.
		     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
		     * _.unset(object, 'a[0].b.c');
		     * // => true
		     *
		     * console.log(object);
		     * // => { 'a': [{ 'b': {} }] };
		     *
		     * _.unset(object, ['a', '0', 'b', 'c']);
		     * // => true
		     *
		     * console.log(object);
		     * // => { 'a': [{ 'b': {} }] };
		     */
		    function unset(object, path) {
		      return object == null ? true : baseUnset(object, path);
		    }

		    /**
		     * This method is like `_.set` except that accepts `updater` to produce the
		     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
		     * is invoked with one argument: (value).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {Function} updater The function to produce the updated value.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
		     * console.log(object.a[0].b.c);
		     * // => 9
		     *
		     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
		     * console.log(object.x[0].y.z);
		     * // => 0
		     */
		    function update(object, path, updater) {
		      return object == null ? object : baseUpdate(object, path, castFunction(updater));
		    }

		    /**
		     * This method is like `_.update` except that it accepts `customizer` which is
		     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
		     * path creation is handled by the method instead. The `customizer` is invoked
		     * with three arguments: (nsValue, key, nsObject).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {Function} updater The function to produce the updated value.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {};
		     *
		     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
		     * // => { '0': { '1': 'a' } }
		     */
		    function updateWith(object, path, updater, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
		    }

		    /**
		     * Creates an array of the own enumerable string keyed property values of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property values.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.values(new Foo);
		     * // => [1, 2] (iteration order is not guaranteed)
		     *
		     * _.values('hi');
		     * // => ['h', 'i']
		     */
		    function values(object) {
		      return object == null ? [] : baseValues(object, keys(object));
		    }

		    /**
		     * Creates an array of the own and inherited enumerable string keyed property
		     * values of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property values.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.valuesIn(new Foo);
		     * // => [1, 2, 3] (iteration order is not guaranteed)
		     */
		    function valuesIn(object) {
		      return object == null ? [] : baseValues(object, keysIn(object));
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Clamps `number` within the inclusive `lower` and `upper` bounds.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Number
		     * @param {number} number The number to clamp.
		     * @param {number} [lower] The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the clamped number.
		     * @example
		     *
		     * _.clamp(-10, -5, 5);
		     * // => -5
		     *
		     * _.clamp(10, -5, 5);
		     * // => 5
		     */
		    function clamp(number, lower, upper) {
		      if (upper === undefined$1) {
		        upper = lower;
		        lower = undefined$1;
		      }
		      if (upper !== undefined$1) {
		        upper = toNumber(upper);
		        upper = upper === upper ? upper : 0;
		      }
		      if (lower !== undefined$1) {
		        lower = toNumber(lower);
		        lower = lower === lower ? lower : 0;
		      }
		      return baseClamp(toNumber(number), lower, upper);
		    }

		    /**
		     * Checks if `n` is between `start` and up to, but not including, `end`. If
		     * `end` is not specified, it's set to `start` with `start` then set to `0`.
		     * If `start` is greater than `end` the params are swapped to support
		     * negative ranges.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.3.0
		     * @category Number
		     * @param {number} number The number to check.
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
		     * @see _.range, _.rangeRight
		     * @example
		     *
		     * _.inRange(3, 2, 4);
		     * // => true
		     *
		     * _.inRange(4, 8);
		     * // => true
		     *
		     * _.inRange(4, 2);
		     * // => false
		     *
		     * _.inRange(2, 2);
		     * // => false
		     *
		     * _.inRange(1.2, 2);
		     * // => true
		     *
		     * _.inRange(5.2, 4);
		     * // => false
		     *
		     * _.inRange(-3, -2, -6);
		     * // => true
		     */
		    function inRange(number, start, end) {
		      start = toFinite(start);
		      if (end === undefined$1) {
		        end = start;
		        start = 0;
		      } else {
		        end = toFinite(end);
		      }
		      number = toNumber(number);
		      return baseInRange(number, start, end);
		    }

		    /**
		     * Produces a random number between the inclusive `lower` and `upper` bounds.
		     * If only one argument is provided a number between `0` and the given number
		     * is returned. If `floating` is `true`, or either `lower` or `upper` are
		     * floats, a floating-point number is returned instead of an integer.
		     *
		     * **Note:** JavaScript follows the IEEE-754 standard for resolving
		     * floating-point values which can produce unexpected results.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.7.0
		     * @category Number
		     * @param {number} [lower=0] The lower bound.
		     * @param {number} [upper=1] The upper bound.
		     * @param {boolean} [floating] Specify returning a floating-point number.
		     * @returns {number} Returns the random number.
		     * @example
		     *
		     * _.random(0, 5);
		     * // => an integer between 0 and 5
		     *
		     * _.random(5);
		     * // => also an integer between 0 and 5
		     *
		     * _.random(5, true);
		     * // => a floating-point number between 0 and 5
		     *
		     * _.random(1.2, 5.2);
		     * // => a floating-point number between 1.2 and 5.2
		     */
		    function random(lower, upper, floating) {
		      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
		        upper = floating = undefined$1;
		      }
		      if (floating === undefined$1) {
		        if (typeof upper == 'boolean') {
		          floating = upper;
		          upper = undefined$1;
		        }
		        else if (typeof lower == 'boolean') {
		          floating = lower;
		          lower = undefined$1;
		        }
		      }
		      if (lower === undefined$1 && upper === undefined$1) {
		        lower = 0;
		        upper = 1;
		      }
		      else {
		        lower = toFinite(lower);
		        if (upper === undefined$1) {
		          upper = lower;
		          lower = 0;
		        } else {
		          upper = toFinite(upper);
		        }
		      }
		      if (lower > upper) {
		        var temp = lower;
		        lower = upper;
		        upper = temp;
		      }
		      if (floating || lower % 1 || upper % 1) {
		        var rand = nativeRandom();
		        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
		      }
		      return baseRandom(lower, upper);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the camel cased string.
		     * @example
		     *
		     * _.camelCase('Foo Bar');
		     * // => 'fooBar'
		     *
		     * _.camelCase('--foo-bar--');
		     * // => 'fooBar'
		     *
		     * _.camelCase('__FOO_BAR__');
		     * // => 'fooBar'
		     */
		    var camelCase = createCompounder(function(result, word, index) {
		      word = word.toLowerCase();
		      return result + (index ? capitalize(word) : word);
		    });

		    /**
		     * Converts the first character of `string` to upper case and the remaining
		     * to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to capitalize.
		     * @returns {string} Returns the capitalized string.
		     * @example
		     *
		     * _.capitalize('FRED');
		     * // => 'Fred'
		     */
		    function capitalize(string) {
		      return upperFirst(toString(string).toLowerCase());
		    }

		    /**
		     * Deburrs `string` by converting
		     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
		     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
		     * letters to basic Latin letters and removing
		     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to deburr.
		     * @returns {string} Returns the deburred string.
		     * @example
		     *
		     * _.deburr('dj vu');
		     * // => 'deja vu'
		     */
		    function deburr(string) {
		      string = toString(string);
		      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
		    }

		    /**
		     * Checks if `string` ends with the given target string.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {string} [target] The string to search for.
		     * @param {number} [position=string.length] The position to search up to.
		     * @returns {boolean} Returns `true` if `string` ends with `target`,
		     *  else `false`.
		     * @example
		     *
		     * _.endsWith('abc', 'c');
		     * // => true
		     *
		     * _.endsWith('abc', 'b');
		     * // => false
		     *
		     * _.endsWith('abc', 'b', 2);
		     * // => true
		     */
		    function endsWith(string, target, position) {
		      string = toString(string);
		      target = baseToString(target);

		      var length = string.length;
		      position = position === undefined$1
		        ? length
		        : baseClamp(toInteger(position), 0, length);

		      var end = position;
		      position -= target.length;
		      return position >= 0 && string.slice(position, end) == target;
		    }

		    /**
		     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
		     * corresponding HTML entities.
		     *
		     * **Note:** No other characters are escaped. To escape additional
		     * characters use a third-party library like [_he_](https://mths.be/he).
		     *
		     * Though the ">" character is escaped for symmetry, characters like
		     * ">" and "/" don't need escaping in HTML and have no special meaning
		     * unless they're part of a tag or unquoted attribute value. See
		     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
		     * (under "semi-related fun fact") for more details.
		     *
		     * When working with HTML you should always
		     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
		     * XSS vectors.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category String
		     * @param {string} [string=''] The string to escape.
		     * @returns {string} Returns the escaped string.
		     * @example
		     *
		     * _.escape('fred, barney, & pebbles');
		     * // => 'fred, barney, &amp; pebbles'
		     */
		    function escape(string) {
		      string = toString(string);
		      return (string && reHasUnescapedHtml.test(string))
		        ? string.replace(reUnescapedHtml, escapeHtmlChar)
		        : string;
		    }

		    /**
		     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
		     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to escape.
		     * @returns {string} Returns the escaped string.
		     * @example
		     *
		     * _.escapeRegExp('[lodash](https://lodash.com/)');
		     * // => '\[lodash\]\(https://lodash\.com/\)'
		     */
		    function escapeRegExp(string) {
		      string = toString(string);
		      return (string && reHasRegExpChar.test(string))
		        ? string.replace(reRegExpChar, '\\$&')
		        : string;
		    }

		    /**
		     * Converts `string` to
		     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the kebab cased string.
		     * @example
		     *
		     * _.kebabCase('Foo Bar');
		     * // => 'foo-bar'
		     *
		     * _.kebabCase('fooBar');
		     * // => 'foo-bar'
		     *
		     * _.kebabCase('__FOO_BAR__');
		     * // => 'foo-bar'
		     */
		    var kebabCase = createCompounder(function(result, word, index) {
		      return result + (index ? '-' : '') + word.toLowerCase();
		    });

		    /**
		     * Converts `string`, as space separated words, to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the lower cased string.
		     * @example
		     *
		     * _.lowerCase('--Foo-Bar--');
		     * // => 'foo bar'
		     *
		     * _.lowerCase('fooBar');
		     * // => 'foo bar'
		     *
		     * _.lowerCase('__FOO_BAR__');
		     * // => 'foo bar'
		     */
		    var lowerCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + word.toLowerCase();
		    });

		    /**
		     * Converts the first character of `string` to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.lowerFirst('Fred');
		     * // => 'fred'
		     *
		     * _.lowerFirst('FRED');
		     * // => 'fRED'
		     */
		    var lowerFirst = createCaseFirst('toLowerCase');

		    /**
		     * Pads `string` on the left and right sides if it's shorter than `length`.
		     * Padding characters are truncated if they can't be evenly divided by `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.pad('abc', 8);
		     * // => '  abc   '
		     *
		     * _.pad('abc', 8, '_-');
		     * // => '_-abc_-_'
		     *
		     * _.pad('abc', 3);
		     * // => 'abc'
		     */
		    function pad(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      if (!length || strLength >= length) {
		        return string;
		      }
		      var mid = (length - strLength) / 2;
		      return (
		        createPadding(nativeFloor(mid), chars) +
		        string +
		        createPadding(nativeCeil(mid), chars)
		      );
		    }

		    /**
		     * Pads `string` on the right side if it's shorter than `length`. Padding
		     * characters are truncated if they exceed `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.padEnd('abc', 6);
		     * // => 'abc   '
		     *
		     * _.padEnd('abc', 6, '_-');
		     * // => 'abc_-_'
		     *
		     * _.padEnd('abc', 3);
		     * // => 'abc'
		     */
		    function padEnd(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      return (length && strLength < length)
		        ? (string + createPadding(length - strLength, chars))
		        : string;
		    }

		    /**
		     * Pads `string` on the left side if it's shorter than `length`. Padding
		     * characters are truncated if they exceed `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.padStart('abc', 6);
		     * // => '   abc'
		     *
		     * _.padStart('abc', 6, '_-');
		     * // => '_-_abc'
		     *
		     * _.padStart('abc', 3);
		     * // => 'abc'
		     */
		    function padStart(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      return (length && strLength < length)
		        ? (createPadding(length - strLength, chars) + string)
		        : string;
		    }

		    /**
		     * Converts `string` to an integer of the specified radix. If `radix` is
		     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
		     * hexadecimal, in which case a `radix` of `16` is used.
		     *
		     * **Note:** This method aligns with the
		     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category String
		     * @param {string} string The string to convert.
		     * @param {number} [radix=10] The radix to interpret `value` by.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.parseInt('08');
		     * // => 8
		     *
		     * _.map(['6', '08', '10'], _.parseInt);
		     * // => [6, 8, 10]
		     */
		    function parseInt(string, radix, guard) {
		      if (guard || radix == null) {
		        radix = 0;
		      } else if (radix) {
		        radix = +radix;
		      }
		      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
		    }

		    /**
		     * Repeats the given string `n` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to repeat.
		     * @param {number} [n=1] The number of times to repeat the string.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the repeated string.
		     * @example
		     *
		     * _.repeat('*', 3);
		     * // => '***'
		     *
		     * _.repeat('abc', 2);
		     * // => 'abcabc'
		     *
		     * _.repeat('abc', 0);
		     * // => ''
		     */
		    function repeat(string, n, guard) {
		      if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
		        n = 1;
		      } else {
		        n = toInteger(n);
		      }
		      return baseRepeat(toString(string), n);
		    }

		    /**
		     * Replaces matches for `pattern` in `string` with `replacement`.
		     *
		     * **Note:** This method is based on
		     * [`String#replace`](https://mdn.io/String/replace).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to modify.
		     * @param {RegExp|string} pattern The pattern to replace.
		     * @param {Function|string} replacement The match replacement.
		     * @returns {string} Returns the modified string.
		     * @example
		     *
		     * _.replace('Hi Fred', 'Fred', 'Barney');
		     * // => 'Hi Barney'
		     */
		    function replace() {
		      var args = arguments,
		          string = toString(args[0]);

		      return args.length < 3 ? string : string.replace(args[1], args[2]);
		    }

		    /**
		     * Converts `string` to
		     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the snake cased string.
		     * @example
		     *
		     * _.snakeCase('Foo Bar');
		     * // => 'foo_bar'
		     *
		     * _.snakeCase('fooBar');
		     * // => 'foo_bar'
		     *
		     * _.snakeCase('--FOO-BAR--');
		     * // => 'foo_bar'
		     */
		    var snakeCase = createCompounder(function(result, word, index) {
		      return result + (index ? '_' : '') + word.toLowerCase();
		    });

		    /**
		     * Splits `string` by `separator`.
		     *
		     * **Note:** This method is based on
		     * [`String#split`](https://mdn.io/String/split).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to split.
		     * @param {RegExp|string} separator The separator pattern to split by.
		     * @param {number} [limit] The length to truncate results to.
		     * @returns {Array} Returns the string segments.
		     * @example
		     *
		     * _.split('a-b-c', '-', 2);
		     * // => ['a', 'b']
		     */
		    function split(string, separator, limit) {
		      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
		        separator = limit = undefined$1;
		      }
		      limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
		      if (!limit) {
		        return [];
		      }
		      string = toString(string);
		      if (string && (
		            typeof separator == 'string' ||
		            (separator != null && !isRegExp(separator))
		          )) {
		        separator = baseToString(separator);
		        if (!separator && hasUnicode(string)) {
		          return castSlice(stringToArray(string), 0, limit);
		        }
		      }
		      return string.split(separator, limit);
		    }

		    /**
		     * Converts `string` to
		     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.1.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the start cased string.
		     * @example
		     *
		     * _.startCase('--foo-bar--');
		     * // => 'Foo Bar'
		     *
		     * _.startCase('fooBar');
		     * // => 'Foo Bar'
		     *
		     * _.startCase('__FOO_BAR__');
		     * // => 'FOO BAR'
		     */
		    var startCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + upperFirst(word);
		    });

		    /**
		     * Checks if `string` starts with the given target string.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {string} [target] The string to search for.
		     * @param {number} [position=0] The position to search from.
		     * @returns {boolean} Returns `true` if `string` starts with `target`,
		     *  else `false`.
		     * @example
		     *
		     * _.startsWith('abc', 'a');
		     * // => true
		     *
		     * _.startsWith('abc', 'b');
		     * // => false
		     *
		     * _.startsWith('abc', 'b', 1);
		     * // => true
		     */
		    function startsWith(string, target, position) {
		      string = toString(string);
		      position = position == null
		        ? 0
		        : baseClamp(toInteger(position), 0, string.length);

		      target = baseToString(target);
		      return string.slice(position, position + target.length) == target;
		    }

		    /**
		     * Creates a compiled template function that can interpolate data properties
		     * in "interpolate" delimiters, HTML-escape interpolated data properties in
		     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
		     * properties may be accessed as free variables in the template. If a setting
		     * object is given, it takes precedence over `_.templateSettings` values.
		     *
		     * **Note:** In the development build `_.template` utilizes
		     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
		     * for easier debugging.
		     *
		     * For more information on precompiling templates see
		     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
		     *
		     * For more information on Chrome extension sandboxes see
		     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category String
		     * @param {string} [string=''] The template string.
		     * @param {Object} [options={}] The options object.
		     * @param {RegExp} [options.escape=_.templateSettings.escape]
		     *  The HTML "escape" delimiter.
		     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
		     *  The "evaluate" delimiter.
		     * @param {Object} [options.imports=_.templateSettings.imports]
		     *  An object to import into the template as free variables.
		     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
		     *  The "interpolate" delimiter.
		     * @param {string} [options.sourceURL='lodash.templateSources[n]']
		     *  The sourceURL of the compiled template.
		     * @param {string} [options.variable='obj']
		     *  The data object variable name.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the compiled template function.
		     * @example
		     *
		     * // Use the "interpolate" delimiter to create a compiled template.
		     * var compiled = _.template('hello <%= user %>!');
		     * compiled({ 'user': 'fred' });
		     * // => 'hello fred!'
		     *
		     * // Use the HTML "escape" delimiter to escape data property values.
		     * var compiled = _.template('<b><%- value %></b>');
		     * compiled({ 'value': '<script>' });
		     * // => '<b>&lt;script&gt;</b>'
		     *
		     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
		     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
		     * compiled({ 'users': ['fred', 'barney'] });
		     * // => '<li>fred</li><li>barney</li>'
		     *
		     * // Use the internal `print` function in "evaluate" delimiters.
		     * var compiled = _.template('<% print("hello " + user); %>!');
		     * compiled({ 'user': 'barney' });
		     * // => 'hello barney!'
		     *
		     * // Use the ES template literal delimiter as an "interpolate" delimiter.
		     * // Disable support by replacing the "interpolate" delimiter.
		     * var compiled = _.template('hello ${ user }!');
		     * compiled({ 'user': 'pebbles' });
		     * // => 'hello pebbles!'
		     *
		     * // Use backslashes to treat delimiters as plain text.
		     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
		     * compiled({ 'value': 'ignored' });
		     * // => '<%- value %>'
		     *
		     * // Use the `imports` option to import `jQuery` as `jq`.
		     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
		     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
		     * compiled({ 'users': ['fred', 'barney'] });
		     * // => '<li>fred</li><li>barney</li>'
		     *
		     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
		     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
		     * compiled(data);
		     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
		     *
		     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
		     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
		     * compiled.source;
		     * // => function(data) {
		     * //   var __t, __p = '';
		     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
		     * //   return __p;
		     * // }
		     *
		     * // Use custom template delimiters.
		     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
		     * var compiled = _.template('hello {{ user }}!');
		     * compiled({ 'user': 'mustache' });
		     * // => 'hello mustache!'
		     *
		     * // Use the `source` property to inline compiled templates for meaningful
		     * // line numbers in error messages and stack traces.
		     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
		     *   var JST = {\
		     *     "main": ' + _.template(mainText).source + '\
		     *   };\
		     * ');
		     */
		    function template(string, options, guard) {
		      // Based on John Resig's `tmpl` implementation
		      // (http://ejohn.org/blog/javascript-micro-templating/)
		      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
		      var settings = lodash.templateSettings;

		      if (guard && isIterateeCall(string, options, guard)) {
		        options = undefined$1;
		      }
		      string = toString(string);
		      options = assignInWith({}, options, settings, customDefaultsAssignIn);

		      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
		          importsKeys = keys(imports),
		          importsValues = baseValues(imports, importsKeys);

		      var isEscaping,
		          isEvaluating,
		          index = 0,
		          interpolate = options.interpolate || reNoMatch,
		          source = "__p += '";

		      // Compile the regexp to match each delimiter.
		      var reDelimiters = RegExp(
		        (options.escape || reNoMatch).source + '|' +
		        interpolate.source + '|' +
		        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
		        (options.evaluate || reNoMatch).source + '|$'
		      , 'g');

		      // Use a sourceURL for easier debugging.
		      // The sourceURL gets injected into the source that's eval-ed, so be careful
		      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
		      // and escape the comment, thus injecting code that gets evaled.
		      var sourceURL = '//# sourceURL=' +
		        (hasOwnProperty.call(options, 'sourceURL')
		          ? (options.sourceURL + '').replace(/\s/g, ' ')
		          : ('lodash.templateSources[' + (++templateCounter) + ']')
		        ) + '\n';

		      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
		        interpolateValue || (interpolateValue = esTemplateValue);

		        // Escape characters that can't be included in string literals.
		        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

		        // Replace delimiters with snippets.
		        if (escapeValue) {
		          isEscaping = true;
		          source += "' +\n__e(" + escapeValue + ") +\n'";
		        }
		        if (evaluateValue) {
		          isEvaluating = true;
		          source += "';\n" + evaluateValue + ";\n__p += '";
		        }
		        if (interpolateValue) {
		          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
		        }
		        index = offset + match.length;

		        // The JS engine embedded in Adobe products needs `match` returned in
		        // order to produce the correct `offset` value.
		        return match;
		      });

		      source += "';\n";

		      // If `variable` is not specified wrap a with-statement around the generated
		      // code to add the data object to the top of the scope chain.
		      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
		      if (!variable) {
		        source = 'with (obj) {\n' + source + '\n}\n';
		      }
		      // Throw an error if a forbidden character was found in `variable`, to prevent
		      // potential command injection attacks.
		      else if (reForbiddenIdentifierChars.test(variable)) {
		        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
		      }

		      // Cleanup code by stripping empty strings.
		      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
		        .replace(reEmptyStringMiddle, '$1')
		        .replace(reEmptyStringTrailing, '$1;');

		      // Frame code as the function body.
		      source = 'function(' + (variable || 'obj') + ') {\n' +
		        (variable
		          ? ''
		          : 'obj || (obj = {});\n'
		        ) +
		        "var __t, __p = ''" +
		        (isEscaping
		           ? ', __e = _.escape'
		           : ''
		        ) +
		        (isEvaluating
		          ? ', __j = Array.prototype.join;\n' +
		            "function print() { __p += __j.call(arguments, '') }\n"
		          : ';\n'
		        ) +
		        source +
		        'return __p\n}';

		      var result = attempt(function() {
		        return Function(importsKeys, sourceURL + 'return ' + source)
		          .apply(undefined$1, importsValues);
		      });

		      // Provide the compiled function's source by its `toString` method or
		      // the `source` property as a convenience for inlining compiled templates.
		      result.source = source;
		      if (isError(result)) {
		        throw result;
		      }
		      return result;
		    }

		    /**
		     * Converts `string`, as a whole, to lower case just like
		     * [String#toLowerCase](https://mdn.io/toLowerCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the lower cased string.
		     * @example
		     *
		     * _.toLower('--Foo-Bar--');
		     * // => '--foo-bar--'
		     *
		     * _.toLower('fooBar');
		     * // => 'foobar'
		     *
		     * _.toLower('__FOO_BAR__');
		     * // => '__foo_bar__'
		     */
		    function toLower(value) {
		      return toString(value).toLowerCase();
		    }

		    /**
		     * Converts `string`, as a whole, to upper case just like
		     * [String#toUpperCase](https://mdn.io/toUpperCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the upper cased string.
		     * @example
		     *
		     * _.toUpper('--foo-bar--');
		     * // => '--FOO-BAR--'
		     *
		     * _.toUpper('fooBar');
		     * // => 'FOOBAR'
		     *
		     * _.toUpper('__foo_bar__');
		     * // => '__FOO_BAR__'
		     */
		    function toUpper(value) {
		      return toString(value).toUpperCase();
		    }

		    /**
		     * Removes leading and trailing whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trim('  abc  ');
		     * // => 'abc'
		     *
		     * _.trim('-_-abc-_-', '_-');
		     * // => 'abc'
		     *
		     * _.map(['  foo  ', '  bar  '], _.trim);
		     * // => ['foo', 'bar']
		     */
		    function trim(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return baseTrim(string);
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          chrSymbols = stringToArray(chars),
		          start = charsStartIndex(strSymbols, chrSymbols),
		          end = charsEndIndex(strSymbols, chrSymbols) + 1;

		      return castSlice(strSymbols, start, end).join('');
		    }

		    /**
		     * Removes trailing whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trimEnd('  abc  ');
		     * // => '  abc'
		     *
		     * _.trimEnd('-_-abc-_-', '_-');
		     * // => '-_-abc'
		     */
		    function trimEnd(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return string.slice(0, trimmedEndIndex(string) + 1);
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

		      return castSlice(strSymbols, 0, end).join('');
		    }

		    /**
		     * Removes leading whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trimStart('  abc  ');
		     * // => 'abc  '
		     *
		     * _.trimStart('-_-abc-_-', '_-');
		     * // => 'abc-_-'
		     */
		    function trimStart(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return string.replace(reTrimStart, '');
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          start = charsStartIndex(strSymbols, stringToArray(chars));

		      return castSlice(strSymbols, start).join('');
		    }

		    /**
		     * Truncates `string` if it's longer than the given maximum string length.
		     * The last characters of the truncated string are replaced with the omission
		     * string which defaults to "...".
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to truncate.
		     * @param {Object} [options={}] The options object.
		     * @param {number} [options.length=30] The maximum string length.
		     * @param {string} [options.omission='...'] The string to indicate text is omitted.
		     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
		     * @returns {string} Returns the truncated string.
		     * @example
		     *
		     * _.truncate('hi-diddly-ho there, neighborino');
		     * // => 'hi-diddly-ho there, neighbo...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'length': 24,
		     *   'separator': ' '
		     * });
		     * // => 'hi-diddly-ho there,...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'length': 24,
		     *   'separator': /,? +/
		     * });
		     * // => 'hi-diddly-ho there...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'omission': ' [...]'
		     * });
		     * // => 'hi-diddly-ho there, neig [...]'
		     */
		    function truncate(string, options) {
		      var length = DEFAULT_TRUNC_LENGTH,
		          omission = DEFAULT_TRUNC_OMISSION;

		      if (isObject(options)) {
		        var separator = 'separator' in options ? options.separator : separator;
		        length = 'length' in options ? toInteger(options.length) : length;
		        omission = 'omission' in options ? baseToString(options.omission) : omission;
		      }
		      string = toString(string);

		      var strLength = string.length;
		      if (hasUnicode(string)) {
		        var strSymbols = stringToArray(string);
		        strLength = strSymbols.length;
		      }
		      if (length >= strLength) {
		        return string;
		      }
		      var end = length - stringSize(omission);
		      if (end < 1) {
		        return omission;
		      }
		      var result = strSymbols
		        ? castSlice(strSymbols, 0, end).join('')
		        : string.slice(0, end);

		      if (separator === undefined$1) {
		        return result + omission;
		      }
		      if (strSymbols) {
		        end += (result.length - end);
		      }
		      if (isRegExp(separator)) {
		        if (string.slice(end).search(separator)) {
		          var match,
		              substring = result;

		          if (!separator.global) {
		            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
		          }
		          separator.lastIndex = 0;
		          while ((match = separator.exec(substring))) {
		            var newEnd = match.index;
		          }
		          result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
		        }
		      } else if (string.indexOf(baseToString(separator), end) != end) {
		        var index = result.lastIndexOf(separator);
		        if (index > -1) {
		          result = result.slice(0, index);
		        }
		      }
		      return result + omission;
		    }

		    /**
		     * The inverse of `_.escape`; this method converts the HTML entities
		     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
		     * their corresponding characters.
		     *
		     * **Note:** No other HTML entities are unescaped. To unescape additional
		     * HTML entities use a third-party library like [_he_](https://mths.be/he).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.6.0
		     * @category String
		     * @param {string} [string=''] The string to unescape.
		     * @returns {string} Returns the unescaped string.
		     * @example
		     *
		     * _.unescape('fred, barney, &amp; pebbles');
		     * // => 'fred, barney, & pebbles'
		     */
		    function unescape(string) {
		      string = toString(string);
		      return (string && reHasEscapedHtml.test(string))
		        ? string.replace(reEscapedHtml, unescapeHtmlChar)
		        : string;
		    }

		    /**
		     * Converts `string`, as space separated words, to upper case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the upper cased string.
		     * @example
		     *
		     * _.upperCase('--foo-bar');
		     * // => 'FOO BAR'
		     *
		     * _.upperCase('fooBar');
		     * // => 'FOO BAR'
		     *
		     * _.upperCase('__foo_bar__');
		     * // => 'FOO BAR'
		     */
		    var upperCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + word.toUpperCase();
		    });

		    /**
		     * Converts the first character of `string` to upper case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.upperFirst('fred');
		     * // => 'Fred'
		     *
		     * _.upperFirst('FRED');
		     * // => 'FRED'
		     */
		    var upperFirst = createCaseFirst('toUpperCase');

		    /**
		     * Splits `string` into an array of its words.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {RegExp|string} [pattern] The pattern to match words.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the words of `string`.
		     * @example
		     *
		     * _.words('fred, barney, & pebbles');
		     * // => ['fred', 'barney', 'pebbles']
		     *
		     * _.words('fred, barney, & pebbles', /[^, ]+/g);
		     * // => ['fred', 'barney', '&', 'pebbles']
		     */
		    function words(string, pattern, guard) {
		      string = toString(string);
		      pattern = guard ? undefined$1 : pattern;

		      if (pattern === undefined$1) {
		        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
		      }
		      return string.match(pattern) || [];
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Attempts to invoke `func`, returning either the result or the caught error
		     * object. Any additional arguments are provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Function} func The function to attempt.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {*} Returns the `func` result or error object.
		     * @example
		     *
		     * // Avoid throwing errors for invalid selectors.
		     * var elements = _.attempt(function(selector) {
		     *   return document.querySelectorAll(selector);
		     * }, '>_>');
		     *
		     * if (_.isError(elements)) {
		     *   elements = [];
		     * }
		     */
		    var attempt = baseRest(function(func, args) {
		      try {
		        return apply(func, undefined$1, args);
		      } catch (e) {
		        return isError(e) ? e : new Error(e);
		      }
		    });

		    /**
		     * Binds methods of an object to the object itself, overwriting the existing
		     * method.
		     *
		     * **Note:** This method doesn't set the "length" property of bound functions.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {Object} object The object to bind and assign the bound methods to.
		     * @param {...(string|string[])} methodNames The object method names to bind.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var view = {
		     *   'label': 'docs',
		     *   'click': function() {
		     *     console.log('clicked ' + this.label);
		     *   }
		     * };
		     *
		     * _.bindAll(view, ['click']);
		     * jQuery(element).on('click', view.click);
		     * // => Logs 'clicked docs' when clicked.
		     */
		    var bindAll = flatRest(function(object, methodNames) {
		      arrayEach(methodNames, function(key) {
		        key = toKey(key);
		        baseAssignValue(object, key, bind(object[key], object));
		      });
		      return object;
		    });

		    /**
		     * Creates a function that iterates over `pairs` and invokes the corresponding
		     * function of the first predicate to return truthy. The predicate-function
		     * pairs are invoked with the `this` binding and arguments of the created
		     * function.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {Array} pairs The predicate-function pairs.
		     * @returns {Function} Returns the new composite function.
		     * @example
		     *
		     * var func = _.cond([
		     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
		     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
		     *   [_.stubTrue,                      _.constant('no match')]
		     * ]);
		     *
		     * func({ 'a': 1, 'b': 2 });
		     * // => 'matches A'
		     *
		     * func({ 'a': 0, 'b': 1 });
		     * // => 'matches B'
		     *
		     * func({ 'a': '1', 'b': '2' });
		     * // => 'no match'
		     */
		    function cond(pairs) {
		      var length = pairs == null ? 0 : pairs.length,
		          toIteratee = getIteratee();

		      pairs = !length ? [] : arrayMap(pairs, function(pair) {
		        if (typeof pair[1] != 'function') {
		          throw new TypeError(FUNC_ERROR_TEXT);
		        }
		        return [toIteratee(pair[0]), pair[1]];
		      });

		      return baseRest(function(args) {
		        var index = -1;
		        while (++index < length) {
		          var pair = pairs[index];
		          if (apply(pair[0], this, args)) {
		            return apply(pair[1], this, args);
		          }
		        }
		      });
		    }

		    /**
		     * Creates a function that invokes the predicate properties of `source` with
		     * the corresponding property values of a given object, returning `true` if
		     * all predicates return truthy, else `false`.
		     *
		     * **Note:** The created function is equivalent to `_.conformsTo` with
		     * `source` partially applied.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 2, 'b': 1 },
		     *   { 'a': 1, 'b': 2 }
		     * ];
		     *
		     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
		     * // => [{ 'a': 1, 'b': 2 }]
		     */
		    function conforms(source) {
		      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that returns `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Util
		     * @param {*} value The value to return from the new function.
		     * @returns {Function} Returns the new constant function.
		     * @example
		     *
		     * var objects = _.times(2, _.constant({ 'a': 1 }));
		     *
		     * console.log(objects);
		     * // => [{ 'a': 1 }, { 'a': 1 }]
		     *
		     * console.log(objects[0] === objects[1]);
		     * // => true
		     */
		    function constant(value) {
		      return function() {
		        return value;
		      };
		    }

		    /**
		     * Checks `value` to determine whether a default value should be returned in
		     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
		     * or `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.14.0
		     * @category Util
		     * @param {*} value The value to check.
		     * @param {*} defaultValue The default value.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * _.defaultTo(1, 10);
		     * // => 1
		     *
		     * _.defaultTo(undefined, 10);
		     * // => 10
		     */
		    function defaultTo(value, defaultValue) {
		      return (value == null || value !== value) ? defaultValue : value;
		    }

		    /**
		     * Creates a function that returns the result of invoking the given functions
		     * with the `this` binding of the created function, where each successive
		     * invocation is supplied the return value of the previous.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [funcs] The functions to invoke.
		     * @returns {Function} Returns the new composite function.
		     * @see _.flowRight
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var addSquare = _.flow([_.add, square]);
		     * addSquare(1, 2);
		     * // => 9
		     */
		    var flow = createFlow();

		    /**
		     * This method is like `_.flow` except that it creates a function that
		     * invokes the given functions from right to left.
		     *
		     * @static
		     * @since 3.0.0
		     * @memberOf _
		     * @category Util
		     * @param {...(Function|Function[])} [funcs] The functions to invoke.
		     * @returns {Function} Returns the new composite function.
		     * @see _.flow
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var addSquare = _.flowRight([square, _.add]);
		     * addSquare(1, 2);
		     * // => 9
		     */
		    var flowRight = createFlow(true);

		    /**
		     * This method returns the first argument it receives.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {*} value Any value.
		     * @returns {*} Returns `value`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     *
		     * console.log(_.identity(object) === object);
		     * // => true
		     */
		    function identity(value) {
		      return value;
		    }

		    /**
		     * Creates a function that invokes `func` with the arguments of the created
		     * function. If `func` is a property name, the created function returns the
		     * property value for a given element. If `func` is an array or object, the
		     * created function returns `true` for elements that contain the equivalent
		     * source properties, otherwise it returns `false`.
		     *
		     * @static
		     * @since 4.0.0
		     * @memberOf _
		     * @category Util
		     * @param {*} [func=_.identity] The value to convert to a callback.
		     * @returns {Function} Returns the callback.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': true },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
		     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.filter(users, _.iteratee(['user', 'fred']));
		     * // => [{ 'user': 'fred', 'age': 40 }]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.map(users, _.iteratee('user'));
		     * // => ['barney', 'fred']
		     *
		     * // Create custom iteratee shorthands.
		     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
		     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
		     *     return func.test(string);
		     *   };
		     * });
		     *
		     * _.filter(['abc', 'def'], /ef/);
		     * // => ['def']
		     */
		    function iteratee(func) {
		      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that performs a partial deep comparison between a given
		     * object and `source`, returning `true` if the given object has equivalent
		     * property values, else `false`.
		     *
		     * **Note:** The created function is equivalent to `_.isMatch` with `source`
		     * partially applied.
		     *
		     * Partial comparisons will match empty array and empty object `source`
		     * values against any array or object value, respectively. See `_.isEqual`
		     * for a list of supported value comparisons.
		     *
		     * **Note:** Multiple values can be checked by combining several matchers
		     * using `_.overSome`
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Object} source The object of property values to match.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 1, 'b': 2, 'c': 3 },
		     *   { 'a': 4, 'b': 5, 'c': 6 }
		     * ];
		     *
		     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
		     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
		     *
		     * // Checking for several possible values
		     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
		     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
		     */
		    function matches(source) {
		      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that performs a partial deep comparison between the
		     * value at `path` of a given object to `srcValue`, returning `true` if the
		     * object value is equivalent, else `false`.
		     *
		     * **Note:** Partial comparisons will match empty array and empty object
		     * `srcValue` values against any array or object value, respectively. See
		     * `_.isEqual` for a list of supported value comparisons.
		     *
		     * **Note:** Multiple values can be checked by combining several matchers
		     * using `_.overSome`
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Util
		     * @param {Array|string} path The path of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 1, 'b': 2, 'c': 3 },
		     *   { 'a': 4, 'b': 5, 'c': 6 }
		     * ];
		     *
		     * _.find(objects, _.matchesProperty('a', 4));
		     * // => { 'a': 4, 'b': 5, 'c': 6 }
		     *
		     * // Checking for several possible values
		     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
		     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
		     */
		    function matchesProperty(path, srcValue) {
		      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that invokes the method at `path` of a given object.
		     * Any additional arguments are provided to the invoked method.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Util
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {Function} Returns the new invoker function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': { 'b': _.constant(2) } },
		     *   { 'a': { 'b': _.constant(1) } }
		     * ];
		     *
		     * _.map(objects, _.method('a.b'));
		     * // => [2, 1]
		     *
		     * _.map(objects, _.method(['a', 'b']));
		     * // => [2, 1]
		     */
		    var method = baseRest(function(path, args) {
		      return function(object) {
		        return baseInvoke(object, path, args);
		      };
		    });

		    /**
		     * The opposite of `_.method`; this method creates a function that invokes
		     * the method at a given path of `object`. Any additional arguments are
		     * provided to the invoked method.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Util
		     * @param {Object} object The object to query.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {Function} Returns the new invoker function.
		     * @example
		     *
		     * var array = _.times(3, _.constant),
		     *     object = { 'a': array, 'b': array, 'c': array };
		     *
		     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
		     * // => [2, 0]
		     *
		     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
		     * // => [2, 0]
		     */
		    var methodOf = baseRest(function(object, args) {
		      return function(path) {
		        return baseInvoke(object, path, args);
		      };
		    });

		    /**
		     * Adds all own enumerable string keyed function properties of a source
		     * object to the destination object. If `object` is a function, then methods
		     * are added to its prototype as well.
		     *
		     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
		     * avoid conflicts caused by modifying the original.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {Function|Object} [object=lodash] The destination object.
		     * @param {Object} source The object of functions to add.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
		     * @returns {Function|Object} Returns `object`.
		     * @example
		     *
		     * function vowels(string) {
		     *   return _.filter(string, function(v) {
		     *     return /[aeiou]/i.test(v);
		     *   });
		     * }
		     *
		     * _.mixin({ 'vowels': vowels });
		     * _.vowels('fred');
		     * // => ['e']
		     *
		     * _('fred').vowels().value();
		     * // => ['e']
		     *
		     * _.mixin({ 'vowels': vowels }, { 'chain': false });
		     * _('fred').vowels();
		     * // => ['e']
		     */
		    function mixin(object, source, options) {
		      var props = keys(source),
		          methodNames = baseFunctions(source, props);

		      if (options == null &&
		          !(isObject(source) && (methodNames.length || !props.length))) {
		        options = source;
		        source = object;
		        object = this;
		        methodNames = baseFunctions(source, keys(source));
		      }
		      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
		          isFunc = isFunction(object);

		      arrayEach(methodNames, function(methodName) {
		        var func = source[methodName];
		        object[methodName] = func;
		        if (isFunc) {
		          object.prototype[methodName] = function() {
		            var chainAll = this.__chain__;
		            if (chain || chainAll) {
		              var result = object(this.__wrapped__),
		                  actions = result.__actions__ = copyArray(this.__actions__);

		              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
		              result.__chain__ = chainAll;
		              return result;
		            }
		            return func.apply(object, arrayPush([this.value()], arguments));
		          };
		        }
		      });

		      return object;
		    }

		    /**
		     * Reverts the `_` variable to its previous value and returns a reference to
		     * the `lodash` function.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @returns {Function} Returns the `lodash` function.
		     * @example
		     *
		     * var lodash = _.noConflict();
		     */
		    function noConflict() {
		      if (root._ === this) {
		        root._ = oldDash;
		      }
		      return this;
		    }

		    /**
		     * This method returns `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.3.0
		     * @category Util
		     * @example
		     *
		     * _.times(2, _.noop);
		     * // => [undefined, undefined]
		     */
		    function noop() {
		      // No operation performed.
		    }

		    /**
		     * Creates a function that gets the argument at index `n`. If `n` is negative,
		     * the nth argument from the end is returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {number} [n=0] The index of the argument to return.
		     * @returns {Function} Returns the new pass-thru function.
		     * @example
		     *
		     * var func = _.nthArg(1);
		     * func('a', 'b', 'c', 'd');
		     * // => 'b'
		     *
		     * var func = _.nthArg(-2);
		     * func('a', 'b', 'c', 'd');
		     * // => 'c'
		     */
		    function nthArg(n) {
		      n = toInteger(n);
		      return baseRest(function(args) {
		        return baseNth(args, n);
		      });
		    }

		    /**
		     * Creates a function that invokes `iteratees` with the arguments it receives
		     * and returns their results.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [iteratees=[_.identity]]
		     *  The iteratees to invoke.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.over([Math.max, Math.min]);
		     *
		     * func(1, 2, 3, 4);
		     * // => [4, 1]
		     */
		    var over = createOver(arrayMap);

		    /**
		     * Creates a function that checks if **all** of the `predicates` return
		     * truthy when invoked with the arguments it receives.
		     *
		     * Following shorthands are possible for providing predicates.
		     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
		     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [predicates=[_.identity]]
		     *  The predicates to check.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.overEvery([Boolean, isFinite]);
		     *
		     * func('1');
		     * // => true
		     *
		     * func(null);
		     * // => false
		     *
		     * func(NaN);
		     * // => false
		     */
		    var overEvery = createOver(arrayEvery);

		    /**
		     * Creates a function that checks if **any** of the `predicates` return
		     * truthy when invoked with the arguments it receives.
		     *
		     * Following shorthands are possible for providing predicates.
		     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
		     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [predicates=[_.identity]]
		     *  The predicates to check.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.overSome([Boolean, isFinite]);
		     *
		     * func('1');
		     * // => true
		     *
		     * func(null);
		     * // => true
		     *
		     * func(NaN);
		     * // => false
		     *
		     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
		     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
		     */
		    var overSome = createOver(arraySome);

		    /**
		     * Creates a function that returns the value at `path` of a given object.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Util
		     * @param {Array|string} path The path of the property to get.
		     * @returns {Function} Returns the new accessor function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': { 'b': 2 } },
		     *   { 'a': { 'b': 1 } }
		     * ];
		     *
		     * _.map(objects, _.property('a.b'));
		     * // => [2, 1]
		     *
		     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
		     * // => [1, 2]
		     */
		    function property(path) {
		      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
		    }

		    /**
		     * The opposite of `_.property`; this method creates a function that returns
		     * the value at a given path of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Object} object The object to query.
		     * @returns {Function} Returns the new accessor function.
		     * @example
		     *
		     * var array = [0, 1, 2],
		     *     object = { 'a': array, 'b': array, 'c': array };
		     *
		     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
		     * // => [2, 0]
		     *
		     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
		     * // => [2, 0]
		     */
		    function propertyOf(object) {
		      return function(path) {
		        return object == null ? undefined$1 : baseGet(object, path);
		      };
		    }

		    /**
		     * Creates an array of numbers (positive and/or negative) progressing from
		     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
		     * `start` is specified without an `end` or `step`. If `end` is not specified,
		     * it's set to `start` with `start` then set to `0`.
		     *
		     * **Note:** JavaScript follows the IEEE-754 standard for resolving
		     * floating-point values which can produce unexpected results.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} [step=1] The value to increment or decrement by.
		     * @returns {Array} Returns the range of numbers.
		     * @see _.inRange, _.rangeRight
		     * @example
		     *
		     * _.range(4);
		     * // => [0, 1, 2, 3]
		     *
		     * _.range(-4);
		     * // => [0, -1, -2, -3]
		     *
		     * _.range(1, 5);
		     * // => [1, 2, 3, 4]
		     *
		     * _.range(0, 20, 5);
		     * // => [0, 5, 10, 15]
		     *
		     * _.range(0, -4, -1);
		     * // => [0, -1, -2, -3]
		     *
		     * _.range(1, 4, 0);
		     * // => [1, 1, 1]
		     *
		     * _.range(0);
		     * // => []
		     */
		    var range = createRange();

		    /**
		     * This method is like `_.range` except that it populates values in
		     * descending order.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} [step=1] The value to increment or decrement by.
		     * @returns {Array} Returns the range of numbers.
		     * @see _.inRange, _.range
		     * @example
		     *
		     * _.rangeRight(4);
		     * // => [3, 2, 1, 0]
		     *
		     * _.rangeRight(-4);
		     * // => [-3, -2, -1, 0]
		     *
		     * _.rangeRight(1, 5);
		     * // => [4, 3, 2, 1]
		     *
		     * _.rangeRight(0, 20, 5);
		     * // => [15, 10, 5, 0]
		     *
		     * _.rangeRight(0, -4, -1);
		     * // => [-3, -2, -1, 0]
		     *
		     * _.rangeRight(1, 4, 0);
		     * // => [1, 1, 1]
		     *
		     * _.rangeRight(0);
		     * // => []
		     */
		    var rangeRight = createRange(true);

		    /**
		     * This method returns a new empty array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {Array} Returns the new empty array.
		     * @example
		     *
		     * var arrays = _.times(2, _.stubArray);
		     *
		     * console.log(arrays);
		     * // => [[], []]
		     *
		     * console.log(arrays[0] === arrays[1]);
		     * // => false
		     */
		    function stubArray() {
		      return [];
		    }

		    /**
		     * This method returns `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {boolean} Returns `false`.
		     * @example
		     *
		     * _.times(2, _.stubFalse);
		     * // => [false, false]
		     */
		    function stubFalse() {
		      return false;
		    }

		    /**
		     * This method returns a new empty object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {Object} Returns the new empty object.
		     * @example
		     *
		     * var objects = _.times(2, _.stubObject);
		     *
		     * console.log(objects);
		     * // => [{}, {}]
		     *
		     * console.log(objects[0] === objects[1]);
		     * // => false
		     */
		    function stubObject() {
		      return {};
		    }

		    /**
		     * This method returns an empty string.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {string} Returns the empty string.
		     * @example
		     *
		     * _.times(2, _.stubString);
		     * // => ['', '']
		     */
		    function stubString() {
		      return '';
		    }

		    /**
		     * This method returns `true`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {boolean} Returns `true`.
		     * @example
		     *
		     * _.times(2, _.stubTrue);
		     * // => [true, true]
		     */
		    function stubTrue() {
		      return true;
		    }

		    /**
		     * Invokes the iteratee `n` times, returning an array of the results of
		     * each invocation. The iteratee is invoked with one argument; (index).
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {number} n The number of times to invoke `iteratee`.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the array of results.
		     * @example
		     *
		     * _.times(3, String);
		     * // => ['0', '1', '2']
		     *
		     *  _.times(4, _.constant(0));
		     * // => [0, 0, 0, 0]
		     */
		    function times(n, iteratee) {
		      n = toInteger(n);
		      if (n < 1 || n > MAX_SAFE_INTEGER) {
		        return [];
		      }
		      var index = MAX_ARRAY_LENGTH,
		          length = nativeMin(n, MAX_ARRAY_LENGTH);

		      iteratee = getIteratee(iteratee);
		      n -= MAX_ARRAY_LENGTH;

		      var result = baseTimes(length, iteratee);
		      while (++index < n) {
		        iteratee(index);
		      }
		      return result;
		    }

		    /**
		     * Converts `value` to a property path array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {*} value The value to convert.
		     * @returns {Array} Returns the new property path array.
		     * @example
		     *
		     * _.toPath('a.b.c');
		     * // => ['a', 'b', 'c']
		     *
		     * _.toPath('a[0].b.c');
		     * // => ['a', '0', 'b', 'c']
		     */
		    function toPath(value) {
		      if (isArray(value)) {
		        return arrayMap(value, toKey);
		      }
		      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
		    }

		    /**
		     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {string} [prefix=''] The value to prefix the ID with.
		     * @returns {string} Returns the unique ID.
		     * @example
		     *
		     * _.uniqueId('contact_');
		     * // => 'contact_104'
		     *
		     * _.uniqueId();
		     * // => '105'
		     */
		    function uniqueId(prefix) {
		      var id = ++idCounter;
		      return toString(prefix) + id;
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Adds two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.4.0
		     * @category Math
		     * @param {number} augend The first number in an addition.
		     * @param {number} addend The second number in an addition.
		     * @returns {number} Returns the total.
		     * @example
		     *
		     * _.add(6, 4);
		     * // => 10
		     */
		    var add = createMathOperation(function(augend, addend) {
		      return augend + addend;
		    }, 0);

		    /**
		     * Computes `number` rounded up to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round up.
		     * @param {number} [precision=0] The precision to round up to.
		     * @returns {number} Returns the rounded up number.
		     * @example
		     *
		     * _.ceil(4.006);
		     * // => 5
		     *
		     * _.ceil(6.004, 2);
		     * // => 6.01
		     *
		     * _.ceil(6040, -2);
		     * // => 6100
		     */
		    var ceil = createRound('ceil');

		    /**
		     * Divide two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {number} dividend The first number in a division.
		     * @param {number} divisor The second number in a division.
		     * @returns {number} Returns the quotient.
		     * @example
		     *
		     * _.divide(6, 4);
		     * // => 1.5
		     */
		    var divide = createMathOperation(function(dividend, divisor) {
		      return dividend / divisor;
		    }, 1);

		    /**
		     * Computes `number` rounded down to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round down.
		     * @param {number} [precision=0] The precision to round down to.
		     * @returns {number} Returns the rounded down number.
		     * @example
		     *
		     * _.floor(4.006);
		     * // => 4
		     *
		     * _.floor(0.046, 2);
		     * // => 0.04
		     *
		     * _.floor(4060, -2);
		     * // => 4000
		     */
		    var floor = createRound('floor');

		    /**
		     * Computes the maximum value of `array`. If `array` is empty or falsey,
		     * `undefined` is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {*} Returns the maximum value.
		     * @example
		     *
		     * _.max([4, 2, 8, 6]);
		     * // => 8
		     *
		     * _.max([]);
		     * // => undefined
		     */
		    function max(array) {
		      return (array && array.length)
		        ? baseExtremum(array, identity, baseGt)
		        : undefined$1;
		    }

		    /**
		     * This method is like `_.max` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * the value is ranked. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {*} Returns the maximum value.
		     * @example
		     *
		     * var objects = [{ 'n': 1 }, { 'n': 2 }];
		     *
		     * _.maxBy(objects, function(o) { return o.n; });
		     * // => { 'n': 2 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.maxBy(objects, 'n');
		     * // => { 'n': 2 }
		     */
		    function maxBy(array, iteratee) {
		      return (array && array.length)
		        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
		        : undefined$1;
		    }

		    /**
		     * Computes the mean of the values in `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {number} Returns the mean.
		     * @example
		     *
		     * _.mean([4, 2, 8, 6]);
		     * // => 5
		     */
		    function mean(array) {
		      return baseMean(array, identity);
		    }

		    /**
		     * This method is like `_.mean` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the value to be averaged.
		     * The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the mean.
		     * @example
		     *
		     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
		     *
		     * _.meanBy(objects, function(o) { return o.n; });
		     * // => 5
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.meanBy(objects, 'n');
		     * // => 5
		     */
		    function meanBy(array, iteratee) {
		      return baseMean(array, getIteratee(iteratee, 2));
		    }

		    /**
		     * Computes the minimum value of `array`. If `array` is empty or falsey,
		     * `undefined` is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {*} Returns the minimum value.
		     * @example
		     *
		     * _.min([4, 2, 8, 6]);
		     * // => 2
		     *
		     * _.min([]);
		     * // => undefined
		     */
		    function min(array) {
		      return (array && array.length)
		        ? baseExtremum(array, identity, baseLt)
		        : undefined$1;
		    }

		    /**
		     * This method is like `_.min` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * the value is ranked. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {*} Returns the minimum value.
		     * @example
		     *
		     * var objects = [{ 'n': 1 }, { 'n': 2 }];
		     *
		     * _.minBy(objects, function(o) { return o.n; });
		     * // => { 'n': 1 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.minBy(objects, 'n');
		     * // => { 'n': 1 }
		     */
		    function minBy(array, iteratee) {
		      return (array && array.length)
		        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
		        : undefined$1;
		    }

		    /**
		     * Multiply two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {number} multiplier The first number in a multiplication.
		     * @param {number} multiplicand The second number in a multiplication.
		     * @returns {number} Returns the product.
		     * @example
		     *
		     * _.multiply(6, 4);
		     * // => 24
		     */
		    var multiply = createMathOperation(function(multiplier, multiplicand) {
		      return multiplier * multiplicand;
		    }, 1);

		    /**
		     * Computes `number` rounded to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round.
		     * @param {number} [precision=0] The precision to round to.
		     * @returns {number} Returns the rounded number.
		     * @example
		     *
		     * _.round(4.006);
		     * // => 4
		     *
		     * _.round(4.006, 2);
		     * // => 4.01
		     *
		     * _.round(4060, -2);
		     * // => 4100
		     */
		    var round = createRound('round');

		    /**
		     * Subtract two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {number} minuend The first number in a subtraction.
		     * @param {number} subtrahend The second number in a subtraction.
		     * @returns {number} Returns the difference.
		     * @example
		     *
		     * _.subtract(6, 4);
		     * // => 2
		     */
		    var subtract = createMathOperation(function(minuend, subtrahend) {
		      return minuend - subtrahend;
		    }, 0);

		    /**
		     * Computes the sum of the values in `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.4.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {number} Returns the sum.
		     * @example
		     *
		     * _.sum([4, 2, 8, 6]);
		     * // => 20
		     */
		    function sum(array) {
		      return (array && array.length)
		        ? baseSum(array, identity)
		        : 0;
		    }

		    /**
		     * This method is like `_.sum` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the value to be summed.
		     * The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the sum.
		     * @example
		     *
		     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
		     *
		     * _.sumBy(objects, function(o) { return o.n; });
		     * // => 20
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sumBy(objects, 'n');
		     * // => 20
		     */
		    function sumBy(array, iteratee) {
		      return (array && array.length)
		        ? baseSum(array, getIteratee(iteratee, 2))
		        : 0;
		    }

		    /*------------------------------------------------------------------------*/

		    // Add methods that return wrapped values in chain sequences.
		    lodash.after = after;
		    lodash.ary = ary;
		    lodash.assign = assign;
		    lodash.assignIn = assignIn;
		    lodash.assignInWith = assignInWith;
		    lodash.assignWith = assignWith;
		    lodash.at = at;
		    lodash.before = before;
		    lodash.bind = bind;
		    lodash.bindAll = bindAll;
		    lodash.bindKey = bindKey;
		    lodash.castArray = castArray;
		    lodash.chain = chain;
		    lodash.chunk = chunk;
		    lodash.compact = compact;
		    lodash.concat = concat;
		    lodash.cond = cond;
		    lodash.conforms = conforms;
		    lodash.constant = constant;
		    lodash.countBy = countBy;
		    lodash.create = create;
		    lodash.curry = curry;
		    lodash.curryRight = curryRight;
		    lodash.debounce = debounce;
		    lodash.defaults = defaults;
		    lodash.defaultsDeep = defaultsDeep;
		    lodash.defer = defer;
		    lodash.delay = delay;
		    lodash.difference = difference;
		    lodash.differenceBy = differenceBy;
		    lodash.differenceWith = differenceWith;
		    lodash.drop = drop;
		    lodash.dropRight = dropRight;
		    lodash.dropRightWhile = dropRightWhile;
		    lodash.dropWhile = dropWhile;
		    lodash.fill = fill;
		    lodash.filter = filter;
		    lodash.flatMap = flatMap;
		    lodash.flatMapDeep = flatMapDeep;
		    lodash.flatMapDepth = flatMapDepth;
		    lodash.flatten = flatten;
		    lodash.flattenDeep = flattenDeep;
		    lodash.flattenDepth = flattenDepth;
		    lodash.flip = flip;
		    lodash.flow = flow;
		    lodash.flowRight = flowRight;
		    lodash.fromPairs = fromPairs;
		    lodash.functions = functions;
		    lodash.functionsIn = functionsIn;
		    lodash.groupBy = groupBy;
		    lodash.initial = initial;
		    lodash.intersection = intersection;
		    lodash.intersectionBy = intersectionBy;
		    lodash.intersectionWith = intersectionWith;
		    lodash.invert = invert;
		    lodash.invertBy = invertBy;
		    lodash.invokeMap = invokeMap;
		    lodash.iteratee = iteratee;
		    lodash.keyBy = keyBy;
		    lodash.keys = keys;
		    lodash.keysIn = keysIn;
		    lodash.map = map;
		    lodash.mapKeys = mapKeys;
		    lodash.mapValues = mapValues;
		    lodash.matches = matches;
		    lodash.matchesProperty = matchesProperty;
		    lodash.memoize = memoize;
		    lodash.merge = merge;
		    lodash.mergeWith = mergeWith;
		    lodash.method = method;
		    lodash.methodOf = methodOf;
		    lodash.mixin = mixin;
		    lodash.negate = negate;
		    lodash.nthArg = nthArg;
		    lodash.omit = omit;
		    lodash.omitBy = omitBy;
		    lodash.once = once;
		    lodash.orderBy = orderBy;
		    lodash.over = over;
		    lodash.overArgs = overArgs;
		    lodash.overEvery = overEvery;
		    lodash.overSome = overSome;
		    lodash.partial = partial;
		    lodash.partialRight = partialRight;
		    lodash.partition = partition;
		    lodash.pick = pick;
		    lodash.pickBy = pickBy;
		    lodash.property = property;
		    lodash.propertyOf = propertyOf;
		    lodash.pull = pull;
		    lodash.pullAll = pullAll;
		    lodash.pullAllBy = pullAllBy;
		    lodash.pullAllWith = pullAllWith;
		    lodash.pullAt = pullAt;
		    lodash.range = range;
		    lodash.rangeRight = rangeRight;
		    lodash.rearg = rearg;
		    lodash.reject = reject;
		    lodash.remove = remove;
		    lodash.rest = rest;
		    lodash.reverse = reverse;
		    lodash.sampleSize = sampleSize;
		    lodash.set = set;
		    lodash.setWith = setWith;
		    lodash.shuffle = shuffle;
		    lodash.slice = slice;
		    lodash.sortBy = sortBy;
		    lodash.sortedUniq = sortedUniq;
		    lodash.sortedUniqBy = sortedUniqBy;
		    lodash.split = split;
		    lodash.spread = spread;
		    lodash.tail = tail;
		    lodash.take = take;
		    lodash.takeRight = takeRight;
		    lodash.takeRightWhile = takeRightWhile;
		    lodash.takeWhile = takeWhile;
		    lodash.tap = tap;
		    lodash.throttle = throttle;
		    lodash.thru = thru;
		    lodash.toArray = toArray;
		    lodash.toPairs = toPairs;
		    lodash.toPairsIn = toPairsIn;
		    lodash.toPath = toPath;
		    lodash.toPlainObject = toPlainObject;
		    lodash.transform = transform;
		    lodash.unary = unary;
		    lodash.union = union;
		    lodash.unionBy = unionBy;
		    lodash.unionWith = unionWith;
		    lodash.uniq = uniq;
		    lodash.uniqBy = uniqBy;
		    lodash.uniqWith = uniqWith;
		    lodash.unset = unset;
		    lodash.unzip = unzip;
		    lodash.unzipWith = unzipWith;
		    lodash.update = update;
		    lodash.updateWith = updateWith;
		    lodash.values = values;
		    lodash.valuesIn = valuesIn;
		    lodash.without = without;
		    lodash.words = words;
		    lodash.wrap = wrap;
		    lodash.xor = xor;
		    lodash.xorBy = xorBy;
		    lodash.xorWith = xorWith;
		    lodash.zip = zip;
		    lodash.zipObject = zipObject;
		    lodash.zipObjectDeep = zipObjectDeep;
		    lodash.zipWith = zipWith;

		    // Add aliases.
		    lodash.entries = toPairs;
		    lodash.entriesIn = toPairsIn;
		    lodash.extend = assignIn;
		    lodash.extendWith = assignInWith;

		    // Add methods to `lodash.prototype`.
		    mixin(lodash, lodash);

		    /*------------------------------------------------------------------------*/

		    // Add methods that return unwrapped values in chain sequences.
		    lodash.add = add;
		    lodash.attempt = attempt;
		    lodash.camelCase = camelCase;
		    lodash.capitalize = capitalize;
		    lodash.ceil = ceil;
		    lodash.clamp = clamp;
		    lodash.clone = clone;
		    lodash.cloneDeep = cloneDeep;
		    lodash.cloneDeepWith = cloneDeepWith;
		    lodash.cloneWith = cloneWith;
		    lodash.conformsTo = conformsTo;
		    lodash.deburr = deburr;
		    lodash.defaultTo = defaultTo;
		    lodash.divide = divide;
		    lodash.endsWith = endsWith;
		    lodash.eq = eq;
		    lodash.escape = escape;
		    lodash.escapeRegExp = escapeRegExp;
		    lodash.every = every;
		    lodash.find = find;
		    lodash.findIndex = findIndex;
		    lodash.findKey = findKey;
		    lodash.findLast = findLast;
		    lodash.findLastIndex = findLastIndex;
		    lodash.findLastKey = findLastKey;
		    lodash.floor = floor;
		    lodash.forEach = forEach;
		    lodash.forEachRight = forEachRight;
		    lodash.forIn = forIn;
		    lodash.forInRight = forInRight;
		    lodash.forOwn = forOwn;
		    lodash.forOwnRight = forOwnRight;
		    lodash.get = get;
		    lodash.gt = gt;
		    lodash.gte = gte;
		    lodash.has = has;
		    lodash.hasIn = hasIn;
		    lodash.head = head;
		    lodash.identity = identity;
		    lodash.includes = includes;
		    lodash.indexOf = indexOf;
		    lodash.inRange = inRange;
		    lodash.invoke = invoke;
		    lodash.isArguments = isArguments;
		    lodash.isArray = isArray;
		    lodash.isArrayBuffer = isArrayBuffer;
		    lodash.isArrayLike = isArrayLike;
		    lodash.isArrayLikeObject = isArrayLikeObject;
		    lodash.isBoolean = isBoolean;
		    lodash.isBuffer = isBuffer;
		    lodash.isDate = isDate;
		    lodash.isElement = isElement;
		    lodash.isEmpty = isEmpty;
		    lodash.isEqual = isEqual;
		    lodash.isEqualWith = isEqualWith;
		    lodash.isError = isError;
		    lodash.isFinite = isFinite;
		    lodash.isFunction = isFunction;
		    lodash.isInteger = isInteger;
		    lodash.isLength = isLength;
		    lodash.isMap = isMap;
		    lodash.isMatch = isMatch;
		    lodash.isMatchWith = isMatchWith;
		    lodash.isNaN = isNaN;
		    lodash.isNative = isNative;
		    lodash.isNil = isNil;
		    lodash.isNull = isNull;
		    lodash.isNumber = isNumber;
		    lodash.isObject = isObject;
		    lodash.isObjectLike = isObjectLike;
		    lodash.isPlainObject = isPlainObject;
		    lodash.isRegExp = isRegExp;
		    lodash.isSafeInteger = isSafeInteger;
		    lodash.isSet = isSet;
		    lodash.isString = isString;
		    lodash.isSymbol = isSymbol;
		    lodash.isTypedArray = isTypedArray;
		    lodash.isUndefined = isUndefined;
		    lodash.isWeakMap = isWeakMap;
		    lodash.isWeakSet = isWeakSet;
		    lodash.join = join;
		    lodash.kebabCase = kebabCase;
		    lodash.last = last;
		    lodash.lastIndexOf = lastIndexOf;
		    lodash.lowerCase = lowerCase;
		    lodash.lowerFirst = lowerFirst;
		    lodash.lt = lt;
		    lodash.lte = lte;
		    lodash.max = max;
		    lodash.maxBy = maxBy;
		    lodash.mean = mean;
		    lodash.meanBy = meanBy;
		    lodash.min = min;
		    lodash.minBy = minBy;
		    lodash.stubArray = stubArray;
		    lodash.stubFalse = stubFalse;
		    lodash.stubObject = stubObject;
		    lodash.stubString = stubString;
		    lodash.stubTrue = stubTrue;
		    lodash.multiply = multiply;
		    lodash.nth = nth;
		    lodash.noConflict = noConflict;
		    lodash.noop = noop;
		    lodash.now = now;
		    lodash.pad = pad;
		    lodash.padEnd = padEnd;
		    lodash.padStart = padStart;
		    lodash.parseInt = parseInt;
		    lodash.random = random;
		    lodash.reduce = reduce;
		    lodash.reduceRight = reduceRight;
		    lodash.repeat = repeat;
		    lodash.replace = replace;
		    lodash.result = result;
		    lodash.round = round;
		    lodash.runInContext = runInContext;
		    lodash.sample = sample;
		    lodash.size = size;
		    lodash.snakeCase = snakeCase;
		    lodash.some = some;
		    lodash.sortedIndex = sortedIndex;
		    lodash.sortedIndexBy = sortedIndexBy;
		    lodash.sortedIndexOf = sortedIndexOf;
		    lodash.sortedLastIndex = sortedLastIndex;
		    lodash.sortedLastIndexBy = sortedLastIndexBy;
		    lodash.sortedLastIndexOf = sortedLastIndexOf;
		    lodash.startCase = startCase;
		    lodash.startsWith = startsWith;
		    lodash.subtract = subtract;
		    lodash.sum = sum;
		    lodash.sumBy = sumBy;
		    lodash.template = template;
		    lodash.times = times;
		    lodash.toFinite = toFinite;
		    lodash.toInteger = toInteger;
		    lodash.toLength = toLength;
		    lodash.toLower = toLower;
		    lodash.toNumber = toNumber;
		    lodash.toSafeInteger = toSafeInteger;
		    lodash.toString = toString;
		    lodash.toUpper = toUpper;
		    lodash.trim = trim;
		    lodash.trimEnd = trimEnd;
		    lodash.trimStart = trimStart;
		    lodash.truncate = truncate;
		    lodash.unescape = unescape;
		    lodash.uniqueId = uniqueId;
		    lodash.upperCase = upperCase;
		    lodash.upperFirst = upperFirst;

		    // Add aliases.
		    lodash.each = forEach;
		    lodash.eachRight = forEachRight;
		    lodash.first = head;

		    mixin(lodash, (function() {
		      var source = {};
		      baseForOwn(lodash, function(func, methodName) {
		        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
		          source[methodName] = func;
		        }
		      });
		      return source;
		    }()), { 'chain': false });

		    /*------------------------------------------------------------------------*/

		    /**
		     * The semantic version number.
		     *
		     * @static
		     * @memberOf _
		     * @type {string}
		     */
		    lodash.VERSION = VERSION;

		    // Assign default placeholders.
		    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
		      lodash[methodName].placeholder = lodash;
		    });

		    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
		    arrayEach(['drop', 'take'], function(methodName, index) {
		      LazyWrapper.prototype[methodName] = function(n) {
		        n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

		        var result = (this.__filtered__ && !index)
		          ? new LazyWrapper(this)
		          : this.clone();

		        if (result.__filtered__) {
		          result.__takeCount__ = nativeMin(n, result.__takeCount__);
		        } else {
		          result.__views__.push({
		            'size': nativeMin(n, MAX_ARRAY_LENGTH),
		            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
		          });
		        }
		        return result;
		      };

		      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
		        return this.reverse()[methodName](n).reverse();
		      };
		    });

		    // Add `LazyWrapper` methods that accept an `iteratee` value.
		    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
		      var type = index + 1,
		          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

		      LazyWrapper.prototype[methodName] = function(iteratee) {
		        var result = this.clone();
		        result.__iteratees__.push({
		          'iteratee': getIteratee(iteratee, 3),
		          'type': type
		        });
		        result.__filtered__ = result.__filtered__ || isFilter;
		        return result;
		      };
		    });

		    // Add `LazyWrapper` methods for `_.head` and `_.last`.
		    arrayEach(['head', 'last'], function(methodName, index) {
		      var takeName = 'take' + (index ? 'Right' : '');

		      LazyWrapper.prototype[methodName] = function() {
		        return this[takeName](1).value()[0];
		      };
		    });

		    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
		    arrayEach(['initial', 'tail'], function(methodName, index) {
		      var dropName = 'drop' + (index ? '' : 'Right');

		      LazyWrapper.prototype[methodName] = function() {
		        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
		      };
		    });

		    LazyWrapper.prototype.compact = function() {
		      return this.filter(identity);
		    };

		    LazyWrapper.prototype.find = function(predicate) {
		      return this.filter(predicate).head();
		    };

		    LazyWrapper.prototype.findLast = function(predicate) {
		      return this.reverse().find(predicate);
		    };

		    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
		      if (typeof path == 'function') {
		        return new LazyWrapper(this);
		      }
		      return this.map(function(value) {
		        return baseInvoke(value, path, args);
		      });
		    });

		    LazyWrapper.prototype.reject = function(predicate) {
		      return this.filter(negate(getIteratee(predicate)));
		    };

		    LazyWrapper.prototype.slice = function(start, end) {
		      start = toInteger(start);

		      var result = this;
		      if (result.__filtered__ && (start > 0 || end < 0)) {
		        return new LazyWrapper(result);
		      }
		      if (start < 0) {
		        result = result.takeRight(-start);
		      } else if (start) {
		        result = result.drop(start);
		      }
		      if (end !== undefined$1) {
		        end = toInteger(end);
		        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
		      }
		      return result;
		    };

		    LazyWrapper.prototype.takeRightWhile = function(predicate) {
		      return this.reverse().takeWhile(predicate).reverse();
		    };

		    LazyWrapper.prototype.toArray = function() {
		      return this.take(MAX_ARRAY_LENGTH);
		    };

		    // Add `LazyWrapper` methods to `lodash.prototype`.
		    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
		      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
		          isTaker = /^(?:head|last)$/.test(methodName),
		          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
		          retUnwrapped = isTaker || /^find/.test(methodName);

		      if (!lodashFunc) {
		        return;
		      }
		      lodash.prototype[methodName] = function() {
		        var value = this.__wrapped__,
		            args = isTaker ? [1] : arguments,
		            isLazy = value instanceof LazyWrapper,
		            iteratee = args[0],
		            useLazy = isLazy || isArray(value);

		        var interceptor = function(value) {
		          var result = lodashFunc.apply(lodash, arrayPush([value], args));
		          return (isTaker && chainAll) ? result[0] : result;
		        };

		        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
		          // Avoid lazy use if the iteratee has a "length" value other than `1`.
		          isLazy = useLazy = false;
		        }
		        var chainAll = this.__chain__,
		            isHybrid = !!this.__actions__.length,
		            isUnwrapped = retUnwrapped && !chainAll,
		            onlyLazy = isLazy && !isHybrid;

		        if (!retUnwrapped && useLazy) {
		          value = onlyLazy ? value : new LazyWrapper(this);
		          var result = func.apply(value, args);
		          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
		          return new LodashWrapper(result, chainAll);
		        }
		        if (isUnwrapped && onlyLazy) {
		          return func.apply(this, args);
		        }
		        result = this.thru(interceptor);
		        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
		      };
		    });

		    // Add `Array` methods to `lodash.prototype`.
		    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
		      var func = arrayProto[methodName],
		          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
		          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

		      lodash.prototype[methodName] = function() {
		        var args = arguments;
		        if (retUnwrapped && !this.__chain__) {
		          var value = this.value();
		          return func.apply(isArray(value) ? value : [], args);
		        }
		        return this[chainName](function(value) {
		          return func.apply(isArray(value) ? value : [], args);
		        });
		      };
		    });

		    // Map minified method names to their real names.
		    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
		      var lodashFunc = lodash[methodName];
		      if (lodashFunc) {
		        var key = lodashFunc.name + '';
		        if (!hasOwnProperty.call(realNames, key)) {
		          realNames[key] = [];
		        }
		        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
		      }
		    });

		    realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
		      'name': 'wrapper',
		      'func': undefined$1
		    }];

		    // Add methods to `LazyWrapper`.
		    LazyWrapper.prototype.clone = lazyClone;
		    LazyWrapper.prototype.reverse = lazyReverse;
		    LazyWrapper.prototype.value = lazyValue;

		    // Add chain sequence methods to the `lodash` wrapper.
		    lodash.prototype.at = wrapperAt;
		    lodash.prototype.chain = wrapperChain;
		    lodash.prototype.commit = wrapperCommit;
		    lodash.prototype.next = wrapperNext;
		    lodash.prototype.plant = wrapperPlant;
		    lodash.prototype.reverse = wrapperReverse;
		    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

		    // Add lazy aliases.
		    lodash.prototype.first = lodash.prototype.head;

		    if (symIterator) {
		      lodash.prototype[symIterator] = wrapperToIterator;
		    }
		    return lodash;
		  });

		  /*--------------------------------------------------------------------------*/

		  // Export lodash.
		  var _ = runInContext();

		  // Some AMD build optimizers, like r.js, check for condition patterns like:
		  if (freeModule) {
		    // Export for Node.js.
		    (freeModule.exports = _)._ = _;
		    // Export for CommonJS support.
		    freeExports._ = _;
		  }
		  else {
		    // Export to the global object.
		    root._ = _;
		  }
		}.call(lodash)); 
	} (lodash$1, lodash$1.exports));
	return lodash$1.exports;
}

var account$2;
var hasRequiredAccount;

function requireAccount () {
	if (hasRequiredAccount) return account$2;
	hasRequiredAccount = 1;
	const { omitBy, isNil } = requireLodash();
	function get() {
	    return this.sendRequest("/account");
	}
	function updateConfigs(configs) {
	    return this.sendRequest("/account/configurations", null, configs, "PATCH");
	}
	function getConfigs() {
	    return this.sendRequest("/account/configurations");
	}
	function getActivities({ activityTypes, until, after, direction, date, pageSize, pageToken, }) {
	    if (Array.isArray(activityTypes)) {
	        activityTypes = activityTypes.join(",");
	    }
	    const queryParams = omitBy({
	        activity_types: activityTypes,
	        until,
	        after,
	        direction,
	        date,
	        page_size: pageSize,
	        page_token: pageToken,
	    }, isNil);
	    return this.sendRequest("/account/activities", queryParams);
	}
	function getPortfolioHistory({ date_start, date_end, period, timeframe, extended_hours, }) {
	    const queryParams = omitBy({
	        date_start,
	        date_end,
	        period,
	        timeframe,
	        extended_hours,
	    }, isNil);
	    return this.sendRequest("/account/portfolio/history", queryParams);
	}
	account$2 = {
	    get,
	    getConfigs,
	    updateConfigs,
	    getActivities,
	    getPortfolioHistory,
	};
	return account$2;
}

var position;
var hasRequiredPosition;

function requirePosition () {
	if (hasRequiredPosition) return position;
	hasRequiredPosition = 1;
	function getAll() {
	    return this.sendRequest("/positions");
	}
	function getOne(symbol) {
	    return this.sendRequest("/positions/" + symbol);
	}
	function closeAll() {
	    return this.sendRequest("/positions", null, null, "DELETE");
	}
	function closeOne(symbol) {
	    return this.sendRequest("/positions/" + symbol, null, null, "DELETE");
	}
	position = {
	    getAll,
	    getOne,
	    closeAll,
	    closeOne,
	};
	return position;
}

var dateformat;
var hasRequiredDateformat;

function requireDateformat () {
	if (hasRequiredDateformat) return dateformat;
	hasRequiredDateformat = 1;
	// certain endpoints don't accept ISO dates,
	// so to allow the user to use regular JS date objects
	// with the api, we need to convert them to strings
	function toDateString(date) {
	    if (date == null || typeof date === 'string')
	        return date;
	    const year = date.getUTCFullYear();
	    const month = numPad(date.getUTCMonth() + 1);
	    const day = numPad(date.getUTCDate());
	    return `${year}-${month}-${day}`;
	}
	function numPad(num) {
	    if (num < 10) {
	        return '0' + num;
	    }
	    return num;
	}
	dateformat = {
	    toDateString
	};
	return dateformat;
}

var calendar;
var hasRequiredCalendar;

function requireCalendar () {
	if (hasRequiredCalendar) return calendar;
	hasRequiredCalendar = 1;
	const { omitBy, isNil } = requireLodash();
	const { toDateString } = requireDateformat();
	function get({ start, end } = {}) {
	    const queryParams = omitBy({
	        start: toDateString(start),
	        end: toDateString(end),
	    }, isNil);
	    return this.sendRequest("/calendar", queryParams);
	}
	calendar = {
	    get,
	};
	return calendar;
}

var clock;
var hasRequiredClock;

function requireClock () {
	if (hasRequiredClock) return clock;
	hasRequiredClock = 1;
	function get() {
	    return this.sendRequest("/clock");
	}
	clock = {
	    get,
	};
	return clock;
}

var asset;
var hasRequiredAsset;

function requireAsset () {
	if (hasRequiredAsset) return asset;
	hasRequiredAsset = 1;
	function getAll(options = {}) {
	    return this.sendRequest("/assets", options);
	}
	function getOne(symbol) {
	    return this.sendRequest("/assets/" + symbol);
	}
	asset = {
	    getAll,
	    getOne,
	};
	return asset;
}

var order;
var hasRequiredOrder;

function requireOrder () {
	if (hasRequiredOrder) return order;
	hasRequiredOrder = 1;
	const { omitBy, isNil } = requireLodash();
	function getAll({ status, until, after, limit, direction, nested, symbols } = {}) {
	    const queryParams = omitBy({
	        status,
	        until,
	        after,
	        limit,
	        direction,
	        nested,
	        symbols
	    }, isNil);
	    return this.sendRequest("/orders", queryParams);
	}
	function getOne(id) {
	    return this.sendRequest("/orders/" + id);
	}
	function getByClientOrderId(clientOrderId) {
	    const queryParams = { client_order_id: clientOrderId };
	    return this.sendRequest("/orders:by_client_order_id", queryParams);
	}
	function post(order) {
	    return this.sendRequest("/orders", null, order, "POST");
	}
	function cancel(id) {
	    return this.sendRequest("/orders/" + id, null, null, "DELETE");
	}
	function cancelAll() {
	    return this.sendRequest("/orders", null, null, "DELETE");
	}
	function patchOrder(id, newOrder) {
	    return this.sendRequest(`/orders/${id}`, null, newOrder, "PATCH");
	}
	order = {
	    getAll,
	    getOne,
	    getByClientOrderId,
	    post,
	    patchOrder,
	    cancel,
	    cancelAll,
	};
	return order;
}

var watchlist;
var hasRequiredWatchlist;

function requireWatchlist () {
	if (hasRequiredWatchlist) return watchlist;
	hasRequiredWatchlist = 1;
	// todo: try this
	// const { omitBy, isNil } = require('lodash')
	function getAll() {
	    return this.sendRequest("/watchlists");
	}
	function getOne(id) {
	    return this.sendRequest(`/watchlists/${id}`);
	}
	function addWatchlist(name, symbols = undefined) {
	    const body = { name: name, symbols: symbols };
	    return this.sendRequest("/watchlists", null, body, "POST");
	}
	function addToWatchlist(id, symbol) {
	    const body = { symbol: symbol };
	    return this.sendRequest(`/watchlists/${id}`, null, body, "POST");
	}
	function updateWatchlist(id, newWatchList) {
	    return this.sendRequest(`/watchlists/${id}`, null, newWatchList, "PUT");
	}
	function deleteWatchlist(id) {
	    return this.sendRequest(`/watchlists/${id}`, null, null, "DELETE");
	}
	function deleteFromWatchlist(id, symbol) {
	    return this.sendRequest(`/watchlists/${id}/${symbol}`, null, null, "DELETE");
	}
	watchlist = {
	    getAll,
	    getOne,
	    addWatchlist,
	    addToWatchlist,
	    updateWatchlist,
	    deleteWatchlist,
	    deleteFromWatchlist,
	};
	return watchlist;
}

var rest_v2 = {};

var entityv2 = {};

/** Detect free variable `global` from Node.js. */

var _freeGlobal;
var hasRequired_freeGlobal;

function require_freeGlobal () {
	if (hasRequired_freeGlobal) return _freeGlobal;
	hasRequired_freeGlobal = 1;
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	_freeGlobal = freeGlobal;
	return _freeGlobal;
}

var _root;
var hasRequired_root;

function require_root () {
	if (hasRequired_root) return _root;
	hasRequired_root = 1;
	var freeGlobal = require_freeGlobal();

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	_root = root;
	return _root;
}

var _Symbol;
var hasRequired_Symbol;

function require_Symbol () {
	if (hasRequired_Symbol) return _Symbol;
	hasRequired_Symbol = 1;
	var root = require_root();

	/** Built-in value references. */
	var Symbol = root.Symbol;

	_Symbol = Symbol;
	return _Symbol;
}

var _getRawTag;
var hasRequired_getRawTag;

function require_getRawTag () {
	if (hasRequired_getRawTag) return _getRawTag;
	hasRequired_getRawTag = 1;
	var Symbol = require_Symbol();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	_getRawTag = getRawTag;
	return _getRawTag;
}

/** Used for built-in method references. */

var _objectToString;
var hasRequired_objectToString;

function require_objectToString () {
	if (hasRequired_objectToString) return _objectToString;
	hasRequired_objectToString = 1;
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	_objectToString = objectToString;
	return _objectToString;
}

var _baseGetTag;
var hasRequired_baseGetTag;

function require_baseGetTag () {
	if (hasRequired_baseGetTag) return _baseGetTag;
	hasRequired_baseGetTag = 1;
	var Symbol = require_Symbol(),
	    getRawTag = require_getRawTag(),
	    objectToString = require_objectToString();

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	_baseGetTag = baseGetTag;
	return _baseGetTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */

var isObject_1;
var hasRequiredIsObject;

function requireIsObject () {
	if (hasRequiredIsObject) return isObject_1;
	hasRequiredIsObject = 1;
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	isObject_1 = isObject;
	return isObject_1;
}

var isFunction_1;
var hasRequiredIsFunction;

function requireIsFunction () {
	if (hasRequiredIsFunction) return isFunction_1;
	hasRequiredIsFunction = 1;
	var baseGetTag = require_baseGetTag(),
	    isObject = requireIsObject();

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	isFunction_1 = isFunction;
	return isFunction_1;
}

var _coreJsData;
var hasRequired_coreJsData;

function require_coreJsData () {
	if (hasRequired_coreJsData) return _coreJsData;
	hasRequired_coreJsData = 1;
	var root = require_root();

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	_coreJsData = coreJsData;
	return _coreJsData;
}

var _isMasked;
var hasRequired_isMasked;

function require_isMasked () {
	if (hasRequired_isMasked) return _isMasked;
	hasRequired_isMasked = 1;
	var coreJsData = require_coreJsData();

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	_isMasked = isMasked;
	return _isMasked;
}

/** Used for built-in method references. */

var _toSource;
var hasRequired_toSource;

function require_toSource () {
	if (hasRequired_toSource) return _toSource;
	hasRequired_toSource = 1;
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	_toSource = toSource;
	return _toSource;
}

var _baseIsNative;
var hasRequired_baseIsNative;

function require_baseIsNative () {
	if (hasRequired_baseIsNative) return _baseIsNative;
	hasRequired_baseIsNative = 1;
	var isFunction = requireIsFunction(),
	    isMasked = require_isMasked(),
	    isObject = requireIsObject(),
	    toSource = require_toSource();

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	_baseIsNative = baseIsNative;
	return _baseIsNative;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

var _getValue;
var hasRequired_getValue;

function require_getValue () {
	if (hasRequired_getValue) return _getValue;
	hasRequired_getValue = 1;
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	_getValue = getValue;
	return _getValue;
}

var _getNative;
var hasRequired_getNative;

function require_getNative () {
	if (hasRequired_getNative) return _getNative;
	hasRequired_getNative = 1;
	var baseIsNative = require_baseIsNative(),
	    getValue = require_getValue();

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	_getNative = getNative;
	return _getNative;
}

var _defineProperty;
var hasRequired_defineProperty;

function require_defineProperty () {
	if (hasRequired_defineProperty) return _defineProperty;
	hasRequired_defineProperty = 1;
	var getNative = require_getNative();

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	_defineProperty = defineProperty;
	return _defineProperty;
}

var _baseAssignValue;
var hasRequired_baseAssignValue;

function require_baseAssignValue () {
	if (hasRequired_baseAssignValue) return _baseAssignValue;
	hasRequired_baseAssignValue = 1;
	var defineProperty = require_defineProperty();

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	_baseAssignValue = baseAssignValue;
	return _baseAssignValue;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

var _createBaseFor;
var hasRequired_createBaseFor;

function require_createBaseFor () {
	if (hasRequired_createBaseFor) return _createBaseFor;
	hasRequired_createBaseFor = 1;
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	_createBaseFor = createBaseFor;
	return _createBaseFor;
}

var _baseFor;
var hasRequired_baseFor;

function require_baseFor () {
	if (hasRequired_baseFor) return _baseFor;
	hasRequired_baseFor = 1;
	var createBaseFor = require_createBaseFor();

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	_baseFor = baseFor;
	return _baseFor;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */

var _baseTimes;
var hasRequired_baseTimes;

function require_baseTimes () {
	if (hasRequired_baseTimes) return _baseTimes;
	hasRequired_baseTimes = 1;
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	_baseTimes = baseTimes;
	return _baseTimes;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */

var isObjectLike_1;
var hasRequiredIsObjectLike;

function requireIsObjectLike () {
	if (hasRequiredIsObjectLike) return isObjectLike_1;
	hasRequiredIsObjectLike = 1;
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	isObjectLike_1 = isObjectLike;
	return isObjectLike_1;
}

var _baseIsArguments;
var hasRequired_baseIsArguments;

function require_baseIsArguments () {
	if (hasRequired_baseIsArguments) return _baseIsArguments;
	hasRequired_baseIsArguments = 1;
	var baseGetTag = require_baseGetTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	_baseIsArguments = baseIsArguments;
	return _baseIsArguments;
}

var isArguments_1;
var hasRequiredIsArguments;

function requireIsArguments () {
	if (hasRequiredIsArguments) return isArguments_1;
	hasRequiredIsArguments = 1;
	var baseIsArguments = require_baseIsArguments(),
	    isObjectLike = requireIsObjectLike();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	isArguments_1 = isArguments;
	return isArguments_1;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */

var isArray_1;
var hasRequiredIsArray;

function requireIsArray () {
	if (hasRequiredIsArray) return isArray_1;
	hasRequiredIsArray = 1;
	var isArray = Array.isArray;

	isArray_1 = isArray;
	return isArray_1;
}

var isBuffer = {exports: {}};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */

var stubFalse_1;
var hasRequiredStubFalse;

function requireStubFalse () {
	if (hasRequiredStubFalse) return stubFalse_1;
	hasRequiredStubFalse = 1;
	function stubFalse() {
	  return false;
	}

	stubFalse_1 = stubFalse;
	return stubFalse_1;
}

isBuffer.exports;

var hasRequiredIsBuffer;

function requireIsBuffer () {
	if (hasRequiredIsBuffer) return isBuffer.exports;
	hasRequiredIsBuffer = 1;
	(function (module, exports$1) {
		var root = require_root(),
		    stubFalse = requireStubFalse();

		/** Detect free variable `exports`. */
		var freeExports = exports$1 && !exports$1.nodeType && exports$1;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined;

		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

		/**
		 * Checks if `value` is a buffer.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.3.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		 * @example
		 *
		 * _.isBuffer(new Buffer(2));
		 * // => true
		 *
		 * _.isBuffer(new Uint8Array(2));
		 * // => false
		 */
		var isBuffer = nativeIsBuffer || stubFalse;

		module.exports = isBuffer; 
	} (isBuffer, isBuffer.exports));
	return isBuffer.exports;
}

/** Used as references for various `Number` constants. */

var _isIndex;
var hasRequired_isIndex;

function require_isIndex () {
	if (hasRequired_isIndex) return _isIndex;
	hasRequired_isIndex = 1;
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	_isIndex = isIndex;
	return _isIndex;
}

/** Used as references for various `Number` constants. */

var isLength_1;
var hasRequiredIsLength;

function requireIsLength () {
	if (hasRequiredIsLength) return isLength_1;
	hasRequiredIsLength = 1;
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	isLength_1 = isLength;
	return isLength_1;
}

var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;

function require_baseIsTypedArray () {
	if (hasRequired_baseIsTypedArray) return _baseIsTypedArray;
	hasRequired_baseIsTypedArray = 1;
	var baseGetTag = require_baseGetTag(),
	    isLength = requireIsLength(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	_baseIsTypedArray = baseIsTypedArray;
	return _baseIsTypedArray;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */

var _baseUnary;
var hasRequired_baseUnary;

function require_baseUnary () {
	if (hasRequired_baseUnary) return _baseUnary;
	hasRequired_baseUnary = 1;
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	_baseUnary = baseUnary;
	return _baseUnary;
}

var _nodeUtil = {exports: {}};

_nodeUtil.exports;

var hasRequired_nodeUtil;

function require_nodeUtil () {
	if (hasRequired_nodeUtil) return _nodeUtil.exports;
	hasRequired_nodeUtil = 1;
	(function (module, exports$1) {
		var freeGlobal = require_freeGlobal();

		/** Detect free variable `exports`. */
		var freeExports = exports$1 && !exports$1.nodeType && exports$1;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Detect free variable `process` from Node.js. */
		var freeProcess = moduleExports && freeGlobal.process;

		/** Used to access faster Node.js helpers. */
		var nodeUtil = (function() {
		  try {
		    // Use `util.types` for Node.js 10+.
		    var types = freeModule && freeModule.require && freeModule.require('util').types;

		    if (types) {
		      return types;
		    }

		    // Legacy `process.binding('util')` for Node.js < 10.
		    return freeProcess && freeProcess.binding && freeProcess.binding('util');
		  } catch (e) {}
		}());

		module.exports = nodeUtil; 
	} (_nodeUtil, _nodeUtil.exports));
	return _nodeUtil.exports;
}

var isTypedArray_1;
var hasRequiredIsTypedArray;

function requireIsTypedArray () {
	if (hasRequiredIsTypedArray) return isTypedArray_1;
	hasRequiredIsTypedArray = 1;
	var baseIsTypedArray = require_baseIsTypedArray(),
	    baseUnary = require_baseUnary(),
	    nodeUtil = require_nodeUtil();

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	isTypedArray_1 = isTypedArray;
	return isTypedArray_1;
}

var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;

function require_arrayLikeKeys () {
	if (hasRequired_arrayLikeKeys) return _arrayLikeKeys;
	hasRequired_arrayLikeKeys = 1;
	var baseTimes = require_baseTimes(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray(),
	    isBuffer = requireIsBuffer(),
	    isIndex = require_isIndex(),
	    isTypedArray = requireIsTypedArray();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_arrayLikeKeys = arrayLikeKeys;
	return _arrayLikeKeys;
}

/** Used for built-in method references. */

var _isPrototype;
var hasRequired_isPrototype;

function require_isPrototype () {
	if (hasRequired_isPrototype) return _isPrototype;
	hasRequired_isPrototype = 1;
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	_isPrototype = isPrototype;
	return _isPrototype;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */

var _overArg;
var hasRequired_overArg;

function require_overArg () {
	if (hasRequired_overArg) return _overArg;
	hasRequired_overArg = 1;
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	_overArg = overArg;
	return _overArg;
}

var _nativeKeys;
var hasRequired_nativeKeys;

function require_nativeKeys () {
	if (hasRequired_nativeKeys) return _nativeKeys;
	hasRequired_nativeKeys = 1;
	var overArg = require_overArg();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	_nativeKeys = nativeKeys;
	return _nativeKeys;
}

var _baseKeys;
var hasRequired_baseKeys;

function require_baseKeys () {
	if (hasRequired_baseKeys) return _baseKeys;
	hasRequired_baseKeys = 1;
	var isPrototype = require_isPrototype(),
	    nativeKeys = require_nativeKeys();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_baseKeys = baseKeys;
	return _baseKeys;
}

var isArrayLike_1;
var hasRequiredIsArrayLike;

function requireIsArrayLike () {
	if (hasRequiredIsArrayLike) return isArrayLike_1;
	hasRequiredIsArrayLike = 1;
	var isFunction = requireIsFunction(),
	    isLength = requireIsLength();

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	isArrayLike_1 = isArrayLike;
	return isArrayLike_1;
}

var keys_1;
var hasRequiredKeys;

function requireKeys () {
	if (hasRequiredKeys) return keys_1;
	hasRequiredKeys = 1;
	var arrayLikeKeys = require_arrayLikeKeys(),
	    baseKeys = require_baseKeys(),
	    isArrayLike = requireIsArrayLike();

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	keys_1 = keys;
	return keys_1;
}

var _baseForOwn;
var hasRequired_baseForOwn;

function require_baseForOwn () {
	if (hasRequired_baseForOwn) return _baseForOwn;
	hasRequired_baseForOwn = 1;
	var baseFor = require_baseFor(),
	    keys = requireKeys();

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	_baseForOwn = baseForOwn;
	return _baseForOwn;
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */

var _listCacheClear;
var hasRequired_listCacheClear;

function require_listCacheClear () {
	if (hasRequired_listCacheClear) return _listCacheClear;
	hasRequired_listCacheClear = 1;
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	_listCacheClear = listCacheClear;
	return _listCacheClear;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */

var eq_1;
var hasRequiredEq;

function requireEq () {
	if (hasRequiredEq) return eq_1;
	hasRequiredEq = 1;
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	eq_1 = eq;
	return eq_1;
}

var _assocIndexOf;
var hasRequired_assocIndexOf;

function require_assocIndexOf () {
	if (hasRequired_assocIndexOf) return _assocIndexOf;
	hasRequired_assocIndexOf = 1;
	var eq = requireEq();

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	_assocIndexOf = assocIndexOf;
	return _assocIndexOf;
}

var _listCacheDelete;
var hasRequired_listCacheDelete;

function require_listCacheDelete () {
	if (hasRequired_listCacheDelete) return _listCacheDelete;
	hasRequired_listCacheDelete = 1;
	var assocIndexOf = require_assocIndexOf();

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	_listCacheDelete = listCacheDelete;
	return _listCacheDelete;
}

var _listCacheGet;
var hasRequired_listCacheGet;

function require_listCacheGet () {
	if (hasRequired_listCacheGet) return _listCacheGet;
	hasRequired_listCacheGet = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	_listCacheGet = listCacheGet;
	return _listCacheGet;
}

var _listCacheHas;
var hasRequired_listCacheHas;

function require_listCacheHas () {
	if (hasRequired_listCacheHas) return _listCacheHas;
	hasRequired_listCacheHas = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	_listCacheHas = listCacheHas;
	return _listCacheHas;
}

var _listCacheSet;
var hasRequired_listCacheSet;

function require_listCacheSet () {
	if (hasRequired_listCacheSet) return _listCacheSet;
	hasRequired_listCacheSet = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	_listCacheSet = listCacheSet;
	return _listCacheSet;
}

var _ListCache;
var hasRequired_ListCache;

function require_ListCache () {
	if (hasRequired_ListCache) return _ListCache;
	hasRequired_ListCache = 1;
	var listCacheClear = require_listCacheClear(),
	    listCacheDelete = require_listCacheDelete(),
	    listCacheGet = require_listCacheGet(),
	    listCacheHas = require_listCacheHas(),
	    listCacheSet = require_listCacheSet();

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	_ListCache = ListCache;
	return _ListCache;
}

var _stackClear;
var hasRequired_stackClear;

function require_stackClear () {
	if (hasRequired_stackClear) return _stackClear;
	hasRequired_stackClear = 1;
	var ListCache = require_ListCache();

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	_stackClear = stackClear;
	return _stackClear;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

var _stackDelete;
var hasRequired_stackDelete;

function require_stackDelete () {
	if (hasRequired_stackDelete) return _stackDelete;
	hasRequired_stackDelete = 1;
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	_stackDelete = stackDelete;
	return _stackDelete;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

var _stackGet;
var hasRequired_stackGet;

function require_stackGet () {
	if (hasRequired_stackGet) return _stackGet;
	hasRequired_stackGet = 1;
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	_stackGet = stackGet;
	return _stackGet;
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

var _stackHas;
var hasRequired_stackHas;

function require_stackHas () {
	if (hasRequired_stackHas) return _stackHas;
	hasRequired_stackHas = 1;
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	_stackHas = stackHas;
	return _stackHas;
}

var _Map;
var hasRequired_Map;

function require_Map () {
	if (hasRequired_Map) return _Map;
	hasRequired_Map = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	_Map = Map;
	return _Map;
}

var _nativeCreate;
var hasRequired_nativeCreate;

function require_nativeCreate () {
	if (hasRequired_nativeCreate) return _nativeCreate;
	hasRequired_nativeCreate = 1;
	var getNative = require_getNative();

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	_nativeCreate = nativeCreate;
	return _nativeCreate;
}

var _hashClear;
var hasRequired_hashClear;

function require_hashClear () {
	if (hasRequired_hashClear) return _hashClear;
	hasRequired_hashClear = 1;
	var nativeCreate = require_nativeCreate();

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	_hashClear = hashClear;
	return _hashClear;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

var _hashDelete;
var hasRequired_hashDelete;

function require_hashDelete () {
	if (hasRequired_hashDelete) return _hashDelete;
	hasRequired_hashDelete = 1;
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	_hashDelete = hashDelete;
	return _hashDelete;
}

var _hashGet;
var hasRequired_hashGet;

function require_hashGet () {
	if (hasRequired_hashGet) return _hashGet;
	hasRequired_hashGet = 1;
	var nativeCreate = require_nativeCreate();

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	_hashGet = hashGet;
	return _hashGet;
}

var _hashHas;
var hasRequired_hashHas;

function require_hashHas () {
	if (hasRequired_hashHas) return _hashHas;
	hasRequired_hashHas = 1;
	var nativeCreate = require_nativeCreate();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	_hashHas = hashHas;
	return _hashHas;
}

var _hashSet;
var hasRequired_hashSet;

function require_hashSet () {
	if (hasRequired_hashSet) return _hashSet;
	hasRequired_hashSet = 1;
	var nativeCreate = require_nativeCreate();

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	_hashSet = hashSet;
	return _hashSet;
}

var _Hash;
var hasRequired_Hash;

function require_Hash () {
	if (hasRequired_Hash) return _Hash;
	hasRequired_Hash = 1;
	var hashClear = require_hashClear(),
	    hashDelete = require_hashDelete(),
	    hashGet = require_hashGet(),
	    hashHas = require_hashHas(),
	    hashSet = require_hashSet();

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	_Hash = Hash;
	return _Hash;
}

var _mapCacheClear;
var hasRequired_mapCacheClear;

function require_mapCacheClear () {
	if (hasRequired_mapCacheClear) return _mapCacheClear;
	hasRequired_mapCacheClear = 1;
	var Hash = require_Hash(),
	    ListCache = require_ListCache(),
	    Map = require_Map();

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	_mapCacheClear = mapCacheClear;
	return _mapCacheClear;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */

var _isKeyable;
var hasRequired_isKeyable;

function require_isKeyable () {
	if (hasRequired_isKeyable) return _isKeyable;
	hasRequired_isKeyable = 1;
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	_isKeyable = isKeyable;
	return _isKeyable;
}

var _getMapData;
var hasRequired_getMapData;

function require_getMapData () {
	if (hasRequired_getMapData) return _getMapData;
	hasRequired_getMapData = 1;
	var isKeyable = require_isKeyable();

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	_getMapData = getMapData;
	return _getMapData;
}

var _mapCacheDelete;
var hasRequired_mapCacheDelete;

function require_mapCacheDelete () {
	if (hasRequired_mapCacheDelete) return _mapCacheDelete;
	hasRequired_mapCacheDelete = 1;
	var getMapData = require_getMapData();

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	_mapCacheDelete = mapCacheDelete;
	return _mapCacheDelete;
}

var _mapCacheGet;
var hasRequired_mapCacheGet;

function require_mapCacheGet () {
	if (hasRequired_mapCacheGet) return _mapCacheGet;
	hasRequired_mapCacheGet = 1;
	var getMapData = require_getMapData();

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	_mapCacheGet = mapCacheGet;
	return _mapCacheGet;
}

var _mapCacheHas;
var hasRequired_mapCacheHas;

function require_mapCacheHas () {
	if (hasRequired_mapCacheHas) return _mapCacheHas;
	hasRequired_mapCacheHas = 1;
	var getMapData = require_getMapData();

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	_mapCacheHas = mapCacheHas;
	return _mapCacheHas;
}

var _mapCacheSet;
var hasRequired_mapCacheSet;

function require_mapCacheSet () {
	if (hasRequired_mapCacheSet) return _mapCacheSet;
	hasRequired_mapCacheSet = 1;
	var getMapData = require_getMapData();

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	_mapCacheSet = mapCacheSet;
	return _mapCacheSet;
}

var _MapCache;
var hasRequired_MapCache;

function require_MapCache () {
	if (hasRequired_MapCache) return _MapCache;
	hasRequired_MapCache = 1;
	var mapCacheClear = require_mapCacheClear(),
	    mapCacheDelete = require_mapCacheDelete(),
	    mapCacheGet = require_mapCacheGet(),
	    mapCacheHas = require_mapCacheHas(),
	    mapCacheSet = require_mapCacheSet();

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	_MapCache = MapCache;
	return _MapCache;
}

var _stackSet;
var hasRequired_stackSet;

function require_stackSet () {
	if (hasRequired_stackSet) return _stackSet;
	hasRequired_stackSet = 1;
	var ListCache = require_ListCache(),
	    Map = require_Map(),
	    MapCache = require_MapCache();

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	_stackSet = stackSet;
	return _stackSet;
}

var _Stack;
var hasRequired_Stack;

function require_Stack () {
	if (hasRequired_Stack) return _Stack;
	hasRequired_Stack = 1;
	var ListCache = require_ListCache(),
	    stackClear = require_stackClear(),
	    stackDelete = require_stackDelete(),
	    stackGet = require_stackGet(),
	    stackHas = require_stackHas(),
	    stackSet = require_stackSet();

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	_Stack = Stack;
	return _Stack;
}

/** Used to stand-in for `undefined` hash values. */

var _setCacheAdd;
var hasRequired_setCacheAdd;

function require_setCacheAdd () {
	if (hasRequired_setCacheAdd) return _setCacheAdd;
	hasRequired_setCacheAdd = 1;
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	_setCacheAdd = setCacheAdd;
	return _setCacheAdd;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */

var _setCacheHas;
var hasRequired_setCacheHas;

function require_setCacheHas () {
	if (hasRequired_setCacheHas) return _setCacheHas;
	hasRequired_setCacheHas = 1;
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	_setCacheHas = setCacheHas;
	return _setCacheHas;
}

var _SetCache;
var hasRequired_SetCache;

function require_SetCache () {
	if (hasRequired_SetCache) return _SetCache;
	hasRequired_SetCache = 1;
	var MapCache = require_MapCache(),
	    setCacheAdd = require_setCacheAdd(),
	    setCacheHas = require_setCacheHas();

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	_SetCache = SetCache;
	return _SetCache;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */

var _arraySome;
var hasRequired_arraySome;

function require_arraySome () {
	if (hasRequired_arraySome) return _arraySome;
	hasRequired_arraySome = 1;
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	_arraySome = arraySome;
	return _arraySome;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

var _cacheHas;
var hasRequired_cacheHas;

function require_cacheHas () {
	if (hasRequired_cacheHas) return _cacheHas;
	hasRequired_cacheHas = 1;
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	_cacheHas = cacheHas;
	return _cacheHas;
}

var _equalArrays;
var hasRequired_equalArrays;

function require_equalArrays () {
	if (hasRequired_equalArrays) return _equalArrays;
	hasRequired_equalArrays = 1;
	var SetCache = require_SetCache(),
	    arraySome = require_arraySome(),
	    cacheHas = require_cacheHas();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Check that cyclic values are equal.
	  var arrStacked = stack.get(array);
	  var othStacked = stack.get(other);
	  if (arrStacked && othStacked) {
	    return arrStacked == other && othStacked == array;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	_equalArrays = equalArrays;
	return _equalArrays;
}

var _Uint8Array;
var hasRequired_Uint8Array;

function require_Uint8Array () {
	if (hasRequired_Uint8Array) return _Uint8Array;
	hasRequired_Uint8Array = 1;
	var root = require_root();

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	_Uint8Array = Uint8Array;
	return _Uint8Array;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */

var _mapToArray;
var hasRequired_mapToArray;

function require_mapToArray () {
	if (hasRequired_mapToArray) return _mapToArray;
	hasRequired_mapToArray = 1;
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	_mapToArray = mapToArray;
	return _mapToArray;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */

var _setToArray;
var hasRequired_setToArray;

function require_setToArray () {
	if (hasRequired_setToArray) return _setToArray;
	hasRequired_setToArray = 1;
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	_setToArray = setToArray;
	return _setToArray;
}

var _equalByTag;
var hasRequired_equalByTag;

function require_equalByTag () {
	if (hasRequired_equalByTag) return _equalByTag;
	hasRequired_equalByTag = 1;
	var Symbol = require_Symbol(),
	    Uint8Array = require_Uint8Array(),
	    eq = requireEq(),
	    equalArrays = require_equalArrays(),
	    mapToArray = require_mapToArray(),
	    setToArray = require_setToArray();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	_equalByTag = equalByTag;
	return _equalByTag;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */

var _arrayPush;
var hasRequired_arrayPush;

function require_arrayPush () {
	if (hasRequired_arrayPush) return _arrayPush;
	hasRequired_arrayPush = 1;
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	_arrayPush = arrayPush;
	return _arrayPush;
}

var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;

function require_baseGetAllKeys () {
	if (hasRequired_baseGetAllKeys) return _baseGetAllKeys;
	hasRequired_baseGetAllKeys = 1;
	var arrayPush = require_arrayPush(),
	    isArray = requireIsArray();

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	_baseGetAllKeys = baseGetAllKeys;
	return _baseGetAllKeys;
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */

var _arrayFilter;
var hasRequired_arrayFilter;

function require_arrayFilter () {
	if (hasRequired_arrayFilter) return _arrayFilter;
	hasRequired_arrayFilter = 1;
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	_arrayFilter = arrayFilter;
	return _arrayFilter;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */

var stubArray_1;
var hasRequiredStubArray;

function requireStubArray () {
	if (hasRequiredStubArray) return stubArray_1;
	hasRequiredStubArray = 1;
	function stubArray() {
	  return [];
	}

	stubArray_1 = stubArray;
	return stubArray_1;
}

var _getSymbols;
var hasRequired_getSymbols;

function require_getSymbols () {
	if (hasRequired_getSymbols) return _getSymbols;
	hasRequired_getSymbols = 1;
	var arrayFilter = require_arrayFilter(),
	    stubArray = requireStubArray();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	_getSymbols = getSymbols;
	return _getSymbols;
}

var _getAllKeys;
var hasRequired_getAllKeys;

function require_getAllKeys () {
	if (hasRequired_getAllKeys) return _getAllKeys;
	hasRequired_getAllKeys = 1;
	var baseGetAllKeys = require_baseGetAllKeys(),
	    getSymbols = require_getSymbols(),
	    keys = requireKeys();

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	_getAllKeys = getAllKeys;
	return _getAllKeys;
}

var _equalObjects;
var hasRequired_equalObjects;

function require_equalObjects () {
	if (hasRequired_equalObjects) return _equalObjects;
	hasRequired_equalObjects = 1;
	var getAllKeys = require_getAllKeys();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Check that cyclic values are equal.
	  var objStacked = stack.get(object);
	  var othStacked = stack.get(other);
	  if (objStacked && othStacked) {
	    return objStacked == other && othStacked == object;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	_equalObjects = equalObjects;
	return _equalObjects;
}

var _DataView;
var hasRequired_DataView;

function require_DataView () {
	if (hasRequired_DataView) return _DataView;
	hasRequired_DataView = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');

	_DataView = DataView;
	return _DataView;
}

var _Promise;
var hasRequired_Promise;

function require_Promise () {
	if (hasRequired_Promise) return _Promise;
	hasRequired_Promise = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');

	_Promise = Promise;
	return _Promise;
}

var _Set;
var hasRequired_Set;

function require_Set () {
	if (hasRequired_Set) return _Set;
	hasRequired_Set = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	_Set = Set;
	return _Set;
}

var _WeakMap;
var hasRequired_WeakMap;

function require_WeakMap () {
	if (hasRequired_WeakMap) return _WeakMap;
	hasRequired_WeakMap = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');

	_WeakMap = WeakMap;
	return _WeakMap;
}

var _getTag;
var hasRequired_getTag;

function require_getTag () {
	if (hasRequired_getTag) return _getTag;
	hasRequired_getTag = 1;
	var DataView = require_DataView(),
	    Map = require_Map(),
	    Promise = require_Promise(),
	    Set = require_Set(),
	    WeakMap = require_WeakMap(),
	    baseGetTag = require_baseGetTag(),
	    toSource = require_toSource();

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	_getTag = getTag;
	return _getTag;
}

var _baseIsEqualDeep;
var hasRequired_baseIsEqualDeep;

function require_baseIsEqualDeep () {
	if (hasRequired_baseIsEqualDeep) return _baseIsEqualDeep;
	hasRequired_baseIsEqualDeep = 1;
	var Stack = require_Stack(),
	    equalArrays = require_equalArrays(),
	    equalByTag = require_equalByTag(),
	    equalObjects = require_equalObjects(),
	    getTag = require_getTag(),
	    isArray = requireIsArray(),
	    isBuffer = requireIsBuffer(),
	    isTypedArray = requireIsTypedArray();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	_baseIsEqualDeep = baseIsEqualDeep;
	return _baseIsEqualDeep;
}

var _baseIsEqual;
var hasRequired_baseIsEqual;

function require_baseIsEqual () {
	if (hasRequired_baseIsEqual) return _baseIsEqual;
	hasRequired_baseIsEqual = 1;
	var baseIsEqualDeep = require_baseIsEqualDeep(),
	    isObjectLike = requireIsObjectLike();

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	_baseIsEqual = baseIsEqual;
	return _baseIsEqual;
}

var _baseIsMatch;
var hasRequired_baseIsMatch;

function require_baseIsMatch () {
	if (hasRequired_baseIsMatch) return _baseIsMatch;
	hasRequired_baseIsMatch = 1;
	var Stack = require_Stack(),
	    baseIsEqual = require_baseIsEqual();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	_baseIsMatch = baseIsMatch;
	return _baseIsMatch;
}

var _isStrictComparable;
var hasRequired_isStrictComparable;

function require_isStrictComparable () {
	if (hasRequired_isStrictComparable) return _isStrictComparable;
	hasRequired_isStrictComparable = 1;
	var isObject = requireIsObject();

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	_isStrictComparable = isStrictComparable;
	return _isStrictComparable;
}

var _getMatchData;
var hasRequired_getMatchData;

function require_getMatchData () {
	if (hasRequired_getMatchData) return _getMatchData;
	hasRequired_getMatchData = 1;
	var isStrictComparable = require_isStrictComparable(),
	    keys = requireKeys();

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	_getMatchData = getMatchData;
	return _getMatchData;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

var _matchesStrictComparable;
var hasRequired_matchesStrictComparable;

function require_matchesStrictComparable () {
	if (hasRequired_matchesStrictComparable) return _matchesStrictComparable;
	hasRequired_matchesStrictComparable = 1;
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	_matchesStrictComparable = matchesStrictComparable;
	return _matchesStrictComparable;
}

var _baseMatches;
var hasRequired_baseMatches;

function require_baseMatches () {
	if (hasRequired_baseMatches) return _baseMatches;
	hasRequired_baseMatches = 1;
	var baseIsMatch = require_baseIsMatch(),
	    getMatchData = require_getMatchData(),
	    matchesStrictComparable = require_matchesStrictComparable();

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	_baseMatches = baseMatches;
	return _baseMatches;
}

var isSymbol_1;
var hasRequiredIsSymbol;

function requireIsSymbol () {
	if (hasRequiredIsSymbol) return isSymbol_1;
	hasRequiredIsSymbol = 1;
	var baseGetTag = require_baseGetTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	isSymbol_1 = isSymbol;
	return isSymbol_1;
}

var _isKey;
var hasRequired_isKey;

function require_isKey () {
	if (hasRequired_isKey) return _isKey;
	hasRequired_isKey = 1;
	var isArray = requireIsArray(),
	    isSymbol = requireIsSymbol();

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	_isKey = isKey;
	return _isKey;
}

var memoize_1;
var hasRequiredMemoize;

function requireMemoize () {
	if (hasRequiredMemoize) return memoize_1;
	hasRequiredMemoize = 1;
	var MapCache = require_MapCache();

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	memoize_1 = memoize;
	return memoize_1;
}

var _memoizeCapped;
var hasRequired_memoizeCapped;

function require_memoizeCapped () {
	if (hasRequired_memoizeCapped) return _memoizeCapped;
	hasRequired_memoizeCapped = 1;
	var memoize = requireMemoize();

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	_memoizeCapped = memoizeCapped;
	return _memoizeCapped;
}

var _stringToPath;
var hasRequired_stringToPath;

function require_stringToPath () {
	if (hasRequired_stringToPath) return _stringToPath;
	hasRequired_stringToPath = 1;
	var memoizeCapped = require_memoizeCapped();

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	_stringToPath = stringToPath;
	return _stringToPath;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

var _arrayMap;
var hasRequired_arrayMap;

function require_arrayMap () {
	if (hasRequired_arrayMap) return _arrayMap;
	hasRequired_arrayMap = 1;
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	_arrayMap = arrayMap;
	return _arrayMap;
}

var _baseToString;
var hasRequired_baseToString;

function require_baseToString () {
	if (hasRequired_baseToString) return _baseToString;
	hasRequired_baseToString = 1;
	var Symbol = require_Symbol(),
	    arrayMap = require_arrayMap(),
	    isArray = requireIsArray(),
	    isSymbol = requireIsSymbol();

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
	}

	_baseToString = baseToString;
	return _baseToString;
}

var toString_1;
var hasRequiredToString;

function requireToString () {
	if (hasRequiredToString) return toString_1;
	hasRequiredToString = 1;
	var baseToString = require_baseToString();

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	toString_1 = toString;
	return toString_1;
}

var _castPath;
var hasRequired_castPath;

function require_castPath () {
	if (hasRequired_castPath) return _castPath;
	hasRequired_castPath = 1;
	var isArray = requireIsArray(),
	    isKey = require_isKey(),
	    stringToPath = require_stringToPath(),
	    toString = requireToString();

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	_castPath = castPath;
	return _castPath;
}

var _toKey;
var hasRequired_toKey;

function require_toKey () {
	if (hasRequired_toKey) return _toKey;
	hasRequired_toKey = 1;
	var isSymbol = requireIsSymbol();

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
	}

	_toKey = toKey;
	return _toKey;
}

var _baseGet;
var hasRequired_baseGet;

function require_baseGet () {
	if (hasRequired_baseGet) return _baseGet;
	hasRequired_baseGet = 1;
	var castPath = require_castPath(),
	    toKey = require_toKey();

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	_baseGet = baseGet;
	return _baseGet;
}

var get_1;
var hasRequiredGet;

function requireGet () {
	if (hasRequiredGet) return get_1;
	hasRequiredGet = 1;
	var baseGet = require_baseGet();

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	get_1 = get;
	return get_1;
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */

var _baseHasIn;
var hasRequired_baseHasIn;

function require_baseHasIn () {
	if (hasRequired_baseHasIn) return _baseHasIn;
	hasRequired_baseHasIn = 1;
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	_baseHasIn = baseHasIn;
	return _baseHasIn;
}

var _hasPath;
var hasRequired_hasPath;

function require_hasPath () {
	if (hasRequired_hasPath) return _hasPath;
	hasRequired_hasPath = 1;
	var castPath = require_castPath(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray(),
	    isIndex = require_isIndex(),
	    isLength = requireIsLength(),
	    toKey = require_toKey();

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	_hasPath = hasPath;
	return _hasPath;
}

var hasIn_1;
var hasRequiredHasIn;

function requireHasIn () {
	if (hasRequiredHasIn) return hasIn_1;
	hasRequiredHasIn = 1;
	var baseHasIn = require_baseHasIn(),
	    hasPath = require_hasPath();

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	hasIn_1 = hasIn;
	return hasIn_1;
}

var _baseMatchesProperty;
var hasRequired_baseMatchesProperty;

function require_baseMatchesProperty () {
	if (hasRequired_baseMatchesProperty) return _baseMatchesProperty;
	hasRequired_baseMatchesProperty = 1;
	var baseIsEqual = require_baseIsEqual(),
	    get = requireGet(),
	    hasIn = requireHasIn(),
	    isKey = require_isKey(),
	    isStrictComparable = require_isStrictComparable(),
	    matchesStrictComparable = require_matchesStrictComparable(),
	    toKey = require_toKey();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	  };
	}

	_baseMatchesProperty = baseMatchesProperty;
	return _baseMatchesProperty;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */

var identity_1;
var hasRequiredIdentity;

function requireIdentity () {
	if (hasRequiredIdentity) return identity_1;
	hasRequiredIdentity = 1;
	function identity(value) {
	  return value;
	}

	identity_1 = identity;
	return identity_1;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

var _baseProperty;
var hasRequired_baseProperty;

function require_baseProperty () {
	if (hasRequired_baseProperty) return _baseProperty;
	hasRequired_baseProperty = 1;
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	_baseProperty = baseProperty;
	return _baseProperty;
}

var _basePropertyDeep;
var hasRequired_basePropertyDeep;

function require_basePropertyDeep () {
	if (hasRequired_basePropertyDeep) return _basePropertyDeep;
	hasRequired_basePropertyDeep = 1;
	var baseGet = require_baseGet();

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	_basePropertyDeep = basePropertyDeep;
	return _basePropertyDeep;
}

var property_1;
var hasRequiredProperty;

function requireProperty () {
	if (hasRequiredProperty) return property_1;
	hasRequiredProperty = 1;
	var baseProperty = require_baseProperty(),
	    basePropertyDeep = require_basePropertyDeep(),
	    isKey = require_isKey(),
	    toKey = require_toKey();

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	property_1 = property;
	return property_1;
}

var _baseIteratee;
var hasRequired_baseIteratee;

function require_baseIteratee () {
	if (hasRequired_baseIteratee) return _baseIteratee;
	hasRequired_baseIteratee = 1;
	var baseMatches = require_baseMatches(),
	    baseMatchesProperty = require_baseMatchesProperty(),
	    identity = requireIdentity(),
	    isArray = requireIsArray(),
	    property = requireProperty();

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	_baseIteratee = baseIteratee;
	return _baseIteratee;
}

var mapKeys_1;
var hasRequiredMapKeys;

function requireMapKeys () {
	if (hasRequiredMapKeys) return mapKeys_1;
	hasRequiredMapKeys = 1;
	var baseAssignValue = require_baseAssignValue(),
	    baseForOwn = require_baseForOwn(),
	    baseIteratee = require_baseIteratee();

	/**
	 * The opposite of `_.mapValues`; this method creates an object with the
	 * same values as `object` and keys generated by running each own enumerable
	 * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	 * with three arguments: (value, key, object).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.8.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Object} Returns the new mapped object.
	 * @see _.mapValues
	 * @example
	 *
	 * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	 *   return key + value;
	 * });
	 * // => { 'a1': 1, 'b2': 2 }
	 */
	function mapKeys(object, iteratee) {
	  var result = {};
	  iteratee = baseIteratee(iteratee, 3);

	  baseForOwn(object, function(value, key, object) {
	    baseAssignValue(result, iteratee(value, key, object), value);
	  });
	  return result;
	}

	mapKeys_1 = mapKeys;
	return mapKeys_1;
}

var mapValues_1;
var hasRequiredMapValues;

function requireMapValues () {
	if (hasRequiredMapValues) return mapValues_1;
	hasRequiredMapValues = 1;
	var baseAssignValue = require_baseAssignValue(),
	    baseForOwn = require_baseForOwn(),
	    baseIteratee = require_baseIteratee();

	/**
	 * Creates an object with the same keys as `object` and values generated
	 * by running each own enumerable string keyed property of `object` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, key, object).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Object} Returns the new mapped object.
	 * @see _.mapKeys
	 * @example
	 *
	 * var users = {
	 *   'fred':    { 'user': 'fred',    'age': 40 },
	 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	 * };
	 *
	 * _.mapValues(users, function(o) { return o.age; });
	 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.mapValues(users, 'age');
	 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	 */
	function mapValues(object, iteratee) {
	  var result = {};
	  iteratee = baseIteratee(iteratee, 3);

	  baseForOwn(object, function(value, key, object) {
	    baseAssignValue(result, key, iteratee(value, key, object));
	  });
	  return result;
	}

	mapValues_1 = mapValues;
	return mapValues_1;
}

var hasRequiredEntityv2;

function requireEntityv2 () {
	if (hasRequiredEntityv2) return entityv2;
	hasRequiredEntityv2 = 1;
	var __importDefault = (entityv2 && entityv2.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(entityv2, "__esModule", { value: true });
	entityv2.mergeCorporateActions = entityv2.getCorporateActionsSize = entityv2.convertCorporateActions = entityv2.NewTimeframe = entityv2.TimeFrameUnit = entityv2.AlpacaNews = entityv2.AlpacaOptionSnapshotV1Beta1 = entityv2.AlpacaOptionQuoteV1Beta1 = entityv2.AlpacaOptionTradeV1Beta1 = entityv2.AlpacaOptionBarV1Beta1 = entityv2.AlpacaCryptoOrderbook = entityv2.AlpacaCryptoSnapshot = entityv2.AlpacaCryptoBar = entityv2.AlpacaCryptoQuote = entityv2.AlpacaCryptoTrade = entityv2.AlpacaCorrectionV2 = entityv2.AlpacaCancelErrorV2 = entityv2.AlpacaLuldV2 = entityv2.AlpacaStatusV2 = entityv2.AlpacaSnapshotV2 = entityv2.AlpacaBarV2 = entityv2.AlpacaQuoteV2 = entityv2.AlpacaTradeV2 = void 0;
	const mapKeys_1 = __importDefault(requireMapKeys());
	const mapValues_1 = __importDefault(requireMapValues());
	const trade_mapping_v2 = {
	    S: "Symbol",
	    i: "ID",
	    x: "Exchange",
	    p: "Price",
	    s: "Size",
	    t: "Timestamp",
	    c: "Conditions",
	    z: "Tape",
	};
	const quote_mapping_v2 = {
	    S: "Symbol",
	    bx: "BidExchange",
	    bp: "BidPrice",
	    bs: "BidSize",
	    ax: "AskExchange",
	    ap: "AskPrice",
	    as: "AskSize",
	    t: "Timestamp",
	    c: "Conditions",
	    z: "Tape",
	};
	const bar_mapping_v2 = {
	    S: "Symbol",
	    o: "OpenPrice",
	    h: "HighPrice",
	    l: "LowPrice",
	    c: "ClosePrice",
	    v: "Volume",
	    t: "Timestamp",
	    vw: "VWAP",
	    n: "TradeCount",
	};
	const snapshot_mapping_v2 = {
	    symbol: "symbol",
	    latestTrade: "LatestTrade",
	    latestQuote: "LatestQuote",
	    minuteBar: "MinuteBar",
	    dailyBar: "DailyBar",
	    prevDailyBar: "PrevDailyBar",
	};
	const status_mapping_v2 = {
	    S: "Symbol",
	    sc: "StatusCode",
	    sm: "StatusMessage",
	    rc: "ReasonCode",
	    rm: "ReasonMessage",
	    t: "Timestamp",
	    z: "Tape",
	};
	const luld_mapping_v2 = {
	    S: "Symbol",
	    u: "LimitUpPrice",
	    d: "LimitDownPrice",
	    i: "Indicator",
	    t: "Timestamp",
	    z: "Tape",
	};
	const cancel_error_mapping_v2 = {
	    S: "Symbol",
	    i: "ID",
	    x: "Exchange",
	    p: "Price",
	    s: "Size",
	    a: "CancelErrorAction",
	    z: "Tape",
	    t: "Timestamp",
	};
	const correction_mapping_v2 = {
	    S: "Symbol",
	    x: "Exchange",
	    oi: "OriginalID",
	    op: "OriginalPrice",
	    os: "OriginalSize",
	    oc: "OriginalConditions",
	    ci: "CorrectedID",
	    cp: "CorrectedPrice",
	    cs: "CorrectedSize",
	    cc: "CorrectedConditions",
	    z: "Tape",
	    t: "Timestamp",
	};
	const crypto_trade_mapping = {
	    S: "Symbol",
	    t: "Timestamp",
	    x: "Exchange",
	    p: "Price",
	    s: "Size",
	    tks: "TakerSide",
	    i: "ID",
	};
	const crypto_quote_mapping = {
	    t: "Timestamp",
	    bp: "BidPrice",
	    bs: "BidSize",
	    ap: "AskPrice",
	    as: "AskSize",
	};
	const crypto_bar_mapping = {
	    t: "Timestamp",
	    o: "Open",
	    h: "High",
	    l: "Low",
	    c: "Close",
	    v: "Volume",
	    vw: "VWAP",
	    n: "TradeCount",
	};
	const crypto_snapshot_mapping = {
	    latestTrade: "LatestTrade",
	    latestQuote: "LatestQuote",
	    minuteBar: "MinuteBar",
	    dailyBar: "DailyBar",
	    prevDailyBar: "PrevDailyBar",
	};
	const crypto_orderbook_entry_mapping = {
	    p: "Price",
	    s: "Size",
	};
	const crypto_orderbook_mapping = {
	    t: "Timestamp",
	    b: "Bids",
	    a: "Asks",
	};
	const news_image_mapping = {
	    size: "Size",
	    url: "URL",
	};
	const news_mapping = {
	    id: "ID",
	    author: "Author",
	    created_at: "CreatedAt",
	    updated_at: "UpdatedAt",
	    headline: "Headline",
	    summary: "Summary",
	    content: "Content",
	    images: "Images",
	    url: "URL",
	    symbols: "Symbols",
	    source: "Source",
	};
	const option_bar_mapping = {
	    S: "Symbol",
	    o: "Open",
	    h: "High",
	    l: "Low",
	    c: "Close",
	    v: "Volume",
	    t: "Timestamp",
	    vw: "VWAP",
	    n: "TradeCount",
	};
	const option_tarde_mapping = {
	    S: "Symbol",
	    x: "Exchange",
	    p: "Price",
	    s: "Size",
	    t: "Timestamp",
	    c: "Condition",
	};
	const option_quote_mapping = {
	    S: "Symbol",
	    bx: "BidExchange",
	    bp: "BidPrice",
	    bs: "BidSize",
	    ax: "AskExchange",
	    ap: "AskPrice",
	    as: "AskSize",
	    t: "Timestamp",
	    c: "Conditions",
	    z: "Tape",
	};
	const option_snapshot_mapping = {
	    symbol: "symbol",
	    latestTrade: "LatestTrade",
	    latestQuote: "LatestQuote",
	    impliedVolatility: "ImpliedVolatility",
	    greeks: "Greeks",
	};
	function AlpacaTradeV2(data) {
	    return aliasObjectKey(data, trade_mapping_v2);
	}
	entityv2.AlpacaTradeV2 = AlpacaTradeV2;
	function AlpacaQuoteV2(data) {
	    return aliasObjectKey(data, quote_mapping_v2);
	}
	entityv2.AlpacaQuoteV2 = AlpacaQuoteV2;
	function AlpacaBarV2(data) {
	    return aliasObjectKey(data, bar_mapping_v2);
	}
	entityv2.AlpacaBarV2 = AlpacaBarV2;
	function AlpacaSnapshotV2(data) {
	    const snapshot = aliasObjectKey(data, snapshot_mapping_v2);
	    return (0, mapValues_1.default)(snapshot, (value, key) => {
	        return convertSnapshotData(key, value, false);
	    });
	}
	entityv2.AlpacaSnapshotV2 = AlpacaSnapshotV2;
	function AlpacaStatusV2(data) {
	    return aliasObjectKey(data, status_mapping_v2);
	}
	entityv2.AlpacaStatusV2 = AlpacaStatusV2;
	function AlpacaLuldV2(data) {
	    return aliasObjectKey(data, luld_mapping_v2);
	}
	entityv2.AlpacaLuldV2 = AlpacaLuldV2;
	function AlpacaCancelErrorV2(data) {
	    return aliasObjectKey(data, cancel_error_mapping_v2);
	}
	entityv2.AlpacaCancelErrorV2 = AlpacaCancelErrorV2;
	function AlpacaCorrectionV2(data) {
	    return aliasObjectKey(data, correction_mapping_v2);
	}
	entityv2.AlpacaCorrectionV2 = AlpacaCorrectionV2;
	function AlpacaCryptoTrade(data) {
	    return aliasObjectKey(data, crypto_trade_mapping);
	}
	entityv2.AlpacaCryptoTrade = AlpacaCryptoTrade;
	function AlpacaCryptoQuote(data) {
	    return aliasObjectKey(data, crypto_quote_mapping);
	}
	entityv2.AlpacaCryptoQuote = AlpacaCryptoQuote;
	function AlpacaCryptoBar(data) {
	    return aliasObjectKey(data, crypto_bar_mapping);
	}
	entityv2.AlpacaCryptoBar = AlpacaCryptoBar;
	function AlpacaCryptoSnapshot(data) {
	    const snapshot = aliasObjectKey(data, crypto_snapshot_mapping);
	    return (0, mapValues_1.default)(snapshot, (value, key) => {
	        return convertSnapshotData(key, value, true);
	    });
	}
	entityv2.AlpacaCryptoSnapshot = AlpacaCryptoSnapshot;
	function AlpacaCryptoOrderbook(data) {
	    const mapFn = (entries) => entries.map((entry) => aliasObjectKey(entry, crypto_orderbook_entry_mapping));
	    const orderbook = aliasObjectKey(data, crypto_orderbook_mapping);
	    return Object.assign(Object.assign({}, orderbook), { Bids: mapFn(orderbook.Bids), Asks: mapFn(orderbook.Asks) });
	}
	entityv2.AlpacaCryptoOrderbook = AlpacaCryptoOrderbook;
	function AlpacaOptionBarV1Beta1(data) {
	    return aliasObjectKey(data, option_bar_mapping);
	}
	entityv2.AlpacaOptionBarV1Beta1 = AlpacaOptionBarV1Beta1;
	function AlpacaOptionTradeV1Beta1(data) {
	    return aliasObjectKey(data, option_tarde_mapping);
	}
	entityv2.AlpacaOptionTradeV1Beta1 = AlpacaOptionTradeV1Beta1;
	function AlpacaOptionQuoteV1Beta1(data) {
	    return aliasObjectKey(data, option_quote_mapping);
	}
	entityv2.AlpacaOptionQuoteV1Beta1 = AlpacaOptionQuoteV1Beta1;
	function AlpacaOptionSnapshotV1Beta1(data) {
	    const snapshot = aliasObjectKey(data, option_snapshot_mapping);
	    return (0, mapValues_1.default)(snapshot, (value, key) => {
	        return convertOptionSnapshotData(key, value);
	    });
	}
	entityv2.AlpacaOptionSnapshotV1Beta1 = AlpacaOptionSnapshotV1Beta1;
	function aliasObjectKey(data, mapping) {
	    return (0, mapKeys_1.default)(data, (_value, key) => {
	        return Object.hasOwn(mapping, key) ? mapping[key] : key;
	    });
	}
	function convertSnapshotData(key, data, isCrypto) {
	    switch (key) {
	        case "LatestTrade":
	            return isCrypto ? AlpacaCryptoTrade(data) : AlpacaTradeV2(data);
	        case "LatestQuote":
	            return isCrypto ? AlpacaCryptoQuote(data) : AlpacaQuoteV2(data);
	        case "MinuteBar":
	        case "DailyBar":
	        case "PrevDailyBar":
	            return isCrypto ? AlpacaCryptoBar(data) : AlpacaBarV2(data);
	        default:
	            return data;
	    }
	}
	function convertOptionSnapshotData(key, data) {
	    switch (key) {
	        case "LatestTrade":
	            return AlpacaOptionTradeV1Beta1(data);
	        case "LatestQuote":
	            return AlpacaOptionQuoteV1Beta1(data);
	        default:
	            return data;
	    }
	}
	function AlpacaNews(data) {
	    const mappedNews = aliasObjectKey(data, news_mapping);
	    if (mappedNews.Images) {
	        mappedNews.Images.forEach((element) => {
	            return aliasObjectKey(element, news_image_mapping);
	        });
	    }
	    return mappedNews;
	}
	entityv2.AlpacaNews = AlpacaNews;
	var TimeFrameUnit;
	(function (TimeFrameUnit) {
	    TimeFrameUnit["MIN"] = "Min";
	    TimeFrameUnit["HOUR"] = "Hour";
	    TimeFrameUnit["DAY"] = "Day";
	    TimeFrameUnit["WEEK"] = "Week";
	    TimeFrameUnit["MONTH"] = "Month";
	})(TimeFrameUnit || (entityv2.TimeFrameUnit = TimeFrameUnit = {}));
	function NewTimeframe(amount, unit) {
	    if (amount <= 0) {
	        throw new Error("amount must be a positive integer value");
	    }
	    if (unit == TimeFrameUnit.MIN && amount > 59) {
	        throw new Error("minute timeframe can only be used with amount between 1-59");
	    }
	    if (unit == TimeFrameUnit.HOUR && amount > 23) {
	        throw new Error("hour timeframe can only be used with amounts 1-23");
	    }
	    if ((unit == TimeFrameUnit.DAY || unit == TimeFrameUnit.WEEK) && amount != 1) {
	        throw new Error("day and week timeframes can only be used with amount 1");
	    }
	    if (unit == TimeFrameUnit.MONTH && ![1, 2, 3, 6, 12].includes(amount)) {
	        throw new Error("month timeframe can only be used with amount 1, 2, 3, 6 and 12");
	    }
	    return `${amount}${unit}`;
	}
	entityv2.NewTimeframe = NewTimeframe;
	const cash_dividend_mapping = {
	    ex_date: "ExDate",
	    foreign: "Foreign",
	    payable_date: "PayableDate",
	    process_date: "ProcessDate",
	    rate: "Rate",
	    record_date: "RecordDate",
	    special: "Special",
	    symbol: "Symbol",
	};
	const reverse_split_mapping = {
	    ex_date: "ExDate",
	    new_rate: "NewRate",
	    old_rate: "OldRate",
	    payable_date: "PayableDate",
	    process_date: "ProcessDate",
	    record_date: "RecordDate",
	    symbol: "Symbol",
	};
	const forward_split_mapping = {
	    due_bill_redemption_date: "DueBillRedemptionDate",
	    ex_date: "ExDate",
	    new_rate: "NewRate",
	    old_rate: "OldRate",
	    payable_date: "PayableDate",
	    process_date: "ProcessDate",
	    record_date: "RecordDate",
	    symbol: "Symbol",
	};
	const unit_split_mapping = {
	    alternate_rate: "AlternateRate",
	    alternate_symbol: "AlternateSymbol",
	    effective_date: "EffectiveDate",
	    new_rate: "NewRate",
	    new_symbol: "NewSymbol",
	    old_rate: "OldRate",
	    old_symbol: "OldSymbol",
	    process_date: "ProcessDate",
	};
	const cash_merger_mapping = {
	    acquiree_symbol: "AcquireeSymbol",
	    acquirer_symbol: "AcquirerSymbol",
	    effective_date: "EffectiveDate",
	    process_date: "ProcessDate",
	    rate: "Rate",
	};
	const stock_merger_mapping = {
	    acquiree_rate: "AcquireeRate",
	    acquiree_symbol: "AcquireeSymbol",
	    acquirer_rate: "AcquirerRate",
	    acquirer_symbol: "AcquirerSymbol",
	    effective_date: "EffectiveDate",
	    payable_date: "PayableDate",
	    process_date: "ProcessDate",
	};
	const stock_and_cash_merger_mapping = {
	    stock_merger_mapping,
	    cash_rate: "CashRate",
	};
	const stock_dividends_mapping = {
	    ex_date: "ExDate",
	    payable_date: "PayableDate",
	    process_date: "ProcessDate",
	    rate: "Rate",
	    record_date: "RecordDate",
	    symbol: "Symbol",
	};
	const redemption_mapping = {
	    payable_date: "PayableDate",
	    process_date: "ProcessDate",
	    rate: "Rate",
	    symbol: "Symbol",
	};
	const spin_off_mapping = {
	    ex_date: "ExDate",
	    new_rate: "NewRate",
	    new_symbol: "NewSymbol",
	    process_date: "ProcessDate",
	    record_date: "RecordDate",
	    source_rate: "Rate",
	    source_symbol: "SourceSymbol",
	};
	const name_change_mapping = {
	    new_symbol: "NewSymbol",
	    old_symbol: "OldSymbol",
	    process_date: "ProcessDate",
	};
	const worthless_removal_mapping = {
	    symbol: "Symbol",
	    process_date: "ProcessDate",
	};
	const rights_distribution_mapping = {
	    source_symbol: "SourceSymbol",
	    new_symbol: "NewSymbol",
	    rate: "Rate",
	    process_date: "ProcessDate",
	    ex_date: "ExDate",
	    payable_date: "PayableDate",
	    record_date: "RecordDate",
	    expiration_date: "ExpirationDate",
	};
	function convertCorporateActions(data) {
	    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
	    let cas = {};
	    if (((_a = data.cash_dividends) === null || _a === void 0 ? void 0 : _a.length) > 0) {
	        cas.CashDividends = cas.CashDividends ? cas.CashDividends : Array();
	        data.cash_dividends.forEach((cd) => {
	            cas.CashDividends.push(aliasObjectKey(cd, cash_dividend_mapping));
	        });
	    }
	    if (((_b = data.reverse_splits) === null || _b === void 0 ? void 0 : _b.length) > 0) {
	        cas.ReverseSplits = cas.ReverseSplits ? cas.ReverseSplits : Array();
	        data.reverse_splits.forEach((rs) => {
	            cas.ReverseSplits.push(aliasObjectKey(rs, reverse_split_mapping));
	        });
	    }
	    if (((_c = data.forward_splits) === null || _c === void 0 ? void 0 : _c.length) > 0) {
	        cas.ForwardSplits = cas.ForwardSplits ? cas.ForwardSplits : Array();
	        data.forward_splits.forEach((fs) => {
	            cas.ForwardSplits.push(aliasObjectKey(fs, forward_split_mapping));
	        });
	    }
	    if (((_d = data.unit_splits) === null || _d === void 0 ? void 0 : _d.length) > 0) {
	        cas.UnitSplits = cas.UnitSplits ? cas.UnitSplits : Array();
	        data.unit_splits.forEach((fs) => {
	            cas.UnitSplits.push(aliasObjectKey(fs, unit_split_mapping));
	        });
	    }
	    if (((_e = data.cash_mergers) === null || _e === void 0 ? void 0 : _e.length) > 0) {
	        cas.CashMergers = cas.CashMergers ? cas.CashMergers : Array();
	        data.cash_mergers.forEach((cm) => {
	            cas.CashMergers.push(aliasObjectKey(cm, cash_merger_mapping));
	        });
	    }
	    if (((_f = data.stock_mergers) === null || _f === void 0 ? void 0 : _f.length) > 0) {
	        cas.StockMergers = cas.StockMergers ? cas.StockMergers : Array();
	        data.stock_mergers.forEach((sm) => {
	            cas.StockMergers.push(aliasObjectKey(sm, stock_merger_mapping));
	        });
	    }
	    if (((_g = data.stock_and_cash_mergers) === null || _g === void 0 ? void 0 : _g.length) > 0) {
	        cas.StockAndCashMerger = cas.StockAndCashMerger
	            ? cas.StockAndCashMerger
	            : Array();
	        data.stock_and_cash_mergers.forEach((scm) => {
	            cas.StockAndCashMerger.push(aliasObjectKey(scm, stock_and_cash_merger_mapping));
	        });
	    }
	    if (((_h = data.stock_dividends) === null || _h === void 0 ? void 0 : _h.length) > 0) {
	        cas.StockDividends = cas.StockDividends
	            ? cas.StockDividends
	            : Array();
	        data.stock_dividends.forEach((sd) => {
	            cas.StockDividends.push(aliasObjectKey(sd, stock_dividends_mapping));
	        });
	    }
	    if (((_j = data.redemptions) === null || _j === void 0 ? void 0 : _j.length) > 0) {
	        cas.Redemptions = cas.Redemptions ? cas.Redemptions : Array();
	        data.redemptions.forEach((r) => {
	            cas.Redemptions.push(aliasObjectKey(r, redemption_mapping));
	        });
	    }
	    if (((_k = data.spin_offs) === null || _k === void 0 ? void 0 : _k.length) > 0) {
	        cas.SpinOffs = cas.SpinOffs ? cas.SpinOffs : Array();
	        data.spin_offs.forEach((so) => {
	            cas.SpinOffs.push(aliasObjectKey(so, spin_off_mapping));
	        });
	    }
	    if (((_l = data.name_changes) === null || _l === void 0 ? void 0 : _l.length) > 0) {
	        cas.NameChanges = cas.NameChanges ? cas.NameChanges : Array();
	        data.name_changes.forEach((nc) => {
	            cas.NameChanges.push(aliasObjectKey(nc, name_change_mapping));
	        });
	    }
	    if (((_m = data.worthless_removals) === null || _m === void 0 ? void 0 : _m.length) > 0) {
	        cas.WorthlessRemovals = cas.WorthlessRemovals
	            ? cas.WorthlessRemovals
	            : Array();
	        data.worthless_removals.forEach((wr) => {
	            cas.WorthlessRemovals.push(aliasObjectKey(wr, worthless_removal_mapping));
	        });
	    }
	    if (((_o = data.rights_distributions) === null || _o === void 0 ? void 0 : _o.length) > 0) {
	        cas.RightsDistributions = cas.RightsDistributions
	            ? cas.RightsDistributions
	            : Array();
	        data.rights_distributions.forEach((rd) => {
	            cas.RightsDistributions.push(aliasObjectKey(rd, rights_distribution_mapping));
	        });
	    }
	    return cas;
	}
	entityv2.convertCorporateActions = convertCorporateActions;
	function getCorporateActionsSize(cas) {
	    let sum = 0;
	    for (const key in cas) {
	        sum += cas[key]
	            ? cas[key].length
	            : 0;
	    }
	    return sum;
	}
	entityv2.getCorporateActionsSize = getCorporateActionsSize;
	function mergeCorporateActions(ca1, ca2) {
	    return {
	        CashDividends: (ca1.CashDividends || []).concat(ca2.CashDividends || []),
	        ReverseSplits: (ca1.ReverseSplits || []).concat(ca2.ReverseSplits || []),
	        ForwardSplits: (ca1.ForwardSplits || []).concat(ca2.ForwardSplits || []),
	        UnitSplits: (ca1.UnitSplits || []).concat(ca2.UnitSplits || []),
	        CashMergers: (ca1.CashMergers || []).concat(ca2.CashMergers || []),
	        StockMergers: (ca1.StockMergers || []).concat(ca2.StockMergers || []),
	        StockAndCashMerger: (ca1.StockAndCashMerger || []).concat(ca2.StockAndCashMerger || []),
	        StockDividends: (ca1.StockDividends || []).concat(ca2.StockDividends || []),
	        Redemptions: (ca1.Redemptions || []).concat(ca2.Redemptions || []),
	        SpinOffs: (ca1.SpinOffs || []).concat(ca2.SpinOffs || []),
	        NameChanges: (ca1.NameChanges || []).concat(ca2.NameChanges || []),
	        WorthlessRemovals: (ca1.WorthlessRemovals || []).concat(ca2.WorthlessRemovals || []),
	        RightsDistributions: (ca1.RightsDistributions || []).concat(ca2.RightsDistributions || []),
	    };
	}
	entityv2.mergeCorporateActions = mergeCorporateActions;
	return entityv2;
}

var hasRequiredRest_v2;

function requireRest_v2 () {
	if (hasRequiredRest_v2) return rest_v2;
	hasRequiredRest_v2 = 1;
	var __awaiter = (rest_v2 && rest_v2.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __await = (rest_v2 && rest_v2.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); };
	var __asyncGenerator = (rest_v2 && rest_v2.__asyncGenerator) || function (thisArg, _arguments, generator) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var g = generator.apply(thisArg, _arguments || []), i, q = [];
	    return i = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
	    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
	    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
	    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
	    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
	    function fulfill(value) { resume("next", value); }
	    function reject(value) { resume("throw", value); }
	    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
	};
	var __asyncValues = (rest_v2 && rest_v2.__asyncValues) || function (o) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var m = o[Symbol.asyncIterator], i;
	    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
	    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
	    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
	};
	var __importDefault = (rest_v2 && rest_v2.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(rest_v2, "__esModule", { value: true });
	rest_v2.getCorporateActions = rest_v2.getOptionChain = rest_v2.getOptionSnapshots = rest_v2.getLatestOptionQuotes = rest_v2.getLatestOptionTrades = rest_v2.getMultiOptionTradesAsync = rest_v2.getMultiOptionTrades = rest_v2.getMultiOptionBarsAsync = rest_v2.getMultiOptionBars = rest_v2.getNews = rest_v2.Sort = rest_v2.getLatestCryptoOrderbooks = rest_v2.getCryptoSnapshots = rest_v2.getLatestCryptoQuotes = rest_v2.getLatestCryptoTrades = rest_v2.getLatestCryptoBars = rest_v2.getCryptoBars = rest_v2.getCryptoQuotes = rest_v2.getCryptoTrades = rest_v2.getSnapshots = rest_v2.getSnapshot = rest_v2.getLatestBars = rest_v2.getLatestBar = rest_v2.getLatestQuotes = rest_v2.getLatestQuote = rest_v2.getLatestTrades = rest_v2.getLatestTrade = rest_v2.getMultiBarsAsync = rest_v2.getMultiBars = rest_v2.getBars = rest_v2.getMultiQuotesAsync = rest_v2.getMultiQuotes = rest_v2.getQuotes = rest_v2.getMultiTradesAsync = rest_v2.getMultiTrades = rest_v2.getTrades = rest_v2.getMultiDataV2 = rest_v2.getDataV2 = rest_v2.dataV2HttpRequest = rest_v2.TYPE = rest_v2.Adjustment = void 0;
	const axios_1 = __importDefault(requireAxios());
	const entityv2_1 = requireEntityv2();
	// Number of data points to return.
	const V2_MAX_LIMIT = 10000;
	const V2_NEWS_MAX_LIMIT = 50;
	const V1_BETA1_MAX_LIMIT = 1000;
	var Adjustment;
	(function (Adjustment) {
	    Adjustment["RAW"] = "raw";
	    Adjustment["DIVIDEND"] = "dividend";
	    Adjustment["SPLIT"] = "split";
	    Adjustment["ALL"] = "all";
	})(Adjustment || (rest_v2.Adjustment = Adjustment = {}));
	var TYPE;
	(function (TYPE) {
	    TYPE["TRADES"] = "trades";
	    TYPE["QUOTES"] = "quotes";
	    TYPE["BARS"] = "bars";
	    TYPE["SNAPSHOTS"] = "snapshots";
	})(TYPE || (rest_v2.TYPE = TYPE = {}));
	function dataV2HttpRequest(url, queryParams, config) {
	    const { dataBaseUrl, keyId, secretKey, oauth } = config;
	    const headers = {
	        "Content-Type": "application/json",
	        "Accept-Encoding": "gzip",
	    };
	    if (oauth == "") {
	        headers["APCA-API-KEY-ID"] = keyId;
	        headers["APCA-API-SECRET-KEY"] = secretKey;
	    }
	    else {
	        headers["Authorization"] = "Bearer " + oauth;
	    }
	    return axios_1.default
	        .get(`${dataBaseUrl}${url}`, {
	        params: queryParams,
	        headers: headers,
	    })
	        .catch((err) => {
	        var _a, _b;
	        throw new Error(`code: ${((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) || err.statusCode}, message: ${(_b = err.response) === null || _b === void 0 ? void 0 : _b.data.message}`);
	    });
	}
	rest_v2.dataV2HttpRequest = dataV2HttpRequest;
	function getQueryLimit(totalLimit, pageLimit, received) {
	    let limit = 0;
	    if (pageLimit !== 0) {
	        limit = pageLimit;
	    }
	    if (totalLimit !== 0) {
	        const remaining = totalLimit - received;
	        if (remaining <= 0) {
	            // this should never happen
	            return -1;
	        }
	        if (limit == 0 || limit > remaining) {
	            limit = remaining;
	        }
	    }
	    return limit;
	}
	function getDataV2(endpoint, path, options, config) {
	    return __asyncGenerator(this, arguments, function* getDataV2_1() {
	        var _a;
	        let pageToken = null;
	        let received = 0;
	        const pageLimit = options.pageLimit
	            ? Math.min(options.pageLimit, V2_MAX_LIMIT)
	            : V2_MAX_LIMIT;
	        delete options.pageLimit;
	        options.limit = (_a = options.limit) !== null && _a !== void 0 ? _a : 0;
	        while (options.limit > received || options.limit === 0) {
	            let limit;
	            if (options.limit !== 0) {
	                limit = getQueryLimit(options.limit, pageLimit, received);
	                if (limit == -1) {
	                    break;
	                }
	            }
	            else {
	                limit = null;
	            }
	            const resp = yield __await(dataV2HttpRequest(path, Object.assign(Object.assign({}, options), { limit, page_token: pageToken }), config));
	            const items = resp.data[endpoint] || [];
	            for (const item of items) {
	                yield yield __await(item);
	            }
	            received += items.length;
	            pageToken = resp.data.next_page_token;
	            if (!pageToken) {
	                break;
	            }
	        }
	    });
	}
	rest_v2.getDataV2 = getDataV2;
	function getMultiDataV2(symbols, url, endpoint, options, config) {
	    return __asyncGenerator(this, arguments, function* getMultiDataV2_1() {
	        var _a;
	        let pageToken = null;
	        let received = 0;
	        const pageLimit = options.pageLimit
	            ? Math.min(options.pageLimit, V2_MAX_LIMIT)
	            : V2_MAX_LIMIT;
	        delete options.pageLimit;
	        options.limit = (_a = options.limit) !== null && _a !== void 0 ? _a : 0;
	        while (options.limit > received || options.limit === 0) {
	            const limit = getQueryLimit(options.limit, pageLimit, received);
	            if (limit == -1) {
	                break;
	            }
	            const params = Object.assign(Object.assign({}, options), { symbols: symbols.join(","), limit: limit, page_token: pageToken });
	            const resp = yield __await(dataV2HttpRequest(`${url}${endpoint}`, params, config));
	            const items = resp.data[endpoint];
	            for (const symbol in items) {
	                for (const data of items[symbol]) {
	                    received++;
	                    yield yield __await({ symbol: symbol, data: data });
	                }
	            }
	            pageToken = resp.data.next_page_token;
	            if (!pageToken) {
	                break;
	            }
	        }
	    });
	}
	rest_v2.getMultiDataV2 = getMultiDataV2;
	function getTrades(symbol, options, config) {
	    return __asyncGenerator(this, arguments, function* getTrades_1() {
	        var _a, e_1, _b, _c;
	        const trades = getDataV2(TYPE.TRADES, `/v2/stocks/${symbol}/${TYPE.TRADES}`, options, config);
	        try {
	            for (var _d = true, trades_1 = __asyncValues(trades), trades_1_1; trades_1_1 = yield __await(trades_1.next()), _a = trades_1_1.done, !_a; _d = true) {
	                _c = trades_1_1.value;
	                _d = false;
	                const trade = _c;
	                yield yield __await((0, entityv2_1.AlpacaTradeV2)(trade));
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = trades_1.return)) yield __await(_b.call(trades_1));
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	    });
	}
	rest_v2.getTrades = getTrades;
	function getMultiTrades(symbols, options, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        var _a, e_2, _b, _c;
	        const multiTrades = getMultiTradesAsync(symbols, options, config);
	        const trades = new Map();
	        try {
	            for (var _d = true, multiTrades_1 = __asyncValues(multiTrades), multiTrades_1_1; multiTrades_1_1 = yield multiTrades_1.next(), _a = multiTrades_1_1.done, !_a; _d = true) {
	                _c = multiTrades_1_1.value;
	                _d = false;
	                const t = _c;
	                const items = trades.get(t.Symbol) || new Array();
	                trades.set(t.Symbol, [...items, t]);
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = multiTrades_1.return)) yield _b.call(multiTrades_1);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	        return trades;
	    });
	}
	rest_v2.getMultiTrades = getMultiTrades;
	function getMultiTradesAsync(symbols, options, config) {
	    return __asyncGenerator(this, arguments, function* getMultiTradesAsync_1() {
	        var _a, e_3, _b, _c;
	        const multiTrades = getMultiDataV2(symbols, "/v2/stocks/", TYPE.TRADES, options, config);
	        try {
	            for (var _d = true, multiTrades_2 = __asyncValues(multiTrades), multiTrades_2_1; multiTrades_2_1 = yield __await(multiTrades_2.next()), _a = multiTrades_2_1.done, !_a; _d = true) {
	                _c = multiTrades_2_1.value;
	                _d = false;
	                const t = _c;
	                t.data = Object.assign(Object.assign({}, t.data), { S: t.symbol });
	                yield yield __await((0, entityv2_1.AlpacaTradeV2)(t.data));
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = multiTrades_2.return)) yield __await(_b.call(multiTrades_2));
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	    });
	}
	rest_v2.getMultiTradesAsync = getMultiTradesAsync;
	function getQuotes(symbol, options, config) {
	    return __asyncGenerator(this, arguments, function* getQuotes_1() {
	        var _a, e_4, _b, _c;
	        const quotes = getDataV2(TYPE.QUOTES, `/v2/stocks/${symbol}/${TYPE.QUOTES}`, options, config);
	        try {
	            for (var _d = true, quotes_1 = __asyncValues(quotes), quotes_1_1; quotes_1_1 = yield __await(quotes_1.next()), _a = quotes_1_1.done, !_a; _d = true) {
	                _c = quotes_1_1.value;
	                _d = false;
	                const quote = _c;
	                yield yield __await((0, entityv2_1.AlpacaQuoteV2)(quote));
	            }
	        }
	        catch (e_4_1) { e_4 = { error: e_4_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = quotes_1.return)) yield __await(_b.call(quotes_1));
	            }
	            finally { if (e_4) throw e_4.error; }
	        }
	    });
	}
	rest_v2.getQuotes = getQuotes;
	function getMultiQuotes(symbols, options, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        var _a, e_5, _b, _c;
	        const multiQuotes = getMultiQuotesAsync(symbols, options, config);
	        const quotes = new Map();
	        try {
	            for (var _d = true, multiQuotes_1 = __asyncValues(multiQuotes), multiQuotes_1_1; multiQuotes_1_1 = yield multiQuotes_1.next(), _a = multiQuotes_1_1.done, !_a; _d = true) {
	                _c = multiQuotes_1_1.value;
	                _d = false;
	                const q = _c;
	                const items = quotes.get(q.Symbol) || new Array();
	                quotes.set(q.Symbol, [...items, q]);
	            }
	        }
	        catch (e_5_1) { e_5 = { error: e_5_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = multiQuotes_1.return)) yield _b.call(multiQuotes_1);
	            }
	            finally { if (e_5) throw e_5.error; }
	        }
	        return quotes;
	    });
	}
	rest_v2.getMultiQuotes = getMultiQuotes;
	function getMultiQuotesAsync(symbols, options, config) {
	    return __asyncGenerator(this, arguments, function* getMultiQuotesAsync_1() {
	        var _a, e_6, _b, _c;
	        const multiQuotes = getMultiDataV2(symbols, "/v2/stocks/", TYPE.QUOTES, options, config);
	        try {
	            for (var _d = true, multiQuotes_2 = __asyncValues(multiQuotes), multiQuotes_2_1; multiQuotes_2_1 = yield __await(multiQuotes_2.next()), _a = multiQuotes_2_1.done, !_a; _d = true) {
	                _c = multiQuotes_2_1.value;
	                _d = false;
	                const q = _c;
	                q.data = Object.assign(Object.assign({}, q.data), { S: q.symbol });
	                yield yield __await((0, entityv2_1.AlpacaQuoteV2)(q.data));
	            }
	        }
	        catch (e_6_1) { e_6 = { error: e_6_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = multiQuotes_2.return)) yield __await(_b.call(multiQuotes_2));
	            }
	            finally { if (e_6) throw e_6.error; }
	        }
	    });
	}
	rest_v2.getMultiQuotesAsync = getMultiQuotesAsync;
	function getBars(symbol, options, config) {
	    return __asyncGenerator(this, arguments, function* getBars_1() {
	        var _a, e_7, _b, _c;
	        const bars = getDataV2(TYPE.BARS, `/v2/stocks/${symbol}/${TYPE.BARS}`, options, config);
	        try {
	            for (var _d = true, _e = __asyncValues(bars || []), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
	                _c = _f.value;
	                _d = false;
	                const bar = _c;
	                yield yield __await((0, entityv2_1.AlpacaBarV2)(bar));
	            }
	        }
	        catch (e_7_1) { e_7 = { error: e_7_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
	            }
	            finally { if (e_7) throw e_7.error; }
	        }
	    });
	}
	rest_v2.getBars = getBars;
	function getMultiBars(symbols, options, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        var _a, e_8, _b, _c;
	        const multiBars = getMultiBarsAsync(symbols, options, config);
	        const bars = new Map();
	        try {
	            for (var _d = true, multiBars_1 = __asyncValues(multiBars), multiBars_1_1; multiBars_1_1 = yield multiBars_1.next(), _a = multiBars_1_1.done, !_a; _d = true) {
	                _c = multiBars_1_1.value;
	                _d = false;
	                const b = _c;
	                const items = bars.get(b.Symbol) || new Array();
	                bars.set(b.Symbol, [...items, b]);
	            }
	        }
	        catch (e_8_1) { e_8 = { error: e_8_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = multiBars_1.return)) yield _b.call(multiBars_1);
	            }
	            finally { if (e_8) throw e_8.error; }
	        }
	        return bars;
	    });
	}
	rest_v2.getMultiBars = getMultiBars;
	function getMultiBarsAsync(symbols, options, config) {
	    return __asyncGenerator(this, arguments, function* getMultiBarsAsync_1() {
	        var _a, e_9, _b, _c;
	        const multiBars = getMultiDataV2(symbols, "/v2/stocks/", TYPE.BARS, options, config);
	        try {
	            for (var _d = true, multiBars_2 = __asyncValues(multiBars), multiBars_2_1; multiBars_2_1 = yield __await(multiBars_2.next()), _a = multiBars_2_1.done, !_a; _d = true) {
	                _c = multiBars_2_1.value;
	                _d = false;
	                const b = _c;
	                b.data = Object.assign(Object.assign({}, b.data), { S: b.symbol });
	                yield yield __await((0, entityv2_1.AlpacaBarV2)(b.data));
	            }
	        }
	        catch (e_9_1) { e_9 = { error: e_9_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = multiBars_2.return)) yield __await(_b.call(multiBars_2));
	            }
	            finally { if (e_9) throw e_9.error; }
	        }
	    });
	}
	rest_v2.getMultiBarsAsync = getMultiBarsAsync;
	function getLatestTrade(symbol, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const resp = yield dataV2HttpRequest(`/v2/stocks/${symbol}/trades/latest`, {}, config);
	        return (0, entityv2_1.AlpacaTradeV2)(resp.data.trade);
	    });
	}
	rest_v2.getLatestTrade = getLatestTrade;
	function getLatestTrades(symbols, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const resp = yield dataV2HttpRequest(`/v2/stocks/${TYPE.TRADES}/latest`, { symbols: symbols.join(",") }, config);
	        const multiLatestTrades = resp.data.trades;
	        const multiLatestTradesResp = new Map();
	        for (const symbol in multiLatestTrades) {
	            multiLatestTradesResp.set(symbol, (0, entityv2_1.AlpacaTradeV2)(Object.assign({ S: symbol }, multiLatestTrades[symbol])));
	        }
	        return multiLatestTradesResp;
	    });
	}
	rest_v2.getLatestTrades = getLatestTrades;
	function getLatestQuote(symbol, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const resp = yield dataV2HttpRequest(`/v2/stocks/${symbol}/quotes/latest`, {}, config);
	        return (0, entityv2_1.AlpacaQuoteV2)(resp.data.quote);
	    });
	}
	rest_v2.getLatestQuote = getLatestQuote;
	function getLatestQuotes(symbols, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const resp = yield dataV2HttpRequest(`/v2/stocks/${TYPE.QUOTES}/latest`, { symbols: symbols.join(",") }, config);
	        const multiLatestQuotes = resp.data.quotes;
	        const multiLatestQuotesResp = new Map();
	        for (const symbol in multiLatestQuotes) {
	            multiLatestQuotesResp.set(symbol, (0, entityv2_1.AlpacaQuoteV2)(Object.assign({ S: symbol }, multiLatestQuotes[symbol])));
	        }
	        return multiLatestQuotesResp;
	    });
	}
	rest_v2.getLatestQuotes = getLatestQuotes;
	function getLatestBar(symbol, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const resp = yield dataV2HttpRequest(`/v2/stocks/${symbol}/bars/latest`, {}, config);
	        return (0, entityv2_1.AlpacaBarV2)(resp.data.bar);
	    });
	}
	rest_v2.getLatestBar = getLatestBar;
	function getLatestBars(symbols, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const resp = yield dataV2HttpRequest(`/v2/stocks/${TYPE.BARS}/latest`, { symbols: symbols.join(",") }, config);
	        const multiLatestBars = resp.data.bars;
	        const multiLatestBarsResp = new Map();
	        for (const symbol in multiLatestBars) {
	            multiLatestBarsResp.set(symbol, (0, entityv2_1.AlpacaBarV2)(Object.assign({ S: symbol }, multiLatestBars[symbol])));
	        }
	        return multiLatestBarsResp;
	    });
	}
	rest_v2.getLatestBars = getLatestBars;
	function getSnapshot(symbol, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const resp = yield dataV2HttpRequest(`/v2/stocks/${symbol}/snapshot`, {}, config);
	        return (0, entityv2_1.AlpacaSnapshotV2)(resp.data);
	    });
	}
	rest_v2.getSnapshot = getSnapshot;
	function getSnapshots(symbols, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const resp = yield dataV2HttpRequest(`/v2/stocks/snapshots?symbols=${symbols.join(",")}`, {}, config);
	        const result = Object.entries(resp.data).map(([key, val]) => {
	            return (0, entityv2_1.AlpacaSnapshotV2)(Object.assign({ symbol: key }, val));
	        });
	        return result;
	    });
	}
	rest_v2.getSnapshots = getSnapshots;
	function getCryptoTrades(symbols, options, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        var _a, e_10, _b, _c;
	        const cryptoTrades = getMultiDataV2(symbols, "/v1beta3/crypto/us/", TYPE.TRADES, options, config);
	        const trades = new Map();
	        try {
	            for (var _d = true, cryptoTrades_1 = __asyncValues(cryptoTrades), cryptoTrades_1_1; cryptoTrades_1_1 = yield cryptoTrades_1.next(), _a = cryptoTrades_1_1.done, !_a; _d = true) {
	                _c = cryptoTrades_1_1.value;
	                _d = false;
	                const t = _c;
	                const items = trades.get(t.symbol) || new Array();
	                trades.set(t.symbol, [...items, (0, entityv2_1.AlpacaCryptoTrade)(t.data)]);
	            }
	        }
	        catch (e_10_1) { e_10 = { error: e_10_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = cryptoTrades_1.return)) yield _b.call(cryptoTrades_1);
	            }
	            finally { if (e_10) throw e_10.error; }
	        }
	        return trades;
	    });
	}
	rest_v2.getCryptoTrades = getCryptoTrades;
	function getCryptoQuotes(symbols, options, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        var _a, e_11, _b, _c;
	        const cryptoQuotes = getMultiDataV2(symbols, "/v1beta3/crypto/us/", TYPE.QUOTES, options, config);
	        const quotes = new Map();
	        try {
	            for (var _d = true, cryptoQuotes_1 = __asyncValues(cryptoQuotes), cryptoQuotes_1_1; cryptoQuotes_1_1 = yield cryptoQuotes_1.next(), _a = cryptoQuotes_1_1.done, !_a; _d = true) {
	                _c = cryptoQuotes_1_1.value;
	                _d = false;
	                const t = _c;
	                const items = quotes.get(t.symbol) || new Array();
	                quotes.set(t.symbol, [...items, (0, entityv2_1.AlpacaCryptoQuote)(t.data)]);
	            }
	        }
	        catch (e_11_1) { e_11 = { error: e_11_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = cryptoQuotes_1.return)) yield _b.call(cryptoQuotes_1);
	            }
	            finally { if (e_11) throw e_11.error; }
	        }
	        return quotes;
	    });
	}
	rest_v2.getCryptoQuotes = getCryptoQuotes;
	function getCryptoBars(symbols, options, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        var _a, e_12, _b, _c;
	        const cryptoBars = getMultiDataV2(symbols, "/v1beta3/crypto/us/", TYPE.BARS, options, config);
	        const bars = new Map();
	        try {
	            for (var _d = true, cryptoBars_1 = __asyncValues(cryptoBars), cryptoBars_1_1; cryptoBars_1_1 = yield cryptoBars_1.next(), _a = cryptoBars_1_1.done, !_a; _d = true) {
	                _c = cryptoBars_1_1.value;
	                _d = false;
	                const t = _c;
	                const items = bars.get(t.symbol) || new Array();
	                bars.set(t.symbol, [...items, (0, entityv2_1.AlpacaCryptoBar)(t.data)]);
	            }
	        }
	        catch (e_12_1) { e_12 = { error: e_12_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = cryptoBars_1.return)) yield _b.call(cryptoBars_1);
	            }
	            finally { if (e_12) throw e_12.error; }
	        }
	        return bars;
	    });
	}
	rest_v2.getCryptoBars = getCryptoBars;
	function getLatestCryptoBars(symbols, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const params = { symbols: symbols.join(",") };
	        const resp = yield dataV2HttpRequest(`/v1beta3/crypto/us/latest/bars`, params, config);
	        const multiLatestCryptoBars = resp.data.bars;
	        const result = new Map();
	        for (const symbol in multiLatestCryptoBars) {
	            const bar = multiLatestCryptoBars[symbol];
	            result.set(symbol, (0, entityv2_1.AlpacaCryptoBar)(bar));
	        }
	        return result;
	    });
	}
	rest_v2.getLatestCryptoBars = getLatestCryptoBars;
	function getLatestCryptoTrades(symbols, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const params = { symbols: symbols.join(",") };
	        const resp = yield dataV2HttpRequest(`/v1beta3/crypto/us/latest/trades`, params, config);
	        const multiLatestCryptoTrades = resp.data.trades;
	        const result = new Map();
	        for (const symbol in multiLatestCryptoTrades) {
	            const trade = multiLatestCryptoTrades[symbol];
	            result.set(symbol, (0, entityv2_1.AlpacaCryptoTrade)(trade));
	        }
	        return result;
	    });
	}
	rest_v2.getLatestCryptoTrades = getLatestCryptoTrades;
	function getLatestCryptoQuotes(symbols, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const params = { symbols: symbols.join(",") };
	        const resp = yield dataV2HttpRequest(`/v1beta3/crypto/us/latest/quotes`, params, config);
	        const multiLatestCryptoQuotes = resp.data.quotes;
	        const result = new Map();
	        for (const symbol in multiLatestCryptoQuotes) {
	            const quote = multiLatestCryptoQuotes[symbol];
	            result.set(symbol, (0, entityv2_1.AlpacaCryptoQuote)(quote));
	        }
	        return result;
	    });
	}
	rest_v2.getLatestCryptoQuotes = getLatestCryptoQuotes;
	function getCryptoSnapshots(symbols, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const params = { symbols: symbols.join(",") };
	        const resp = yield dataV2HttpRequest(`/v1beta3/crypto/us/snapshots`, params, config);
	        const snapshots = resp.data.snapshots;
	        const result = new Map();
	        for (const symbol in snapshots) {
	            const snapshot = snapshots[symbol];
	            result.set(symbol, (0, entityv2_1.AlpacaCryptoSnapshot)(snapshot));
	        }
	        return result;
	    });
	}
	rest_v2.getCryptoSnapshots = getCryptoSnapshots;
	function getLatestCryptoOrderbooks(symbols, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const params = { symbols: symbols.join(",") };
	        const resp = yield dataV2HttpRequest(`/v1beta3/crypto/us/latest/orderbooks`, params, config);
	        const orderbooks = resp.data.orderbooks;
	        const result = new Map();
	        for (const symbol in orderbooks) {
	            const orderbook = orderbooks[symbol];
	            result.set(symbol, (0, entityv2_1.AlpacaCryptoOrderbook)(orderbook));
	        }
	        return result;
	    });
	}
	rest_v2.getLatestCryptoOrderbooks = getLatestCryptoOrderbooks;
	var Sort;
	(function (Sort) {
	    Sort["ASC"] = "asc";
	    Sort["DESC"] = "desc";
	})(Sort || (rest_v2.Sort = Sort = {}));
	function getNewsParams(options) {
	    var _a;
	    const query = {};
	    query.symbols = ((_a = options.symbols) === null || _a === void 0 ? void 0 : _a.length) > 0 ? options.symbols.join(",") : null;
	    query.start = options.start;
	    query.end = options.end;
	    query.sort = options.sort;
	    query.include_content = options.includeContent;
	    query.exclude_contentless = options.excludeContentless;
	    return query;
	}
	function getNews(options, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        var _a;
	        if (options.totalLimit && options.totalLimit < 0) {
	            throw new Error("negative total limit");
	        }
	        if (options.pageLimit && options.pageLimit < 0) {
	            throw new Error("negative page limit");
	        }
	        let pageToken = null;
	        let received = 0;
	        const pageLimit = (options === null || options === void 0 ? void 0 : options.pageLimit)
	            ? Math.min(options.pageLimit, V2_NEWS_MAX_LIMIT)
	            : V2_NEWS_MAX_LIMIT;
	        options === null || options === void 0 ? true : delete options.pageLimit;
	        const totalLimit = (_a = options.totalLimit) !== null && _a !== void 0 ? _a : 10;
	        const result = [];
	        const params = getNewsParams(options);
	        let limit;
	        for (;;) {
	            limit = getQueryLimit(totalLimit, pageLimit, received);
	            if (limit < 1) {
	                break;
	            }
	            const resp = yield dataV2HttpRequest("/v1beta1/news", Object.assign(Object.assign({}, params), { limit: limit, page_token: pageToken }), config);
	            resp.data.news.forEach((n) => result.push((0, entityv2_1.AlpacaNews)(n)));
	            received += resp.data.news.length;
	            pageToken = resp.data.next_page_token;
	            if (!pageToken) {
	                break;
	            }
	        }
	        return result;
	    });
	}
	rest_v2.getNews = getNews;
	function getMultiOptionBars(symbols, options, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        var _a, e_13, _b, _c;
	        const multiBars = getMultiOptionBarsAsync(symbols, options, config);
	        const bars = new Map();
	        try {
	            for (var _d = true, multiBars_3 = __asyncValues(multiBars), multiBars_3_1; multiBars_3_1 = yield multiBars_3.next(), _a = multiBars_3_1.done, !_a; _d = true) {
	                _c = multiBars_3_1.value;
	                _d = false;
	                const b = _c;
	                // symbol will always have a value
	                let symbol = b.Symbol ? b.Symbol : "";
	                delete b.Symbol;
	                const items = bars.get(symbol) || new Array();
	                bars.set(symbol, [...items, b]);
	            }
	        }
	        catch (e_13_1) { e_13 = { error: e_13_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = multiBars_3.return)) yield _b.call(multiBars_3);
	            }
	            finally { if (e_13) throw e_13.error; }
	        }
	        return bars;
	    });
	}
	rest_v2.getMultiOptionBars = getMultiOptionBars;
	function getMultiOptionBarsAsync(symbols, options, config) {
	    return __asyncGenerator(this, arguments, function* getMultiOptionBarsAsync_1() {
	        var _a, e_14, _b, _c;
	        const multiBars = getMultiDataV2(symbols, "/v1beta1/options/", TYPE.BARS, options, config);
	        try {
	            for (var _d = true, multiBars_4 = __asyncValues(multiBars), multiBars_4_1; multiBars_4_1 = yield __await(multiBars_4.next()), _a = multiBars_4_1.done, !_a; _d = true) {
	                _c = multiBars_4_1.value;
	                _d = false;
	                const b = _c;
	                b.data = Object.assign(Object.assign({}, b.data), { S: b.symbol });
	                yield yield __await((0, entityv2_1.AlpacaOptionBarV1Beta1)(b.data));
	            }
	        }
	        catch (e_14_1) { e_14 = { error: e_14_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = multiBars_4.return)) yield __await(_b.call(multiBars_4));
	            }
	            finally { if (e_14) throw e_14.error; }
	        }
	    });
	}
	rest_v2.getMultiOptionBarsAsync = getMultiOptionBarsAsync;
	function getMultiOptionTrades(symbols, options, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        var _a, e_15, _b, _c;
	        const multiTrades = getMultiOptionTradesAsync(symbols, options, config);
	        const trades = new Map();
	        try {
	            for (var _d = true, multiTrades_3 = __asyncValues(multiTrades), multiTrades_3_1; multiTrades_3_1 = yield multiTrades_3.next(), _a = multiTrades_3_1.done, !_a; _d = true) {
	                _c = multiTrades_3_1.value;
	                _d = false;
	                const t = _c;
	                // symbol will always have a value
	                let symbol = t.Symbol ? t.Symbol : "";
	                delete t.Symbol;
	                const items = trades.get(symbol) || new Array();
	                trades.set(symbol, [...items, t]);
	            }
	        }
	        catch (e_15_1) { e_15 = { error: e_15_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = multiTrades_3.return)) yield _b.call(multiTrades_3);
	            }
	            finally { if (e_15) throw e_15.error; }
	        }
	        return trades;
	    });
	}
	rest_v2.getMultiOptionTrades = getMultiOptionTrades;
	function getMultiOptionTradesAsync(symbols, options, config) {
	    return __asyncGenerator(this, arguments, function* getMultiOptionTradesAsync_1() {
	        var _a, e_16, _b, _c;
	        const multiBars = getMultiDataV2(symbols, "/v1beta1/options/", TYPE.TRADES, options, config);
	        try {
	            for (var _d = true, multiBars_5 = __asyncValues(multiBars), multiBars_5_1; multiBars_5_1 = yield __await(multiBars_5.next()), _a = multiBars_5_1.done, !_a; _d = true) {
	                _c = multiBars_5_1.value;
	                _d = false;
	                const b = _c;
	                b.data = Object.assign(Object.assign({}, b.data), { S: b.symbol });
	                yield yield __await((0, entityv2_1.AlpacaOptionTradeV1Beta1)(b.data));
	            }
	        }
	        catch (e_16_1) { e_16 = { error: e_16_1 }; }
	        finally {
	            try {
	                if (!_d && !_a && (_b = multiBars_5.return)) yield __await(_b.call(multiBars_5));
	            }
	            finally { if (e_16) throw e_16.error; }
	        }
	    });
	}
	rest_v2.getMultiOptionTradesAsync = getMultiOptionTradesAsync;
	function getLatestOptionTrades(symbols, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const resp = yield dataV2HttpRequest(`/v1beta1/options/${TYPE.TRADES}/latest`, { symbols: symbols.join(",") }, config);
	        const multiLatestTrades = resp.data.trades;
	        const multiLatestTradesResp = new Map();
	        for (const symbol in multiLatestTrades) {
	            multiLatestTradesResp.set(symbol, (0, entityv2_1.AlpacaOptionTradeV1Beta1)(Object.assign({}, multiLatestTrades[symbol])));
	        }
	        return multiLatestTradesResp;
	    });
	}
	rest_v2.getLatestOptionTrades = getLatestOptionTrades;
	function getLatestOptionQuotes(symbols, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const resp = yield dataV2HttpRequest(`/v1beta1/options/${TYPE.QUOTES}/latest`, { symbols: symbols.join(",") }, config);
	        const multiLatestQuotes = resp.data.quotes;
	        const multiLatestQuotesResp = new Map();
	        for (const symbol in multiLatestQuotes) {
	            multiLatestQuotesResp.set(symbol, (0, entityv2_1.AlpacaOptionQuoteV1Beta1)(Object.assign({}, multiLatestQuotes[symbol])));
	        }
	        return multiLatestQuotesResp;
	    });
	}
	rest_v2.getLatestOptionQuotes = getLatestOptionQuotes;
	function getOptionSnapshots(symbols, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const resp = yield dataV2HttpRequest(`/v1beta1/options/snapshots?symbols=${symbols.join(",")}`, {}, config);
	        const result = Object.entries(resp.data.snapshots).map(([key, val]) => {
	            return (0, entityv2_1.AlpacaOptionSnapshotV1Beta1)(Object.assign({ Symbol: key }, val));
	        });
	        return result;
	    });
	}
	rest_v2.getOptionSnapshots = getOptionSnapshots;
	function getOptionChain(underlyingSymbol, options, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        var _a;
	        if (options.totalLimit && options.totalLimit < 0) {
	            throw new Error("negative total limit");
	        }
	        if (options.pageLimit && options.pageLimit < 0) {
	            throw new Error("negative page limit");
	        }
	        let pageToken = null;
	        let received = 0;
	        const pageLimit = (options === null || options === void 0 ? void 0 : options.pageLimit)
	            ? Math.min(options.pageLimit, V1_BETA1_MAX_LIMIT)
	            : V1_BETA1_MAX_LIMIT;
	        delete options.pageLimit;
	        const totalLimit = (_a = options === null || options === void 0 ? void 0 : options.totalLimit) !== null && _a !== void 0 ? _a : 10000;
	        delete options.totalLimit;
	        const result = [];
	        let limit;
	        for (;;) {
	            limit = getQueryLimit(totalLimit, pageLimit, received);
	            if (limit < 1) {
	                break;
	            }
	            const resp = yield dataV2HttpRequest(`/v1beta1/options/snapshots/${underlyingSymbol}`, Object.assign(Object.assign({}, options), { limit: limit, page_token: pageToken }), config);
	            const res = Object.entries(resp.data.snapshots).map(([key, val]) => {
	                return (0, entityv2_1.AlpacaOptionSnapshotV1Beta1)(Object.assign({ Symbol: key }, val));
	            });
	            received = received + res.length;
	            result.push(...res);
	            pageToken = resp.data.next_page_token;
	            if (!pageToken) {
	                break;
	            }
	        }
	        return result;
	    });
	}
	rest_v2.getOptionChain = getOptionChain;
	function getCorporateActions(symbols, options, config) {
	    return __awaiter(this, void 0, void 0, function* () {
	        var _a, _b;
	        if (options.totalLimit && options.totalLimit < 0) {
	            throw new Error("negative total limit");
	        }
	        if (options.pageLimit && options.pageLimit < 0) {
	            throw new Error("negative page limit");
	        }
	        let pageToken = null;
	        let received = 0;
	        const pageLimit = (options === null || options === void 0 ? void 0 : options.pageLimit)
	            ? Math.min(options.pageLimit, V1_BETA1_MAX_LIMIT)
	            : V1_BETA1_MAX_LIMIT;
	        options === null || options === void 0 ? true : delete options.pageLimit;
	        const totalLimit = (_a = options === null || options === void 0 ? void 0 : options.totalLimit) !== null && _a !== void 0 ? _a : V2_MAX_LIMIT;
	        delete options.totalLimit;
	        let result = {};
	        const types = (_b = options === null || options === void 0 ? void 0 : options.types) === null || _b === void 0 ? void 0 : _b.join(",");
	        const params = Object.assign(Object.assign({}, options), { symbols, types });
	        let limit;
	        for (;;) {
	            limit = getQueryLimit(totalLimit, pageLimit, received);
	            if (limit < 1) {
	                break;
	            }
	            const resp = yield dataV2HttpRequest(`/v1beta1/corporate-actions`, Object.assign(Object.assign({}, params), { limit: limit, page_token: pageToken }), config);
	            const cas = (0, entityv2_1.convertCorporateActions)(resp.data.corporate_actions);
	            result = (0, entityv2_1.mergeCorporateActions)(result, cas);
	            received += (0, entityv2_1.getCorporateActionsSize)(cas);
	            pageToken = resp.data.next_page_token;
	            if (!pageToken) {
	                break;
	            }
	        }
	        return result;
	    });
	}
	rest_v2.getCorporateActions = getCorporateActions;
	return rest_v2;
}

var crypto_websocket_v1beta3 = {};

var websocket = {};

var safeBuffer = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredSafeBuffer;

function requireSafeBuffer () {
	if (hasRequiredSafeBuffer) return safeBuffer.exports;
	hasRequiredSafeBuffer = 1;
	(function (module, exports$1) {
		/* eslint-disable node/no-deprecated-api */
		var buffer = require$$0$5;
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports$1);
		  exports$1.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer, safeBuffer.exports));
	return safeBuffer.exports;
}

var bl = {exports: {}};

var readable = {exports: {}};

var stream;
var hasRequiredStream;

function requireStream () {
	if (hasRequiredStream) return stream;
	hasRequiredStream = 1;
	stream = require$$0$2;
	return stream;
}

var buffer_list;
var hasRequiredBuffer_list;

function requireBuffer_list () {
	if (hasRequiredBuffer_list) return buffer_list;
	hasRequiredBuffer_list = 1;

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(input); }
	var _require = require$$0$5,
	  Buffer = _require.Buffer;
	var _require2 = require$$1$2,
	  inspect = _require2.inspect;
	var custom = inspect && inspect.custom || 'inspect';
	function copyBuffer(src, target, offset) {
	  Buffer.prototype.copy.call(src, target, offset);
	}
	buffer_list = /*#__PURE__*/function () {
	  function BufferList() {
	    _classCallCheck(this, BufferList);
	    this.head = null;
	    this.tail = null;
	    this.length = 0;
	  }
	  _createClass(BufferList, [{
	    key: "push",
	    value: function push(v) {
	      var entry = {
	        data: v,
	        next: null
	      };
	      if (this.length > 0) this.tail.next = entry;else this.head = entry;
	      this.tail = entry;
	      ++this.length;
	    }
	  }, {
	    key: "unshift",
	    value: function unshift(v) {
	      var entry = {
	        data: v,
	        next: this.head
	      };
	      if (this.length === 0) this.tail = entry;
	      this.head = entry;
	      ++this.length;
	    }
	  }, {
	    key: "shift",
	    value: function shift() {
	      if (this.length === 0) return;
	      var ret = this.head.data;
	      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	      --this.length;
	      return ret;
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.head = this.tail = null;
	      this.length = 0;
	    }
	  }, {
	    key: "join",
	    value: function join(s) {
	      if (this.length === 0) return '';
	      var p = this.head;
	      var ret = '' + p.data;
	      while (p = p.next) ret += s + p.data;
	      return ret;
	    }
	  }, {
	    key: "concat",
	    value: function concat(n) {
	      if (this.length === 0) return Buffer.alloc(0);
	      var ret = Buffer.allocUnsafe(n >>> 0);
	      var p = this.head;
	      var i = 0;
	      while (p) {
	        copyBuffer(p.data, ret, i);
	        i += p.data.length;
	        p = p.next;
	      }
	      return ret;
	    }

	    // Consumes a specified amount of bytes or characters from the buffered data.
	  }, {
	    key: "consume",
	    value: function consume(n, hasStrings) {
	      var ret;
	      if (n < this.head.data.length) {
	        // `slice` is the same for buffers and strings.
	        ret = this.head.data.slice(0, n);
	        this.head.data = this.head.data.slice(n);
	      } else if (n === this.head.data.length) {
	        // First chunk is a perfect match.
	        ret = this.shift();
	      } else {
	        // Result spans more than one buffer.
	        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
	      }
	      return ret;
	    }
	  }, {
	    key: "first",
	    value: function first() {
	      return this.head.data;
	    }

	    // Consumes a specified amount of characters from the buffered data.
	  }, {
	    key: "_getString",
	    value: function _getString(n) {
	      var p = this.head;
	      var c = 1;
	      var ret = p.data;
	      n -= ret.length;
	      while (p = p.next) {
	        var str = p.data;
	        var nb = n > str.length ? str.length : n;
	        if (nb === str.length) ret += str;else ret += str.slice(0, n);
	        n -= nb;
	        if (n === 0) {
	          if (nb === str.length) {
	            ++c;
	            if (p.next) this.head = p.next;else this.head = this.tail = null;
	          } else {
	            this.head = p;
	            p.data = str.slice(nb);
	          }
	          break;
	        }
	        ++c;
	      }
	      this.length -= c;
	      return ret;
	    }

	    // Consumes a specified amount of bytes from the buffered data.
	  }, {
	    key: "_getBuffer",
	    value: function _getBuffer(n) {
	      var ret = Buffer.allocUnsafe(n);
	      var p = this.head;
	      var c = 1;
	      p.data.copy(ret);
	      n -= p.data.length;
	      while (p = p.next) {
	        var buf = p.data;
	        var nb = n > buf.length ? buf.length : n;
	        buf.copy(ret, ret.length - n, 0, nb);
	        n -= nb;
	        if (n === 0) {
	          if (nb === buf.length) {
	            ++c;
	            if (p.next) this.head = p.next;else this.head = this.tail = null;
	          } else {
	            this.head = p;
	            p.data = buf.slice(nb);
	          }
	          break;
	        }
	        ++c;
	      }
	      this.length -= c;
	      return ret;
	    }

	    // Make sure the linked list only shows the minimal necessary information.
	  }, {
	    key: custom,
	    value: function value(_, options) {
	      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
	        // Only inspect one level.
	        depth: 0,
	        // It should not recurse.
	        customInspect: false
	      }));
	    }
	  }]);
	  return BufferList;
	}();
	return buffer_list;
}

var destroy_1;
var hasRequiredDestroy;

function requireDestroy () {
	if (hasRequiredDestroy) return destroy_1;
	hasRequiredDestroy = 1;

	// undocumented cb() API, needed for core, not for public API
	function destroy(err, cb) {
	  var _this = this;
	  var readableDestroyed = this._readableState && this._readableState.destroyed;
	  var writableDestroyed = this._writableState && this._writableState.destroyed;
	  if (readableDestroyed || writableDestroyed) {
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      if (!this._writableState) {
	        process.nextTick(emitErrorNT, this, err);
	      } else if (!this._writableState.errorEmitted) {
	        this._writableState.errorEmitted = true;
	        process.nextTick(emitErrorNT, this, err);
	      }
	    }
	    return this;
	  }

	  // we set destroyed to true before firing error callbacks in order
	  // to make it re-entrance safe in case destroy() is called within callbacks

	  if (this._readableState) {
	    this._readableState.destroyed = true;
	  }

	  // if this is a duplex stream mark the writable part as destroyed as well
	  if (this._writableState) {
	    this._writableState.destroyed = true;
	  }
	  this._destroy(err || null, function (err) {
	    if (!cb && err) {
	      if (!_this._writableState) {
	        process.nextTick(emitErrorAndCloseNT, _this, err);
	      } else if (!_this._writableState.errorEmitted) {
	        _this._writableState.errorEmitted = true;
	        process.nextTick(emitErrorAndCloseNT, _this, err);
	      } else {
	        process.nextTick(emitCloseNT, _this);
	      }
	    } else if (cb) {
	      process.nextTick(emitCloseNT, _this);
	      cb(err);
	    } else {
	      process.nextTick(emitCloseNT, _this);
	    }
	  });
	  return this;
	}
	function emitErrorAndCloseNT(self, err) {
	  emitErrorNT(self, err);
	  emitCloseNT(self);
	}
	function emitCloseNT(self) {
	  if (self._writableState && !self._writableState.emitClose) return;
	  if (self._readableState && !self._readableState.emitClose) return;
	  self.emit('close');
	}
	function undestroy() {
	  if (this._readableState) {
	    this._readableState.destroyed = false;
	    this._readableState.reading = false;
	    this._readableState.ended = false;
	    this._readableState.endEmitted = false;
	  }
	  if (this._writableState) {
	    this._writableState.destroyed = false;
	    this._writableState.ended = false;
	    this._writableState.ending = false;
	    this._writableState.finalCalled = false;
	    this._writableState.prefinished = false;
	    this._writableState.finished = false;
	    this._writableState.errorEmitted = false;
	  }
	}
	function emitErrorNT(self, err) {
	  self.emit('error', err);
	}
	function errorOrDestroy(stream, err) {
	  // We have tests that rely on errors being emitted
	  // in the same tick, so changing this is semver major.
	  // For now when you opt-in to autoDestroy we allow
	  // the error to be emitted nextTick. In a future
	  // semver major update we should change the default to this.

	  var rState = stream._readableState;
	  var wState = stream._writableState;
	  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
	}
	destroy_1 = {
	  destroy: destroy,
	  undestroy: undestroy,
	  errorOrDestroy: errorOrDestroy
	};
	return destroy_1;
}

var errors = {};

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;

	const codes = {};

	function createErrorType(code, message, Base) {
	  if (!Base) {
	    Base = Error;
	  }

	  function getMessage (arg1, arg2, arg3) {
	    if (typeof message === 'string') {
	      return message
	    } else {
	      return message(arg1, arg2, arg3)
	    }
	  }

	  class NodeError extends Base {
	    constructor (arg1, arg2, arg3) {
	      super(getMessage(arg1, arg2, arg3));
	    }
	  }

	  NodeError.prototype.name = Base.name;
	  NodeError.prototype.code = code;

	  codes[code] = NodeError;
	}

	// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
	function oneOf(expected, thing) {
	  if (Array.isArray(expected)) {
	    const len = expected.length;
	    expected = expected.map((i) => String(i));
	    if (len > 2) {
	      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
	             expected[len - 1];
	    } else if (len === 2) {
	      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
	    } else {
	      return `of ${thing} ${expected[0]}`;
	    }
	  } else {
	    return `of ${thing} ${String(expected)}`;
	  }
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
	function startsWith(str, search, pos) {
		return str.substr(0 , search.length) === search;
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
	function endsWith(str, search, this_len) {
		if (this_len === undefined || this_len > str.length) {
			this_len = str.length;
		}
		return str.substring(this_len - search.length, this_len) === search;
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
	function includes(str, search, start) {
	  if (typeof start !== 'number') {
	    start = 0;
	  }

	  if (start + search.length > str.length) {
	    return false;
	  } else {
	    return str.indexOf(search, start) !== -1;
	  }
	}

	createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
	  return 'The value "' + value + '" is invalid for option "' + name + '"'
	}, TypeError);
	createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
	  // determiner: 'must be' or 'must not be'
	  let determiner;
	  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
	    determiner = 'must not be';
	    expected = expected.replace(/^not /, '');
	  } else {
	    determiner = 'must be';
	  }

	  let msg;
	  if (endsWith(name, ' argument')) {
	    // For cases like 'first argument'
	    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
	  } else {
	    const type = includes(name, '.') ? 'property' : 'argument';
	    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
	  }

	  msg += `. Received type ${typeof actual}`;
	  return msg;
	}, TypeError);
	createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
	createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
	  return 'The ' + name + ' method is not implemented'
	});
	createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
	createErrorType('ERR_STREAM_DESTROYED', function (name) {
	  return 'Cannot call ' + name + ' after a stream was destroyed';
	});
	createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
	createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
	createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
	createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
	createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
	  return 'Unknown encoding: ' + arg
	}, TypeError);
	createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

	errors.codes = codes;
	return errors;
}

var state;
var hasRequiredState;

function requireState () {
	if (hasRequiredState) return state;
	hasRequiredState = 1;

	var ERR_INVALID_OPT_VALUE = requireErrors().codes.ERR_INVALID_OPT_VALUE;
	function highWaterMarkFrom(options, isDuplex, duplexKey) {
	  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
	}
	function getHighWaterMark(state, options, duplexKey, isDuplex) {
	  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
	  if (hwm != null) {
	    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
	      var name = isDuplex ? duplexKey : 'highWaterMark';
	      throw new ERR_INVALID_OPT_VALUE(name, hwm);
	    }
	    return Math.floor(hwm);
	  }

	  // Default value
	  return state.objectMode ? 16 : 16 * 1024;
	}
	state = {
	  getHighWaterMark: getHighWaterMark
	};
	return state;
}

var inherits = {exports: {}};

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;

function requireInherits_browser () {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	return inherits_browser.exports;
}

var hasRequiredInherits;

function requireInherits () {
	if (hasRequiredInherits) return inherits.exports;
	hasRequiredInherits = 1;
	try {
	  var util = require('util');
	  /* istanbul ignore next */
	  if (typeof util.inherits !== 'function') throw '';
	  inherits.exports = util.inherits;
	} catch (e) {
	  /* istanbul ignore next */
	  inherits.exports = requireInherits_browser();
	}
	return inherits.exports;
}

var node;
var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;
	/**
	 * For Node.js, simply re-export the core `util.deprecate` function.
	 */

	node = require$$1$2.deprecate;
	return node;
}

var _stream_writable;
var hasRequired_stream_writable;

function require_stream_writable () {
	if (hasRequired_stream_writable) return _stream_writable;
	hasRequired_stream_writable = 1;

	_stream_writable = Writable;

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	  this.next = null;
	  this.entry = null;
	  this.finish = function () {
	    onCorkedFinish(_this, state);
	  };
	}
	/* </replacement> */

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Writable.WritableState = WritableState;

	/*<replacement>*/
	var internalUtil = {
	  deprecate: requireNode()
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStream();
	/*</replacement>*/

	var Buffer = require$$0$5.Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}
	var destroyImpl = requireDestroy();
	var _require = requireState(),
	  getHighWaterMark = _require.getHighWaterMark;
	var _require$codes = requireErrors().codes,
	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
	  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
	  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
	  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
	  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
	var errorOrDestroy = destroyImpl.errorOrDestroy;
	requireInherits()(Writable, Stream);
	function nop() {}
	function WritableState(options, stream, isDuplex) {
	  Duplex = Duplex || require_stream_duplex();
	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream,
	  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

	  // if _final has been called
	  this.finalCalled = false;

	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // has it been destroyed
	  this.destroyed = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // Should close be emitted on destroy. Defaults to true.
	  this.emitClose = options.emitClose !== false;

	  // Should .destroy() be called after 'finish' (and potentially 'end')
	  this.autoDestroy = !!options.autoDestroy;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function writableStateBufferGetter() {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
	    });
	  } catch (_) {}
	})();

	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function value(object) {
	      if (realHasInstance.call(this, object)) return true;
	      if (this !== Writable) return false;
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function realHasInstance(object) {
	    return object instanceof this;
	  };
	}
	function Writable(options) {
	  Duplex = Duplex || require_stream_duplex();

	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.

	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the WritableState constructor, at least with V8 6.5
	  var isDuplex = this instanceof Duplex;
	  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
	  this._writableState = new WritableState(options, this, isDuplex);

	  // legacy.
	  this.writable = true;
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	    if (typeof options.writev === 'function') this._writev = options.writev;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	    if (typeof options.final === 'function') this._final = options.final;
	  }
	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
	};
	function writeAfterEnd(stream, cb) {
	  var er = new ERR_STREAM_WRITE_AFTER_END();
	  // TODO: defer error events consistently everywhere, not just the cb
	  errorOrDestroy(stream, er);
	  process.nextTick(cb, er);
	}

	// Checks that a user-supplied chunk is valid, especially for the particular
	// mode the stream is in. Currently this means that `null` is never accepted
	// and undefined/non-string values are only allowed in object mode.
	function validChunk(stream, state, chunk, cb) {
	  var er;
	  if (chunk === null) {
	    er = new ERR_STREAM_NULL_VALUES();
	  } else if (typeof chunk !== 'string' && !state.objectMode) {
	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
	  }
	  if (er) {
	    errorOrDestroy(stream, er);
	    process.nextTick(cb, er);
	    return false;
	  }
	  return true;
	}
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	  var isBuf = !state.objectMode && _isUint8Array(chunk);
	  if (isBuf && !Buffer.isBuffer(chunk)) {
	    chunk = _uint8ArrayToBuffer(chunk);
	  }
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	  if (typeof cb !== 'function') cb = nop;
	  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
	  }
	  return ret;
	};
	Writable.prototype.cork = function () {
	  this._writableState.corked++;
	};
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	  if (state.corked) {
	    state.corked--;
	    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	Object.defineProperty(Writable.prototype, 'writableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState && this._writableState.getBuffer();
	  }
	});
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = Buffer.from(chunk, encoding);
	  }
	  return chunk;
	}
	Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.highWaterMark;
	  }
	});

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
	  if (!isBuf) {
	    var newChunk = decodeChunk(state, chunk, encoding);
	    if (chunk !== newChunk) {
	      isBuf = true;
	      encoding = 'buffer';
	      chunk = newChunk;
	    }
	  }
	  var len = state.objectMode ? 1 : chunk.length;
	  state.length += len;
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = {
	      chunk: chunk,
	      encoding: encoding,
	      isBuf: isBuf,
	      callback: cb,
	      next: null
	    };
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	  return ret;
	}
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) {
	    // defer the callback if we are being called synchronously
	    // to avoid piling up things on the stack
	    process.nextTick(cb, er);
	    // this can emit finish, and it will always happen
	    // after error
	    process.nextTick(finishMaybe, stream, state);
	    stream._writableState.errorEmitted = true;
	    errorOrDestroy(stream, er);
	  } else {
	    // the caller expect this to happen before if
	    // it is async
	    cb(er);
	    stream._writableState.errorEmitted = true;
	    errorOrDestroy(stream, er);
	    // this can emit finish, but finish must
	    // always follow error
	    finishMaybe(stream, state);
	  }
	}
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
	  onwriteStateUpdate(state);
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state) || stream.destroyed;
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	    if (sync) {
	      process.nextTick(afterWrite, stream, state, finished, cb);
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	    var count = 0;
	    var allBuffers = true;
	    while (entry) {
	      buffer[count] = entry;
	      if (!entry.isBuf) allBuffers = false;
	      entry = entry.next;
	      count += 1;
	    }
	    buffer.allBuffers = allBuffers;
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	    state.bufferedRequestCount = 0;
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      state.bufferedRequestCount--;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
	};
	Writable.prototype._writev = null;
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending) endWritable(this, state, cb);
	  return this;
	};
	Object.defineProperty(Writable.prototype, 'writableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.length;
	  }
	});
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	function callFinal(stream, state) {
	  stream._final(function (err) {
	    state.pendingcb--;
	    if (err) {
	      errorOrDestroy(stream, err);
	    }
	    state.prefinished = true;
	    stream.emit('prefinish');
	    finishMaybe(stream, state);
	  });
	}
	function prefinish(stream, state) {
	  if (!state.prefinished && !state.finalCalled) {
	    if (typeof stream._final === 'function' && !state.destroyed) {
	      state.pendingcb++;
	      state.finalCalled = true;
	      process.nextTick(callFinal, stream, state);
	    } else {
	      state.prefinished = true;
	      stream.emit('prefinish');
	    }
	  }
	}
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    prefinish(stream, state);
	    if (state.pendingcb === 0) {
	      state.finished = true;
	      stream.emit('finish');
	      if (state.autoDestroy) {
	        // In case of duplex streams we need a way to detect
	        // if the readable side is ready for autoDestroy as well
	        var rState = stream._readableState;
	        if (!rState || rState.autoDestroy && rState.endEmitted) {
	          stream.destroy();
	        }
	      }
	    }
	  }
	  return need;
	}
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	function onCorkedFinish(corkReq, state, err) {
	  var entry = corkReq.entry;
	  corkReq.entry = null;
	  while (entry) {
	    var cb = entry.callback;
	    state.pendingcb--;
	    cb(err);
	    entry = entry.next;
	  }

	  // reuse the free corkReq.
	  state.corkedRequestsFree.next = corkReq;
	}
	Object.defineProperty(Writable.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._writableState === undefined) {
	      return false;
	    }
	    return this._writableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._writableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._writableState.destroyed = value;
	  }
	});
	Writable.prototype.destroy = destroyImpl.destroy;
	Writable.prototype._undestroy = destroyImpl.undestroy;
	Writable.prototype._destroy = function (err, cb) {
	  cb(err);
	};
	return _stream_writable;
}

var _stream_duplex;
var hasRequired_stream_duplex;

function require_stream_duplex () {
	if (hasRequired_stream_duplex) return _stream_duplex;
	hasRequired_stream_duplex = 1;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	};
	/*</replacement>*/

	_stream_duplex = Duplex;
	var Readable = require_stream_readable();
	var Writable = require_stream_writable();
	requireInherits()(Duplex, Readable);
	{
	  // Allow the keys array to be GC'ed.
	  var keys = objectKeys(Writable.prototype);
	  for (var v = 0; v < keys.length; v++) {
	    var method = keys[v];
	    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	  }
	}
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	  Readable.call(this, options);
	  Writable.call(this, options);
	  this.allowHalfOpen = true;
	  if (options) {
	    if (options.readable === false) this.readable = false;
	    if (options.writable === false) this.writable = false;
	    if (options.allowHalfOpen === false) {
	      this.allowHalfOpen = false;
	      this.once('end', onend);
	    }
	  }
	}
	Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.highWaterMark;
	  }
	});
	Object.defineProperty(Duplex.prototype, 'writableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState && this._writableState.getBuffer();
	  }
	});
	Object.defineProperty(Duplex.prototype, 'writableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.length;
	  }
	});

	// the no-half-open enforcer
	function onend() {
	  // If the writable side ended, then we're ok.
	  if (this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(onEndNT, this);
	}
	function onEndNT(self) {
	  self.end();
	}
	Object.defineProperty(Duplex.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed && this._writableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	    this._writableState.destroyed = value;
	  }
	});
	return _stream_duplex;
}

var string_decoder = {};

var hasRequiredString_decoder;

function requireString_decoder () {
	if (hasRequiredString_decoder) return string_decoder;
	hasRequiredString_decoder = 1;

	/*<replacement>*/

	var Buffer = requireSafeBuffer().Buffer;
	/*</replacement>*/

	var isEncoding = Buffer.isEncoding || function (encoding) {
	  encoding = '' + encoding;
	  switch (encoding && encoding.toLowerCase()) {
	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
	      return true;
	    default:
	      return false;
	  }
	};

	function _normalizeEncoding(enc) {
	  if (!enc) return 'utf8';
	  var retried;
	  while (true) {
	    switch (enc) {
	      case 'utf8':
	      case 'utf-8':
	        return 'utf8';
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return 'utf16le';
	      case 'latin1':
	      case 'binary':
	        return 'latin1';
	      case 'base64':
	      case 'ascii':
	      case 'hex':
	        return enc;
	      default:
	        if (retried) return; // undefined
	        enc = ('' + enc).toLowerCase();
	        retried = true;
	    }
	  }
	}
	// Do not cache `Buffer.isEncoding` when checking encoding names as some
	// modules monkey-patch it to support additional encodings
	function normalizeEncoding(enc) {
	  var nenc = _normalizeEncoding(enc);
	  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
	  return nenc || enc;
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters.
	string_decoder.StringDecoder = StringDecoder;
	function StringDecoder(encoding) {
	  this.encoding = normalizeEncoding(encoding);
	  var nb;
	  switch (this.encoding) {
	    case 'utf16le':
	      this.text = utf16Text;
	      this.end = utf16End;
	      nb = 4;
	      break;
	    case 'utf8':
	      this.fillLast = utf8FillLast;
	      nb = 4;
	      break;
	    case 'base64':
	      this.text = base64Text;
	      this.end = base64End;
	      nb = 3;
	      break;
	    default:
	      this.write = simpleWrite;
	      this.end = simpleEnd;
	      return;
	  }
	  this.lastNeed = 0;
	  this.lastTotal = 0;
	  this.lastChar = Buffer.allocUnsafe(nb);
	}

	StringDecoder.prototype.write = function (buf) {
	  if (buf.length === 0) return '';
	  var r;
	  var i;
	  if (this.lastNeed) {
	    r = this.fillLast(buf);
	    if (r === undefined) return '';
	    i = this.lastNeed;
	    this.lastNeed = 0;
	  } else {
	    i = 0;
	  }
	  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
	  return r || '';
	};

	StringDecoder.prototype.end = utf8End;

	// Returns only complete characters in a Buffer
	StringDecoder.prototype.text = utf8Text;

	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
	StringDecoder.prototype.fillLast = function (buf) {
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
	  this.lastNeed -= buf.length;
	};

	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
	// continuation byte. If an invalid byte is detected, -2 is returned.
	function utf8CheckByte(byte) {
	  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
	  return byte >> 6 === 0x02 ? -1 : -2;
	}

	// Checks at most 3 bytes at the end of a Buffer in order to detect an
	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
	// needed to complete the UTF-8 character (if applicable) are returned.
	function utf8CheckIncomplete(self, buf, i) {
	  var j = buf.length - 1;
	  if (j < i) return 0;
	  var nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 1;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 2;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) {
	      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
	    }
	    return nb;
	  }
	  return 0;
	}

	// Validates as many continuation bytes for a multi-byte UTF-8 character as
	// needed or are available. If we see a non-continuation byte where we expect
	// one, we "replace" the validated continuation bytes we've seen so far with
	// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
	// behavior. The continuation byte check is included three times in the case
	// where all of the continuation bytes for a character exist in the same buffer.
	// It is also done this way as a slight performance increase instead of using a
	// loop.
	function utf8CheckExtraBytes(self, buf, p) {
	  if ((buf[0] & 0xC0) !== 0x80) {
	    self.lastNeed = 0;
	    return '\ufffd';
	  }
	  if (self.lastNeed > 1 && buf.length > 1) {
	    if ((buf[1] & 0xC0) !== 0x80) {
	      self.lastNeed = 1;
	      return '\ufffd';
	    }
	    if (self.lastNeed > 2 && buf.length > 2) {
	      if ((buf[2] & 0xC0) !== 0x80) {
	        self.lastNeed = 2;
	        return '\ufffd';
	      }
	    }
	  }
	}

	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
	function utf8FillLast(buf) {
	  var p = this.lastTotal - this.lastNeed;
	  var r = utf8CheckExtraBytes(this, buf);
	  if (r !== undefined) return r;
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, p, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, p, 0, buf.length);
	  this.lastNeed -= buf.length;
	}

	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
	// partial character, the character's bytes are buffered until the required
	// number of bytes are available.
	function utf8Text(buf, i) {
	  var total = utf8CheckIncomplete(this, buf, i);
	  if (!this.lastNeed) return buf.toString('utf8', i);
	  this.lastTotal = total;
	  var end = buf.length - (total - this.lastNeed);
	  buf.copy(this.lastChar, 0, end);
	  return buf.toString('utf8', i, end);
	}

	// For UTF-8, a replacement character is added when ending on a partial
	// character.
	function utf8End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + '\ufffd';
	  return r;
	}

	// UTF-16LE typically needs two bytes per character, but even if we have an even
	// number of bytes available, we need to check if we end on a leading/high
	// surrogate. In that case, we need to wait for the next two bytes in order to
	// decode the last character properly.
	function utf16Text(buf, i) {
	  if ((buf.length - i) % 2 === 0) {
	    var r = buf.toString('utf16le', i);
	    if (r) {
	      var c = r.charCodeAt(r.length - 1);
	      if (c >= 0xD800 && c <= 0xDBFF) {
	        this.lastNeed = 2;
	        this.lastTotal = 4;
	        this.lastChar[0] = buf[buf.length - 2];
	        this.lastChar[1] = buf[buf.length - 1];
	        return r.slice(0, -1);
	      }
	    }
	    return r;
	  }
	  this.lastNeed = 1;
	  this.lastTotal = 2;
	  this.lastChar[0] = buf[buf.length - 1];
	  return buf.toString('utf16le', i, buf.length - 1);
	}

	// For UTF-16LE we do not explicitly append special replacement characters if we
	// end on a partial character, we simply let v8 handle that.
	function utf16End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) {
	    var end = this.lastTotal - this.lastNeed;
	    return r + this.lastChar.toString('utf16le', 0, end);
	  }
	  return r;
	}

	function base64Text(buf, i) {
	  var n = (buf.length - i) % 3;
	  if (n === 0) return buf.toString('base64', i);
	  this.lastNeed = 3 - n;
	  this.lastTotal = 3;
	  if (n === 1) {
	    this.lastChar[0] = buf[buf.length - 1];
	  } else {
	    this.lastChar[0] = buf[buf.length - 2];
	    this.lastChar[1] = buf[buf.length - 1];
	  }
	  return buf.toString('base64', i, buf.length - n);
	}

	function base64End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
	  return r;
	}

	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
	function simpleWrite(buf) {
	  return buf.toString(this.encoding);
	}

	function simpleEnd(buf) {
	  return buf && buf.length ? this.write(buf) : '';
	}
	return string_decoder;
}

var endOfStream;
var hasRequiredEndOfStream;

function requireEndOfStream () {
	if (hasRequiredEndOfStream) return endOfStream;
	hasRequiredEndOfStream = 1;

	var ERR_STREAM_PREMATURE_CLOSE = requireErrors().codes.ERR_STREAM_PREMATURE_CLOSE;
	function once(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    callback.apply(this, args);
	  };
	}
	function noop() {}
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}
	function eos(stream, opts, callback) {
	  if (typeof opts === 'function') return eos(stream, null, opts);
	  if (!opts) opts = {};
	  callback = once(callback || noop);
	  var readable = opts.readable || opts.readable !== false && stream.readable;
	  var writable = opts.writable || opts.writable !== false && stream.writable;
	  var onlegacyfinish = function onlegacyfinish() {
	    if (!stream.writable) onfinish();
	  };
	  var writableEnded = stream._writableState && stream._writableState.finished;
	  var onfinish = function onfinish() {
	    writable = false;
	    writableEnded = true;
	    if (!readable) callback.call(stream);
	  };
	  var readableEnded = stream._readableState && stream._readableState.endEmitted;
	  var onend = function onend() {
	    readable = false;
	    readableEnded = true;
	    if (!writable) callback.call(stream);
	  };
	  var onerror = function onerror(err) {
	    callback.call(stream, err);
	  };
	  var onclose = function onclose() {
	    var err;
	    if (readable && !readableEnded) {
	      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	    if (writable && !writableEnded) {
	      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	  };
	  var onrequest = function onrequest() {
	    stream.req.on('finish', onfinish);
	  };
	  if (isRequest(stream)) {
	    stream.on('complete', onfinish);
	    stream.on('abort', onclose);
	    if (stream.req) onrequest();else stream.on('request', onrequest);
	  } else if (writable && !stream._writableState) {
	    // legacy streams
	    stream.on('end', onlegacyfinish);
	    stream.on('close', onlegacyfinish);
	  }
	  stream.on('end', onend);
	  stream.on('finish', onfinish);
	  if (opts.error !== false) stream.on('error', onerror);
	  stream.on('close', onclose);
	  return function () {
	    stream.removeListener('complete', onfinish);
	    stream.removeListener('abort', onclose);
	    stream.removeListener('request', onrequest);
	    if (stream.req) stream.req.removeListener('finish', onfinish);
	    stream.removeListener('end', onlegacyfinish);
	    stream.removeListener('close', onlegacyfinish);
	    stream.removeListener('finish', onfinish);
	    stream.removeListener('end', onend);
	    stream.removeListener('error', onerror);
	    stream.removeListener('close', onclose);
	  };
	}
	endOfStream = eos;
	return endOfStream;
}

var async_iterator;
var hasRequiredAsync_iterator;

function requireAsync_iterator () {
	if (hasRequiredAsync_iterator) return async_iterator;
	hasRequiredAsync_iterator = 1;

	var _Object$setPrototypeO;
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
	var finished = requireEndOfStream();
	var kLastResolve = Symbol('lastResolve');
	var kLastReject = Symbol('lastReject');
	var kError = Symbol('error');
	var kEnded = Symbol('ended');
	var kLastPromise = Symbol('lastPromise');
	var kHandlePromise = Symbol('handlePromise');
	var kStream = Symbol('stream');
	function createIterResult(value, done) {
	  return {
	    value: value,
	    done: done
	  };
	}
	function readAndResolve(iter) {
	  var resolve = iter[kLastResolve];
	  if (resolve !== null) {
	    var data = iter[kStream].read();
	    // we defer if data is null
	    // we can be expecting either 'end' or
	    // 'error'
	    if (data !== null) {
	      iter[kLastPromise] = null;
	      iter[kLastResolve] = null;
	      iter[kLastReject] = null;
	      resolve(createIterResult(data, false));
	    }
	  }
	}
	function onReadable(iter) {
	  // we wait for the next tick, because it might
	  // emit an error with process.nextTick
	  process.nextTick(readAndResolve, iter);
	}
	function wrapForNext(lastPromise, iter) {
	  return function (resolve, reject) {
	    lastPromise.then(function () {
	      if (iter[kEnded]) {
	        resolve(createIterResult(undefined, true));
	        return;
	      }
	      iter[kHandlePromise](resolve, reject);
	    }, reject);
	  };
	}
	var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
	var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
	  get stream() {
	    return this[kStream];
	  },
	  next: function next() {
	    var _this = this;
	    // if we have detected an error in the meanwhile
	    // reject straight away
	    var error = this[kError];
	    if (error !== null) {
	      return Promise.reject(error);
	    }
	    if (this[kEnded]) {
	      return Promise.resolve(createIterResult(undefined, true));
	    }
	    if (this[kStream].destroyed) {
	      // We need to defer via nextTick because if .destroy(err) is
	      // called, the error will be emitted via nextTick, and
	      // we cannot guarantee that there is no error lingering around
	      // waiting to be emitted.
	      return new Promise(function (resolve, reject) {
	        process.nextTick(function () {
	          if (_this[kError]) {
	            reject(_this[kError]);
	          } else {
	            resolve(createIterResult(undefined, true));
	          }
	        });
	      });
	    }

	    // if we have multiple next() calls
	    // we will wait for the previous Promise to finish
	    // this logic is optimized to support for await loops,
	    // where next() is only called once at a time
	    var lastPromise = this[kLastPromise];
	    var promise;
	    if (lastPromise) {
	      promise = new Promise(wrapForNext(lastPromise, this));
	    } else {
	      // fast path needed to support multiple this.push()
	      // without triggering the next() queue
	      var data = this[kStream].read();
	      if (data !== null) {
	        return Promise.resolve(createIterResult(data, false));
	      }
	      promise = new Promise(this[kHandlePromise]);
	    }
	    this[kLastPromise] = promise;
	    return promise;
	  }
	}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
	  return this;
	}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
	  var _this2 = this;
	  // destroy(err, cb) is a private API
	  // we can guarantee we have that here, because we control the
	  // Readable class this is attached to
	  return new Promise(function (resolve, reject) {
	    _this2[kStream].destroy(null, function (err) {
	      if (err) {
	        reject(err);
	        return;
	      }
	      resolve(createIterResult(undefined, true));
	    });
	  });
	}), _Object$setPrototypeO), AsyncIteratorPrototype);
	var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
	  var _Object$create;
	  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
	    value: stream,
	    writable: true
	  }), _defineProperty(_Object$create, kLastResolve, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kLastReject, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kError, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kEnded, {
	    value: stream._readableState.endEmitted,
	    writable: true
	  }), _defineProperty(_Object$create, kHandlePromise, {
	    value: function value(resolve, reject) {
	      var data = iterator[kStream].read();
	      if (data) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        resolve(createIterResult(data, false));
	      } else {
	        iterator[kLastResolve] = resolve;
	        iterator[kLastReject] = reject;
	      }
	    },
	    writable: true
	  }), _Object$create));
	  iterator[kLastPromise] = null;
	  finished(stream, function (err) {
	    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
	      var reject = iterator[kLastReject];
	      // reject if we are waiting for data in the Promise
	      // returned by next() and store the error
	      if (reject !== null) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        reject(err);
	      }
	      iterator[kError] = err;
	      return;
	    }
	    var resolve = iterator[kLastResolve];
	    if (resolve !== null) {
	      iterator[kLastPromise] = null;
	      iterator[kLastResolve] = null;
	      iterator[kLastReject] = null;
	      resolve(createIterResult(undefined, true));
	    }
	    iterator[kEnded] = true;
	  });
	  stream.on('readable', onReadable.bind(null, iterator));
	  return iterator;
	};
	async_iterator = createReadableStreamAsyncIterator;
	return async_iterator;
}

var from_1;
var hasRequiredFrom;

function requireFrom () {
	if (hasRequiredFrom) return from_1;
	hasRequiredFrom = 1;

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
	var ERR_INVALID_ARG_TYPE = requireErrors().codes.ERR_INVALID_ARG_TYPE;
	function from(Readable, iterable, opts) {
	  var iterator;
	  if (iterable && typeof iterable.next === 'function') {
	    iterator = iterable;
	  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);
	  var readable = new Readable(_objectSpread({
	    objectMode: true
	  }, opts));
	  // Reading boolean to protect against _read
	  // being called before last iteration completion.
	  var reading = false;
	  readable._read = function () {
	    if (!reading) {
	      reading = true;
	      next();
	    }
	  };
	  function next() {
	    return _next2.apply(this, arguments);
	  }
	  function _next2() {
	    _next2 = _asyncToGenerator(function* () {
	      try {
	        var _yield$iterator$next = yield iterator.next(),
	          value = _yield$iterator$next.value,
	          done = _yield$iterator$next.done;
	        if (done) {
	          readable.push(null);
	        } else if (readable.push(yield value)) {
	          next();
	        } else {
	          reading = false;
	        }
	      } catch (err) {
	        readable.destroy(err);
	      }
	    });
	    return _next2.apply(this, arguments);
	  }
	  return readable;
	}
	from_1 = from;
	return from_1;
}

var _stream_readable;
var hasRequired_stream_readable;

function require_stream_readable () {
	if (hasRequired_stream_readable) return _stream_readable;
	hasRequired_stream_readable = 1;

	_stream_readable = Readable;

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	/*<replacement>*/
	require$$0$3.EventEmitter;
	var EElistenerCount = function EElistenerCount(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStream();
	/*</replacement>*/

	var Buffer = require$$0$5.Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}

	/*<replacement>*/
	var debugUtil = require$$1$2;
	var debug;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function debug() {};
	}
	/*</replacement>*/

	var BufferList = requireBuffer_list();
	var destroyImpl = requireDestroy();
	var _require = requireState(),
	  getHighWaterMark = _require.getHighWaterMark;
	var _require$codes = requireErrors().codes,
	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

	// Lazy loaded to improve the startup performance.
	var StringDecoder;
	var createReadableStreamAsyncIterator;
	var from;
	requireInherits()(Readable, Stream);
	var errorOrDestroy = destroyImpl.errorOrDestroy;
	var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

	  // This is a hack to make sure that our error handler is attached before any
	  // userland ones.  NEVER DO THIS. This is here only because this code needs
	  // to continue to work with older versions of Node.js that do not include
	  // the prependListener() method. The goal is to eventually remove this hack.
	  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	}
	function ReadableState(options, stream, isDuplex) {
	  Duplex = Duplex || require_stream_duplex();
	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the event 'readable'/'data' is emitted
	  // immediately, or on a later tick.  We set this to true at first, because
	  // any actions that shouldn't happen until "later" should generally also
	  // not happen before the first read call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	  this.paused = true;

	  // Should close be emitted on destroy. Defaults to true.
	  this.emitClose = options.emitClose !== false;

	  // Should .destroy() be called after 'end' (and potentially 'finish')
	  this.autoDestroy = !!options.autoDestroy;

	  // has it been destroyed
	  this.destroyed = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	function Readable(options) {
	  Duplex = Duplex || require_stream_duplex();
	  if (!(this instanceof Readable)) return new Readable(options);

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the ReadableState constructor, at least with V8 6.5
	  var isDuplex = this instanceof Duplex;
	  this._readableState = new ReadableState(options, this, isDuplex);

	  // legacy
	  this.readable = true;
	  if (options) {
	    if (typeof options.read === 'function') this._read = options.read;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	  }
	  Stream.call(this);
	}
	Object.defineProperty(Readable.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._readableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._readableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	  }
	});
	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function (err, cb) {
	  cb(err);
	};

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	  var skipChunkCheck;
	  if (!state.objectMode) {
	    if (typeof chunk === 'string') {
	      encoding = encoding || state.defaultEncoding;
	      if (encoding !== state.encoding) {
	        chunk = Buffer.from(chunk, encoding);
	        encoding = '';
	      }
	      skipChunkCheck = true;
	    }
	  } else {
	    skipChunkCheck = true;
	  }
	  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  return readableAddChunk(this, chunk, null, true, false);
	};
	function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
	  debug('readableAddChunk', chunk);
	  var state = stream._readableState;
	  if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else {
	    var er;
	    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
	    if (er) {
	      errorOrDestroy(stream, er);
	    } else if (state.objectMode || chunk && chunk.length > 0) {
	      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
	        chunk = _uint8ArrayToBuffer(chunk);
	      }
	      if (addToFront) {
	        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
	      } else if (state.ended) {
	        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
	      } else if (state.destroyed) {
	        return false;
	      } else {
	        state.reading = false;
	        if (state.decoder && !encoding) {
	          chunk = state.decoder.write(chunk);
	          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
	        } else {
	          addChunk(stream, state, chunk, false);
	        }
	      }
	    } else if (!addToFront) {
	      state.reading = false;
	      maybeReadMore(stream, state);
	    }
	  }

	  // We can push more data if we are below the highWaterMark.
	  // Also, if we have no data yet, we can stand some more bytes.
	  // This is to work around cases where hwm=0, such as the repl.
	  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
	}
	function addChunk(stream, state, chunk, addToFront) {
	  if (state.flowing && state.length === 0 && !state.sync) {
	    state.awaitDrain = 0;
	    stream.emit('data', chunk);
	  } else {
	    // update the buffer info.
	    state.length += state.objectMode ? 1 : chunk.length;
	    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	    if (state.needReadable) emitReadable(stream);
	  }
	  maybeReadMore(stream, state);
	}
	function chunkInvalid(state, chunk) {
	  var er;
	  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
	  }
	  return er;
	}
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
	  var decoder = new StringDecoder(enc);
	  this._readableState.decoder = decoder;
	  // If setEncoding(null), decoder.encoding equals utf8
	  this._readableState.encoding = this._readableState.decoder.encoding;

	  // Iterate over current buffer to convert already stored Buffers:
	  var p = this._readableState.buffer.head;
	  var content = '';
	  while (p !== null) {
	    content += decoder.write(p.data);
	    p = p.next;
	  }
	  this._readableState.buffer.clear();
	  if (content !== '') this._readableState.buffer.push(content);
	  this._readableState.length = content.length;
	  return this;
	};

	// Don't raise the hwm > 1GB
	var MAX_HWM = 0x40000000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	  if (n !== 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	  if (ret === null) {
	    state.needReadable = state.length <= state.highWaterMark;
	    n = 0;
	  } else {
	    state.length -= n;
	    state.awaitDrain = 0;
	  }
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	  if (ret !== null) this.emit('data', ret);
	  return ret;
	};
	function onEofChunk(stream, state) {
	  debug('onEofChunk');
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	  if (state.sync) {
	    // if we are sync, wait until next tick to emit the data.
	    // Otherwise we risk emitting data in the flow()
	    // the readable code triggers during a read() call
	    emitReadable(stream);
	  } else {
	    // emit 'readable' now to make sure it gets picked up.
	    state.needReadable = false;
	    if (!state.emittedReadable) {
	      state.emittedReadable = true;
	      emitReadable_(stream);
	    }
	  }
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  debug('emitReadable', state.needReadable, state.emittedReadable);
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    process.nextTick(emitReadable_, stream);
	  }
	}
	function emitReadable_(stream) {
	  var state = stream._readableState;
	  debug('emitReadable_', state.destroyed, state.length, state.ended);
	  if (!state.destroyed && (state.length || state.ended)) {
	    stream.emit('readable');
	    state.emittedReadable = false;
	  }

	  // The stream needs another readable event if
	  // 1. It is not flowing, as the flow mechanism will take
	  //    care of it.
	  // 2. It is not ended.
	  // 3. It is below the highWaterMark, so we can schedule
	  //    another readable later.
	  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(maybeReadMore_, stream, state);
	  }
	}
	function maybeReadMore_(stream, state) {
	  // Attempt to read more data if we should.
	  //
	  // The conditions for reading more data are (one of):
	  // - Not enough data buffered (state.length < state.highWaterMark). The loop
	  //   is responsible for filling the buffer with enough data if such data
	  //   is available. If highWaterMark is 0 and we are not in the flowing mode
	  //   we should _not_ attempt to buffer any extra data. We'll get more data
	  //   when the stream consumer calls read() instead.
	  // - No data in the buffer, and the stream is in flowing mode. In this mode
	  //   the loop below is responsible for ensuring read() is called. Failing to
	  //   call read here would abort the flow and there's no other mechanism for
	  //   continuing the flow if the stream consumer has just subscribed to the
	  //   'data' event.
	  //
	  // In addition to the above conditions to keep reading data, the following
	  // conditions prevent the data from being read:
	  // - The stream has ended (state.ended).
	  // - There is already a pending 'read' operation (state.reading). This is a
	  //   case where the the stream has called the implementation defined _read()
	  //   method, but they are processing the call asynchronously and have _not_
	  //   called push() with new data. In this case we skip performing more
	  //   read()s. The execution ends in this method again after the _read() ends
	  //   up calling push() with more data.
	  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
	    var len = state.length;
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
	};
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	  var endFn = doEnd ? onend : unpipe;
	  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable, unpipeInfo) {
	    debug('onunpipe');
	    if (readable === src) {
	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
	        unpipeInfo.hasUnpiped = true;
	        cleanup();
	      }
	    }
	  }
	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', unpipe);
	    src.removeListener('data', ondata);
	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    debug('dest.write', ret);
	    if (ret === false) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', state.awaitDrain);
	        state.awaitDrain++;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	  return dest;
	};
	function pipeOnDrain(src) {
	  return function pipeOnDrainFunctionResult() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	  var unpipeInfo = {
	    hasUnpiped: false
	  };

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this, unpipeInfo);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
	      hasUnpiped: false
	    });
	    return this;
	  }

	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	  dest.emit('unpipe', this, unpipeInfo);
	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	  var state = this._readableState;
	  if (ev === 'data') {
	    // update readableListening so that resume() may be a no-op
	    // a few lines down. This is needed to support once('readable').
	    state.readableListening = this.listenerCount('readable') > 0;

	    // Try start flowing on next tick if stream isn't explicitly paused
	    if (state.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.flowing = false;
	      state.emittedReadable = false;
	      debug('on readable', state.length, state.reading);
	      if (state.length) {
	        emitReadable(this);
	      } else if (!state.reading) {
	        process.nextTick(nReadingNextTick, this);
	      }
	    }
	  }
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	Readable.prototype.removeListener = function (ev, fn) {
	  var res = Stream.prototype.removeListener.call(this, ev, fn);
	  if (ev === 'readable') {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }
	  return res;
	};
	Readable.prototype.removeAllListeners = function (ev) {
	  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
	  if (ev === 'readable' || ev === undefined) {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }
	  return res;
	};
	function updateReadableListening(self) {
	  var state = self._readableState;
	  state.readableListening = self.listenerCount('readable') > 0;
	  if (state.resumeScheduled && !state.paused) {
	    // flowing needs to be set to true now, otherwise
	    // the upcoming resume will not flow.
	    state.flowing = true;

	    // crude way to check if we should resume
	  } else if (self.listenerCount('data') > 0) {
	    self.resume();
	  }
	}
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    // we flow only if there is no one listening
	    // for readable, but we still have to call
	    // resume()
	    state.flowing = !state.readableListening;
	    resume(this, state);
	  }
	  state.paused = false;
	  return this;
	};
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(resume_, stream, state);
	  }
	}
	function resume_(stream, state) {
	  debug('resume', state.reading);
	  if (!state.reading) {
	    stream.read(0);
	  }
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (this._readableState.flowing !== false) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  this._readableState.paused = true;
	  return this;
	};
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null);
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var _this = this;
	  var state = this._readableState;
	  var paused = false;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) _this.push(chunk);
	    }
	    _this.push(null);
	  });
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	    var ret = _this.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function methodWrap(method) {
	        return function methodWrapReturnFunction() {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  for (var n = 0; n < kProxyEvents.length; n++) {
	    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
	  }

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  this._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	  return this;
	};
	if (typeof Symbol === 'function') {
	  Readable.prototype[Symbol.asyncIterator] = function () {
	    if (createReadableStreamAsyncIterator === undefined) {
	      createReadableStreamAsyncIterator = requireAsync_iterator();
	    }
	    return createReadableStreamAsyncIterator(this);
	  };
	}
	Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.highWaterMark;
	  }
	});
	Object.defineProperty(Readable.prototype, 'readableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState && this._readableState.buffer;
	  }
	});
	Object.defineProperty(Readable.prototype, 'readableFlowing', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.flowing;
	  },
	  set: function set(state) {
	    if (this._readableState) {
	      this._readableState.flowing = state;
	    }
	  }
	});

	// exposed for testing purposes only.
	Readable._fromList = fromList;
	Object.defineProperty(Readable.prototype, 'readableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.length;
	  }
	});

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = state.buffer.consume(n, state.decoder);
	  }
	  return ret;
	}
	function endReadable(stream) {
	  var state = stream._readableState;
	  debug('endReadable', state.endEmitted);
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(endReadableNT, state, stream);
	  }
	}
	function endReadableNT(state, stream) {
	  debug('endReadableNT', state.endEmitted, state.length);

	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	    if (state.autoDestroy) {
	      // In case of duplex streams we need a way to detect
	      // if the writable side is ready for autoDestroy as well
	      var wState = stream._writableState;
	      if (!wState || wState.autoDestroy && wState.finished) {
	        stream.destroy();
	      }
	    }
	  }
	}
	if (typeof Symbol === 'function') {
	  Readable.from = function (iterable, opts) {
	    if (from === undefined) {
	      from = requireFrom();
	    }
	    return from(Readable, iterable, opts);
	  };
	}
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	return _stream_readable;
}

var _stream_transform;
var hasRequired_stream_transform;

function require_stream_transform () {
	if (hasRequired_stream_transform) return _stream_transform;
	hasRequired_stream_transform = 1;

	_stream_transform = Transform;
	var _require$codes = requireErrors().codes,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
	  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
	var Duplex = require_stream_duplex();
	requireInherits()(Transform, Duplex);
	function afterTransform(er, data) {
	  var ts = this._transformState;
	  ts.transforming = false;
	  var cb = ts.writecb;
	  if (cb === null) {
	    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
	  }
	  ts.writechunk = null;
	  ts.writecb = null;
	  if (data != null)
	    // single equals check for both `null` and `undefined`
	    this.push(data);
	  cb(er);
	  var rs = this._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    this._read(rs.highWaterMark);
	  }
	}
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	  Duplex.call(this, options);
	  this._transformState = {
	    afterTransform: afterTransform.bind(this),
	    needTransform: false,
	    transforming: false,
	    writecb: null,
	    writechunk: null,
	    writeencoding: null
	  };

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  // When the writable side finishes, then flush out anything remaining.
	  this.on('prefinish', prefinish);
	}
	function prefinish() {
	  var _this = this;
	  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
	    this._flush(function (er, data) {
	      done(_this, er, data);
	    });
	  } else {
	    done(this, null, null);
	  }
	}
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
	};
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	  if (ts.writechunk !== null && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	Transform.prototype._destroy = function (err, cb) {
	  Duplex.prototype._destroy.call(this, err, function (err2) {
	    cb(err2);
	  });
	};
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	  if (data != null)
	    // single equals check for both `null` and `undefined`
	    stream.push(data);

	  // TODO(BridgeAR): Write a test for these two error cases
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
	  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
	  return stream.push(null);
	}
	return _stream_transform;
}

var _stream_passthrough;
var hasRequired_stream_passthrough;

function require_stream_passthrough () {
	if (hasRequired_stream_passthrough) return _stream_passthrough;
	hasRequired_stream_passthrough = 1;

	_stream_passthrough = PassThrough;
	var Transform = require_stream_transform();
	requireInherits()(PassThrough, Transform);
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	  Transform.call(this, options);
	}
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};
	return _stream_passthrough;
}

var pipeline_1;
var hasRequiredPipeline;

function requirePipeline () {
	if (hasRequiredPipeline) return pipeline_1;
	hasRequiredPipeline = 1;

	var eos;
	function once(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    callback.apply(void 0, arguments);
	  };
	}
	var _require$codes = requireErrors().codes,
	  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
	  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
	function noop(err) {
	  // Rethrow the error if it exists to avoid swallowing it
	  if (err) throw err;
	}
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}
	function destroyer(stream, reading, writing, callback) {
	  callback = once(callback);
	  var closed = false;
	  stream.on('close', function () {
	    closed = true;
	  });
	  if (eos === undefined) eos = requireEndOfStream();
	  eos(stream, {
	    readable: reading,
	    writable: writing
	  }, function (err) {
	    if (err) return callback(err);
	    closed = true;
	    callback();
	  });
	  var destroyed = false;
	  return function (err) {
	    if (closed) return;
	    if (destroyed) return;
	    destroyed = true;

	    // request.destroy just do .end - .abort is what we want
	    if (isRequest(stream)) return stream.abort();
	    if (typeof stream.destroy === 'function') return stream.destroy();
	    callback(err || new ERR_STREAM_DESTROYED('pipe'));
	  };
	}
	function call(fn) {
	  fn();
	}
	function pipe(from, to) {
	  return from.pipe(to);
	}
	function popCallback(streams) {
	  if (!streams.length) return noop;
	  if (typeof streams[streams.length - 1] !== 'function') return noop;
	  return streams.pop();
	}
	function pipeline() {
	  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
	    streams[_key] = arguments[_key];
	  }
	  var callback = popCallback(streams);
	  if (Array.isArray(streams[0])) streams = streams[0];
	  if (streams.length < 2) {
	    throw new ERR_MISSING_ARGS('streams');
	  }
	  var error;
	  var destroys = streams.map(function (stream, i) {
	    var reading = i < streams.length - 1;
	    var writing = i > 0;
	    return destroyer(stream, reading, writing, function (err) {
	      if (!error) error = err;
	      if (err) destroys.forEach(call);
	      if (reading) return;
	      destroys.forEach(call);
	      callback(error);
	    });
	  });
	  return streams.reduce(pipe);
	}
	pipeline_1 = pipeline;
	return pipeline_1;
}

var hasRequiredReadable;

function requireReadable () {
	if (hasRequiredReadable) return readable.exports;
	hasRequiredReadable = 1;
	(function (module, exports$1) {
		var Stream = require$$0$2;
		if (process.env.READABLE_STREAM === 'disable' && Stream) {
		  module.exports = Stream.Readable;
		  Object.assign(module.exports, Stream);
		  module.exports.Stream = Stream;
		} else {
		  exports$1 = module.exports = require_stream_readable();
		  exports$1.Stream = Stream || exports$1;
		  exports$1.Readable = exports$1;
		  exports$1.Writable = require_stream_writable();
		  exports$1.Duplex = require_stream_duplex();
		  exports$1.Transform = require_stream_transform();
		  exports$1.PassThrough = require_stream_passthrough();
		  exports$1.finished = requireEndOfStream();
		  exports$1.pipeline = requirePipeline();
		} 
	} (readable, readable.exports));
	return readable.exports;
}

var BufferList_1;
var hasRequiredBufferList;

function requireBufferList () {
	if (hasRequiredBufferList) return BufferList_1;
	hasRequiredBufferList = 1;

	const { Buffer } = require$$0$5;
	const symbol = Symbol.for('BufferList');

	function BufferList (buf) {
	  if (!(this instanceof BufferList)) {
	    return new BufferList(buf)
	  }

	  BufferList._init.call(this, buf);
	}

	BufferList._init = function _init (buf) {
	  Object.defineProperty(this, symbol, { value: true });

	  this._bufs = [];
	  this.length = 0;

	  if (buf) {
	    this.append(buf);
	  }
	};

	BufferList.prototype._new = function _new (buf) {
	  return new BufferList(buf)
	};

	BufferList.prototype._offset = function _offset (offset) {
	  if (offset === 0) {
	    return [0, 0]
	  }

	  let tot = 0;

	  for (let i = 0; i < this._bufs.length; i++) {
	    const _t = tot + this._bufs[i].length;
	    if (offset < _t || i === this._bufs.length - 1) {
	      return [i, offset - tot]
	    }
	    tot = _t;
	  }
	};

	BufferList.prototype._reverseOffset = function (blOffset) {
	  const bufferId = blOffset[0];
	  let offset = blOffset[1];

	  for (let i = 0; i < bufferId; i++) {
	    offset += this._bufs[i].length;
	  }

	  return offset
	};

	BufferList.prototype.get = function get (index) {
	  if (index > this.length || index < 0) {
	    return undefined
	  }

	  const offset = this._offset(index);

	  return this._bufs[offset[0]][offset[1]]
	};

	BufferList.prototype.slice = function slice (start, end) {
	  if (typeof start === 'number' && start < 0) {
	    start += this.length;
	  }

	  if (typeof end === 'number' && end < 0) {
	    end += this.length;
	  }

	  return this.copy(null, 0, start, end)
	};

	BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
	  if (typeof srcStart !== 'number' || srcStart < 0) {
	    srcStart = 0;
	  }

	  if (typeof srcEnd !== 'number' || srcEnd > this.length) {
	    srcEnd = this.length;
	  }

	  if (srcStart >= this.length) {
	    return dst || Buffer.alloc(0)
	  }

	  if (srcEnd <= 0) {
	    return dst || Buffer.alloc(0)
	  }

	  const copy = !!dst;
	  const off = this._offset(srcStart);
	  const len = srcEnd - srcStart;
	  let bytes = len;
	  let bufoff = (copy && dstStart) || 0;
	  let start = off[1];

	  // copy/slice everything
	  if (srcStart === 0 && srcEnd === this.length) {
	    if (!copy) {
	      // slice, but full concat if multiple buffers
	      return this._bufs.length === 1
	        ? this._bufs[0]
	        : Buffer.concat(this._bufs, this.length)
	    }

	    // copy, need to copy individual buffers
	    for (let i = 0; i < this._bufs.length; i++) {
	      this._bufs[i].copy(dst, bufoff);
	      bufoff += this._bufs[i].length;
	    }

	    return dst
	  }

	  // easy, cheap case where it's a subset of one of the buffers
	  if (bytes <= this._bufs[off[0]].length - start) {
	    return copy
	      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
	      : this._bufs[off[0]].slice(start, start + bytes)
	  }

	  if (!copy) {
	    // a slice, we need something to copy in to
	    dst = Buffer.allocUnsafe(len);
	  }

	  for (let i = off[0]; i < this._bufs.length; i++) {
	    const l = this._bufs[i].length - start;

	    if (bytes > l) {
	      this._bufs[i].copy(dst, bufoff, start);
	      bufoff += l;
	    } else {
	      this._bufs[i].copy(dst, bufoff, start, start + bytes);
	      bufoff += l;
	      break
	    }

	    bytes -= l;

	    if (start) {
	      start = 0;
	    }
	  }

	  // safeguard so that we don't return uninitialized memory
	  if (dst.length > bufoff) return dst.slice(0, bufoff)

	  return dst
	};

	BufferList.prototype.shallowSlice = function shallowSlice (start, end) {
	  start = start || 0;
	  end = typeof end !== 'number' ? this.length : end;

	  if (start < 0) {
	    start += this.length;
	  }

	  if (end < 0) {
	    end += this.length;
	  }

	  if (start === end) {
	    return this._new()
	  }

	  const startOffset = this._offset(start);
	  const endOffset = this._offset(end);
	  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);

	  if (endOffset[1] === 0) {
	    buffers.pop();
	  } else {
	    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
	  }

	  if (startOffset[1] !== 0) {
	    buffers[0] = buffers[0].slice(startOffset[1]);
	  }

	  return this._new(buffers)
	};

	BufferList.prototype.toString = function toString (encoding, start, end) {
	  return this.slice(start, end).toString(encoding)
	};

	BufferList.prototype.consume = function consume (bytes) {
	  // first, normalize the argument, in accordance with how Buffer does it
	  bytes = Math.trunc(bytes);
	  // do nothing if not a positive number
	  if (Number.isNaN(bytes) || bytes <= 0) return this

	  while (this._bufs.length) {
	    if (bytes >= this._bufs[0].length) {
	      bytes -= this._bufs[0].length;
	      this.length -= this._bufs[0].length;
	      this._bufs.shift();
	    } else {
	      this._bufs[0] = this._bufs[0].slice(bytes);
	      this.length -= bytes;
	      break
	    }
	  }

	  return this
	};

	BufferList.prototype.duplicate = function duplicate () {
	  const copy = this._new();

	  for (let i = 0; i < this._bufs.length; i++) {
	    copy.append(this._bufs[i]);
	  }

	  return copy
	};

	BufferList.prototype.append = function append (buf) {
	  if (buf == null) {
	    return this
	  }

	  if (buf.buffer) {
	    // append a view of the underlying ArrayBuffer
	    this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));
	  } else if (Array.isArray(buf)) {
	    for (let i = 0; i < buf.length; i++) {
	      this.append(buf[i]);
	    }
	  } else if (this._isBufferList(buf)) {
	    // unwrap argument into individual BufferLists
	    for (let i = 0; i < buf._bufs.length; i++) {
	      this.append(buf._bufs[i]);
	    }
	  } else {
	    // coerce number arguments to strings, since Buffer(number) does
	    // uninitialized memory allocation
	    if (typeof buf === 'number') {
	      buf = buf.toString();
	    }

	    this._appendBuffer(Buffer.from(buf));
	  }

	  return this
	};

	BufferList.prototype._appendBuffer = function appendBuffer (buf) {
	  this._bufs.push(buf);
	  this.length += buf.length;
	};

	BufferList.prototype.indexOf = function (search, offset, encoding) {
	  if (encoding === undefined && typeof offset === 'string') {
	    encoding = offset;
	    offset = undefined;
	  }

	  if (typeof search === 'function' || Array.isArray(search)) {
	    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
	  } else if (typeof search === 'number') {
	    search = Buffer.from([search]);
	  } else if (typeof search === 'string') {
	    search = Buffer.from(search, encoding);
	  } else if (this._isBufferList(search)) {
	    search = search.slice();
	  } else if (Array.isArray(search.buffer)) {
	    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);
	  } else if (!Buffer.isBuffer(search)) {
	    search = Buffer.from(search);
	  }

	  offset = Number(offset || 0);

	  if (isNaN(offset)) {
	    offset = 0;
	  }

	  if (offset < 0) {
	    offset = this.length + offset;
	  }

	  if (offset < 0) {
	    offset = 0;
	  }

	  if (search.length === 0) {
	    return offset > this.length ? this.length : offset
	  }

	  const blOffset = this._offset(offset);
	  let blIndex = blOffset[0]; // index of which internal buffer we're working on
	  let buffOffset = blOffset[1]; // offset of the internal buffer we're working on

	  // scan over each buffer
	  for (; blIndex < this._bufs.length; blIndex++) {
	    const buff = this._bufs[blIndex];

	    while (buffOffset < buff.length) {
	      const availableWindow = buff.length - buffOffset;

	      if (availableWindow >= search.length) {
	        const nativeSearchResult = buff.indexOf(search, buffOffset);

	        if (nativeSearchResult !== -1) {
	          return this._reverseOffset([blIndex, nativeSearchResult])
	        }

	        buffOffset = buff.length - search.length + 1; // end of native search window
	      } else {
	        const revOffset = this._reverseOffset([blIndex, buffOffset]);

	        if (this._match(revOffset, search)) {
	          return revOffset
	        }

	        buffOffset++;
	      }
	    }

	    buffOffset = 0;
	  }

	  return -1
	};

	BufferList.prototype._match = function (offset, search) {
	  if (this.length - offset < search.length) {
	    return false
	  }

	  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
	    if (this.get(offset + searchOffset) !== search[searchOffset]) {
	      return false
	    }
	  }
	  return true
	}

	;(function () {
	  const methods = {
	    readDoubleBE: 8,
	    readDoubleLE: 8,
	    readFloatBE: 4,
	    readFloatLE: 4,
	    readInt32BE: 4,
	    readInt32LE: 4,
	    readUInt32BE: 4,
	    readUInt32LE: 4,
	    readInt16BE: 2,
	    readInt16LE: 2,
	    readUInt16BE: 2,
	    readUInt16LE: 2,
	    readInt8: 1,
	    readUInt8: 1,
	    readIntBE: null,
	    readIntLE: null,
	    readUIntBE: null,
	    readUIntLE: null
	  };

	  for (const m in methods) {
	    (function (m) {
	      if (methods[m] === null) {
	        BufferList.prototype[m] = function (offset, byteLength) {
	          return this.slice(offset, offset + byteLength)[m](0, byteLength)
	        };
	      } else {
	        BufferList.prototype[m] = function (offset = 0) {
	          return this.slice(offset, offset + methods[m])[m](0)
	        };
	      }
	    }(m));
	  }
	}());

	// Used internally by the class and also as an indicator of this object being
	// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
	// environment because there could be multiple different copies of the
	// BufferList class and some `BufferList`s might be `BufferList`s.
	BufferList.prototype._isBufferList = function _isBufferList (b) {
	  return b instanceof BufferList || BufferList.isBufferList(b)
	};

	BufferList.isBufferList = function isBufferList (b) {
	  return b != null && b[symbol]
	};

	BufferList_1 = BufferList;
	return BufferList_1;
}

var hasRequiredBl;

function requireBl () {
	if (hasRequiredBl) return bl.exports;
	hasRequiredBl = 1;

	const DuplexStream = requireReadable().Duplex;
	const inherits = requireInherits();
	const BufferList = requireBufferList();

	function BufferListStream (callback) {
	  if (!(this instanceof BufferListStream)) {
	    return new BufferListStream(callback)
	  }

	  if (typeof callback === 'function') {
	    this._callback = callback;

	    const piper = function piper (err) {
	      if (this._callback) {
	        this._callback(err);
	        this._callback = null;
	      }
	    }.bind(this);

	    this.on('pipe', function onPipe (src) {
	      src.on('error', piper);
	    });
	    this.on('unpipe', function onUnpipe (src) {
	      src.removeListener('error', piper);
	    });

	    callback = null;
	  }

	  BufferList._init.call(this, callback);
	  DuplexStream.call(this);
	}

	inherits(BufferListStream, DuplexStream);
	Object.assign(BufferListStream.prototype, BufferList.prototype);

	BufferListStream.prototype._new = function _new (callback) {
	  return new BufferListStream(callback)
	};

	BufferListStream.prototype._write = function _write (buf, encoding, callback) {
	  this._appendBuffer(buf);

	  if (typeof callback === 'function') {
	    callback();
	  }
	};

	BufferListStream.prototype._read = function _read (size) {
	  if (!this.length) {
	    return this.push(null)
	  }

	  size = Math.min(size, this.length);
	  this.push(this.slice(0, size));
	  this.consume(size);
	};

	BufferListStream.prototype.end = function end (chunk) {
	  DuplexStream.prototype.end.call(this, chunk);

	  if (this._callback) {
	    this._callback(null, this.slice());
	    this._callback = null;
	  }
	};

	BufferListStream.prototype._destroy = function _destroy (err, cb) {
	  this._bufs.length = 0;
	  this.length = 0;
	  cb(err);
	};

	BufferListStream.prototype._isBufferList = function _isBufferList (b) {
	  return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b)
	};

	BufferListStream.isBufferList = BufferList.isBufferList;

	bl.exports = BufferListStream;
	bl.exports.BufferListStream = BufferListStream;
	bl.exports.BufferList = BufferList;
	return bl.exports;
}

var streams$2 = {};

var hasRequiredStreams;

function requireStreams () {
	if (hasRequiredStreams) return streams$2;
	hasRequiredStreams = 1;

	const Transform = requireReadable().Transform;
	const inherits = requireInherits();
	const bl = requireBl();

	function Base (opts) {
	  opts = opts || {};

	  opts.objectMode = true;
	  opts.highWaterMark = 16;

	  Transform.call(this, opts);

	  this._msgpack = opts.msgpack;
	}

	inherits(Base, Transform);

	function Encoder (opts) {
	  if (!(this instanceof Encoder)) {
	    opts = opts || {};
	    opts.msgpack = this;
	    return new Encoder(opts)
	  }

	  Base.call(this, opts);
	  this._wrap = ('wrap' in opts) && opts.wrap;
	}

	inherits(Encoder, Base);

	Encoder.prototype._transform = function (obj, enc, done) {
	  let buf = null;

	  try {
	    buf = this._msgpack.encode(this._wrap ? obj.value : obj).slice(0);
	  } catch (err) {
	    this.emit('error', err);
	    return done()
	  }

	  this.push(buf);
	  done();
	};

	function Decoder (opts) {
	  if (!(this instanceof Decoder)) {
	    opts = opts || {};
	    opts.msgpack = this;
	    return new Decoder(opts)
	  }

	  Base.call(this, opts);

	  this._chunks = bl();
	  this._wrap = ('wrap' in opts) && opts.wrap;
	}

	inherits(Decoder, Base);

	Decoder.prototype._transform = function (buf, enc, done) {
	  if (buf) {
	    this._chunks.append(buf);
	  }

	  try {
	    let result = this._msgpack.decode(this._chunks);
	    if (this._wrap) {
	      result = { value: result };
	    }
	    this.push(result);
	  } catch (err) {
	    if (err instanceof this._msgpack.IncompleteBufferError) {
	      done();
	    } else {
	      this.emit('error', err);
	    }
	    return
	  }

	  if (this._chunks.length > 0) {
	    this._transform(null, enc, done);
	  } else {
	    done();
	  }
	};

	streams$2.decoder = Decoder;
	streams$2.encoder = Encoder;
	return streams$2;
}

var helpers = {};

var hasRequiredHelpers;

function requireHelpers () {
	if (hasRequiredHelpers) return helpers;
	hasRequiredHelpers = 1;

	const util = require$$1$2;

	helpers.IncompleteBufferError = IncompleteBufferError;

	function IncompleteBufferError (message) {
	  Error.call(this); // super constructor
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, this.constructor); // super helper method to include stack trace in error object
	  }
	  this.name = this.constructor.name;
	  this.message = message || 'unable to decode';
	}

	util.inherits(IncompleteBufferError, Error);

	helpers.isFloat = function isFloat (n) {
	  return n % 1 !== 0
	};
	return helpers;
}

var decoder;
var hasRequiredDecoder;

function requireDecoder () {
	if (hasRequiredDecoder) return decoder;
	hasRequiredDecoder = 1;

	const bl = requireBl();
	const IncompleteBufferError = requireHelpers().IncompleteBufferError;

	const SIZES = {
	  0xc4: 2,
	  0xc5: 3,
	  0xc6: 5,
	  0xc7: 3,
	  0xc8: 4,
	  0xc9: 6,
	  0xca: 5,
	  0xcb: 9,
	  0xcc: 2,
	  0xcd: 3,
	  0xce: 5,
	  0xcf: 9,
	  0xd0: 2,
	  0xd1: 3,
	  0xd2: 5,
	  0xd3: 9,
	  0xd4: 3,
	  0xd5: 4,
	  0xd6: 6,
	  0xd7: 10,
	  0xd8: 18,
	  0xd9: 2,
	  0xda: 3,
	  0xdb: 5,
	  0xde: 3,
	  0xdc: 3,
	  0xdd: 5
	};

	function isValidDataSize (dataLength, bufLength, headerLength) {
	  return bufLength >= headerLength + dataLength
	}

	decoder = function buildDecode (decodingTypes, options) {
	  const context = { decodingTypes, options};
	  return decode

	  function decode (buf) {
	    // TODO: Make it into ensureBl handler ?
	    if (!(buf instanceof bl)) {
	      buf = bl().append(buf);
	    }

	    const result = tryDecode(buf, 0, context);
	    // Handle worst case ASAP and keep code flat
	    if (!result) throw new IncompleteBufferError()

	    buf.consume(result[1]);
	    return result[0]
	  }
	};

	function decodeArray (buf, initialOffset, length, headerLength, context) {
	  let offset = initialOffset;
	  const result = [];
	  let i = 0;

	  while (i++ < length) {
	    const decodeResult = tryDecode(buf, offset, context);
	    if (!decodeResult) return null

	    result.push(decodeResult[0]);
	    offset += decodeResult[1];
	  }
	  return [result, headerLength + offset - initialOffset]
	}

	function decodeMap (buf, offset, length, headerLength, context) {
	  const _temp = decodeArray(buf, offset, 2 * length, headerLength, context);
	  if (!_temp) return null
	  const [result, consumedBytes] = _temp;

	  let isPlainObject = !context.options.preferMap;

	  if (isPlainObject) {
	    for (let i = 0; i < 2 * length; i += 2) {
	      if (typeof result[i] !== 'string') {
	        isPlainObject = false;
	        break
	      }
	    }
	  }

	  if (isPlainObject) {
	    const object = {};
	    for (let i = 0; i < 2 * length; i += 2) {
	      const key = result[i];
	      const val = result[i + 1];

	      if (key === '__proto__') {
	        if (context.options.protoAction === 'error') {
	          throw new SyntaxError('Object contains forbidden prototype property')
	        }

	        if (context.options.protoAction === 'remove') {
	          continue
	        }
	      }

	      object[key] = val;
	    }
	    return [object, consumedBytes]
	  } else {
	    const mapping = new Map();
	    for (let i = 0; i < 2 * length; i += 2) {
	      const key = result[i];
	      const val = result[i + 1];
	      mapping.set(key, val);
	    }
	    return [mapping, consumedBytes]
	  }
	}

	function tryDecode (buf, initialOffset, context) {
	  if (buf.length <= initialOffset) return null

	  const bufLength = buf.length - initialOffset;
	  let offset = initialOffset;

	  const first = buf.readUInt8(offset);
	  offset += 1;

	  const size = SIZES[first] || -1;
	  if (bufLength < size) return null

	  if (first < 0x80) return [first, 1] // 7-bits positive ints
	  if ((first & 0xf0) === 0x80) {
	    const length = first & 0x0f;
	    const headerSize = offset - initialOffset;
	    // we have a map with less than 15 elements
	    return decodeMap(buf, offset, length, headerSize, context)
	  }
	  if ((first & 0xf0) === 0x90) {
	    const length = first & 0x0f;
	    const headerSize = offset - initialOffset;
	    // we have an array with less than 15 elements
	    return decodeArray(buf, offset, length, headerSize, context)
	  }

	  if ((first & 0xe0) === 0xa0) {
	    // fixstr up to 31 bytes
	    const length = first & 0x1f;
	    if (!isValidDataSize(length, bufLength, 1)) return null
	    const result = buf.toString('utf8', offset, offset + length);
	    return [result, length + 1]
	  }
	  if (first >= 0xc0 && first <= 0xc3) return decodeConstants(first)
	  if (first >= 0xc4 && first <= 0xc6) {
	    const length = buf.readUIntBE(offset, size - 1);
	    offset += size - 1;

	    if (!isValidDataSize(length, bufLength, size)) return null
	    const result = buf.slice(offset, offset + length);
	    return [result, size + length]
	  }
	  if (first >= 0xc7 && first <= 0xc9) {
	    const length = buf.readUIntBE(offset, size - 2);
	    offset += size - 2;

	    const type = buf.readInt8(offset);
	    offset += 1;

	    if (!isValidDataSize(length, bufLength, size)) return null
	    return decodeExt(buf, offset, type, length, size, context)
	  }
	  if (first >= 0xca && first <= 0xcb) return decodeFloat(buf, offset, size - 1)
	  if (first >= 0xcc && first <= 0xcf) return decodeUnsignedInt(buf, offset, size - 1)
	  if (first >= 0xd0 && first <= 0xd3) return decodeSigned(buf, offset, size - 1)
	  if (first >= 0xd4 && first <= 0xd8) {
	    const type = buf.readInt8(offset); // Signed
	    offset += 1;
	    return decodeExt(buf, offset, type, size - 2, 2, context)
	  }

	  if (first >= 0xd9 && first <= 0xdb) {
	    const length = buf.readUIntBE(offset, size - 1);
	    offset += size - 1;

	    if (!isValidDataSize(length, bufLength, size)) return null
	    const result = buf.toString('utf8', offset, offset + length);
	    return [result, size + length]
	  }
	  if (first >= 0xdc && first <= 0xdd) {
	    const length = buf.readUIntBE(offset, size - 1);
	    offset += size - 1;
	    return decodeArray(buf, offset, length, size, context)
	  }
	  if (first >= 0xde && first <= 0xdf) {
	    let length;
	    switch (first) {
	      case 0xde:
	        // maps up to 2^16 elements - 2 bytes
	        length = buf.readUInt16BE(offset);
	        offset += 2;
	        // console.log(offset - initialOffset)
	        return decodeMap(buf, offset, length, 3, context)

	      case 0xdf:
	        length = buf.readUInt32BE(offset);
	        offset += 4;
	        return decodeMap(buf, offset, length, 5, context)
	    }
	  }
	  if (first >= 0xe0) return [first - 0x100, 1] // 5 bits negative ints

	  throw new Error('not implemented yet')
	}

	function decodeSigned (buf, offset, size) {
	  let result;
	  if (size === 1) result = buf.readInt8(offset);
	  if (size === 2) result = buf.readInt16BE(offset);
	  if (size === 4) result = buf.readInt32BE(offset);
	  if (size === 8) result = readInt64BE(buf.slice(offset, offset + 8), 0);
	  return [result, size + 1]
	}

	function decodeExt (buf, offset, type, size, headerSize, context) {
	  const toDecode = buf.slice(offset, offset + size);

	  const decode = context.decodingTypes.get(type);
	  if (!decode) throw new Error('unable to find ext type ' + type)

	  const value = decode(toDecode);
	  return [value, headerSize + size]
	}

	function decodeUnsignedInt (buf, offset, size) {
	  const maxOffset = offset + size;
	  let result = 0;
	  while (offset < maxOffset) { result += buf.readUInt8(offset++) * Math.pow(256, maxOffset - offset); }
	  return [result, size + 1]
	}

	function decodeConstants (first) {
	  if (first === 0xc0) return [null, 1]
	  if (first === 0xc2) return [false, 1]
	  if (first === 0xc3) return [true, 1]
	}

	function decodeFloat (buf, offset, size) {
	  let result;
	  if (size === 4) result = buf.readFloatBE(offset);
	  if (size === 8) result = buf.readDoubleBE(offset);
	  return [result, size + 1]
	}

	function readInt64BE (buf, offset) {
	  var negate = (buf[offset] & 0x80) == 0x80; // eslint-disable-line

	  if (negate) {
	    let carry = 1;
	    for (let i = offset + 7; i >= offset; i--) {
	      const v = (buf[i] ^ 0xff) + carry;
	      buf[i] = v & 0xff;
	      carry = v >> 8;
	    }
	  }

	  const hi = buf.readUInt32BE(offset + 0);
	  const lo = buf.readUInt32BE(offset + 4);
	  return (hi * 4294967296 + lo) * (negate ? -1 : 1)
	}
	return decoder;
}

var encoder;
var hasRequiredEncoder;

function requireEncoder () {
	if (hasRequiredEncoder) return encoder;
	hasRequiredEncoder = 1;

	const Buffer = requireSafeBuffer().Buffer;
	const bl = requireBl();
	const isFloat = requireHelpers().isFloat;

	encoder = function buildEncode (encodingTypes, options) {
	  function encode (obj) {
	    if (obj === undefined) throw new Error('undefined is not encodable in msgpack!')

	    if (obj === null) return Buffer.from([0xc0])
	    if (obj === true) return Buffer.from([0xc3])
	    if (obj === false) return Buffer.from([0xc2])

	    if (obj instanceof Map) return encodeMap(obj, options, encode)

	    if (typeof obj === 'string') return encodeString(obj, options)

	    if (obj && (obj.readUInt32LE || obj instanceof Uint8Array)) {
	      if (obj instanceof Uint8Array) {
	        obj = Buffer.from(obj);
	      }
	      // weird hack to support Buffer
	      // and Buffer-like objects
	      return bl([getBufferHeader(obj.length), obj])
	    }
	    if (Array.isArray(obj)) return encodeArray(obj, encode)
	    if (typeof obj === 'object') return encodeExt(obj, encodingTypes) || encodeObject(obj, options, encode)
	    if (typeof obj === 'number') return encodeNumber(obj, options)

	    throw new Error('not implemented yet')
	  }

	  return function (obj) {
	    return encode(obj).slice()
	  }
	};

	//
	//
	// === MENTAL SEPARATOR ===
	//
	//

	function encodeArray (array, encode) {
	  const acc = [getHeader(array.length, 0x90, 0xdc)];

	  // This has to be forEach; Array.prototype.map preserves missing values and
	  // Array.prototype.values yields them as undefined
	  array.forEach(item => {
	    acc.push(encode(item));
	  });

	  if (acc.length !== array.length + 1) {
	    throw new Error('Sparse arrays are not encodable in msgpack')
	  }

	  return bl(acc)
	}

	function encodeMap (map, options, encode) {
	  const acc = [getHeader(map.size, 0x80, 0xde)];
	  const keys = [...map.keys()];

	  if (!options.preferMap) {
	    if (keys.every(item => typeof item === 'string')) {
	      console.warn('Map with string only keys will be deserialized as an object!');
	    }
	  }

	  keys.forEach(key => {
	    acc.push(encode(key), encode(map.get(key)));
	  });
	  return bl(acc)
	}

	function encodeObject (obj, options, encode) {
	  const keys = [];

	  for (const key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key) &&
	        obj[key] !== undefined &&
	        typeof obj[key] !== 'function') {
	      keys.push(key);
	    }
	  }

	  const acc = [getHeader(keys.length, 0x80, 0xde)];

	  if (options.sortKeys) keys.sort();

	  keys.forEach(key => {
	    acc.push(encode(key), encode(obj[key]));
	  });

	  return bl(acc)
	}

	function write64BitUint (buf, offset, num) {
	  const lo = num % 4294967296;
	  const hi = Math.floor(num / 4294967296);

	  buf.writeUInt32BE(hi, offset + 0);
	  buf.writeUInt32BE(lo, offset + 4);
	}

	function write64BitInt (buf, offset, num) {
	  const negate = num < 0;
	  num = Math.abs(num);
	  write64BitUint(buf, offset, num);
	  if (negate) negate64BitInt(buf, offset);
	}

	function negate64BitInt (buf, offset) {
	  let i = offset + 8;

	  // Optimization based on the fact that:
	  // buf[i] == 0x00  => (buf[i] ^ 0xff) + 1 = 0x100 = 0x00 + 1 curry

	  while (i-- > offset) {
	    if (buf[i] === 0x00) continue
	    buf[i] = (buf[i] ^ 0xff) + 1;
	    break
	  }

	  while (i-- > offset) {
	    buf[i] = buf[i] ^ 0xff;
	  }
	}

	const fround = Math.fround;

	function encodeFloat (obj, forceFloat64) {
	  let buf;

	  if (forceFloat64 || !fround || !Object.is(fround(obj), obj)) {
	    buf = Buffer.allocUnsafe(9);
	    buf[0] = 0xcb;
	    buf.writeDoubleBE(obj, 1);
	  } else {
	    buf = Buffer.allocUnsafe(5);
	    buf[0] = 0xca;
	    buf.writeFloatBE(obj, 1);
	  }

	  return buf
	}

	function encodeExt (obj, encodingTypes) {
	  const codec = encodingTypes.find(codec => codec.check(obj));
	  if (!codec) return null
	  const encoded = codec.encode(obj);
	  if (!encoded) return null

	  return bl([getExtHeader(encoded.length - 1), encoded])
	}

	function getExtHeader (length) {
	  if (length === 1) return Buffer.from([0xd4])
	  if (length === 2) return Buffer.from([0xd5])
	  if (length === 4) return Buffer.from([0xd6])
	  if (length === 8) return Buffer.from([0xd7])
	  if (length === 16) return Buffer.from([0xd8])

	  if (length < 256) return Buffer.from([0xc7, length])
	  if (length < 0x10000) return Buffer.from([0xc8, length >> 8, length & 0x00ff])
	  return Buffer.from([0xc9, length >> 24, (length >> 16) & 0x000000ff, (length >> 8) & 0x000000ff, length & 0x000000ff])
	}

	function getHeader (length, tag1, tag2) {
	  if (length < 16) return Buffer.from([tag1 | length])
	  const size = length < 0x10000 ? 2 : 4;
	  const buf = Buffer.allocUnsafe(1 + size);
	  buf[0] = length < 0x10000 ? tag2 : tag2 + 1;
	  buf.writeUIntBE(length, 1, size);

	  return buf
	}

	function encodeString (obj, options) {
	  const len = Buffer.byteLength(obj);
	  let buf;
	  if (len < 32) {
	    buf = Buffer.allocUnsafe(1 + len);
	    buf[0] = 0xa0 | len;
	    if (len > 0) {
	      buf.write(obj, 1);
	    }
	  } else if (len <= 0xff && !options.compatibilityMode) {
	    // str8, but only when not in compatibility mode
	    buf = Buffer.allocUnsafe(2 + len);
	    buf[0] = 0xd9;
	    buf[1] = len;
	    buf.write(obj, 2);
	  } else if (len <= 0xffff) {
	    buf = Buffer.allocUnsafe(3 + len);
	    buf[0] = 0xda;
	    buf.writeUInt16BE(len, 1);
	    buf.write(obj, 3);
	  } else {
	    buf = Buffer.allocUnsafe(5 + len);
	    buf[0] = 0xdb;
	    buf.writeUInt32BE(len, 1);
	    buf.write(obj, 5);
	  }
	  return buf
	}

	function getBufferHeader (length) {
	  let header;
	  if (length <= 0xff) {
	    header = Buffer.allocUnsafe(2);
	    header[0] = 0xc4;
	    header[1] = length;
	  } else if (length <= 0xffff) {
	    header = Buffer.allocUnsafe(3);
	    header[0] = 0xc5;
	    header.writeUInt16BE(length, 1);
	  } else {
	    header = Buffer.allocUnsafe(5);
	    header[0] = 0xc6;
	    header.writeUInt32BE(length, 1);
	  }

	  return header
	}

	function encodeNumber (obj, options) {
	  let buf;
	  if (isFloat(obj)) return encodeFloat(obj, options.forceFloat64)
	  if (Math.abs(obj) > 9007199254740991) {
	    return encodeFloat(obj, true)
	  }

	  if (obj >= 0) {
	    if (obj < 128) {
	      return Buffer.from([obj])
	    } else if (obj < 256) {
	      return Buffer.from([0xcc, obj])
	    } else if (obj < 65536) {
	      return Buffer.from([0xcd, 0xff & (obj >> 8), 0xff & (obj)])
	    } else if (obj <= 0xffffffff) {
	      return Buffer.from([0xce, 0xff & (obj >> 24), 0xff & (obj >> 16), 0xff & (obj >> 8), 0xff & (obj)])
	    } else if (obj <= 9007199254740991) {
	      buf = Buffer.allocUnsafe(9);
	      buf[0] = 0xcf;
	      write64BitUint(buf, 1, obj);
	    }
	  } else {
	    if (obj >= -32) {
	      buf = Buffer.allocUnsafe(1);
	      buf[0] = 0x100 + obj;
	    } else if (obj >= -128) {
	      buf = Buffer.allocUnsafe(2);
	      buf[0] = 0xd0;
	      buf.writeInt8(obj, 1);
	    } else if (obj >= -32768) {
	      buf = Buffer.allocUnsafe(3);
	      buf[0] = 0xd1;
	      buf.writeInt16BE(obj, 1);
	    } else if (obj > -214748365) {
	      buf = Buffer.allocUnsafe(5);
	      buf[0] = 0xd2;
	      buf.writeInt32BE(obj, 1);
	    } else if (obj >= -9007199254740991) {
	      buf = Buffer.allocUnsafe(9);
	      buf[0] = 0xd3;
	      write64BitInt(buf, 1, obj);
	    }
	  }
	  return buf
	}

	// function order(num, n = 1, step = 2) {
	//    while (num = num >> step) n++;
	//    return n
	// }
	return encoder;
}

var DateCodec;
var hasRequiredDateCodec;

function requireDateCodec () {
	if (hasRequiredDateCodec) return DateCodec;
	hasRequiredDateCodec = 1;
	const type = -1;

	function encode (dt) {
	  if (dt === null) {
	    return
	  }

	  const millis = dt * 1;
	  const seconds = Math.floor(millis / 1000);
	  const nanos = (millis - seconds * 1000) * 1e6;

	  if (seconds < 0 || seconds > 0x400000000) {
	    // Timestamp96
	    const encoded = Buffer.allocUnsafe(13);
	    encoded[0] = -1;

	    encoded.writeUInt32BE(nanos, 1);

	    let hex = '';
	    if (seconds >= 0) {
	      const padhex = '0000000000000000';
	      hex = seconds.toString(16);
	      // add some padding
	      hex = padhex.slice(0, hex.length * -1) + hex;
	    } else {
	      // encode seconds in 2's Complement 64Bit
	      // reverse sign
	      // keep all bits 0 and first 1 from right
	      // reverse all other bits
	      let bin = (seconds * -1).toString(2);
	      let i = bin.length - 1;
	      while (bin[i] === '0') {
	        i--;
	      }
	      bin = bin.slice(0, i).split('').map(function (bit) { return bit === '1' ? 0 : 1 }).join('') + bin.slice(i, bin.length);
	      // add some padding
	      const pad64 = '1111111111111111111111111111111111111111111111111111111111111111';
	      bin = pad64.slice(0, bin.length * -1) + bin;
	      // convert to hex
	      bin.match(/.{1,8}/g).forEach(function (byte) {
	        byte = parseInt(byte, 2).toString(16);
	        if (byte.length === 1) {
	          byte = '0' + byte;
	        }
	        hex += byte;
	      });
	    }
	    encoded.write(hex, 5, 'hex');
	    return encoded
	  } else if (nanos || seconds > 0xffffffff) {
	    // Timestamp64
	    const encoded = Buffer.allocUnsafe(9);
	    encoded[0] = -1;

	    const upperNanos = nanos * 4;
	    const upperSeconds = seconds / Math.pow(2, 32);
	    const upper = (upperNanos + upperSeconds) & 0xffffffff;
	    const lower = seconds & 0xffffffff;

	    encoded.writeInt32BE(upper, 1);
	    encoded.writeInt32BE(lower, 5);
	    return encoded
	  } else {
	    // Timestamp32
	    const encoded = Buffer.allocUnsafe(5);
	    encoded[0] = -1;
	    encoded.writeUInt32BE(Math.floor(millis / 1000), 1);
	    return encoded
	  }
	}

	function check (obj) {
	  return typeof obj.getDate === 'function'
	}

	function decode (buf) {
	  let seconds;
	  let nanoseconds = 0;
	  let upper;
	  let lower;
	  let hex;

	  switch (buf.length) {
	    case 4:
	      // timestamp 32 stores the number of seconds that have elapsed since 1970-01-01 00:00:00 UTC in an 32-bit unsigned integer
	      seconds = buf.readUInt32BE(0);
	      break

	    case 8:
	      // Timestamp 64 stores the number of seconds and nanoseconds that have elapsed
	      // since 1970-01-01 00:00:00 UTC in 32-bit unsigned integers, split 30/34 bits
	      upper = buf.readUInt32BE(0);
	      lower = buf.readUInt32BE(4);
	      nanoseconds = upper / 4;
	      seconds = ((upper & 0x03) * Math.pow(2, 32)) + lower; // If we use bitwise operators, we get truncated to 32bits
	      break

	    case 12:
	      // timestamp 96 stores the number of seconds and nanoseconds that have elapsed
	      // since 1970-01-01 00:00:00 UTC in 64-bit signed integer and 32-bit unsigned integer

	      // get seconds in hex
	      hex = buf.toString('hex', 4, 12);
	      // check if seconds is a negative number
	      if (parseInt(buf.toString('hex', 4, 6), 16) & 0x80) {
	        // convert to binary
	        let bin = '';
	        const pad8 = '00000000';
	        hex.match(/.{1,2}/g).forEach(function (byte) {
	          byte = parseInt(byte, 16).toString(2);
	          byte = pad8.slice(0, byte.length * -1) + byte;
	          bin += byte;
	        });
	        // decode seconds from 2's Complement 64Bit
	        // reverse all bits
	        // reverse sign
	        // remove one
	        seconds = -1 * parseInt(bin.split('').map(function (bit) { return bit === '1' ? 0 : 1 }).join(''), 2) - 1;
	      } else {
	        seconds = parseInt(hex, 16);
	      }

	      nanoseconds = buf.readUInt32BE(0);
	  }

	  const millis = (seconds * 1000) + Math.round(nanoseconds / 1E6);

	  return new Date(millis)
	}

	DateCodec = { check, type, encode, decode };
	return DateCodec;
}

var msgpack5;
var hasRequiredMsgpack5;

function requireMsgpack5 () {
	if (hasRequiredMsgpack5) return msgpack5;
	hasRequiredMsgpack5 = 1;

	const Buffer = requireSafeBuffer().Buffer;
	const assert = require$$4$1;
	const bl = requireBl();
	const streams = requireStreams();
	const buildDecode = requireDecoder();
	const buildEncode = requireEncoder();
	const IncompleteBufferError = requireHelpers().IncompleteBufferError;
	const DateCodec = requireDateCodec();

	function msgpack (options) {
	  const encodingTypes = [];
	  const decodingTypes = new Map();

	  options = options || {
	    forceFloat64: false,
	    compatibilityMode: false,
	    // if true, skips encoding Dates using the msgpack
	    // timestamp ext format (-1)
	    disableTimestampEncoding: false,
	    preferMap: false,
	    // options.protoAction: 'error' (default) / 'remove' / 'ignore'
	    protoAction: 'error'
	  };

	  decodingTypes.set(DateCodec.type, DateCodec.decode);
	  if (!options.disableTimestampEncoding) {
	    encodingTypes.push(DateCodec);
	  }

	  function registerEncoder (check, encode) {
	    assert(check, 'must have an encode function');
	    assert(encode, 'must have an encode function');

	    encodingTypes.push({ check, encode });

	    return this
	  }

	  function registerDecoder (type, decode) {
	    assert(type >= 0, 'must have a non-negative type');
	    assert(decode, 'must have a decode function');
	    decodingTypes.set(type, decode);
	    return this
	  }

	  function register (type, constructor, encode, decode) {
	    assert(constructor, 'must have a constructor');
	    assert(encode, 'must have an encode function');
	    assert(type >= 0, 'must have a non-negative type');
	    assert(decode, 'must have a decode function');

	    function check (obj) {
	      return (obj instanceof constructor)
	    }

	    function reEncode (obj) {
	      const buf = bl();
	      const header = Buffer.allocUnsafe(1);

	      header.writeInt8(type, 0);

	      buf.append(header);
	      buf.append(encode(obj));

	      return buf
	    }

	    this.registerEncoder(check, reEncode);
	    this.registerDecoder(type, decode);

	    return this
	  }

	  return {
	    encode: buildEncode(encodingTypes, options),
	    decode: buildDecode(decodingTypes, options),
	    register,
	    registerEncoder,
	    registerDecoder,
	    encoder: streams.encoder,
	    decoder: streams.decoder,
	    // needed for levelup support
	    buffer: true,
	    type: 'msgpack5',
	    IncompleteBufferError
	  }
	}

	msgpack5 = msgpack;
	return msgpack5;
}

var hasRequiredWebsocket;

function requireWebsocket () {
	if (hasRequiredWebsocket) return websocket;
	hasRequiredWebsocket = 1;
	(function (exports$1) {
		var __importDefault = (websocket && websocket.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.AlpacaWebsocket = exports$1.ERROR = exports$1.CONN_ERROR = exports$1.EVENT = exports$1.STATE = void 0;
		const events_1 = __importDefault(require$$0$3);
		const ws_1 = __importDefault(requireWs());
		const msgpack5_1 = __importDefault(requireMsgpack5());
		// Connection states. Each of these will also emit EVENT.STATE_CHANGE
		var STATE;
		(function (STATE) {
		    STATE["AUTHENTICATING"] = "authenticating";
		    STATE["AUTHENTICATED"] = "authenticated";
		    STATE["CONNECTED"] = "connected";
		    STATE["CONNECTING"] = "connecting";
		    STATE["DISCONNECTED"] = "disconnected";
		    STATE["WAITING_TO_CONNECT"] = "waiting to connect";
		    STATE["WAITING_TO_RECONNECT"] = "waiting to reconnect";
		})(STATE || (exports$1.STATE = STATE = {}));
		// Client events
		var EVENT;
		(function (EVENT) {
		    EVENT["CLIENT_ERROR"] = "client_error";
		    EVENT["STATE_CHANGE"] = "state_change";
		    EVENT["AUTHORIZED"] = "authorized";
		    EVENT["UNAUTHORIZED"] = "unauthorized";
		    EVENT["TRADES"] = "stock_trades";
		    EVENT["QUOTES"] = "stock_quotes";
		    EVENT["BARS"] = "stock_bars";
		    EVENT["UPDATED_BARS"] = "stock_updated_bars";
		    EVENT["DAILY_BARS"] = "stock_daily_bars";
		    EVENT["TRADING_STATUSES"] = "trading_statuses";
		    EVENT["LULDS"] = "lulds";
		    EVENT["CANCEL_ERRORS"] = "cancel_errors";
		    EVENT["CORRECTIONS"] = "corrections";
		    EVENT["ORDERBOOKS"] = "orderbooks";
		    EVENT["NEWS"] = "news";
		})(EVENT || (exports$1.EVENT = EVENT = {}));
		// Connection errors by code
		exports$1.CONN_ERROR = new Map([
		    [400, "invalid syntax"],
		    [401, "not authenticated"],
		    [402, "auth failed"],
		    [403, "already authenticated"],
		    [404, "auth timeout"],
		    [405, "symbol limit exceeded"],
		    [406, "connection limit exceeded"],
		    [407, "slow client"],
		    [408, "v2 not enabled"],
		    [409, "insufficient subscription"],
		    [500, "internal error"],
		]);
		// Connection errors without code
		var ERROR;
		(function (ERROR) {
		    ERROR["MISSING_SECERT_KEY"] = "missing secret key";
		    ERROR["MISSING_API_KEY"] = "missing api key";
		    ERROR["UNEXPECTED_MESSAGE"] = "unexpected message";
		})(ERROR || (exports$1.ERROR = ERROR = {}));
		class AlpacaWebsocket extends events_1.default.EventEmitter {
		    constructor(options) {
		        super();
		        this.msgpack = (0, msgpack5_1.default)();
		        this.session = {
		            apiKey: options.apiKey,
		            secretKey: options.secretKey,
		            subscriptions: options.subscriptions,
		            reconnect: true,
		            verbose: options.verbose,
		            backoff: true,
		            reconnectTimeout: 0,
		            maxReconnectTimeout: 30,
		            backoffIncrement: 0.5,
		            url: options.url,
		            currentState: STATE.WAITING_TO_CONNECT,
		            isReconnected: false,
		            pongWait: 5000,
		        };
		        // Register internal event handlers
		        // Log and emit every state change
		        Object.values(STATE).forEach((s) => {
		            this.on(s, () => {
		                this.emit(EVENT.STATE_CHANGE, s);
		            });
		        });
		    }
		    connect() {
		        this.emit(STATE.CONNECTING);
		        this.session.currentState = STATE.CONNECTING;
		        // Check the credentials
		        if (this.session.apiKey.length === 0) {
		            throw new Error(ERROR.MISSING_API_KEY);
		        }
		        if (this.session.secretKey.length === 0) {
		            throw new Error(ERROR.MISSING_SECERT_KEY);
		        }
		        this.resetSession();
		        this.conn = new ws_1.default(this.session.url, {
		            perMessageDeflate: {
		                serverNoContextTakeover: false,
		                clientNoContextTakeover: false,
		            },
		            headers: {
		                "Content-Type": "application/msgpack",
		            },
		        });
		        this.conn.binaryType = "nodebuffer";
		        this.conn.once("open", () => this.authenticate());
		        this.conn.on("message", (data) => {
		            this.handleMessage(this.msgpack.decode(data));
		        });
		        this.conn.on("error", (err) => {
		            this.emit(EVENT.CLIENT_ERROR, err.message);
		            this.disconnect();
		        });
		        this.conn.on("close", (code, msg) => {
		            this.log(`connection closed with code: ${code} and message: ${msg}`);
		            if (this.session.reconnect) {
		                this.reconnect();
		            }
		        });
		        this.conn.on("pong", () => {
		            if (this.session.pongTimeout) {
		                clearTimeout(this.session.pongTimeout);
		            }
		        });
		        this.session.pingInterval = setInterval(() => {
		            this.ping();
		        }, 10000);
		        this.on(STATE.WAITING_TO_RECONNECT, (ts) => {
		            this.log(`backoff: ${ts}`);
		        });
		    }
		    onConnect(fn) {
		        this.on(STATE.AUTHENTICATED, () => {
		            if (this.session.isReconnected) {
		                //if reconnected the user should subscribe to its symbols again
		                this.subscribeAll();
		            }
		            else {
		                fn();
		            }
		        });
		    }
		    reconnect() {
		        this.log("Reconnecting...");
		        this.session.isReconnected = true;
		        const { backoff, backoffIncrement, maxReconnectTimeout } = this.session;
		        let reconnectTimeout = this.session.reconnectTimeout;
		        if (backoff) {
		            setTimeout(() => {
		                reconnectTimeout += backoffIncrement;
		                if (reconnectTimeout > maxReconnectTimeout) {
		                    reconnectTimeout = maxReconnectTimeout;
		                }
		                this.emit(STATE.WAITING_TO_RECONNECT, reconnectTimeout);
		                this.connect();
		            }, reconnectTimeout * 1000);
		        }
		    }
		    ping() {
		        this.conn.ping();
		        this.session.pongTimeout = setTimeout(() => {
		            this.log("no pong received from server, terminating...");
		            this.conn.terminate();
		        }, this.session.pongWait);
		    }
		    authenticate() {
		        const authMsg = {
		            action: "auth",
		            key: this.session.apiKey,
		            secret: this.session.secretKey,
		        };
		        this.conn.send(this.msgpack.encode(authMsg));
		        this.emit(STATE.AUTHENTICATING);
		        this.session.currentState = STATE.AUTHENTICATING;
		    }
		    disconnect() {
		        this.emit(STATE.DISCONNECTED);
		        this.session.currentState = STATE.DISCONNECTED;
		        this.conn.close();
		        this.session.reconnect = false;
		        if (this.session.pongTimeout) {
		            clearTimeout(this.session.pongTimeout);
		        }
		        if (this.session.pingInterval) {
		            clearInterval(this.session.pingInterval);
		        }
		    }
		    onDisconnect(fn) {
		        this.on(STATE.DISCONNECTED, () => fn());
		    }
		    onError(fn) {
		        this.on(EVENT.CLIENT_ERROR, (err) => fn(err));
		    }
		    onStateChange(fn) {
		        this.on(EVENT.STATE_CHANGE, (newState) => fn(newState));
		    }
		    handleMessage(data) {
		        const msgType = (data === null || data === void 0 ? void 0 : data.length) ? data[0].T : "";
		        switch (msgType) {
		            case "success":
		                if (data[0].msg === "connected") {
		                    this.emit(STATE.CONNECTED);
		                    this.session.currentState = STATE.CONNECTED;
		                }
		                else if (data[0].msg === "authenticated") {
		                    this.emit(STATE.AUTHENTICATED);
		                    this.session.currentState = STATE.AUTHENTICATED;
		                }
		                break;
		            case "subscription":
		                this.updateSubscriptions(data[0]);
		                break;
		            case "error":
		                this.emit(EVENT.CLIENT_ERROR, exports$1.CONN_ERROR.get(data[0].code));
		                break;
		            default:
		                this.dataHandler(data);
		        }
		    }
		    log(msg) {
		        if (this.session.verbose) {
		            // eslint-disable-next-line no-console
		            console.log(msg);
		        }
		    }
		    getSubscriptions() {
		        return this.session.subscriptions;
		    }
		    resetSession() {
		        this.session.reconnect = true;
		        this.session.backoff = true;
		        this.session.reconnectTimeout = 0;
		        this.session.maxReconnectTimeout = 30;
		        this.session.backoffIncrement = 0.5;
		        if (this.session.pongTimeout) {
		            clearTimeout(this.session.pongTimeout);
		        }
		        if (this.session.pingInterval) {
		            clearInterval(this.session.pingInterval);
		        }
		    }
		}
		exports$1.AlpacaWebsocket = AlpacaWebsocket; 
	} (websocket));
	return websocket;
}

var hasRequiredCrypto_websocket_v1beta3;

function requireCrypto_websocket_v1beta3 () {
	if (hasRequiredCrypto_websocket_v1beta3) return crypto_websocket_v1beta3;
	hasRequiredCrypto_websocket_v1beta3 = 1;
	Object.defineProperty(crypto_websocket_v1beta3, "__esModule", { value: true });
	crypto_websocket_v1beta3.AlpacaCryptoClient = void 0;
	const entityv2_1 = requireEntityv2();
	const websocket_1 = requireWebsocket();
	const eventTypeMap = new Map([
	    ["t", { event: websocket_1.EVENT.TRADES, parse: entityv2_1.AlpacaCryptoTrade }],
	    ["q", { event: websocket_1.EVENT.QUOTES, parse: entityv2_1.AlpacaCryptoQuote }],
	    ["b", { event: websocket_1.EVENT.BARS, parse: entityv2_1.AlpacaCryptoBar }],
	    ["u", { event: websocket_1.EVENT.UPDATED_BARS, parse: entityv2_1.AlpacaCryptoBar }],
	    ["d", { event: websocket_1.EVENT.DAILY_BARS, parse: entityv2_1.AlpacaCryptoBar }],
	    ["o", { event: websocket_1.EVENT.ORDERBOOKS, parse: entityv2_1.AlpacaCryptoOrderbook }],
	]);
	class AlpacaCryptoClient extends websocket_1.AlpacaWebsocket {
	    constructor(options) {
	        options.url = options.url.replace("https", "wss") + "/v1beta3/crypto/us";
	        options.subscriptions = {
	            trades: [],
	            quotes: [],
	            bars: [],
	            updatedBars: [],
	            dailyBars: [],
	            orderbooks: [],
	        };
	        super(options);
	    }
	    subscribeForTrades(trades) {
	        this.session.subscriptions.trades.push(...trades);
	        this.subscribe({ trades });
	    }
	    subscribeForQuotes(quotes) {
	        this.session.subscriptions.quotes.push(...quotes);
	        this.subscribe({ quotes });
	    }
	    subscribeForBars(bars) {
	        this.session.subscriptions.bars.push(...bars);
	        this.subscribe({ bars });
	    }
	    subscribeForUpdatedBars(updatedBars) {
	        this.session.subscriptions.updatedBars.push(...updatedBars);
	        this.subscribe({ updatedBars });
	    }
	    subscribeForDailyBars(dailyBars) {
	        this.session.subscriptions.dailyBars.push(...dailyBars);
	        this.subscribe({ dailyBars });
	    }
	    subscribeForOrderbooks(orderbooks) {
	        this.session.subscriptions.orderbooks.push(...orderbooks);
	        this.subscribe({ orderbooks });
	    }
	    subscribe(symbols) {
	        var _a, _b, _c, _d, _e, _f;
	        const subMsg = {
	            action: "subscribe",
	            trades: (_a = symbols.trades) !== null && _a !== void 0 ? _a : [],
	            quotes: (_b = symbols.quotes) !== null && _b !== void 0 ? _b : [],
	            bars: (_c = symbols.bars) !== null && _c !== void 0 ? _c : [],
	            updatedBars: (_d = symbols.updatedBars) !== null && _d !== void 0 ? _d : [],
	            dailyBars: (_e = symbols.dailyBars) !== null && _e !== void 0 ? _e : [],
	            orderbooks: (_f = symbols.orderbooks) !== null && _f !== void 0 ? _f : [],
	        };
	        this.conn.send(this.msgpack.encode(subMsg));
	    }
	    subscribeAll() {
	        this.subscribe(this.session.subscriptions);
	    }
	    unsubscribeFromTrades(trades) {
	        this.session.subscriptions.trades = this.session.subscriptions.trades.filter((trade) => !trades.includes(trade));
	        this.unsubscribe({ trades });
	    }
	    unsubscribeFromQuotes(quotes) {
	        this.session.subscriptions.quotes = this.session.subscriptions.quotes.filter((quote) => !quotes.includes(quote));
	        this.unsubscribe({ quotes });
	    }
	    unsubscribeFromBars(bars) {
	        this.session.subscriptions.bars = this.session.subscriptions.bars.filter((bar) => !bars.includes(bar));
	        this.unsubscribe({ bars });
	    }
	    unsubscribeFromUpdatedBars(updatedBars) {
	        this.session.subscriptions.updatedBars =
	            this.session.subscriptions.updatedBars.filter((updatedBar) => !updatedBars.includes(updatedBar));
	        this.unsubscribe({ updatedBars });
	    }
	    unsubscriceFromDailyBars(dailyBars) {
	        this.session.subscriptions.dailyBars = this.session.subscriptions.dailyBars.filter((dailyBar) => !dailyBars.includes(dailyBar));
	        this.unsubscribe({ dailyBars });
	    }
	    unsubscribeFromOrderbooks(orderbooks) {
	        this.session.subscriptions.orderbooks = this.session.subscriptions.orderbooks.filter((orderbook) => !orderbooks.includes(orderbook));
	        this.unsubscribe({ orderbooks });
	    }
	    unsubscribe(symbols) {
	        var _a, _b, _c, _d, _e, _f;
	        const unsubMsg = {
	            action: "unsubscribe",
	            trades: (_a = symbols.trades) !== null && _a !== void 0 ? _a : [],
	            quotes: (_b = symbols.quotes) !== null && _b !== void 0 ? _b : [],
	            bars: (_c = symbols.bars) !== null && _c !== void 0 ? _c : [],
	            updatedBars: (_d = symbols.updatedBars) !== null && _d !== void 0 ? _d : [],
	            dailyBars: (_e = symbols.dailyBars) !== null && _e !== void 0 ? _e : [],
	            orderbooks: (_f = symbols.orderbooks) !== null && _f !== void 0 ? _f : [],
	        };
	        this.conn.send(this.msgpack.encode(unsubMsg));
	    }
	    updateSubscriptions(msg) {
	        this.session.subscriptions = {
	            trades: msg.trades,
	            quotes: msg.quotes,
	            bars: msg.bars,
	            updatedBars: msg.updatedBars,
	            dailyBars: msg.dailyBars,
	            orderbooks: msg.orderbooks,
	        };
	        this.log(`listening to streams:
        ${JSON.stringify(this.session.subscriptions)}`);
	    }
	    onCryptoTrade(fn) {
	        this.on(websocket_1.EVENT.TRADES, (trade) => fn(trade));
	    }
	    onCryptoQuote(fn) {
	        this.on(websocket_1.EVENT.QUOTES, (quote) => fn(quote));
	    }
	    onCryptoBar(fn) {
	        this.on(websocket_1.EVENT.BARS, (bar) => fn(bar));
	    }
	    onCryptoUpdatedBar(fn) {
	        this.on(websocket_1.EVENT.UPDATED_BARS, (updatedBar) => fn(updatedBar));
	    }
	    onCryptoDailyBar(fn) {
	        this.on(websocket_1.EVENT.DAILY_BARS, (dailyBar) => fn(dailyBar));
	    }
	    onCryptoOrderbook(fn) {
	        this.on(websocket_1.EVENT.ORDERBOOKS, (orderbook) => fn(orderbook));
	    }
	    dataHandler(data) {
	        data.forEach((element) => {
	            if ("T" in element) {
	                const eventType = eventTypeMap.get(element.T);
	                if (eventType) {
	                    this.emit(eventType.event, eventType.parse(element));
	                }
	                else {
	                    this.emit(websocket_1.EVENT.CLIENT_ERROR, websocket_1.ERROR.UNEXPECTED_MESSAGE);
	                }
	            }
	        });
	    }
	}
	crypto_websocket_v1beta3.AlpacaCryptoClient = AlpacaCryptoClient;
	return crypto_websocket_v1beta3;
}

var news_websocket = {};

var hasRequiredNews_websocket;

function requireNews_websocket () {
	if (hasRequiredNews_websocket) return news_websocket;
	hasRequiredNews_websocket = 1;
	Object.defineProperty(news_websocket, "__esModule", { value: true });
	news_websocket.AlpacaNewsCLient = void 0;
	const websocket_1 = requireWebsocket();
	const entityv2_1 = requireEntityv2();
	const websocket_2 = requireWebsocket();
	class AlpacaNewsCLient extends websocket_2.AlpacaWebsocket {
	    constructor(options) {
	        const url = "wss" + options.url.substr(options.url.indexOf(":")) + "/v1beta1/news";
	        options.url = url;
	        options.subscriptions = {
	            news: [],
	        };
	        super(options);
	    }
	    subscribeForNews(news) {
	        this.session.subscriptions.news.push(...news);
	        this.subscribe(news);
	    }
	    subscribe(news) {
	        const subMsg = {
	            action: "subscribe",
	            news,
	        };
	        console.log("subscribing", subMsg);
	        this.conn.send(this.msgpack.encode(subMsg));
	    }
	    subscribeAll() {
	        if (this.session.subscriptions.news.length > 0) {
	            this.subscribe(this.session.subscriptions.news);
	        }
	    }
	    unsubscribeFromNews(news) {
	        this.session.subscriptions.news = this.session.subscriptions.news.filter((n) => !news.includes(n));
	        this.unsubscribe(news);
	    }
	    unsubscribe(news) {
	        const unsubMsg = {
	            action: "unsubscribe",
	            news,
	        };
	        this.conn.send(this.msgpack.encode(unsubMsg));
	    }
	    updateSubscriptions(msg) {
	        this.log(`listening to streams:
        news: ${msg.news}`);
	        this.session.subscriptions = {
	            news: msg.news,
	        };
	    }
	    onNews(fn) {
	        this.on(websocket_1.EVENT.NEWS, (n) => fn(n));
	    }
	    dataHandler(data) {
	        data.forEach((element) => {
	            if ("T" in element) {
	                switch (element.T) {
	                    case "n":
	                        this.emit(websocket_1.EVENT.NEWS, (0, entityv2_1.AlpacaNews)(element));
	                        break;
	                    default:
	                        this.emit(websocket_1.EVENT.CLIENT_ERROR, websocket_1.ERROR.UNEXPECTED_MESSAGE);
	                }
	            }
	            else {
	                this.emit(websocket_1.EVENT.CLIENT_ERROR, websocket_1.ERROR.UNEXPECTED_MESSAGE);
	            }
	        });
	    }
	}
	news_websocket.AlpacaNewsCLient = AlpacaNewsCLient;
	return news_websocket;
}

var stock_websocket_v2 = {};

var hasRequiredStock_websocket_v2;

function requireStock_websocket_v2 () {
	if (hasRequiredStock_websocket_v2) return stock_websocket_v2;
	hasRequiredStock_websocket_v2 = 1;
	Object.defineProperty(stock_websocket_v2, "__esModule", { value: true });
	stock_websocket_v2.AlpacaStocksClient = void 0;
	const entityv2_1 = requireEntityv2();
	const websocket_1 = requireWebsocket();
	class AlpacaStocksClient extends websocket_1.AlpacaWebsocket {
	    constructor(options) {
	        const url = "wss" + options.url.substr(options.url.indexOf(":")) + "/v2/" + options.feed;
	        options.url = url;
	        options.subscriptions = {
	            trades: [],
	            quotes: [],
	            bars: [],
	            updatedBars: [],
	            dailyBars: [],
	            statuses: [],
	            lulds: [],
	            cancelErrors: [],
	            corrections: [],
	        };
	        super(options);
	    }
	    subscribeForTrades(trades) {
	        this.session.subscriptions.trades.push(...trades);
	        this.subscribe({ trades });
	    }
	    subscribeForQuotes(quotes) {
	        this.session.subscriptions.quotes.push(...quotes);
	        this.subscribe({ quotes });
	    }
	    subscribeForBars(bars) {
	        this.session.subscriptions.bars.push(...bars);
	        this.subscribe({ bars });
	    }
	    subscribeForUpdatedBars(updatedBars) {
	        this.session.subscriptions.updatedBars.push(...updatedBars);
	        this.subscribe({ updatedBars });
	    }
	    subscribeForDailyBars(dailyBars) {
	        this.session.subscriptions.dailyBars.push(...dailyBars);
	        this.subscribe({ dailyBars });
	    }
	    subscribeForStatuses(statuses) {
	        this.session.subscriptions.statuses.push(...statuses);
	        this.subscribe({ statuses });
	    }
	    subscribeForLulds(lulds) {
	        this.session.subscriptions.lulds.push(...lulds);
	        this.subscribe({ lulds });
	    }
	    subscribe(symbols) {
	        var _a, _b, _c, _d, _e, _f, _g;
	        const subMsg = {
	            action: "subscribe",
	            trades: (_a = symbols.trades) !== null && _a !== void 0 ? _a : [],
	            quotes: (_b = symbols.quotes) !== null && _b !== void 0 ? _b : [],
	            bars: (_c = symbols.bars) !== null && _c !== void 0 ? _c : [],
	            updatedBars: (_d = symbols.updatedBars) !== null && _d !== void 0 ? _d : [],
	            dailyBars: (_e = symbols.dailyBars) !== null && _e !== void 0 ? _e : [],
	            statuses: (_f = symbols.statuses) !== null && _f !== void 0 ? _f : [],
	            lulds: (_g = symbols.lulds) !== null && _g !== void 0 ? _g : [],
	        };
	        this.conn.send(this.msgpack.encode(subMsg));
	    }
	    subscribeAll() {
	        this.subscribe(this.session.subscriptions);
	    }
	    unsubscribeFromTrades(trades) {
	        this.session.subscriptions.trades = this.session.subscriptions.trades.filter((trade) => !trades.includes(trade));
	        this.unsubscribe({ trades });
	    }
	    unsubscribeFromQuotes(quotes) {
	        this.session.subscriptions.quotes = this.session.subscriptions.quotes.filter((quote) => !quotes.includes(quote));
	        this.unsubscribe({ quotes });
	    }
	    unsubscribeFromBars(bars) {
	        this.session.subscriptions.bars = this.session.subscriptions.bars.filter((bar) => !bars.includes(bar));
	        this.unsubscribe({ bars });
	    }
	    unsubscribeFromUpdatedBars(updatedBars) {
	        this.session.subscriptions.updatedBars =
	            this.session.subscriptions.updatedBars.filter((updatedBar) => !updatedBars.includes(updatedBar));
	        this.unsubscribe({ updatedBars });
	    }
	    unsubscribeFromDailyBars(dailyBars) {
	        this.session.subscriptions.dailyBars = this.session.subscriptions.dailyBars.filter((dailyBar) => !dailyBars.includes(dailyBar));
	        this.unsubscribe({ dailyBars });
	    }
	    unsubscribeFromStatuses(statuses) {
	        this.session.subscriptions.statuses = this.session.subscriptions.statuses.filter((status) => !statuses.includes(status));
	        this.unsubscribe({ statuses });
	    }
	    unsubscribeFromLulds(lulds) {
	        this.session.subscriptions.lulds = this.session.subscriptions.lulds.filter((luld) => !lulds.includes(luld));
	        this.unsubscribe({ lulds });
	    }
	    unsubscribe(symbols) {
	        var _a, _b, _c, _d, _e, _f, _g;
	        const unsubMsg = {
	            action: "unsubscribe",
	            trades: (_a = symbols.trades) !== null && _a !== void 0 ? _a : [],
	            quotes: (_b = symbols.quotes) !== null && _b !== void 0 ? _b : [],
	            bars: (_c = symbols.bars) !== null && _c !== void 0 ? _c : [],
	            updatedBars: (_d = symbols.updatedBars) !== null && _d !== void 0 ? _d : [],
	            dailyBars: (_e = symbols.dailyBars) !== null && _e !== void 0 ? _e : [],
	            statuses: (_f = symbols.statuses) !== null && _f !== void 0 ? _f : [],
	            lulds: (_g = symbols.lulds) !== null && _g !== void 0 ? _g : [],
	        };
	        this.conn.send(this.msgpack.encode(unsubMsg));
	    }
	    updateSubscriptions(msg) {
	        this.log(`listening to streams:
        trades: ${msg.trades},
        quotes: ${msg.quotes},
        bars: ${msg.bars},
        updatedBars: ${msg.updatedBars},
        dailyBars: ${msg.dailyBars},
        statuses: ${msg.statuses},
        lulds: ${msg.lulds},
        cancelErrors: ${msg.cancelErrors},
        corrections: ${msg.corrections}`);
	        this.session.subscriptions = {
	            trades: msg.trades,
	            quotes: msg.quotes,
	            bars: msg.bars,
	            updatedBars: msg.updatedBars,
	            dailyBars: msg.dailyBars,
	            statuses: msg.statuses,
	            lulds: msg.lulds,
	            cancelErrors: msg.cancelErrors,
	            corrections: msg.corrections,
	        };
	    }
	    onStockTrade(fn) {
	        this.on(websocket_1.EVENT.TRADES, (trade) => fn(trade));
	    }
	    onStockQuote(fn) {
	        this.on(websocket_1.EVENT.QUOTES, (quote) => fn(quote));
	    }
	    onStockBar(fn) {
	        this.on(websocket_1.EVENT.BARS, (bar) => fn(bar));
	    }
	    onStockUpdatedBar(fn) {
	        this.on(websocket_1.EVENT.UPDATED_BARS, (updatedBar) => fn(updatedBar));
	    }
	    onStockDailyBar(fn) {
	        this.on(websocket_1.EVENT.DAILY_BARS, (dailyBar) => fn(dailyBar));
	    }
	    onStatuses(fn) {
	        this.on(websocket_1.EVENT.TRADING_STATUSES, (status) => fn(status));
	    }
	    onLulds(fn) {
	        this.on(websocket_1.EVENT.LULDS, (luld) => fn(luld));
	    }
	    onCancelErrors(fn) {
	        this.on(websocket_1.EVENT.CANCEL_ERRORS, (cancelError) => fn(cancelError));
	    }
	    onCorrections(fn) {
	        this.on(websocket_1.EVENT.CORRECTIONS, (correction) => fn(correction));
	    }
	    dataHandler(data) {
	        data.forEach((element) => {
	            if ("T" in element) {
	                switch (element.T) {
	                    case "t":
	                        this.emit(websocket_1.EVENT.TRADES, (0, entityv2_1.AlpacaTradeV2)(element));
	                        break;
	                    case "q":
	                        this.emit(websocket_1.EVENT.QUOTES, (0, entityv2_1.AlpacaQuoteV2)(element));
	                        break;
	                    case "b":
	                        this.emit(websocket_1.EVENT.BARS, (0, entityv2_1.AlpacaBarV2)(element));
	                        break;
	                    case "u":
	                        this.emit(websocket_1.EVENT.UPDATED_BARS, (0, entityv2_1.AlpacaBarV2)(element));
	                        break;
	                    case "d":
	                        this.emit(websocket_1.EVENT.DAILY_BARS, (0, entityv2_1.AlpacaBarV2)(element));
	                        break;
	                    case "s":
	                        this.emit(websocket_1.EVENT.TRADING_STATUSES, (0, entityv2_1.AlpacaStatusV2)(element));
	                        break;
	                    case "l":
	                        this.emit(websocket_1.EVENT.LULDS, (0, entityv2_1.AlpacaLuldV2)(element));
	                        break;
	                    case "x":
	                        this.emit(websocket_1.EVENT.CANCEL_ERRORS, (0, entityv2_1.AlpacaCancelErrorV2)(element));
	                        break;
	                    case "c":
	                        this.emit(websocket_1.EVENT.CORRECTIONS, (0, entityv2_1.AlpacaCorrectionV2)(element));
	                        break;
	                    default:
	                        this.emit(websocket_1.EVENT.CLIENT_ERROR, websocket_1.ERROR.UNEXPECTED_MESSAGE);
	                }
	            }
	        });
	    }
	}
	stock_websocket_v2.AlpacaStocksClient = AlpacaStocksClient;
	return stock_websocket_v2;
}

var option_websocket_v1beta1 = {};

var hasRequiredOption_websocket_v1beta1;

function requireOption_websocket_v1beta1 () {
	if (hasRequiredOption_websocket_v1beta1) return option_websocket_v1beta1;
	hasRequiredOption_websocket_v1beta1 = 1;
	Object.defineProperty(option_websocket_v1beta1, "__esModule", { value: true });
	option_websocket_v1beta1.AlpacaOptionClient = void 0;
	const entityv2_1 = requireEntityv2();
	const websocket_1 = requireWebsocket();
	class AlpacaOptionClient extends websocket_1.AlpacaWebsocket {
	    constructor(options) {
	        const url = "wss" + options.url.substr(options.url.indexOf(":")) + "/v1beta1/" + options.feed;
	        options.url = url;
	        options.subscriptions = {
	            trades: [],
	            quotes: [],
	        };
	        super(options);
	    }
	    subscribeForTrades(trades) {
	        this.session.subscriptions.trades.push(...trades);
	        this.subscribe({ trades });
	    }
	    subscribeForQuotes(quotes) {
	        this.session.subscriptions.quotes.push(...quotes);
	        this.subscribe({ quotes });
	    }
	    subscribe(symbols) {
	        var _a, _b;
	        const subMsg = {
	            action: "subscribe",
	            trades: (_a = symbols.trades) !== null && _a !== void 0 ? _a : [],
	            quotes: (_b = symbols.quotes) !== null && _b !== void 0 ? _b : [],
	        };
	        this.conn.send(this.msgpack.encode(subMsg));
	    }
	    subscribeAll() {
	        this.subscribe(this.session.subscriptions);
	    }
	    unsubscribeFromTrades(trades) {
	        this.session.subscriptions.trades = this.session.subscriptions.trades.filter((trade) => !trades.includes(trade));
	        this.unsubscribe({ trades });
	    }
	    unsubscribeFromQuotes(quotes) {
	        this.session.subscriptions.quotes = this.session.subscriptions.quotes.filter((quote) => !quotes.includes(quote));
	        this.unsubscribe({ quotes });
	    }
	    unsubscribe(symbols) {
	        var _a, _b;
	        const unsubMsg = {
	            action: "unsubscribe",
	            trades: (_a = symbols.trades) !== null && _a !== void 0 ? _a : [],
	            quotes: (_b = symbols.quotes) !== null && _b !== void 0 ? _b : [],
	        };
	        this.conn.send(this.msgpack.encode(unsubMsg));
	    }
	    updateSubscriptions(msg) {
	        this.log(`listening to streams:
          trades: ${msg.trades},
          quotes: ${msg.quotes}`);
	        this.session.subscriptions = {
	            trades: msg.trades,
	            quotes: msg.quotes,
	        };
	    }
	    onOptionTrade(fn) {
	        this.on(websocket_1.EVENT.TRADES, (trade) => fn(trade));
	    }
	    onOptionQuote(fn) {
	        this.on(websocket_1.EVENT.QUOTES, (quote) => fn(quote));
	    }
	    dataHandler(data) {
	        data.forEach((element) => {
	            if ("T" in element) {
	                switch (element.T) {
	                    case "t":
	                        this.emit(websocket_1.EVENT.TRADES, (0, entityv2_1.AlpacaOptionTradeV1Beta1)(element));
	                        break;
	                    case "q":
	                        this.emit(websocket_1.EVENT.QUOTES, (0, entityv2_1.AlpacaOptionQuoteV1Beta1)(element));
	                        break;
	                    default:
	                        this.emit(websocket_1.EVENT.CLIENT_ERROR, websocket_1.ERROR.UNEXPECTED_MESSAGE);
	                }
	            }
	        });
	    }
	}
	option_websocket_v1beta1.AlpacaOptionClient = AlpacaOptionClient;
	return option_websocket_v1beta1;
}

var websockets = {};

var entity;
var hasRequiredEntity;

function requireEntity () {
	if (hasRequiredEntity) return entity;
	hasRequiredEntity = 1;
	let alpaca_quote_mapping = {
	    T: "symbol",
	    X: "askexchange",
	    P: "askprice",
	    S: "asksize",
	    x: "bidexchange",
	    p: "bidprice",
	    s: "bidsize",
	    c: "conditions",
	    t: "timestamp",
	};
	let alpaca_trade_mapping = {
	    T: "symbol",
	    i: "tradeID",
	    x: "exchange",
	    p: "price",
	    s: "size",
	    t: "timestamp", // in millisecond
	    z: "tapeID",
	    c: "conditions",
	};
	// used in websocket with AM.<SYMBOL>
	let alpaca_agg_minute_bar_mapping = {
	    T: "symbol",
	    v: "volume",
	    av: "accumulatedVolume",
	    op: "officialOpenPrice",
	    vw: "vwap",
	    o: "openPrice",
	    h: "highPrice",
	    l: "lowPrice",
	    c: "closePrice",
	    a: "averagePrice",
	    s: "startEpochTime",
	    e: "endEpochTime",
	};
	// used with rest bars endpoint
	let alpaca_bar_mapping = {
	    t: "startEpochTime", // in seconds
	    o: "openPrice",
	    h: "highPrice",
	    l: "lowPrice",
	    c: "closePrice",
	    v: "volume",
	};
	function AlpacaQuote(data) {
	    return convert(data, alpaca_quote_mapping);
	}
	function AlpacaTrade(data) {
	    return convert(data, alpaca_trade_mapping);
	}
	function AggMinuteBar(data) {
	    return convert(data, alpaca_agg_minute_bar_mapping);
	}
	function Bar(data) {
	    return convert(data, alpaca_bar_mapping);
	}
	function convert(data, mapping) {
	    const obj = {};
	    for (let [key, value] of Object.entries(data)) {
	        if (mapping.hasOwnProperty(key)) {
	            obj[mapping[key]] = value;
	        }
	        else {
	            obj[key] = value;
	        }
	    }
	    return obj;
	}
	entity = {
	    AlpacaTrade: AlpacaTrade,
	    AlpacaQuote: AlpacaQuote,
	    AggMinuteBar: AggMinuteBar,
	    Bar: Bar,
	};
	return entity;
}

var hasRequiredWebsockets;

function requireWebsockets () {
	if (hasRequiredWebsockets) return websockets;
	hasRequiredWebsockets = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		const events = require$$0$3;
		const WebSocket = requireWs();
		const entity = requireEntity();
		// Listeners
		// A client can listen on any of the following events, states, or errors
		// Connection states. Each of these will also emit EVENT.STATE_CHANGE
		var STATE;
		(function (STATE) {
		    STATE.AUTHENTICATING = "authenticating";
		    STATE.CONNECTED = "connected";
		    STATE.CONNECTING = "connecting";
		    STATE.DISCONNECTED = "disconnected";
		    STATE.WAITING_TO_CONNECT = "waiting to connect";
		    STATE.WAITING_TO_RECONNECT = "waiting to reconnect";
		})((STATE = exports$1.STATE || (exports$1.STATE = {})));
		// Client events
		var EVENT;
		(function (EVENT) {
		    EVENT.CLIENT_ERROR = "client_error";
		    EVENT.STATE_CHANGE = "state_change";
		    EVENT.AUTHORIZED = "authorized";
		    EVENT.UNAUTHORIZED = "unauthorized";
		    EVENT.ORDER_UPDATE = "trade_updates";
		    EVENT.ACCOUNT_UPDATE = "account_updates";
		    EVENT.STOCK_TRADES = "stock_trades";
		    EVENT.STOCK_QUOTES = "stock_quotes";
		    EVENT.STOCK_AGG_SEC = "stock_agg_sec";
		    EVENT.STOCK_AGG_MIN = "stock_agg_min";
		})((EVENT = exports$1.EVENT || (exports$1.EVENT = {})));
		// Connection errors Each of these will also emit EVENT.ERROR
		var ERROR;
		(function (ERROR) {
		    ERROR.BAD_KEY_OR_SECRET = "bad key id or secret";
		    ERROR.CONNECTION_REFUSED = "connection refused";
		    ERROR.MISSING_API_KEY = "missing api key";
		    ERROR.MISSING_SECRET_KEY = "missing secret key";
		    ERROR.UNKNOWN = "unknown error";
		})((ERROR = exports$1.ERROR || (exports$1.ERROR = {})));
		/**
		 * AlpacaStreamClient manages a connection to Alpaca's websocket api
		 */
		class AlpacaStreamClient extends events.EventEmitter {
		    constructor(opts = {}) {
		        super();
		        this.defaultOptions = {
		            // A list of subscriptions to subscribe to on connection
		            subscriptions: [],
		            // Whether the library should reconnect automatically
		            reconnect: true,
		            // Reconnection backoff: if true, then the reconnection time will be initially
		            // reconnectTimeout, then will double with each unsuccessful connection attempt.
		            // It will not exceed maxReconnectTimeout
		            backoff: true,
		            // Initial reconnect timeout (seconds) a minimum of 1 will be used if backoff=false
		            reconnectTimeout: 0,
		            // The maximum amount of time between reconnect tries (applies to backoff)
		            maxReconnectTimeout: 30,
		            // The amount of time to increment the delay between each reconnect attempt
		            backoffIncrement: 0.5,
		            // If true, client outputs detailed log messages
		            verbose: false,
		            // If true we will use the polygon ws data source, otherwise we use
		            // alpaca ws data source
		            usePolygon: false,
		        };
		        // Set minimum reconnectTimeout of 1s if backoff=false
		        if (!opts.backoff && opts.reconnectTimeout < 1) {
		            opts.reconnectTimeout = 1;
		        }
		        // Merge supplied options with defaults
		        this.session = Object.assign(this.defaultOptions, opts);
		        this.session.url = this.session.url.replace(/^http/, "ws") + "/stream";
		        // Keep track of subscriptions in case we need to reconnect after the client
		        // has called subscribe()
		        this.subscriptionState = {};
		        this.session.subscriptions.forEach((x) => {
		            this.subscriptionState[x] = true;
		        });
		        this.currentState = STATE.WAITING_TO_CONNECT;
		        // Register internal event handlers
		        // Log and emit every state change
		        Object.keys(STATE).forEach((s) => {
		            this.on(STATE[s], () => {
		                this.currentState = STATE[s];
		                this.log("info", `state change: ${STATE[s]}`);
		                this.emit(EVENT.STATE_CHANGE, STATE[s]);
		            });
		        });
		        // Log and emit every error
		        Object.keys(ERROR).forEach((e) => {
		            this.on(ERROR[e], () => {
		                this.log("error", ERROR[e]);
		                this.emit(EVENT.CLIENT_ERROR, ERROR[e]);
		            });
		        });
		    }
		    connect() {
		        // Check the credentials
		        if (this.session.apiKey.length === 0 && this.session.oauth.length === 0) {
		            throw new Error(ERROR.MISSING_API_KEY);
		        }
		        if (this.session.secretKey.length === 0 && this.session.oauth.length === 0) {
		            throw new Error(ERROR.MISSING_SECRET_KEY);
		        }
		        // Reset reconnectDisabled since the user called connect() again
		        this.reconnectDisabled = false;
		        this.emit(STATE.CONNECTING);
		        this.conn = new WebSocket(this.session.url);
		        this.conn.once("open", () => {
		            this.authenticate();
		        });
		        this.conn.on("message", (data) => this.handleMessage(data));
		        this.conn.once("error", (err) => {
		            this.emit(ERROR.CONNECTION_REFUSED);
		        });
		        this.conn.once("close", () => {
		            this.emit(STATE.DISCONNECTED);
		            if (this.session.reconnect && !this.reconnectDisabled) {
		                this.reconnect();
		            }
		        });
		    }
		    _ensure_polygon(channels) {
		        if (this.polygon.connectCalled) {
		            if (channels) {
		                this.polygon.subscribe(channels);
		            }
		            return;
		        }
		        this.polygon.connect(channels);
		    }
		    _unsubscribe_polygon(channels) {
		        if (this.polygon.connectCalled) {
		            if (channels) {
		                this.polygon.unsubscribe(channels);
		            }
		        }
		    }
		    subscribe(keys) {
		        let wsChannels = [];
		        let polygonChannels = [];
		        keys.forEach((key) => {
		            const poly = ["Q.", "T.", "A.", "AM."];
		            let found = poly.filter((channel) => key.startsWith(channel));
		            if (found.length > 0) {
		                polygonChannels.push(key);
		            }
		            else {
		                wsChannels.push(key);
		            }
		        });
		        if (wsChannels.length > 0) {
		            const subMsg = {
		                action: "listen",
		                data: {
		                    streams: wsChannels,
		                },
		            };
		            this.send(JSON.stringify(subMsg));
		        }
		        if (polygonChannels.length > 0) {
		            this._ensure_polygon(polygonChannels);
		        }
		        keys.forEach((x) => {
		            this.subscriptionState[x] = true;
		        });
		    }
		    unsubscribe(keys) {
		        // Currently, only Polygon channels can be unsubscribed from
		        let polygonChannels = [];
		        keys.forEach((key) => {
		            const poly = ["Q.", "T.", "A.", "AM."];
		            let found = poly.filter((channel) => key.startsWith(channel));
		            if (found.length > 0) {
		                polygonChannels.push(key);
		            }
		        });
		        if (polygonChannels.length > 0) {
		            this._unsubscribe_polygon(polygonChannels);
		        }
		        keys.forEach((x) => {
		            this.subscriptionState[x] = false;
		        });
		    }
		    subscriptions() {
		        // if the user unsubscribes from certain equities, they will still be
		        // under this.subscriptionState but with value "false", so we need to
		        // filter them out
		        return Object.keys(this.subscriptionState).filter((x) => this.subscriptionState[x]);
		    }
		    onConnect(fn) {
		        this.on(STATE.CONNECTED, () => fn());
		    }
		    onDisconnect(fn) {
		        this.on(STATE.DISCONNECTED, () => fn());
		    }
		    onStateChange(fn) {
		        this.on(EVENT.STATE_CHANGE, (newState) => fn(newState));
		    }
		    onError(fn) {
		        this.on(EVENT.CLIENT_ERROR, (err) => fn(err));
		    }
		    onOrderUpdate(fn) {
		        this.on(EVENT.ORDER_UPDATE, (orderUpdate) => fn(orderUpdate));
		    }
		    onAccountUpdate(fn) {
		        this.on(EVENT.ACCOUNT_UPDATE, (accountUpdate) => fn(accountUpdate));
		    }
		    onPolygonConnect(fn) {
		        this.polygon.on(STATE.CONNECTED, () => fn());
		    }
		    onPolygonDisconnect(fn) {
		        this.polygon.on(STATE.DISCONNECTED, () => fn());
		    }
		    onStockTrades(fn) {
		        if (this.session.usePolygon) {
		            this.polygon.on(EVENT.STOCK_TRADES, function (subject, data) {
		                fn(subject, data);
		            });
		        }
		        else {
		            this.on(EVENT.STOCK_TRADES, function (subject, data) {
		                fn(subject, data);
		            });
		        }
		    }
		    onStockQuotes(fn) {
		        if (this.session.usePolygon) {
		            this.polygon.on(EVENT.STOCK_QUOTES, function (subject, data) {
		                fn(subject, data);
		            });
		        }
		        else {
		            this.on(EVENT.STOCK_QUOTES, function (subject, data) {
		                fn(subject, data);
		            });
		        }
		    }
		    onStockAggSec(fn) {
		        this.polygon.on(EVENT.STOCK_AGG_SEC, function (subject, data) {
		            fn(subject, data);
		        });
		    }
		    onStockAggMin(fn) {
		        if (this.session.usePolygon) {
		            this.polygon.on(EVENT.STOCK_AGG_MIN, function (subject, data) {
		                fn(subject, data);
		            });
		        }
		        else {
		            this.on(EVENT.STOCK_AGG_MIN, function (subject, data) {
		                fn(subject, data);
		            });
		        }
		    }
		    send(data) {
		        this.conn.send(data);
		    }
		    disconnect() {
		        this.reconnectDisabled = true;
		        this.conn.close();
		        if (this.polygon) {
		            this.polygon.close();
		        }
		    }
		    state() {
		        return this.currentState;
		    }
		    get(key) {
		        return this.session[key];
		    }
		    reconnect() {
		        setTimeout(() => {
		            if (this.session.backoff) {
		                this.session.reconnectTimeout += this.session.backoffIncrement;
		                if (this.session.reconnectTimeout > this.session.maxReconnectTimeout) {
		                    this.session.reconnectTimeout = this.session.maxReconnectTimeout;
		                }
		            }
		            this.connect();
		        }, this.session.reconnectTimeout * 1000);
		        this.emit(STATE.WAITING_TO_RECONNECT, this.session.reconnectTimeout);
		    }
		    authenticate() {
		        this.emit(STATE.AUTHENTICATING);
		        const authMsg = {
		            action: "authenticate",
		            data: {
		                key_id: this.session.apiKey,
		                secret_key: this.session.secretKey,
		            },
		        };
		        this.send(JSON.stringify(authMsg));
		    }
		    handleMessage(data) {
		        // Heartbeat
		        const bytes = new Uint8Array(data);
		        if (bytes.length === 1 && bytes[0] === 1) {
		            return;
		        }
		        let message = JSON.parse(data);
		        const subject = message.stream;
		        if ("error" in message.data) {
		            console.log(message.data.error);
		        }
		        switch (subject) {
		            case "authorization":
		                this.authResultHandler(message.data.status);
		                break;
		            case "listening":
		                this.log(`listening to the streams: ${message.data.streams}`);
		                break;
		            case "trade_updates":
		                this.emit(EVENT.ORDER_UPDATE, message.data);
		                break;
		            case "account_updates":
		                this.emit(EVENT.ACCOUNT_UPDATE, message.data);
		                break;
		            default:
		                if (message.stream.startsWith("T.")) {
		                    this.emit(EVENT.STOCK_TRADES, subject, entity.AlpacaTrade(message.data));
		                }
		                else if (message.stream.startsWith("Q.")) {
		                    this.emit(EVENT.STOCK_QUOTES, subject, entity.AlpacaQuote(message.data));
		                }
		                else if (message.stream.startsWith("AM.")) {
		                    this.emit(EVENT.STOCK_AGG_MIN, subject, entity.AggMinuteBar(message.data));
		                }
		                else {
		                    this.emit(ERROR.PROTOBUF);
		                }
		        }
		    }
		    authResultHandler(authResult) {
		        switch (authResult) {
		            case "authorized":
		                this.emit(STATE.CONNECTED);
		                break;
		            case "unauthorized":
		                this.emit(ERROR.BAD_KEY_OR_SECRET);
		                this.disconnect();
		                break;
		        }
		    }
		    log(level, ...msg) {
		        if (this.session.verbose) {
		            console[level](...msg);
		        }
		    }
		}
		exports$1.AlpacaStreamClient = AlpacaStreamClient; 
	} (websockets));
	return websockets;
}

var alpacaTradeApi;
var hasRequiredAlpacaTradeApi;

function requireAlpacaTradeApi () {
	if (hasRequiredAlpacaTradeApi) return alpacaTradeApi;
	hasRequiredAlpacaTradeApi = 1;
	requireMain().config();
	const api = requireApi();
	const account = requireAccount();
	const position = requirePosition();
	const calendar = requireCalendar();
	const clock = requireClock();
	const asset = requireAsset();
	const order = requireOrder();
	const watchlist = requireWatchlist();
	const dataV2 = requireRest_v2();
	const entityV2 = requireEntityv2();
	const crypto_websocket = requireCrypto_websocket_v1beta3();
	const news_stream = requireNews_websocket();
	const websockets_v2 = requireStock_websocket_v2();
	const option_stream = requireOption_websocket_v1beta1();
	const websockets = requireWebsockets();
	class Alpaca {
	    constructor(config = {}) {
	        // Helper methods
	        this.httpRequest = api.httpRequest.bind(this);
	        this.dataHttpRequest = api.dataHttpRequest;
	        // Account
	        this.getAccount = account.get;
	        this.updateAccountConfigurations = account.updateConfigs;
	        this.getAccountConfigurations = account.getConfigs;
	        this.getAccountActivities = account.getActivities;
	        this.getPortfolioHistory = account.getPortfolioHistory;
	        // Positions
	        this.getPositions = position.getAll;
	        this.getPosition = position.getOne;
	        this.closeAllPositions = position.closeAll;
	        this.closePosition = position.closeOne;
	        // Calendar
	        this.getCalendar = calendar.get;
	        // Clock
	        this.getClock = clock.get;
	        // Asset
	        this.getAssets = asset.getAll;
	        this.getAsset = asset.getOne;
	        // Order
	        this.getOrders = order.getAll;
	        this.getOrder = order.getOne;
	        this.getOrderByClientId = order.getByClientOrderId;
	        this.createOrder = order.post;
	        this.replaceOrder = order.patchOrder;
	        this.cancelOrder = order.cancel;
	        this.cancelAllOrders = order.cancelAll;
	        // Watchlists
	        this.getWatchlists = watchlist.getAll;
	        this.getWatchlist = watchlist.getOne;
	        this.addWatchlist = watchlist.addWatchlist;
	        this.addToWatchlist = watchlist.addToWatchlist;
	        this.updateWatchlist = watchlist.updateWatchlist;
	        this.deleteWatchlist = watchlist.deleteWatchlist;
	        this.deleteFromWatchlist = watchlist.deleteFromWatchlist;
	        this.configuration = {
	            baseUrl: config.baseUrl ||
	                process.env.APCA_API_BASE_URL ||
	                (config.paper
	                    ? "https://paper-api.alpaca.markets"
	                    : "https://api.alpaca.markets"),
	            dataBaseUrl: config.dataBaseUrl ||
	                process.env.APCA_DATA_BASE_URL ||
	                process.env.DATA_PROXY_WS ||
	                "https://data.alpaca.markets",
	            dataStreamUrl: config.dataStreamUrl ||
	                process.env.APCA_API_STREAM_URL ||
	                "https://stream.data.alpaca.markets",
	            keyId: config.keyId || process.env.APCA_API_KEY_ID || "",
	            secretKey: config.secretKey || process.env.APCA_API_SECRET_KEY || "",
	            apiVersion: config.apiVersion || process.env.APCA_API_VERSION || "v2",
	            oauth: config.oauth || process.env.APCA_API_OAUTH || "",
	            feed: config.feed || "iex", // use 'sip' if you have PRO subscription
	            optionFeed: config.optionFeed || "indicative", // use 'opra' if you have PRO subscription
	            verbose: config.verbose,
	        };
	        this.data_ws = new websockets.AlpacaStreamClient({
	            url: this.configuration.dataBaseUrl,
	            apiKey: this.configuration.keyId,
	            secretKey: this.configuration.secretKey,
	            oauth: this.configuration.oauth,
	        });
	        this.data_ws.STATE = websockets.STATE;
	        this.data_ws.EVENT = websockets.EVENT;
	        this.data_ws.ERROR = websockets.ERROR;
	        this.trade_ws = new websockets.AlpacaStreamClient({
	            url: this.configuration.baseUrl,
	            apiKey: this.configuration.keyId,
	            secretKey: this.configuration.secretKey,
	            oauth: this.configuration.oauth,
	        });
	        this.trade_ws.STATE = websockets.STATE;
	        this.trade_ws.EVENT = websockets.EVENT;
	        this.trade_ws.ERROR = websockets.ERROR;
	        this.data_stream_v2 = new websockets_v2.AlpacaStocksClient({
	            url: this.configuration.dataStreamUrl,
	            feed: this.configuration.feed,
	            apiKey: this.configuration.keyId,
	            secretKey: this.configuration.secretKey,
	            verbose: this.configuration.verbose,
	        });
	        this.adjustment = dataV2.Adjustment;
	        this.timeframeUnit = entityV2.TimeFrameUnit;
	        this.crypto_stream_v1beta3 = new crypto_websocket.AlpacaCryptoClient({
	            url: this.configuration.dataStreamUrl,
	            apiKey: this.configuration.keyId,
	            secretKey: this.configuration.secretKey,
	            verbose: this.configuration.verbose,
	        });
	        this.news_stream = new news_stream.AlpacaNewsCLient({
	            url: this.configuration.dataStreamUrl,
	            apiKey: this.configuration.keyId,
	            secretKey: this.configuration.secretKey,
	            verbose: this.configuration.verbose,
	        });
	        this.option_stream = new option_stream.AlpacaOptionClient({
	            url: this.configuration.dataStreamUrl,
	            feed: this.configuration.optionFeed,
	            apiKey: this.configuration.keyId,
	            secretKey: this.configuration.secretKey,
	            verbose: this.configuration.verbose,
	        });
	    }
	    sendRequest(endpoint, queryParams, body, method) {
	        return api.sendRequest(this.httpRequest, endpoint, queryParams, body, method);
	    }
	    //DataV2
	    getTradesV2(symbol, options, config = this.configuration) {
	        return dataV2.getTrades(symbol, options, config);
	    }
	    getMultiTradesV2(symbols, options, config = this.configuration) {
	        return dataV2.getMultiTrades(symbols, options, config);
	    }
	    getMultiTradesAsyncV2(symbols, options, config = this.configuration) {
	        return dataV2.getMultiTradesAsync(symbols, options, config);
	    }
	    getQuotesV2(symbol, options, config = this.configuration) {
	        return dataV2.getQuotes(symbol, options, config);
	    }
	    getMultiQuotesV2(symbols, options, config = this.configuration) {
	        return dataV2.getMultiQuotes(symbols, options, config);
	    }
	    getMultiQuotesAsyncV2(symbols, options, config = this.configuration) {
	        return dataV2.getMultiQuotesAsync(symbols, options, config);
	    }
	    getBarsV2(symbol, options, config = this.configuration) {
	        return dataV2.getBars(symbol, options, config);
	    }
	    getMultiBarsV2(symbols, options, config = this.configuration) {
	        return dataV2.getMultiBars(symbols, options, config);
	    }
	    getMultiBarsAsyncV2(symbols, options, config = this.configuration) {
	        return dataV2.getMultiBarsAsync(symbols, options, config);
	    }
	    getLatestTrade(symbol, config = this.configuration) {
	        return dataV2.getLatestTrade(symbol, config);
	    }
	    getLatestTrades(symbols, config = this.configuration) {
	        return dataV2.getLatestTrades(symbols, config);
	    }
	    getLatestQuote(symbol, config = this.configuration) {
	        return dataV2.getLatestQuote(symbol, config);
	    }
	    getLatestQuotes(symbols, config = this.configuration) {
	        return dataV2.getLatestQuotes(symbols, config);
	    }
	    getLatestBar(symbol, config = this.configuration) {
	        return dataV2.getLatestBar(symbol, config);
	    }
	    getLatestBars(symbols, config = this.configuration) {
	        return dataV2.getLatestBars(symbols, config);
	    }
	    getSnapshot(symbol, config = this.configuration) {
	        return dataV2.getSnapshot(symbol, config);
	    }
	    getSnapshots(symbols, config = this.configuration) {
	        return dataV2.getSnapshots(symbols, config);
	    }
	    getCryptoTrades(symbols, options, config = this.configuration) {
	        return dataV2.getCryptoTrades(symbols, options, config);
	    }
	    getCryptoQuotes(symbols, options, config = this.configuration) {
	        return dataV2.getCryptoQuotes(symbols, options, config);
	    }
	    getCryptoBars(symbols, options, config = this.configuration) {
	        return dataV2.getCryptoBars(symbols, options, config);
	    }
	    getLatestCryptoTrades(symbols, config = this.configuration) {
	        return dataV2.getLatestCryptoTrades(symbols, config);
	    }
	    getLatestCryptoQuotes(symbols, config = this.configuration) {
	        return dataV2.getLatestCryptoQuotes(symbols, config);
	    }
	    getLatestCryptoBars(symbols, config = this.configuration) {
	        return dataV2.getLatestCryptoBars(symbols, config);
	    }
	    getCryptoSnapshots(symbols, config = this.configuration) {
	        return dataV2.getCryptoSnapshots(symbols, config);
	    }
	    getCryptoOrderbooks(symbols, config = this.configuration) {
	        return dataV2.getLatestCryptoOrderbooks(symbols, config);
	    }
	    getOptionBars(symbols, options, config = this.configuration) {
	        return dataV2.getMultiOptionBars(symbols, options, config);
	    }
	    getOptionTrades(symbols, options, config = this.configuration) {
	        return dataV2.getMultiOptionTrades(symbols, options, config);
	    }
	    getOptionLatestTrades(symbols, config = this.configuration) {
	        return dataV2.getLatestOptionTrades(symbols, config);
	    }
	    getOptionLatestQuotes(symbols, config = this.configuration) {
	        return dataV2.getLatestOptionQuotes(symbols, config);
	    }
	    getOptionSnapshots(symbols, config = this.configuration) {
	        return dataV2.getOptionSnapshots(symbols, config);
	    }
	    getOptionChain(underlying_symbol, options, config = this.configuration) {
	        return dataV2.getOptionChain(underlying_symbol, options, config);
	    }
	    getCorporateActions(symbols, options, config = this.configuration) {
	        return dataV2.getCorporateActions(symbols, options, config);
	    }
	    getNews(options, config = this.configuration) {
	        return dataV2.getNews(options, config);
	    }
	    newTimeframe(amount, unit) {
	        return entityV2.NewTimeframe(amount, unit);
	    }
	}
	alpacaTradeApi = Alpaca;
	return alpacaTradeApi;
}

var dist = dist$1.exports;

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist$1.exports;
	hasRequiredDist = 1;
	(function (module, exports$1) {
		var __importDefault = (dist && dist.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		const alpaca_trade_api_1 = __importDefault(requireAlpacaTradeApi());
		exports$1.default = alpaca_trade_api_1.default;
		module.exports = alpaca_trade_api_1.default; 
	} (dist$1, dist$1.exports));
	return dist$1.exports;
}

var distExports = requireDist();
var Alpaca = /*@__PURE__*/getDefaultExportFromCjs(distExports);

/**
 * Alpaca SDK Client Factory
 * Provides unified access to Alpaca Trading API using official SDK
 */
const log$j = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: 'AlpacaClient' });
};
/**
 * AlpacaClient wraps the official SDK with additional features:
 * - Connection pooling
 * - Automatic reconnection
 * - Logging
 * - Error handling
 * - Direct API access for endpoints not covered by SDK
 */
class AlpacaClient {
    sdk;
    config;
    isConnected = false;
    apiBaseUrl;
    headers;
    constructor(config) {
        this.config = config;
        this.sdk = new Alpaca({
            keyId: config.apiKey,
            secretKey: config.apiSecret,
            paper: config.accountType === 'PAPER',
            usePolygon: false,
        });
        // Set up for direct API calls
        this.apiBaseUrl = config.accountType === 'PAPER'
            ? 'https://paper-api.alpaca.markets/v2'
            : 'https://api.alpaca.markets/v2';
        this.headers = {
            'APCA-API-KEY-ID': config.apiKey,
            'APCA-API-SECRET-KEY': config.apiSecret,
            'Content-Type': 'application/json',
        };
        log$j(`AlpacaClient initialized (${config.accountType} mode)`, { type: 'info' });
    }
    /**
     * Get the underlying SDK instance for direct access
     */
    getSDK() {
        return this.sdk;
    }
    /**
     * Get the configuration
     */
    getConfig() {
        return { ...this.config };
    }
    /**
     * Check if using paper trading
     */
    isPaper() {
        return this.config.accountType === 'PAPER';
    }
    /**
     * Validate credentials by fetching account info
     */
    async validateCredentials() {
        try {
            const account = await this.sdk.getAccount();
            this.isConnected = true;
            return {
                ...this.config,
                accountId: account.id,
                accountNumber: account.account_number,
                isValid: true,
            };
        }
        catch (error) {
            this.isConnected = false;
            log$j(`Credential validation failed: ${error.message}`, { type: 'error' });
            throw error;
        }
    }
    /**
     * Check connection status
     */
    isConnectionValid() {
        return this.isConnected;
    }
    /**
     * Get the API base URL
     */
    getApiBaseUrl() {
        return this.apiBaseUrl;
    }
    /**
     * Get the API headers for authentication
     */
    getHeaders() {
        return { ...this.headers };
    }
    /**
     * Make a direct HTTP request to the Alpaca API
     * Use this for endpoints not covered by the SDK
     *
     * @param endpoint - API endpoint (e.g., '/options/contracts')
     * @param method - HTTP method (default: 'GET')
     * @param body - Request body for POST/PUT requests
     * @returns Response data
     */
    async makeRequest(endpoint, method = 'GET', body) {
        const url = `${this.apiBaseUrl}${endpoint}`;
        const options = {
            method,
            headers: this.headers,
        };
        if (body && (method === 'POST' || method === 'PUT')) {
            options.body = JSON.stringify(body);
        }
        try {
            const response = await fetch(url, options);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API request failed (${response.status}): ${errorText}`);
            }
            // Handle empty responses (e.g., DELETE requests)
            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
                return {};
            }
            return await response.json();
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            log$j(`API request to ${endpoint} failed: ${errorMessage}`, { type: 'error' });
            throw error;
        }
    }
}
// Client cache for connection pooling
const clientCache = new Map();
/**
 * Create or get a cached Alpaca client
 * Uses apiKey as cache key for connection pooling
 */
function createAlpacaClient(config) {
    const cacheKey = `${config.apiKey}-${config.accountType}`;
    if (clientCache.has(cacheKey)) {
        log$j(`Returning cached client for ${config.accountType}`, { type: 'debug' });
        return clientCache.get(cacheKey);
    }
    const client = new AlpacaClient(config);
    clientCache.set(cacheKey, client);
    return client;
}
/**
 * Create a client from environment variables
 */
function createClientFromEnv() {
    const apiKey = process.env.ALPACA_API_KEY;
    const apiSecret = process.env.ALPACA_SECRET_KEY;
    const accountType = process.env.ALPACA_ACCOUNT_TYPE || 'PAPER';
    if (!apiKey || !apiSecret) {
        throw new Error('ALPACA_API_KEY and ALPACA_SECRET_KEY environment variables are required');
    }
    return createAlpacaClient({
        apiKey,
        apiSecret,
        accountType,
    });
}
/**
 * Clear client cache (useful for testing or credential rotation)
 */
function clearClientCache() {
    clientCache.clear();
    log$j('Client cache cleared', { type: 'info' });
}

// src/alpaca/trading/bracket-orders.ts
// Bracket Orders Module - Combines entry, take profit, and stop loss orders
/**
 * Logs a message with the BracketOrders source.
 * @param message - The message to log.
 * @param options - Optional logging options.
 */
const log$i = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: 'BracketOrders' });
};
/**
 * Validates bracket order parameters.
 * @param params - The bracket order parameters to validate.
 * @throws Error if validation fails.
 */
function validateBracketOrderParams(params) {
    if (!params.symbol || params.symbol.trim() === '') {
        throw new Error('Symbol is required for bracket order');
    }
    if (!params.qty || params.qty <= 0) {
        throw new Error('Quantity must be a positive number');
    }
    if (params.type === 'limit' && (params.limitPrice === undefined || params.limitPrice <= 0)) {
        throw new Error('Limit price is required and must be positive for limit orders');
    }
    if (!params.takeProfit?.limitPrice || params.takeProfit.limitPrice <= 0) {
        throw new Error('Take profit limit price is required and must be positive');
    }
    if (!params.stopLoss?.stopPrice || params.stopLoss.stopPrice <= 0) {
        throw new Error('Stop loss stop price is required and must be positive');
    }
    // Validate price levels make sense based on side
    if (params.side === 'buy') {
        // For a buy order, take profit should be higher than entry, stop loss lower
        params.limitPrice || params.takeProfit.limitPrice; // Use a reference price
        if (params.takeProfit.limitPrice <= params.stopLoss.stopPrice) {
            log$i('Warning: Take profit price should typically be higher than stop loss price for buy orders', { type: 'warn' });
        }
    }
    else {
        // For a sell order, take profit should be lower than entry, stop loss higher
        if (params.takeProfit.limitPrice >= params.stopLoss.stopPrice) {
            log$i('Warning: Take profit price should typically be lower than stop loss price for sell orders', { type: 'warn' });
        }
    }
}
/**
 * Rounds a price to the appropriate precision for Alpaca.
 * Uses 2 decimal places for prices >= $1, 4 decimal places for prices < $1.
 * @param price - The price to round.
 * @returns The rounded price as a string.
 */
function roundPriceForAlpaca$4(price) {
    const rounded = price >= 1
        ? Math.round(price * 100) / 100
        : Math.round(price * 10000) / 10000;
    return rounded.toString();
}
/**
 * Create a bracket order (entry + take profit + stop loss).
 *
 * A bracket order ensures that when the entry fills:
 * - A take profit limit order is placed
 * - A stop loss order is placed
 * - If either TP or SL fills, the other is automatically canceled (OCO behavior)
 *
 * @param executor - The order executor (AlpacaTradingAPI or AlpacaClient)
 * @param params - The bracket order parameters
 * @returns The bracket order result containing entry and leg orders
 *
 * @example
 * ```typescript
 * const api = AlpacaTradingAPI.new(credentials);
 * const result = await createBracketOrder(
 *   { createOrder: (p) => api.makeRequest('/orders', 'POST', p) },
 *   {
 *     symbol: 'AAPL',
 *     qty: 100,
 *     side: 'buy',
 *     type: 'limit',
 *     limitPrice: 150.00,
 *     takeProfit: { limitPrice: 160.00 },
 *     stopLoss: { stopPrice: 145.00 },
 *     timeInForce: 'gtc',
 *   }
 * );
 * ```
 */
async function createBracketOrder(executor, params) {
    log$i(`Creating bracket order: ${params.side} ${params.qty} ${params.symbol}`, { type: 'info' });
    log$i(`  Entry: ${params.type}${params.limitPrice ? ` @ $${params.limitPrice}` : ''}`, { type: 'debug' });
    log$i(`  Take Profit: $${params.takeProfit.limitPrice}`, { type: 'debug' });
    log$i(`  Stop Loss: $${params.stopLoss.stopPrice}${params.stopLoss.limitPrice ? ` (limit $${params.stopLoss.limitPrice})` : ''}`, { type: 'debug' });
    // Validate parameters
    validateBracketOrderParams(params);
    try {
        // Build the order parameters
        const orderParams = {
            symbol: params.symbol,
            qty: params.qty.toString(),
            side: params.side,
            type: params.type,
            time_in_force: params.timeInForce || 'day',
            order_class: 'bracket',
            take_profit: {
                limit_price: roundPriceForAlpaca$4(params.takeProfit.limitPrice),
            },
            stop_loss: {
                stop_price: roundPriceForAlpaca$4(params.stopLoss.stopPrice),
                ...(params.stopLoss.limitPrice && {
                    limit_price: roundPriceForAlpaca$4(params.stopLoss.limitPrice),
                }),
            },
        };
        // Add limit price for entry if it's a limit order
        if (params.type === 'limit' && params.limitPrice) {
            orderParams.limit_price = roundPriceForAlpaca$4(params.limitPrice);
        }
        // Add extended hours if specified
        if (params.extendedHours) {
            orderParams.extended_hours = true;
        }
        // Add client order ID if specified
        if (params.clientOrderId) {
            orderParams.client_order_id = params.clientOrderId;
        }
        // Execute the order
        const order = await executor.createOrder(orderParams);
        log$i(`Bracket order created successfully: ${order.id}`, { type: 'info' });
        log$i(`  Order status: ${order.status}`, { type: 'debug' });
        // Parse the legs from the response
        const legs = order.legs || [];
        // Find take profit leg - it's a limit order at the take profit price
        const takeProfitLeg = legs.find((leg) => leg.type === 'limit' &&
            parseFloat(leg.limit_price || '0') === params.takeProfit.limitPrice) || null;
        // Find stop loss leg - it's a stop or stop_limit order
        const stopLossLeg = legs.find((leg) => leg.type === 'stop' || leg.type === 'stop_limit') || null;
        if (takeProfitLeg) {
            log$i(`  Take profit leg ID: ${takeProfitLeg.id}`, { type: 'debug' });
        }
        if (stopLossLeg) {
            log$i(`  Stop loss leg ID: ${stopLossLeg.id}`, { type: 'debug' });
        }
        return {
            entryOrder: order,
            takeProfitLeg,
            stopLossLeg,
            allOrders: [order, ...legs],
        };
    }
    catch (error) {
        const err = error;
        log$i(`Bracket order failed: ${err.message}`, { type: 'error' });
        throw new Error(`Failed to create bracket order for ${params.symbol}: ${err.message}`);
    }
}
/**
 * Create a bracket order for an existing position (protective bracket).
 * Useful for adding stop loss and take profit to a position that was entered without them.
 *
 * Note: This creates an OCO (One-Cancels-Other) order rather than a full bracket
 * because we already have the position - we just need the exit legs.
 *
 * @param executor - The order executor (AlpacaTradingAPI or AlpacaClient)
 * @param params - The protective bracket parameters
 * @returns The bracket order result
 *
 * @example
 * ```typescript
 * // Add protection to an existing long position
 * const result = await createProtectiveBracket(
 *   executor,
 *   {
 *     symbol: 'AAPL',
 *     qty: 100,
 *     side: 'sell',
 *     takeProfit: { limitPrice: 160.00 },
 *     stopLoss: { stopPrice: 145.00 },
 *     timeInForce: 'gtc',
 *   }
 * );
 * ```
 */
async function createProtectiveBracket(executor, params) {
    log$i(`Creating protective bracket for ${params.symbol}: ${params.qty} shares`, { type: 'info' });
    log$i(`  Take Profit: $${params.takeProfit.limitPrice}`, { type: 'debug' });
    log$i(`  Stop Loss: $${params.stopLoss.stopPrice}${params.stopLoss.limitPrice ? ` (limit $${params.stopLoss.limitPrice})` : ''}`, { type: 'debug' });
    // Validate parameters
    if (!params.symbol || params.symbol.trim() === '') {
        throw new Error('Symbol is required for protective bracket');
    }
    if (!params.qty || params.qty <= 0) {
        throw new Error('Quantity must be a positive number');
    }
    if (!params.takeProfit?.limitPrice || params.takeProfit.limitPrice <= 0) {
        throw new Error('Take profit limit price is required and must be positive');
    }
    if (!params.stopLoss?.stopPrice || params.stopLoss.stopPrice <= 0) {
        throw new Error('Stop loss stop price is required and must be positive');
    }
    // For a protective sell bracket, take profit should be higher than stop loss
    if (params.takeProfit.limitPrice <= params.stopLoss.stopPrice) {
        log$i('Warning: Take profit price should be higher than stop loss price for protective sell bracket', { type: 'warn' });
    }
    try {
        // Build the OCO order parameters
        const orderParams = {
            symbol: params.symbol,
            qty: params.qty.toString(),
            side: params.side,
            type: 'limit', // Primary leg is a limit order (take profit)
            time_in_force: params.timeInForce || 'gtc',
            order_class: 'oco',
            limit_price: roundPriceForAlpaca$4(params.takeProfit.limitPrice),
            stop_loss: {
                stop_price: roundPriceForAlpaca$4(params.stopLoss.stopPrice),
                ...(params.stopLoss.limitPrice && {
                    limit_price: roundPriceForAlpaca$4(params.stopLoss.limitPrice),
                }),
            },
        };
        // Execute the order
        const order = await executor.createOrder(orderParams);
        log$i(`Protective bracket created successfully: ${order.id}`, { type: 'info' });
        // Parse the legs from the response
        const legs = order.legs || [];
        // The primary order is the take profit (limit order)
        const takeProfitLeg = order;
        // Find stop loss leg
        const stopLossLeg = legs.find((leg) => leg.type === 'stop' || leg.type === 'stop_limit') || null;
        return {
            entryOrder: order,
            takeProfitLeg,
            stopLossLeg,
            allOrders: [order, ...legs],
        };
    }
    catch (error) {
        const err = error;
        log$i(`Protective bracket failed: ${err.message}`, { type: 'error' });
        throw new Error(`Failed to create protective bracket for ${params.symbol}: ${err.message}`);
    }
}
/**
 * Creates an adapter to use AlpacaTradingAPI as a BracketOrderExecutor.
 *
 * @param api - Instance of AlpacaTradingAPI
 * @returns BracketOrderExecutor compatible with bracket order functions
 *
 * @example
 * ```typescript
 * const api = AlpacaTradingAPI.new(credentials);
 * const executor = createExecutorFromTradingAPI(api);
 * const result = await createBracketOrder(executor, params);
 * ```
 */
function createExecutorFromTradingAPI(api) {
    return {
        createOrder: async (params) => {
            return api.makeRequest('/orders', 'POST', params);
        },
    };
}
var bracketOrders = {
    createBracketOrder,
    createProtectiveBracket,
    createExecutorFromTradingAPI,
};

var bracketOrders$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createBracketOrder: createBracketOrder,
    createExecutorFromTradingAPI: createExecutorFromTradingAPI,
    createProtectiveBracket: createProtectiveBracket,
    default: bracketOrders
});

const log$h = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: 'Account' });
};
/**
 * Get account details from Alpaca
 * @param client - AlpacaClient instance
 * @returns Promise resolving to account details
 */
async function getAccountDetails(client) {
    log$h('Fetching account details');
    try {
        const sdk = client.getSDK();
        const account = await sdk.getAccount();
        log$h(`Account details fetched successfully for account ${account.account_number}`);
        return account;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$h(`Failed to fetch account details: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Get account configuration from Alpaca
 * @param client - AlpacaClient instance
 * @returns Promise resolving to account configuration
 */
async function getAccountConfiguration(client) {
    log$h('Fetching account configuration');
    try {
        const sdk = client.getSDK();
        const config = await sdk.getAccountConfigurations();
        log$h('Account configuration fetched successfully');
        return config;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$h(`Failed to fetch account configuration: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Update account configuration on Alpaca
 * @param client - AlpacaClient instance
 * @param config - Partial configuration to update
 * @returns Promise resolving to updated account configuration
 */
async function updateAccountConfiguration(client, config) {
    log$h('Updating account configuration');
    try {
        const sdk = client.getSDK();
        const updatedConfig = await sdk.updateAccountConfigurations(config);
        log$h('Account configuration updated successfully');
        return updatedConfig;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$h(`Failed to update account configuration: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Get portfolio history from Alpaca
 * @param client - AlpacaClient instance
 * @param params - Parameters for portfolio history request
 * @returns Promise resolving to portfolio history response
 */
async function getPortfolioHistory(client, params) {
    log$h(`Fetching portfolio history with period: ${params.period || 'default'}, timeframe: ${params.timeframe || 'default'}`);
    try {
        const sdk = client.getSDK();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const history = await sdk.getPortfolioHistory(params);
        log$h(`Portfolio history fetched successfully with ${history.equity?.length || 0} data points`);
        return history;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$h(`Failed to fetch portfolio history: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Check if account is eligible for trading
 * @param client - AlpacaClient instance
 * @returns Promise resolving to trading eligibility status
 */
async function checkTradingEligibility(client) {
    log$h('Checking trading eligibility');
    try {
        const account = await getAccountDetails(client);
        const reasons = [];
        let canTrade = true;
        // Check various blocking conditions
        if (account.trading_blocked) {
            canTrade = false;
            reasons.push('Trading is blocked on this account');
        }
        if (account.account_blocked) {
            canTrade = false;
            reasons.push('Account is blocked');
        }
        if (account.trade_suspended_by_user) {
            canTrade = false;
            reasons.push('Trading is suspended by user');
        }
        if (account.status !== 'ACTIVE') {
            canTrade = false;
            reasons.push(`Account status is ${account.status}, not ACTIVE`);
        }
        const buyingPower = parseFloat(account.buying_power);
        if (buyingPower <= 0) {
            canTrade = false;
            reasons.push('No buying power available');
        }
        // Check PDT restrictions for accounts under $25k
        const equity = parseFloat(account.equity);
        if (account.pattern_day_trader && equity < 25000) {
            reasons.push('Pattern day trader with equity below $25,000 - day trading restricted');
        }
        const eligibility = {
            canTrade,
            reasons,
            buyingPower,
            dayTradeCount: account.daytrade_count,
            isPatternDayTrader: account.pattern_day_trader,
        };
        log$h(`Trading eligibility check complete: canTrade=${canTrade}${reasons.length > 0 ? `, reasons: ${reasons.join('; ')}` : ''}`);
        return eligibility;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$h(`Failed to check trading eligibility: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Get buying power breakdown for different asset classes
 * @param client - AlpacaClient instance
 * @returns Promise resolving to buying power breakdown
 */
async function getBuyingPower(client) {
    log$h('Fetching buying power breakdown');
    try {
        const account = await getAccountDetails(client);
        const breakdown = {
            cash: parseFloat(account.cash),
            equity: parseFloat(account.equity),
            dayTradingBuyingPower: parseFloat(account.daytrading_buying_power),
            regtBuyingPower: parseFloat(account.regt_buying_power),
            optionsBuyingPower: parseFloat(account.options_buying_power),
            // Crypto buying power is typically equal to cash for spot trading
            cryptoBuyingPower: parseFloat(account.cash),
        };
        log$h(`Buying power breakdown: cash=$${breakdown.cash.toFixed(2)}, dayTrading=$${breakdown.dayTradingBuyingPower.toFixed(2)}, regT=$${breakdown.regtBuyingPower.toFixed(2)}`);
        return breakdown;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$h(`Failed to fetch buying power: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Get options trading level for the account
 * @param client - AlpacaClient instance
 * @returns Promise resolving to options trading level (0-3)
 */
async function getOptionsTradingLevel(client) {
    log$h('Fetching options trading level');
    try {
        const account = await getAccountDetails(client);
        const level = account.options_trading_level || 0;
        log$h(`Options trading level: ${level}`);
        return level;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$h(`Failed to fetch options trading level: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Get Pattern Day Trader (PDT) status
 * @param client - AlpacaClient instance
 * @returns Promise resolving to PDT status
 */
async function getPDTStatus(client) {
    log$h('Fetching PDT status');
    try {
        const account = await getAccountDetails(client);
        const equity = parseFloat(account.equity);
        const isPDT = account.pattern_day_trader;
        const dayTradeCount = account.daytrade_count;
        // Non-PDT accounts are limited to 3 day trades in a 5-day rolling period
        // PDT accounts with $25k+ equity have no day trade limit
        let dayTradesRemaining;
        let canDayTrade;
        if (isPDT) {
            if (equity >= 25000) {
                // PDT with sufficient equity - unlimited day trades
                dayTradesRemaining = Infinity;
                canDayTrade = true;
            }
            else {
                // PDT with insufficient equity - restricted
                dayTradesRemaining = 0;
                canDayTrade = false;
            }
        }
        else {
            // Non-PDT - limited to 3 day trades per 5-day period
            dayTradesRemaining = Math.max(0, 3 - dayTradeCount);
            canDayTrade = dayTradesRemaining > 0;
        }
        const status = {
            isPatternDayTrader: isPDT,
            dayTradeCount,
            dayTradesRemaining: dayTradesRemaining === Infinity ? -1 : dayTradesRemaining, // Use -1 for unlimited
            canDayTrade,
        };
        log$h(`PDT status: isPDT=${isPDT}, dayTradeCount=${dayTradeCount}, remaining=${dayTradesRemaining === Infinity ? 'unlimited' : dayTradesRemaining}`);
        return status;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$h(`Failed to fetch PDT status: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
// ==================== Portfolio History Utilities ====================
/**
 * Get daily returns from portfolio history
 * @param client - AlpacaClient instance
 * @param period - Period to fetch (e.g., '1W', '1M', '3M', '1A')
 * @returns Promise resolving to array of daily returns
 */
async function getDailyReturns(client, period = '1M') {
    log$h(`Calculating daily returns for period: ${period}`);
    try {
        const history = await getPortfolioHistory(client, {
            period,
            timeframe: '1D',
        });
        if (!history.timestamp || !history.equity || history.timestamp.length === 0) {
            log$h('No portfolio history data available', { type: 'warn' });
            return [];
        }
        const dailyReturns = [];
        for (let i = 0; i < history.timestamp.length; i++) {
            const timestamp = history.timestamp[i];
            const equity = history.equity[i];
            const profitLoss = history.profit_loss?.[i] || 0;
            const profitLossPct = history.profit_loss_pct?.[i] || 0;
            // Calculate daily return (percentage change from previous day)
            let dailyReturn = 0;
            if (i > 0 && history.equity[i - 1] !== 0) {
                dailyReturn = ((equity - history.equity[i - 1]) / history.equity[i - 1]) * 100;
            }
            dailyReturns.push({
                date: new Date(timestamp * 1000),
                equity,
                profitLoss,
                profitLossPct: profitLossPct * 100, // Convert to percentage
                dailyReturn,
            });
        }
        log$h(`Calculated ${dailyReturns.length} daily returns`);
        return dailyReturns;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$h(`Failed to calculate daily returns: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Calculate period performance metrics
 * @param client - AlpacaClient instance
 * @param period - Period to analyze (e.g., '1W', '1M', '3M', '1A')
 * @returns Promise resolving to period performance metrics
 */
async function calculatePeriodPerformance(client, period = '1M') {
    log$h(`Calculating period performance for: ${period}`);
    try {
        const dailyReturns = await getDailyReturns(client, period);
        if (dailyReturns.length < 2) {
            throw new Error('Insufficient data points for performance calculation');
        }
        const startingEquity = dailyReturns[0].equity;
        const endingEquity = dailyReturns[dailyReturns.length - 1].equity;
        const totalReturn = endingEquity - startingEquity;
        const totalReturnPct = ((endingEquity - startingEquity) / startingEquity) * 100;
        // Calculate average daily return
        const returns = dailyReturns.map((d) => d.dailyReturn).filter((r) => !isNaN(r));
        const averageDailyReturn = returns.length > 0 ? returns.reduce((a, b) => a + b, 0) / returns.length : 0;
        // Calculate max drawdown
        let peak = dailyReturns[0].equity;
        let maxDrawdown = 0;
        let maxDrawdownPct = 0;
        for (const day of dailyReturns) {
            if (day.equity > peak) {
                peak = day.equity;
            }
            const drawdown = peak - day.equity;
            const drawdownPct = peak > 0 ? (drawdown / peak) * 100 : 0;
            if (drawdown > maxDrawdown) {
                maxDrawdown = drawdown;
                maxDrawdownPct = drawdownPct;
            }
        }
        // Calculate volatility (standard deviation of daily returns)
        const variance = returns.length > 1
            ? returns.reduce((sum, r) => sum + Math.pow(r - averageDailyReturn, 2), 0) / (returns.length - 1)
            : 0;
        const volatility = Math.sqrt(variance);
        // Calculate Sharpe Ratio (assuming risk-free rate of 0 for simplicity)
        // Annualized: (avg daily return * 252) / (volatility * sqrt(252))
        let sharpeRatio = null;
        if (volatility > 0) {
            const annualizedReturn = averageDailyReturn * 252;
            const annualizedVolatility = volatility * Math.sqrt(252);
            sharpeRatio = annualizedReturn / annualizedVolatility;
        }
        // Count winning and losing days
        const winningDays = returns.filter((r) => r > 0).length;
        const losingDays = returns.filter((r) => r < 0).length;
        const winRate = returns.length > 0 ? (winningDays / returns.length) * 100 : 0;
        const performance = {
            startDate: dailyReturns[0].date,
            endDate: dailyReturns[dailyReturns.length - 1].date,
            startingEquity,
            endingEquity,
            totalReturn,
            totalReturnPct,
            averageDailyReturn,
            maxDrawdown,
            maxDrawdownPct,
            sharpeRatio,
            volatility,
            winningDays,
            losingDays,
            winRate,
        };
        log$h(`Period performance: totalReturn=${totalReturnPct.toFixed(2)}%, maxDrawdown=${maxDrawdownPct.toFixed(2)}%, sharpe=${sharpeRatio?.toFixed(2) || 'N/A'}`);
        return performance;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$h(`Failed to calculate period performance: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Get equity curve data
 * @param client - AlpacaClient instance
 * @param params - Portfolio history parameters
 * @returns Promise resolving to equity curve data points
 */
async function getEquityCurve(client, params = { period: '1M', timeframe: '1D' }) {
    log$h(`Fetching equity curve with period: ${params.period || 'default'}`);
    try {
        const history = await getPortfolioHistory(client, params);
        if (!history.timestamp || !history.equity || history.timestamp.length === 0) {
            log$h('No portfolio history data available for equity curve', { type: 'warn' });
            return [];
        }
        const baseValue = history.base_value || history.equity[0];
        const curve = [];
        for (let i = 0; i < history.timestamp.length; i++) {
            const timestamp = history.timestamp[i];
            const equity = history.equity[i];
            const profitLoss = history.profit_loss?.[i] || 0;
            const profitLossPct = history.profit_loss_pct?.[i] || 0;
            // Calculate cumulative return from base value
            const cumulativeReturn = baseValue > 0 ? ((equity - baseValue) / baseValue) * 100 : 0;
            curve.push({
                timestamp: new Date(timestamp * 1000),
                equity,
                profitLoss,
                profitLossPct: profitLossPct * 100, // Convert to percentage
                cumulativeReturn,
            });
        }
        log$h(`Generated equity curve with ${curve.length} data points`);
        return curve;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$h(`Failed to get equity curve: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Get account equity and cash summary
 * @param client - AlpacaClient instance
 * @returns Promise resolving to account summary
 */
async function getAccountSummary(client) {
    log$h('Fetching account summary');
    try {
        const account = await getAccountDetails(client);
        const equity = parseFloat(account.equity);
        const lastEquity = parseFloat(account.last_equity);
        const todayProfitLoss = equity - lastEquity;
        const todayProfitLossPct = lastEquity > 0 ? (todayProfitLoss / lastEquity) * 100 : 0;
        const summary = {
            equity,
            cash: parseFloat(account.cash),
            portfolioValue: parseFloat(account.portfolio_value),
            longMarketValue: parseFloat(account.long_market_value),
            shortMarketValue: parseFloat(account.short_market_value),
            lastEquity,
            todayProfitLoss,
            todayProfitLossPct,
        };
        log$h(`Account summary: equity=$${summary.equity.toFixed(2)}, cash=$${summary.cash.toFixed(2)}, todayP/L=${summary.todayProfitLossPct.toFixed(2)}%`);
        return summary;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$h(`Failed to get account summary: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Check if account is a margin account
 * @param client - AlpacaClient instance
 * @returns Promise resolving to boolean indicating margin status
 */
async function isMarginAccount(client) {
    log$h('Checking margin account status');
    try {
        const account = await getAccountDetails(client);
        // Multiplier > 1 indicates margin account
        const isMargin = account.multiplier !== '1';
        log$h(`Margin account: ${isMargin} (multiplier: ${account.multiplier})`);
        return isMargin;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$h(`Failed to check margin account status: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Get margin information for the account
 * @param client - AlpacaClient instance
 * @returns Promise resolving to margin information
 */
async function getMarginInfo(client) {
    log$h('Fetching margin information');
    try {
        const account = await getAccountDetails(client);
        const initialMargin = parseFloat(account.initial_margin);
        const maintenanceMargin = parseFloat(account.maintenance_margin);
        const equity = parseFloat(account.equity);
        // Calculate margin call amount if applicable
        const marginCallAmount = Math.max(0, maintenanceMargin - equity);
        const marginInfo = {
            multiplier: account.multiplier,
            initialMargin,
            maintenanceMargin,
            lastMaintenanceMargin: parseFloat(account.last_maintenance_margin),
            sma: parseFloat(account.sma),
            marginCallAmount,
        };
        log$h(`Margin info: multiplier=${marginInfo.multiplier}, initialMargin=$${marginInfo.initialMargin.toFixed(2)}, maintenanceMargin=$${marginInfo.maintenanceMargin.toFixed(2)}`);
        return marginInfo;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$h(`Failed to get margin information: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
var account = {
    getAccountDetails,
    getAccountConfiguration,
    updateAccountConfiguration,
    getPortfolioHistory,
    checkTradingEligibility,
    getBuyingPower,
    getOptionsTradingLevel,
    getPDTStatus,
    getDailyReturns,
    calculatePeriodPerformance,
    getEquityCurve,
    getAccountSummary,
    isMarginAccount,
    getMarginInfo,
};

var account$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    calculatePeriodPerformance: calculatePeriodPerformance,
    checkTradingEligibility: checkTradingEligibility,
    default: account,
    getAccountConfiguration: getAccountConfiguration,
    getAccountDetails: getAccountDetails,
    getAccountSummary: getAccountSummary,
    getBuyingPower: getBuyingPower,
    getDailyReturns: getDailyReturns,
    getEquityCurve: getEquityCurve,
    getMarginInfo: getMarginInfo,
    getOptionsTradingLevel: getOptionsTradingLevel,
    getPDTStatus: getPDTStatus,
    getPortfolioHistory: getPortfolioHistory,
    isMarginAccount: isMarginAccount,
    updateAccountConfiguration: updateAccountConfiguration
});

/**
 * Order Query Utilities for Alpaca Trading
 *
 * Provides utility functions for querying, filtering, and managing Alpaca orders.
 * Includes auto-pagination, order status helpers, and formatting utilities.
 *
 * @module order-utils
 */
const log$g = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: 'OrderUtils' });
};
/**
 * Default delay between pagination requests to avoid rate limits (in milliseconds)
 */
const DEFAULT_PAGINATION_DELAY_MS = 300;
/**
 * Maximum orders per Alpaca API request
 */
const MAX_ORDERS_PER_REQUEST = 500;
/**
 * Order statuses that are considered "open"
 */
const OPEN_ORDER_STATUSES = [
    'new',
    'accepted',
    'pending_new',
    'accepted_for_bidding',
    'partially_filled',
];
/**
 * Order statuses that indicate a filled order
 */
const FILLED_ORDER_STATUSES = ['filled'];
/**
 * Order statuses that can still potentially be filled
 */
const FILLABLE_ORDER_STATUSES = [
    'new',
    'accepted',
    'pending_new',
    'accepted_for_bidding',
    'partially_filled',
];
/**
 * Terminal order statuses (order is no longer active)
 */
const TERMINAL_ORDER_STATUSES = [
    'filled',
    'canceled',
    'expired',
    'replaced',
    'stopped',
    'rejected',
    'suspended',
];
/**
 * Delay execution for the specified number of milliseconds
 */
async function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
/**
 * Build SDK-compatible query parameters from GetOrdersParams
 */
function buildOrderQueryParams(params) {
    const queryParams = {};
    if (params.status)
        queryParams.status = params.status;
    if (params.limit)
        queryParams.limit = params.limit;
    if (params.after)
        queryParams.after = params.after;
    if (params.until)
        queryParams.until = params.until;
    if (params.direction)
        queryParams.direction = params.direction;
    if (params.nested !== undefined)
        queryParams.nested = params.nested;
    if (params.symbols && params.symbols.length > 0) {
        queryParams.symbols = params.symbols.join(',');
    }
    if (params.side)
        queryParams.side = params.side;
    return queryParams;
}
/**
 * Get all orders for a specific symbol
 *
 * @param client - AlpacaClient instance
 * @param symbol - Symbol to filter orders by (e.g., 'AAPL', 'BTCUSD')
 * @param params - Optional additional filter parameters
 * @returns Promise resolving to array of orders for the symbol
 *
 * @example
 * ```typescript
 * const client = createAlpacaClient({ apiKey, apiSecret, accountType: 'PAPER' });
 * const orders = await getOrdersBySymbol(client, 'AAPL', { status: 'all' });
 * console.log(`Found ${orders.length} orders for AAPL`);
 * ```
 */
async function getOrdersBySymbol(client, symbol, params = {}) {
    const sdk = client.getSDK();
    try {
        log$g(`Fetching orders for symbol: ${symbol}`, {
            type: 'debug',
            metadata: { symbol, ...params },
        });
        // Build query parameters as Record<string, unknown> to match SDK expectations
        const queryParams = {
            symbols: symbol,
        };
        if (params.status)
            queryParams.status = params.status;
        if (params.limit)
            queryParams.limit = params.limit;
        if (params.after)
            queryParams.after = params.after;
        if (params.until)
            queryParams.until = params.until;
        if (params.direction)
            queryParams.direction = params.direction;
        if (params.nested !== undefined)
            queryParams.nested = params.nested;
        if (params.side)
            queryParams.side = params.side;
        const orders = await sdk.getOrders(queryParams);
        log$g(`Found ${orders.length} orders for ${symbol}`, {
            type: 'debug',
            metadata: { symbol, count: orders.length },
        });
        return orders;
    }
    catch (error) {
        log$g(`Error fetching orders for symbol ${symbol}: ${error.message}`, {
            type: 'error',
            metadata: { symbol, error: error.message },
        });
        throw error;
    }
}
/**
 * Get only open orders
 *
 * @param client - AlpacaClient instance
 * @param params - Optional filter parameters
 * @returns Promise resolving to array of open orders
 *
 * @example
 * ```typescript
 * const openOrders = await getOpenOrders(client);
 * console.log(`You have ${openOrders.length} open orders`);
 * ```
 */
async function getOpenOrders$1(client, params = {}) {
    const sdk = client.getSDK();
    try {
        log$g('Fetching open orders', { type: 'debug' });
        // Build query parameters as Record<string, unknown> to match SDK expectations
        const queryParams = {
            status: 'open',
        };
        if (params.limit)
            queryParams.limit = params.limit;
        if (params.after)
            queryParams.after = params.after;
        if (params.until)
            queryParams.until = params.until;
        if (params.direction)
            queryParams.direction = params.direction;
        if (params.nested !== undefined)
            queryParams.nested = params.nested;
        if (params.symbols && params.symbols.length > 0) {
            queryParams.symbols = params.symbols.join(',');
        }
        if (params.side)
            queryParams.side = params.side;
        const orders = await sdk.getOrders(queryParams);
        log$g(`Found ${orders.length} open orders`, {
            type: 'debug',
            metadata: { count: orders.length },
        });
        return orders;
    }
    catch (error) {
        log$g(`Error fetching open orders: ${error.message}`, {
            type: 'error',
            metadata: { error: error.message },
        });
        throw error;
    }
}
/**
 * Get only filled orders within a date range
 *
 * @param client - AlpacaClient instance
 * @param params - Date range and optional filter parameters
 * @returns Promise resolving to array of filled orders in the date range
 *
 * @example
 * ```typescript
 * const startDate = new Date('2024-01-01');
 * const endDate = new Date('2024-01-31');
 * const filledOrders = await getFilledOrders(client, { startDate, endDate });
 * console.log(`Found ${filledOrders.length} filled orders in January`);
 * ```
 */
async function getFilledOrders(client, params) {
    client.getSDK();
    const { startDate, endDate, symbols, side } = params;
    try {
        log$g(`Fetching filled orders from ${startDate.toISOString()} to ${endDate.toISOString()}`, {
            type: 'debug',
            metadata: { startDate: startDate.toISOString(), endDate: endDate.toISOString() },
        });
        const queryParams = {
            status: 'closed',
            after: startDate.toISOString(),
            until: endDate.toISOString(),
            limit: MAX_ORDERS_PER_REQUEST,
        };
        if (symbols && symbols.length > 0) {
            queryParams.symbols = symbols;
        }
        if (side) {
            queryParams.side = side;
        }
        const allOrders = await getAllOrders(client, { ...queryParams, fetchAll: true });
        // Filter to only filled orders
        const filledOrders = allOrders.filter((order) => FILLED_ORDER_STATUSES.includes(order.status));
        log$g(`Found ${filledOrders.length} filled orders in date range`, {
            type: 'debug',
            metadata: { count: filledOrders.length },
        });
        return filledOrders;
    }
    catch (error) {
        log$g(`Error fetching filled orders: ${error.message}`, {
            type: 'error',
            metadata: { error: error.message },
        });
        throw error;
    }
}
/**
 * Get paginated order history with auto-pagination support
 *
 * @param client - AlpacaClient instance
 * @param params - Pagination and filter parameters
 * @returns Promise resolving to order history result with pagination info
 *
 * @example
 * ```typescript
 * // Get first page
 * const result = await getOrderHistory(client, { pageSize: 100, page: 1 });
 *
 * // Get all pages
 * let allOrders: AlpacaOrder[] = [];
 * let page = 1;
 * let hasMore = true;
 *
 * while (hasMore) {
 *   const result = await getOrderHistory(client, { pageSize: 100, page });
 *   allOrders = allOrders.concat(result.orders);
 *   hasMore = result.hasMore;
 *   page++;
 * }
 * ```
 */
async function getOrderHistory(client, params = {}) {
    const { pageSize = 100, page = 1, symbols, status = 'all', side, direction = 'desc', } = params;
    const effectivePageSize = Math.min(pageSize, MAX_ORDERS_PER_REQUEST);
    const sdk = client.getSDK();
    try {
        log$g(`Fetching order history page ${page} (size: ${effectivePageSize})`, {
            type: 'debug',
            metadata: { page, pageSize: effectivePageSize },
        });
        // Build base query parameters
        const baseParams = {
            status,
            limit: effectivePageSize,
            direction,
        };
        if (symbols && symbols.length > 0) {
            baseParams.symbols = symbols;
        }
        if (side) {
            baseParams.side = side;
        }
        // For pages > 1, we need to fetch previous pages to get the timestamp cursor
        // This is a limitation of Alpaca's API which uses timestamp-based pagination
        if (page > 1) {
            // Fetch all orders up to the requested page
            const allPreviousOrders = [];
            let currentBatch = [];
            let iterations = 0;
            const maxIterations = page;
            do {
                const batchParams = {
                    ...baseParams,
                    limit: effectivePageSize,
                };
                if (allPreviousOrders.length > 0) {
                    const lastOrder = allPreviousOrders[allPreviousOrders.length - 1];
                    if (direction === 'desc') {
                        batchParams.until = lastOrder.created_at;
                    }
                    else {
                        batchParams.after = lastOrder.created_at;
                    }
                }
                const sdkParams = buildOrderQueryParams(batchParams);
                currentBatch = (await sdk.getOrders(sdkParams));
                allPreviousOrders.push(...currentBatch);
                iterations++;
                if (iterations < maxIterations && currentBatch.length === effectivePageSize) {
                    await delay(DEFAULT_PAGINATION_DELAY_MS);
                }
            } while (currentBatch.length === effectivePageSize && iterations < maxIterations);
            // Get the orders for the requested page
            const startIndex = (page - 1) * effectivePageSize;
            const endIndex = startIndex + effectivePageSize;
            const pageOrders = allPreviousOrders.slice(startIndex, endIndex);
            return {
                orders: pageOrders,
                page,
                pageSize: effectivePageSize,
                totalFetched: allPreviousOrders.length,
                hasMore: endIndex < allPreviousOrders.length || currentBatch.length === effectivePageSize,
            };
        }
        // First page - simple fetch
        const sdkParams = buildOrderQueryParams(baseParams);
        const orders = (await sdk.getOrders(sdkParams));
        return {
            orders,
            page,
            pageSize: effectivePageSize,
            totalFetched: orders.length,
            hasMore: orders.length === effectivePageSize,
        };
    }
    catch (error) {
        log$g(`Error fetching order history: ${error.message}`, {
            type: 'error',
            metadata: { error: error.message },
        });
        throw error;
    }
}
/**
 * Get all orders with automatic pagination
 * Alpaca limits to 500 orders per request, so this function handles
 * pagination automatically when fetchAll is true.
 *
 * @param client - AlpacaClient instance
 * @param params - Query parameters with optional fetchAll flag
 * @returns Promise resolving to array of all orders matching the criteria
 *
 * @example
 * ```typescript
 * // Fetch all closed orders
 * const allOrders = await getAllOrders(client, {
 *   status: 'closed',
 *   fetchAll: true
 * });
 * console.log(`Total orders: ${allOrders.length}`);
 * ```
 */
async function getAllOrders(client, params = {}) {
    const { fetchAll = false, paginationDelayMs = DEFAULT_PAGINATION_DELAY_MS, ...queryParams } = params;
    const sdk = client.getSDK();
    try {
        // If not fetching all, just make a single request
        if (!fetchAll) {
            const singleParams = {
                ...queryParams,
                limit: queryParams.limit || MAX_ORDERS_PER_REQUEST,
            };
            const sdkParams = buildOrderQueryParams(singleParams);
            const orders = await sdk.getOrders(sdkParams);
            return orders;
        }
        log$g('Fetching all orders with pagination', {
            type: 'debug',
            metadata: { params: queryParams },
        });
        const allOrders = [];
        let hasMore = true;
        let currentUntil = queryParams.until;
        let pageCount = 0;
        while (hasMore) {
            const batchParams = {
                ...queryParams,
                limit: MAX_ORDERS_PER_REQUEST,
            };
            if (currentUntil) {
                batchParams.until = currentUntil;
            }
            const sdkParams = buildOrderQueryParams(batchParams);
            const batch = (await sdk.getOrders(sdkParams));
            pageCount++;
            log$g(`Fetched page ${pageCount}: ${batch.length} orders`, {
                type: 'debug',
                metadata: { pageCount, batchSize: batch.length },
            });
            if (batch.length === 0) {
                hasMore = false;
            }
            else {
                // Add orders to result, avoiding duplicates
                const existingIds = new Set(allOrders.map((o) => o.id));
                const newOrders = batch.filter((o) => !existingIds.has(o.id));
                allOrders.push(...newOrders);
                // Check if we got a full page (might be more)
                if (batch.length < MAX_ORDERS_PER_REQUEST) {
                    hasMore = false;
                }
                else {
                    // Use the oldest order's created_at as the next until cursor
                    const oldestOrder = batch[batch.length - 1];
                    currentUntil = oldestOrder.created_at;
                    // Add delay to avoid rate limiting
                    await delay(paginationDelayMs);
                }
            }
        }
        log$g(`Fetched total of ${allOrders.length} orders across ${pageCount} pages`, {
            type: 'info',
            metadata: { totalOrders: allOrders.length, pageCount },
        });
        return allOrders;
    }
    catch (error) {
        log$g(`Error fetching all orders: ${error.message}`, {
            type: 'error',
            metadata: { error: error.message },
        });
        throw error;
    }
}
/**
 * Wait for an order to be filled or timeout
 *
 * @param client - AlpacaClient instance
 * @param params - Order ID and timeout parameters
 * @returns Promise resolving to fill result with order state and timing info
 *
 * @example
 * ```typescript
 * const order = await submitOrder(client, { ... });
 *
 * const result = await waitForOrderFill(client, {
 *   orderId: order.id,
 *   timeoutMs: 30000, // 30 seconds
 *   pollIntervalMs: 500 // Poll every 500ms
 * });
 *
 * if (result.filled) {
 *   console.log(`Order filled at ${result.order.filled_avg_price}`);
 * } else {
 *   console.log(`Order not filled, status: ${result.order.status}`);
 * }
 * ```
 */
async function waitForOrderFill(client, params) {
    const { orderId, timeoutMs = 60000, pollIntervalMs = 1000, } = params;
    const sdk = client.getSDK();
    const startTime = Date.now();
    log$g(`Waiting for order ${orderId} to fill (timeout: ${timeoutMs}ms)`, {
        type: 'debug',
        metadata: { orderId, timeoutMs, pollIntervalMs },
    });
    try {
        while (true) {
            const elapsed = Date.now() - startTime;
            if (elapsed >= timeoutMs) {
                // Fetch final state before returning
                const order = (await sdk.getOrder(orderId));
                log$g(`Order ${orderId} timed out after ${elapsed}ms, status: ${order.status}`, {
                    type: 'warn',
                    metadata: { orderId, elapsed, status: order.status },
                });
                return {
                    filled: FILLED_ORDER_STATUSES.includes(order.status),
                    order,
                    elapsedMs: elapsed,
                };
            }
            const order = (await sdk.getOrder(orderId));
            // Check if filled
            if (FILLED_ORDER_STATUSES.includes(order.status)) {
                log$g(`Order ${orderId} filled after ${elapsed}ms`, {
                    type: 'info',
                    metadata: { orderId, elapsed, status: order.status },
                });
                return {
                    filled: true,
                    order,
                    elapsedMs: elapsed,
                };
            }
            // Check if terminal but not filled
            if (TERMINAL_ORDER_STATUSES.includes(order.status)) {
                log$g(`Order ${orderId} reached terminal state ${order.status} after ${elapsed}ms`, {
                    type: 'info',
                    metadata: { orderId, elapsed, status: order.status },
                });
                return {
                    filled: false,
                    order,
                    elapsedMs: elapsed,
                };
            }
            // Wait before next poll
            await delay(pollIntervalMs);
        }
    }
    catch (error) {
        log$g(`Error waiting for order fill: ${error.message}`, {
            type: 'error',
            metadata: { orderId, error: error.message },
        });
        throw error;
    }
}
/**
 * Check if an order can still be filled
 *
 * @param order - AlpacaOrder to check
 * @returns True if the order can potentially still be filled
 *
 * @example
 * ```typescript
 * const order = await getOrder(client, orderId);
 * if (isOrderFillable(order)) {
 *   console.log('Order is still active and may be filled');
 * } else {
 *   console.log('Order cannot be filled anymore');
 * }
 * ```
 */
function isOrderFillable(order) {
    return FILLABLE_ORDER_STATUSES.includes(order.status);
}
/**
 * Check if an order has been filled
 *
 * @param order - AlpacaOrder to check
 * @returns True if the order has been filled
 */
function isOrderFilled(order) {
    return FILLED_ORDER_STATUSES.includes(order.status);
}
/**
 * Check if an order is in a terminal state
 *
 * @param order - AlpacaOrder to check
 * @returns True if the order is in a terminal state (no longer active)
 */
function isOrderTerminal$1(order) {
    return TERMINAL_ORDER_STATUSES.includes(order.status);
}
/**
 * Check if an order is open (active, waiting to be filled)
 *
 * @param order - AlpacaOrder to check
 * @returns True if the order is open
 */
function isOrderOpen(order) {
    return OPEN_ORDER_STATUSES.includes(order.status);
}
/**
 * Calculate the total value of an order
 * For filled orders, uses the filled quantity and average price.
 * For unfilled orders, uses the order quantity and limit/stop price.
 *
 * @param order - AlpacaOrder to calculate value for
 * @returns Total order value, or null if cannot be calculated
 *
 * @example
 * ```typescript
 * const order = await getOrder(client, orderId);
 * const value = calculateOrderValue(order);
 * if (value !== null) {
 *   console.log(`Order value: $${value.toFixed(2)}`);
 * }
 * ```
 */
function calculateOrderValue(order) {
    // For filled orders, use filled quantity and average price
    if (isOrderFilled(order)) {
        const filledQty = parseFloat(order.filled_qty);
        const avgPrice = order.filled_avg_price ? parseFloat(order.filled_avg_price) : null;
        if (avgPrice !== null && !isNaN(filledQty) && !isNaN(avgPrice)) {
            return filledQty * avgPrice;
        }
    }
    // For notional orders
    if (order.notional) {
        const notionalValue = parseFloat(order.notional);
        if (!isNaN(notionalValue)) {
            return notionalValue;
        }
    }
    // For limit orders, use limit price
    if (order.limit_price && order.qty) {
        const qty = parseFloat(order.qty);
        const limitPrice = parseFloat(order.limit_price);
        if (!isNaN(qty) && !isNaN(limitPrice)) {
            return qty * limitPrice;
        }
    }
    // For stop orders, use stop price
    if (order.stop_price && order.qty) {
        const qty = parseFloat(order.qty);
        const stopPrice = parseFloat(order.stop_price);
        if (!isNaN(qty) && !isNaN(stopPrice)) {
            return qty * stopPrice;
        }
    }
    // Cannot calculate value (e.g., market orders without fill info)
    return null;
}
/**
 * Format an order for logging or display
 *
 * @param order - AlpacaOrder to format
 * @returns OrderSummary with formatted fields
 *
 * @example
 * ```typescript
 * const order = await getOrder(client, orderId);
 * const summary = formatOrderSummary(order);
 * console.log(`${summary.side.toUpperCase()} ${summary.qty} ${summary.symbol} @ ${summary.avgFillPrice || summary.limitPrice || 'MARKET'}`);
 * ```
 */
function formatOrderSummary(order) {
    return {
        id: order.id,
        symbol: order.symbol,
        side: order.side,
        type: order.type,
        status: order.status,
        qty: order.qty || '0',
        filledQty: order.filled_qty || '0',
        limitPrice: order.limit_price,
        stopPrice: order.stop_price,
        avgFillPrice: order.filled_avg_price,
        createdAt: order.created_at,
        filledAt: order.filled_at,
        timeInForce: order.time_in_force,
        assetClass: order.asset_class,
    };
}
/**
 * Format order summary as a single-line string for logging
 *
 * @param order - AlpacaOrder to format
 * @returns Formatted string for logging
 *
 * @example
 * ```typescript
 * const order = await getOrder(client, orderId);
 * console.log(formatOrderForLog(order));
 * // Output: "BUY 100 AAPL LIMIT @ $150.00 [filled] - filled 100 @ $149.95"
 * ```
 */
function formatOrderForLog(order) {
    const side = order.side.toUpperCase();
    const qty = order.qty || order.notional || '?';
    const qtyLabel = order.notional ? `$${order.notional}` : qty;
    const type = order.type.toUpperCase();
    let priceInfo = '';
    if (order.limit_price) {
        priceInfo = ` @ $${order.limit_price}`;
    }
    else if (order.stop_price) {
        priceInfo = ` stop @ $${order.stop_price}`;
    }
    else if (order.trail_percent) {
        priceInfo = ` trail ${order.trail_percent}%`;
    }
    let fillInfo = '';
    if (order.filled_qty && parseFloat(order.filled_qty) > 0) {
        fillInfo = ` - filled ${order.filled_qty}`;
        if (order.filled_avg_price) {
            fillInfo += ` @ $${order.filled_avg_price}`;
        }
    }
    return `${side} ${qtyLabel} ${order.symbol} ${type}${priceInfo} [${order.status}]${fillInfo}`;
}
/**
 * Round prices correctly for Alpaca API
 * Uses 2 decimal places for prices >= $1
 * Uses 4 decimal places for prices < $1 (penny stocks, crypto)
 *
 * @param price - Price to round
 * @returns Formatted price string
 *
 * @example
 * ```typescript
 * roundPriceForAlpaca(150.12345) // "150.12"
 * roundPriceForAlpaca(0.12345)   // "0.1235"
 * roundPriceForAlpaca(0.00123)   // "0.0012"
 * ```
 */
function roundPriceForAlpaca$3(price) {
    if (price >= 1) {
        return price.toFixed(2);
    }
    return price.toFixed(4);
}
/**
 * Round price as a number for calculations
 *
 * @param price - Price to round
 * @returns Rounded price as number
 */
function roundPriceForAlpacaNumber(price) {
    if (price >= 1) {
        return Math.round(price * 100) / 100;
    }
    return Math.round(price * 10000) / 10000;
}
/**
 * Get orders grouped by symbol
 *
 * @param orders - Array of orders to group
 * @returns Map of symbol to orders
 *
 * @example
 * ```typescript
 * const orders = await getAllOrders(client, { fetchAll: true });
 * const bySymbol = groupOrdersBySymbol(orders);
 *
 * for (const [symbol, symbolOrders] of bySymbol) {
 *   console.log(`${symbol}: ${symbolOrders.length} orders`);
 * }
 * ```
 */
function groupOrdersBySymbol(orders) {
    const grouped = new Map();
    for (const order of orders) {
        const existing = grouped.get(order.symbol) || [];
        existing.push(order);
        grouped.set(order.symbol, existing);
    }
    return grouped;
}
/**
 * Get orders grouped by status
 *
 * @param orders - Array of orders to group
 * @returns Map of status to orders
 */
function groupOrdersByStatus(orders) {
    const grouped = new Map();
    for (const order of orders) {
        const existing = grouped.get(order.status) || [];
        existing.push(order);
        grouped.set(order.status, existing);
    }
    return grouped;
}
/**
 * Calculate total filled value across multiple orders
 *
 * @param orders - Array of orders
 * @returns Total filled value
 */
function calculateTotalFilledValue(orders) {
    let total = 0;
    for (const order of orders) {
        if (isOrderFilled(order)) {
            const value = calculateOrderValue(order);
            if (value !== null) {
                total += value;
            }
        }
    }
    return total;
}
/**
 * Filter orders by date range
 *
 * @param orders - Array of orders to filter
 * @param startDate - Start of date range (inclusive)
 * @param endDate - End of date range (inclusive)
 * @returns Filtered orders
 */
function filterOrdersByDateRange(orders, startDate, endDate) {
    const startMs = startDate.getTime();
    const endMs = endDate.getTime();
    return orders.filter((order) => {
        const orderDate = new Date(order.created_at).getTime();
        return orderDate >= startMs && orderDate <= endMs;
    });
}
/**
 * Sort orders by created date
 *
 * @param orders - Array of orders to sort
 * @param direction - Sort direction ('asc' or 'desc')
 * @returns Sorted orders (new array)
 */
function sortOrdersByDate(orders, direction = 'desc') {
    const sorted = [...orders];
    sorted.sort((a, b) => {
        const dateA = new Date(a.created_at).getTime();
        const dateB = new Date(b.created_at).getTime();
        return direction === 'asc' ? dateA - dateB : dateB - dateA;
    });
    return sorted;
}
/**
 * Default export containing all order utility functions
 */
var orderUtils = {
    // Query functions
    getOrdersBySymbol,
    getOpenOrders: getOpenOrders$1,
    getFilledOrders,
    getOrderHistory,
    getAllOrders,
    waitForOrderFill,
    // Status check functions
    isOrderFillable,
    isOrderFilled,
    isOrderTerminal: isOrderTerminal$1,
    isOrderOpen,
    // Value calculation
    calculateOrderValue,
    calculateTotalFilledValue,
    // Formatting
    formatOrderSummary,
    formatOrderForLog,
    roundPriceForAlpaca: roundPriceForAlpaca$3,
    roundPriceForAlpacaNumber,
    // Grouping and filtering
    groupOrdersBySymbol,
    groupOrdersByStatus,
    filterOrdersByDateRange,
    sortOrdersByDate,
};

var orderUtils$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    calculateOrderValue: calculateOrderValue,
    calculateTotalFilledValue: calculateTotalFilledValue,
    default: orderUtils,
    filterOrdersByDateRange: filterOrdersByDateRange,
    formatOrderForLog: formatOrderForLog,
    formatOrderSummary: formatOrderSummary,
    getAllOrders: getAllOrders,
    getFilledOrders: getFilledOrders,
    getOpenOrders: getOpenOrders$1,
    getOrderHistory: getOrderHistory,
    getOrdersBySymbol: getOrdersBySymbol,
    groupOrdersByStatus: groupOrdersByStatus,
    groupOrdersBySymbol: groupOrdersBySymbol,
    isOrderFillable: isOrderFillable,
    isOrderFilled: isOrderFilled,
    isOrderOpen: isOrderOpen,
    isOrderTerminal: isOrderTerminal$1,
    roundPriceForAlpaca: roundPriceForAlpaca$3,
    roundPriceForAlpacaNumber: roundPriceForAlpacaNumber,
    sortOrdersByDate: sortOrdersByDate,
    waitForOrderFill: waitForOrderFill
});

const LOG_SOURCE$7 = 'TrailingStops';
/**
 * Internal logging helper with consistent source
 */
const log$f = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: LOG_SOURCE$7 });
};
/**
 * Validation error for trailing stop parameters
 */
class TrailingStopValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'TrailingStopValidationError';
    }
}
/**
 * Validates trailing stop parameters
 * @throws {TrailingStopValidationError} If validation fails
 */
function validateTrailingStopParams(params) {
    // Must have either trailPercent or trailPrice, not both
    if (params.trailPercent === undefined && params.trailPrice === undefined) {
        throw new TrailingStopValidationError('Must specify either trailPercent or trailPrice');
    }
    if (params.trailPercent !== undefined && params.trailPrice !== undefined) {
        throw new TrailingStopValidationError('Cannot specify both trailPercent and trailPrice');
    }
    // Validate trailPercent range
    if (params.trailPercent !== undefined) {
        if (params.trailPercent <= 0) {
            throw new TrailingStopValidationError('trailPercent must be greater than 0');
        }
        if (params.trailPercent > 100) {
            throw new TrailingStopValidationError('trailPercent cannot exceed 100');
        }
    }
    // Validate trailPrice
    if (params.trailPrice !== undefined) {
        if (params.trailPrice <= 0) {
            throw new TrailingStopValidationError('trailPrice must be greater than 0');
        }
    }
    // Validate quantity
    if (params.qty <= 0) {
        throw new TrailingStopValidationError('qty must be greater than 0');
    }
    // Validate symbol
    if (!params.symbol || params.symbol.trim() === '') {
        throw new TrailingStopValidationError('symbol is required');
    }
}
/**
 * Create a native trailing stop order
 *
 * The trailing stop automatically adjusts based on price movement:
 * - For SELL: Stop rises as price rises, locks in when price falls
 * - For BUY: Stop falls as price falls, triggers when price rises
 *
 * Must specify either trailPercent OR trailPrice (not both)
 *
 * @param client - AlpacaClient instance
 * @param params - Trailing stop parameters
 * @returns The created order
 * @throws {TrailingStopValidationError} If parameters are invalid
 * @throws {Error} If order creation fails
 *
 * @example
 * ```typescript
 * // Trail by 2% on a sell (closing long position)
 * await createTrailingStop(client, {
 *   symbol: 'AAPL',
 *   qty: 100,
 *   side: 'sell',
 *   trailPercent: 2.0,
 * });
 *
 * // Trail by $5 on a sell
 * await createTrailingStop(client, {
 *   symbol: 'AAPL',
 *   qty: 100,
 *   side: 'sell',
 *   trailPrice: 5.00,
 * });
 * ```
 */
async function createTrailingStop(client, params) {
    // Validate parameters
    validateTrailingStopParams(params);
    const sdk = client.getSDK();
    const trailDescription = params.trailPercent
        ? `${params.trailPercent}%`
        : `$${params.trailPrice?.toFixed(2)}`;
    log$f(`Creating trailing stop: ${params.side} ${params.qty} ${params.symbol} (trail: ${trailDescription})`, {
        type: 'info',
    });
    try {
        const orderParams = {
            symbol: params.symbol,
            qty: params.qty,
            side: params.side,
            type: 'trailing_stop',
            time_in_force: params.timeInForce || 'gtc',
        };
        if (params.trailPercent !== undefined) {
            orderParams.trail_percent = params.trailPercent.toString();
        }
        else if (params.trailPrice !== undefined) {
            orderParams.trail_price = params.trailPrice.toString();
        }
        if (params.extendedHours) {
            orderParams.extended_hours = true;
        }
        if (params.clientOrderId) {
            orderParams.client_order_id = params.clientOrderId;
        }
        const order = await sdk.createOrder(orderParams);
        log$f(`Trailing stop created: orderId=${order.id}, HWM=${order.hwm || 'pending'}, status=${order.status}`, { type: 'info' });
        return order;
    }
    catch (error) {
        const err = error;
        log$f(`Trailing stop creation failed for ${params.symbol}: ${err.message}`, { type: 'error' });
        throw new Error(`Failed to create trailing stop for ${params.symbol}: ${err.message}`);
    }
}
/**
 * Update an existing trailing stop order
 *
 * You can update the trail_percent or trail_price of an existing order.
 * Note: Alpaca uses 'trail' parameter for replacements (works for both percent and price).
 *
 * @param client - AlpacaClient instance
 * @param orderId - The ID of the order to update
 * @param updates - New trail parameters (specify one of trailPercent or trailPrice)
 * @returns The updated order
 * @throws {Error} If no update parameters provided or update fails
 *
 * @example
 * ```typescript
 * // Tighten trailing stop to 1.5%
 * await updateTrailingStop(client, 'order-id-123', { trailPercent: 1.5 });
 *
 * // Change to $3 trail
 * await updateTrailingStop(client, 'order-id-123', { trailPrice: 3.00 });
 * ```
 */
async function updateTrailingStop(client, orderId, updates) {
    // Validate that at least one update is provided
    if (updates.trailPercent === undefined && updates.trailPrice === undefined) {
        throw new Error('Must specify either trailPercent or trailPrice for update');
    }
    if (updates.trailPercent !== undefined && updates.trailPrice !== undefined) {
        throw new Error('Cannot specify both trailPercent and trailPrice for update');
    }
    // Validate values
    if (updates.trailPercent !== undefined && updates.trailPercent <= 0) {
        throw new Error('trailPercent must be greater than 0');
    }
    if (updates.trailPrice !== undefined && updates.trailPrice <= 0) {
        throw new Error('trailPrice must be greater than 0');
    }
    const sdk = client.getSDK();
    const updateDescription = updates.trailPercent
        ? `${updates.trailPercent}%`
        : `$${updates.trailPrice?.toFixed(2)}`;
    log$f(`Updating trailing stop ${orderId} to trail: ${updateDescription}`, { type: 'info' });
    try {
        const replaceParams = {};
        // Alpaca's replaceOrder uses 'trail' for both percent and price updates
        if (updates.trailPercent !== undefined) {
            replaceParams.trail = updates.trailPercent.toString();
        }
        else if (updates.trailPrice !== undefined) {
            replaceParams.trail = updates.trailPrice.toString();
        }
        const order = await sdk.replaceOrder(orderId, replaceParams);
        log$f(`Trailing stop updated: orderId=${order.id}, new replacement created`, { type: 'info' });
        return order;
    }
    catch (error) {
        const err = error;
        log$f(`Trailing stop update failed for ${orderId}: ${err.message}`, { type: 'error' });
        throw new Error(`Failed to update trailing stop ${orderId}: ${err.message}`);
    }
}
/**
 * Get the current high water mark (HWM) for a trailing stop
 *
 * The HWM is the highest price seen since order placement (for sell stops)
 * or the lowest price (for buy stops). The current stop price is calculated
 * based on the HWM and the trail amount.
 *
 * @param client - AlpacaClient instance
 * @param orderId - The ID of the trailing stop order
 * @returns Object containing HWM and current stop price (null if not yet established)
 * @throws {Error} If order retrieval fails
 *
 * @example
 * ```typescript
 * const { hwm, currentStop } = await getTrailingStopHWM(client, 'order-id-123');
 * console.log(`High water mark: $${hwm}, Current stop: $${currentStop}`);
 * ```
 */
async function getTrailingStopHWM(client, orderId) {
    const sdk = client.getSDK();
    try {
        const order = await sdk.getOrder(orderId);
        // Validate this is actually a trailing stop order
        if (order.type !== 'trailing_stop') {
            log$f(`Order ${orderId} is not a trailing stop order (type: ${order.type})`, { type: 'warn' });
        }
        const result = {
            hwm: order.hwm ? parseFloat(order.hwm) : null,
            currentStop: order.stop_price ? parseFloat(order.stop_price) : null,
        };
        log$f(`Retrieved HWM for ${orderId}: HWM=${result.hwm ?? 'N/A'}, currentStop=${result.currentStop ?? 'N/A'}`, { type: 'debug' });
        return result;
    }
    catch (error) {
        const err = error;
        log$f(`Failed to get trailing stop HWM for ${orderId}: ${err.message}`, { type: 'error' });
        throw new Error(`Failed to get trailing stop HWM for ${orderId}: ${err.message}`);
    }
}
/**
 * Cancel a trailing stop order
 *
 * @param client - AlpacaClient instance
 * @param orderId - The ID of the trailing stop order to cancel
 * @throws {Error} If cancellation fails
 *
 * @example
 * ```typescript
 * await cancelTrailingStop(client, 'order-id-123');
 * ```
 */
async function cancelTrailingStop(client, orderId) {
    const sdk = client.getSDK();
    log$f(`Canceling trailing stop order: ${orderId}`, { type: 'info' });
    try {
        await sdk.cancelOrder(orderId);
        log$f(`Trailing stop order canceled: ${orderId}`, { type: 'info' });
    }
    catch (error) {
        const err = error;
        // Check if the order was already filled or canceled
        if (err.message.includes('order is not cancelable')) {
            log$f(`Trailing stop ${orderId} is not cancelable (may already be filled or canceled)`, {
                type: 'warn',
            });
            throw new Error(`Trailing stop ${orderId} is not cancelable: order may already be filled or canceled`);
        }
        log$f(`Failed to cancel trailing stop ${orderId}: ${err.message}`, { type: 'error' });
        throw new Error(`Failed to cancel trailing stop ${orderId}: ${err.message}`);
    }
}
/**
 * Create trailing stops for all positions in a portfolio
 *
 * This function creates trailing stop orders for all long positions in the portfolio,
 * which is useful for applying blanket downside protection. Short positions are skipped.
 *
 * @param client - AlpacaClient instance
 * @param params - Configuration for portfolio-wide trailing stops
 * @returns Map of symbol to created order (symbols that failed are not included)
 *
 * @example
 * ```typescript
 * // Apply 3% trailing stops to all positions except TSLA and NVDA
 * const orders = await createPortfolioTrailingStops(client, {
 *   trailPercent: 3.0,
 *   excludeSymbols: ['TSLA', 'NVDA'],
 * });
 *
 * console.log(`Created ${orders.size} trailing stops`);
 * for (const [symbol, order] of orders) {
 *   console.log(`${symbol}: ${order.id}`);
 * }
 * ```
 */
async function createPortfolioTrailingStops(client, params) {
    // Validate trail percent
    if (params.trailPercent <= 0) {
        throw new Error('trailPercent must be greater than 0');
    }
    if (params.trailPercent > 100) {
        throw new Error('trailPercent cannot exceed 100');
    }
    const sdk = client.getSDK();
    const results = new Map();
    const excludeSet = new Set(params.excludeSymbols?.map((s) => s.toUpperCase()) || []);
    log$f(`Creating portfolio trailing stops at ${params.trailPercent}%`, { type: 'info' });
    try {
        const positions = await sdk.getPositions();
        if (positions.length === 0) {
            log$f('No positions found in portfolio', { type: 'info' });
            return results;
        }
        log$f(`Found ${positions.length} positions, checking for eligible trailing stops`, { type: 'debug' });
        const errors = [];
        for (const position of positions) {
            const symbol = position.symbol.toUpperCase();
            // Skip excluded symbols
            if (excludeSet.has(symbol)) {
                log$f(`Skipping ${symbol} (excluded)`, { type: 'debug' });
                continue;
            }
            // Only create trailing stops for long positions
            const qty = parseFloat(position.qty);
            if (qty <= 0) {
                log$f(`Skipping ${symbol} (not a long position, qty: ${qty})`, { type: 'debug' });
                continue;
            }
            try {
                const order = await createTrailingStop(client, {
                    symbol,
                    qty: Math.abs(qty),
                    side: 'sell',
                    trailPercent: params.trailPercent,
                    timeInForce: params.timeInForce || 'gtc',
                });
                results.set(symbol, order);
            }
            catch (err) {
                const errorMessage = err.message;
                errors.push({ symbol, error: errorMessage });
                log$f(`Failed to create trailing stop for ${symbol}: ${errorMessage}`, { type: 'error' });
            }
        }
        // Log summary
        const successCount = results.size;
        const failureCount = errors.length;
        const skippedCount = positions.length - successCount - failureCount;
        log$f(`Portfolio trailing stops complete: ${successCount} created, ${failureCount} failed, ${skippedCount} skipped`, { type: 'info' });
        if (errors.length > 0) {
            log$f(`Failed symbols: ${errors.map((e) => `${e.symbol} (${e.error})`).join(', ')}`, {
                type: 'warn',
            });
        }
        return results;
    }
    catch (error) {
        const err = error;
        log$f(`Failed to create portfolio trailing stops: ${err.message}`, { type: 'error' });
        throw new Error(`Failed to create portfolio trailing stops: ${err.message}`);
    }
}
/**
 * Get all open trailing stop orders
 *
 * @param client - AlpacaClient instance
 * @param symbol - Optional symbol to filter by
 * @returns Array of open trailing stop orders
 *
 * @example
 * ```typescript
 * // Get all trailing stops
 * const allStops = await getOpenTrailingStops(client);
 *
 * // Get trailing stops for specific symbol
 * const appleStops = await getOpenTrailingStops(client, 'AAPL');
 * ```
 */
async function getOpenTrailingStops(client, symbol) {
    const sdk = client.getSDK();
    try {
        const queryParams = {
            status: 'open',
        };
        if (symbol) {
            queryParams.symbols = symbol.toUpperCase();
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const orders = (await sdk.getOrders(queryParams));
        // Filter to only trailing stop orders
        const trailingStops = orders.filter((order) => order.type === 'trailing_stop');
        log$f(`Found ${trailingStops.length} open trailing stop orders${symbol ? ` for ${symbol}` : ''}`, {
            type: 'debug',
        });
        return trailingStops;
    }
    catch (error) {
        const err = error;
        log$f(`Failed to get open trailing stops: ${err.message}`, { type: 'error' });
        throw new Error(`Failed to get open trailing stops: ${err.message}`);
    }
}
/**
 * Check if a symbol has an active trailing stop order
 *
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol to check
 * @returns True if an active trailing stop exists for the symbol
 *
 * @example
 * ```typescript
 * if (await hasActiveTrailingStop(client, 'AAPL')) {
 *   console.log('AAPL already has a trailing stop');
 * }
 * ```
 */
async function hasActiveTrailingStop(client, symbol) {
    const trailingStops = await getOpenTrailingStops(client, symbol);
    return trailingStops.length > 0;
}
/**
 * Cancel all trailing stop orders for a specific symbol
 *
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @returns Number of orders canceled
 *
 * @example
 * ```typescript
 * const canceled = await cancelTrailingStopsForSymbol(client, 'AAPL');
 * console.log(`Canceled ${canceled} trailing stop orders for AAPL`);
 * ```
 */
async function cancelTrailingStopsForSymbol(client, symbol) {
    const trailingStops = await getOpenTrailingStops(client, symbol);
    if (trailingStops.length === 0) {
        log$f(`No trailing stops to cancel for ${symbol}`, { type: 'debug' });
        return 0;
    }
    let canceledCount = 0;
    const errors = [];
    for (const order of trailingStops) {
        try {
            await cancelTrailingStop(client, order.id);
            canceledCount++;
        }
        catch (err) {
            errors.push(`${order.id}: ${err.message}`);
        }
    }
    if (errors.length > 0) {
        log$f(`Some trailing stops failed to cancel for ${symbol}: ${errors.join(', ')}`, { type: 'warn' });
    }
    log$f(`Canceled ${canceledCount}/${trailingStops.length} trailing stops for ${symbol}`, { type: 'info' });
    return canceledCount;
}
/**
 * Default export object with all trailing stop functions
 */
var trailingStops = {
    createTrailingStop,
    updateTrailingStop,
    getTrailingStopHWM,
    cancelTrailingStop,
    createPortfolioTrailingStops,
    getOpenTrailingStops,
    hasActiveTrailingStop,
    cancelTrailingStopsForSymbol,
};

var trailingStops$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    TrailingStopValidationError: TrailingStopValidationError,
    cancelTrailingStop: cancelTrailingStop,
    cancelTrailingStopsForSymbol: cancelTrailingStopsForSymbol,
    createPortfolioTrailingStops: createPortfolioTrailingStops,
    createTrailingStop: createTrailingStop,
    default: trailingStops,
    getOpenTrailingStops: getOpenTrailingStops,
    getTrailingStopHWM: getTrailingStopHWM,
    hasActiveTrailingStop: hasActiveTrailingStop,
    updateTrailingStop: updateTrailingStop
});

/**
 * OCO (One-Cancels-Other) Order Module
 *
 * OCO orders consist of two orders where filling one automatically cancels the other.
 * This is commonly used for protective strategies where you want to either:
 * - Take profit at a target price, OR
 * - Stop loss at a predetermined level
 *
 * When either order fills, Alpaca automatically cancels the other order.
 *
 * @module oco-orders
 */
const log$e = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: 'OCOOrders' });
};
/**
 * Round a price to the nearest 2 decimal places for Alpaca,
 * or 4 decimal places for prices less than $1
 */
function roundPriceForAlpaca$2(price) {
    return price >= 1 ? Math.round(price * 100) / 100 : Math.round(price * 10000) / 10000;
}
/**
 * Validate OCO order parameters
 * @throws Error if parameters are invalid
 */
function validateOCOParams(params) {
    if (!params.symbol || params.symbol.trim() === '') {
        throw new Error('OCO order requires a valid symbol');
    }
    if (!params.qty || params.qty <= 0) {
        throw new Error('OCO order requires a positive quantity');
    }
    if (!Number.isInteger(params.qty)) {
        throw new Error('OCO order quantity must be a whole number');
    }
    if (!params.takeProfit || !params.takeProfit.limitPrice) {
        throw new Error('OCO order requires takeProfit with limitPrice');
    }
    if (params.takeProfit.limitPrice <= 0) {
        throw new Error('Take profit limitPrice must be positive');
    }
    if (!params.stopLoss || !params.stopLoss.stopPrice) {
        throw new Error('OCO order requires stopLoss with stopPrice');
    }
    if (params.stopLoss.stopPrice <= 0) {
        throw new Error('Stop loss stopPrice must be positive');
    }
    if (params.stopLoss.limitPrice !== undefined && params.stopLoss.limitPrice <= 0) {
        throw new Error('Stop loss limitPrice must be positive if provided');
    }
    // Validate price logic based on side
    if (params.side === 'sell') {
        // For sell orders (closing long): take profit should be higher than stop
        if (params.takeProfit.limitPrice <= params.stopLoss.stopPrice) {
            throw new Error('For sell OCO orders, take profit limit price must be higher than stop loss price');
        }
    }
    else {
        // For buy orders (closing short): take profit should be lower than stop
        if (params.takeProfit.limitPrice >= params.stopLoss.stopPrice) {
            throw new Error('For buy OCO orders, take profit limit price must be lower than stop loss price');
        }
    }
}
/**
 * Create an OCO order (take profit OR stop loss)
 *
 * Use this to protect an existing position with automatic cancellation
 * of the remaining order when one fills.
 *
 * @param client - AlpacaClient instance
 * @param params - OCO order parameters
 * @returns OCO order result with both leg orders
 *
 * @example
 * // Protect 100 shares of AAPL long position
 * // Take profit at $155, stop loss at $145
 * const result = await createOCOOrder(client, {
 *   symbol: 'AAPL',
 *   qty: 100,
 *   side: 'sell',
 *   takeProfit: { limitPrice: 155.00 },
 *   stopLoss: { stopPrice: 145.00 },
 *   timeInForce: 'gtc'
 * });
 *
 * console.log('Take profit order:', result.takeProfitOrder.id);
 * console.log('Stop loss order:', result.stopLossOrder.id);
 *
 * @example
 * // Use stop-limit instead of stop-market for stop loss
 * const result = await createOCOOrder(client, {
 *   symbol: 'TSLA',
 *   qty: 50,
 *   side: 'sell',
 *   takeProfit: { limitPrice: 280.00 },
 *   stopLoss: {
 *     stopPrice: 240.00,
 *     limitPrice: 238.00 // Limit price for stop-limit order
 *   },
 *   timeInForce: 'gtc'
 * });
 *
 * @example
 * // Protect a short position (buying to close)
 * const result = await createOCOOrder(client, {
 *   symbol: 'NVDA',
 *   qty: 25,
 *   side: 'buy', // Buy to close short
 *   takeProfit: { limitPrice: 380.00 }, // Take profit at lower price
 *   stopLoss: { stopPrice: 420.00 }, // Stop loss at higher price
 *   timeInForce: 'gtc'
 * });
 */
async function createOCOOrder(client, params) {
    // Validate parameters
    validateOCOParams(params);
    const { symbol, qty, side, takeProfit, stopLoss, timeInForce = 'gtc' } = params;
    log$e(`Creating OCO order for ${symbol}: ${side} ${qty} shares | ` +
        `Take profit at $${takeProfit.limitPrice.toFixed(2)} | ` +
        `Stop loss at $${stopLoss.stopPrice.toFixed(2)}` +
        (stopLoss.limitPrice ? ` (limit: $${stopLoss.limitPrice.toFixed(2)})` : ''), { symbol, type: 'info' });
    const sdk = client.getSDK();
    try {
        // Build the OCO order request
        const orderRequest = {
            symbol,
            qty: qty.toString(),
            side,
            type: 'limit', // Primary order is the take profit limit
            time_in_force: timeInForce,
            order_class: 'oco',
            limit_price: roundPriceForAlpaca$2(takeProfit.limitPrice).toString(),
            stop_loss: {
                stop_price: roundPriceForAlpaca$2(stopLoss.stopPrice).toString(),
            },
        };
        // Add stop-limit price if provided
        if (stopLoss.limitPrice !== undefined) {
            orderRequest.stop_loss.limit_price = roundPriceForAlpaca$2(stopLoss.limitPrice).toString();
        }
        log$e(`Submitting OCO order request: ${JSON.stringify(orderRequest)}`, { symbol, type: 'debug' });
        // Submit the order
        const order = await sdk.createOrder(orderRequest);
        // Extract leg orders from the response
        const legs = order.legs || [];
        if (legs.length < 2) {
            log$e(`OCO order created but legs not found in response. Order ID: ${order.id}`, { symbol, type: 'warn' });
        }
        // Identify take profit and stop loss orders from legs
        // Take profit is the limit order, stop loss is the stop/stop_limit order
        const takeProfitOrder = legs.find((leg) => leg.type === 'limit') || order;
        const stopLossOrder = legs.find((leg) => leg.type === 'stop' || leg.type === 'stop_limit') || legs.find((leg) => leg !== takeProfitOrder) || order;
        log$e(`OCO order created successfully | Parent ID: ${order.id} | ` +
            `Take profit ID: ${takeProfitOrder.id} | Stop loss ID: ${stopLossOrder.id}`, { symbol, type: 'info' });
        return {
            takeProfitOrder,
            stopLossOrder,
            allOrders: legs.length > 0 ? legs : [order],
            parentOrderId: order.id,
        };
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$e(`Failed to create OCO order for ${symbol}: ${errorMessage}`, { symbol, type: 'error' });
        throw error;
    }
}
/**
 * Cancel an OCO order group by parent order ID
 * This will cancel both the take profit and stop loss orders
 *
 * @param client - AlpacaClient instance
 * @param parentOrderId - The parent order ID from OCOOrderResult
 *
 * @example
 * const result = await createOCOOrder(client, params);
 * // Later...
 * await cancelOCOOrder(client, result.parentOrderId);
 */
async function cancelOCOOrder(client, parentOrderId) {
    log$e(`Canceling OCO order group: ${parentOrderId}`, { type: 'info' });
    const sdk = client.getSDK();
    try {
        await sdk.cancelOrder(parentOrderId);
        log$e(`OCO order group canceled successfully: ${parentOrderId}`, { type: 'info' });
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$e(`Failed to cancel OCO order ${parentOrderId}: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Get the status of an OCO order group
 *
 * @param client - AlpacaClient instance
 * @param parentOrderId - The parent order ID from OCOOrderResult
 * @returns The parent order with leg status information
 *
 * @example
 * const result = await createOCOOrder(client, params);
 * const status = await getOCOOrderStatus(client, result.parentOrderId);
 * console.log('Order status:', status.status);
 * status.legs?.forEach(leg => {
 *   console.log(`Leg ${leg.id}: ${leg.status}`);
 * });
 */
async function getOCOOrderStatus(client, parentOrderId) {
    log$e(`Getting OCO order status: ${parentOrderId}`, { type: 'debug' });
    const sdk = client.getSDK();
    try {
        const order = await sdk.getOrder(parentOrderId);
        log$e(`OCO order ${parentOrderId} status: ${order.status} | ` +
            `Legs: ${order.legs?.length || 0}`, { type: 'debug' });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$e(`Failed to get OCO order status ${parentOrderId}: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Helper to create OCO order for protecting a long position
 * Convenience wrapper with sensible defaults for long protection
 *
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param qty - Number of shares to protect
 * @param takeProfitPrice - Price to take profit
 * @param stopLossPrice - Price to stop loss
 * @param stopLimitPrice - Optional limit price for stop-limit order
 *
 * @example
 * // Simple long protection
 * const result = await protectLongPosition(
 *   client,
 *   'AAPL',
 *   100,
 *   155.00, // Take profit
 *   145.00  // Stop loss
 * );
 */
async function protectLongPosition(client, symbol, qty, takeProfitPrice, stopLossPrice, stopLimitPrice) {
    return createOCOOrder(client, {
        symbol,
        qty,
        side: 'sell',
        takeProfit: { limitPrice: takeProfitPrice },
        stopLoss: {
            stopPrice: stopLossPrice,
            limitPrice: stopLimitPrice,
        },
        timeInForce: 'gtc',
    });
}
/**
 * Helper to create OCO order for protecting a short position
 * Convenience wrapper with sensible defaults for short protection
 *
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param qty - Number of shares to cover
 * @param takeProfitPrice - Price to take profit (lower than current)
 * @param stopLossPrice - Price to stop loss (higher than current)
 * @param stopLimitPrice - Optional limit price for stop-limit order
 *
 * @example
 * // Simple short protection
 * const result = await protectShortPosition(
 *   client,
 *   'TSLA',
 *   50,
 *   200.00, // Take profit at lower price
 *   260.00  // Stop loss at higher price
 * );
 */
async function protectShortPosition(client, symbol, qty, takeProfitPrice, stopLossPrice, stopLimitPrice) {
    return createOCOOrder(client, {
        symbol,
        qty,
        side: 'buy',
        takeProfit: { limitPrice: takeProfitPrice },
        stopLoss: {
            stopPrice: stopLossPrice,
            limitPrice: stopLimitPrice,
        },
        timeInForce: 'gtc',
    });
}
var ocoOrders = {
    createOCOOrder,
    cancelOCOOrder,
    getOCOOrderStatus,
    protectLongPosition,
    protectShortPosition,
};

var ocoOrders$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    cancelOCOOrder: cancelOCOOrder,
    createOCOOrder: createOCOOrder,
    default: ocoOrders,
    getOCOOrderStatus: getOCOOrderStatus,
    protectLongPosition: protectLongPosition,
    protectShortPosition: protectShortPosition
});

/**
 * OTO (One-Triggers-Other) Order Module
 *
 * OTO orders consist of a primary order and a dependent order. When the primary
 * order fills, it automatically triggers the dependent order. This is commonly
 * used for:
 * - Entry orders that automatically set up a stop loss
 * - Entry orders that automatically set up a take profit
 * - Automatic position management after entry
 *
 * Unlike bracket orders, OTO only has one dependent order (not two).
 *
 * @module oto-orders
 */
const log$d = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: 'OTOOrders' });
};
/**
 * Round a price to the nearest 2 decimal places for Alpaca,
 * or 4 decimal places for prices less than $1
 */
function roundPriceForAlpaca$1(price) {
    return price >= 1 ? Math.round(price * 100) / 100 : Math.round(price * 10000) / 10000;
}
/**
 * Validate OTO order parameters
 * @throws Error if parameters are invalid
 */
function validateOTOParams(params) {
    if (!params.symbol || params.symbol.trim() === '') {
        throw new Error('OTO order requires a valid symbol');
    }
    if (!params.qty || params.qty <= 0) {
        throw new Error('OTO order requires a positive quantity');
    }
    if (!Number.isInteger(params.qty)) {
        throw new Error('OTO order quantity must be a whole number');
    }
    // Validate primary order type requirements
    if (params.type === 'limit' || params.type === 'stop_limit') {
        if (!params.limitPrice || params.limitPrice <= 0) {
            throw new Error(`Primary ${params.type} order requires a positive limitPrice`);
        }
    }
    if (params.type === 'stop' || params.type === 'stop_limit') {
        if (!params.stopPrice || params.stopPrice <= 0) {
            throw new Error(`Primary ${params.type} order requires a positive stopPrice`);
        }
    }
    // Validate dependent order
    if (!params.dependent) {
        throw new Error('OTO order requires a dependent order configuration');
    }
    const { dependent } = params;
    // Validate dependent order type requirements
    if (dependent.type === 'limit' || dependent.type === 'stop_limit') {
        if (!dependent.limitPrice || dependent.limitPrice <= 0) {
            throw new Error(`Dependent ${dependent.type} order requires a positive limitPrice`);
        }
    }
    if (dependent.type === 'stop' || dependent.type === 'stop_limit') {
        if (!dependent.stopPrice || dependent.stopPrice <= 0) {
            throw new Error(`Dependent ${dependent.type} order requires a positive stopPrice`);
        }
    }
    if (dependent.type === 'trailing_stop') {
        if (!dependent.trailPercent && !dependent.trailPrice) {
            throw new Error('Trailing stop requires either trailPercent or trailPrice');
        }
        if (dependent.trailPercent && dependent.trailPrice) {
            throw new Error('Trailing stop cannot have both trailPercent and trailPrice');
        }
        if (dependent.trailPercent && (dependent.trailPercent <= 0 || dependent.trailPercent > 100)) {
            throw new Error('trailPercent must be between 0 and 100');
        }
        if (dependent.trailPrice && dependent.trailPrice <= 0) {
            throw new Error('trailPrice must be positive');
        }
    }
    // Validate logical order of sides for typical use cases
    // Primary buy should typically trigger sell (exit), and vice versa
    if (params.side === dependent.side) {
        log$d(`Warning: Primary and dependent orders have the same side (${params.side}). ` +
            'This is unusual - typically entry and exit are opposite sides.', { symbol: params.symbol, type: 'warn' });
    }
}
/**
 * Create an OTO order (entry triggers exit)
 *
 * Useful for setting up automatic exit orders when an entry fills.
 * The dependent order remains dormant until the primary order fills.
 *
 * @param client - AlpacaClient instance
 * @param params - OTO order parameters
 * @returns OTO order result with primary and dependent orders
 *
 * @example
 * // Buy entry with automatic stop loss
 * const result = await createOTOOrder(client, {
 *   symbol: 'AAPL',
 *   qty: 100,
 *   side: 'buy',
 *   type: 'limit',
 *   limitPrice: 150.00,
 *   dependent: {
 *     side: 'sell',
 *     type: 'stop',
 *     stopPrice: 145.00
 *   },
 *   timeInForce: 'gtc'
 * });
 *
 * @example
 * // Market entry with automatic trailing stop
 * const result = await createOTOOrder(client, {
 *   symbol: 'TSLA',
 *   qty: 50,
 *   side: 'buy',
 *   type: 'market',
 *   dependent: {
 *     side: 'sell',
 *     type: 'trailing_stop',
 *     trailPercent: 3 // 3% trailing stop
 *   }
 * });
 *
 * @example
 * // Limit entry with take profit limit order
 * const result = await createOTOOrder(client, {
 *   symbol: 'NVDA',
 *   qty: 25,
 *   side: 'buy',
 *   type: 'limit',
 *   limitPrice: 400.00,
 *   dependent: {
 *     side: 'sell',
 *     type: 'limit',
 *     limitPrice: 440.00 // Take profit at 10% gain
 *   },
 *   timeInForce: 'gtc'
 * });
 *
 * @example
 * // Short entry with stop-limit protection
 * const result = await createOTOOrder(client, {
 *   symbol: 'GOOGL',
 *   qty: 10,
 *   side: 'sell',
 *   type: 'limit',
 *   limitPrice: 140.00,
 *   dependent: {
 *     side: 'buy',
 *     type: 'stop_limit',
 *     stopPrice: 145.00,
 *     limitPrice: 146.00
 *   },
 *   timeInForce: 'gtc'
 * });
 */
async function createOTOOrder(client, params) {
    // Validate parameters
    validateOTOParams(params);
    const { symbol, qty, side, type, limitPrice, stopPrice, dependent, timeInForce = 'day', extendedHours, clientOrderId, } = params;
    // Build log message
    let primaryDescription = `${type} ${side} ${qty} shares`;
    if (limitPrice)
        primaryDescription += ` at $${limitPrice.toFixed(2)}`;
    if (stopPrice)
        primaryDescription += ` stop $${stopPrice.toFixed(2)}`;
    let dependentDescription = `${dependent.type} ${dependent.side}`;
    if (dependent.limitPrice)
        dependentDescription += ` at $${dependent.limitPrice.toFixed(2)}`;
    if (dependent.stopPrice)
        dependentDescription += ` stop $${dependent.stopPrice.toFixed(2)}`;
    if (dependent.trailPercent)
        dependentDescription += ` trail ${dependent.trailPercent}%`;
    if (dependent.trailPrice)
        dependentDescription += ` trail $${dependent.trailPrice.toFixed(2)}`;
    log$d(`Creating OTO order for ${symbol}: Primary [${primaryDescription}] -> Dependent [${dependentDescription}]`, { symbol, type: 'info' });
    const sdk = client.getSDK();
    try {
        // Build the OTO order request
        const orderRequest = {
            symbol,
            qty: qty.toString(),
            side,
            type,
            time_in_force: timeInForce,
            order_class: 'oto',
        };
        // Add primary order prices
        if (limitPrice !== undefined) {
            orderRequest.limit_price = roundPriceForAlpaca$1(limitPrice).toString();
        }
        if (stopPrice !== undefined) {
            orderRequest.stop_price = roundPriceForAlpaca$1(stopPrice).toString();
        }
        // Add extended hours if specified
        if (extendedHours) {
            orderRequest.extended_hours = true;
        }
        // Add client order ID if specified
        if (clientOrderId) {
            orderRequest.client_order_id = clientOrderId;
        }
        // Build dependent order based on type
        // For OTO orders, Alpaca uses take_profit or stop_loss object
        // We need to determine which one based on the dependent order configuration
        if (dependent.type === 'limit') {
            // Take profit order
            orderRequest.take_profit = {
                limit_price: roundPriceForAlpaca$1(dependent.limitPrice).toString(),
            };
        }
        else if (dependent.type === 'stop') {
            // Stop loss order (market)
            orderRequest.stop_loss = {
                stop_price: roundPriceForAlpaca$1(dependent.stopPrice).toString(),
            };
        }
        else if (dependent.type === 'stop_limit') {
            // Stop loss order with limit
            orderRequest.stop_loss = {
                stop_price: roundPriceForAlpaca$1(dependent.stopPrice).toString(),
                limit_price: roundPriceForAlpaca$1(dependent.limitPrice).toString(),
            };
        }
        else if (dependent.type === 'trailing_stop') {
            // Trailing stop order
            orderRequest.stop_loss = {};
            if (dependent.trailPercent !== undefined) {
                orderRequest.stop_loss.trail_percent = dependent.trailPercent.toString();
            }
            if (dependent.trailPrice !== undefined) {
                orderRequest.stop_loss.trail_price = roundPriceForAlpaca$1(dependent.trailPrice).toString();
            }
        }
        log$d(`Submitting OTO order request: ${JSON.stringify(orderRequest)}`, { symbol, type: 'debug' });
        // Submit the order
        const order = await sdk.createOrder(orderRequest);
        // Extract leg orders from the response
        const legs = order.legs || [];
        // The primary order is the parent, dependent is in legs
        const primaryOrder = order;
        const dependentOrder = legs.length > 0 ? legs[0] : null;
        log$d(`OTO order created successfully | Parent ID: ${order.id} | Status: ${order.status}` +
            (dependentOrder ? ` | Dependent ID: ${dependentOrder.id}` : ''), { symbol, type: 'info' });
        return {
            primaryOrder,
            dependentOrder,
            allOrders: [order, ...(dependentOrder ? [dependentOrder] : [])],
            parentOrderId: order.id,
        };
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$d(`Failed to create OTO order for ${symbol}: ${errorMessage}`, { symbol, type: 'error' });
        throw error;
    }
}
/**
 * Cancel an OTO order group by parent order ID
 * This will cancel both the primary order and any pending dependent order
 *
 * @param client - AlpacaClient instance
 * @param parentOrderId - The parent order ID from OTOOrderResult
 *
 * @example
 * const result = await createOTOOrder(client, params);
 * // Later, before primary fills...
 * await cancelOTOOrder(client, result.parentOrderId);
 */
async function cancelOTOOrder(client, parentOrderId) {
    log$d(`Canceling OTO order group: ${parentOrderId}`, { type: 'info' });
    const sdk = client.getSDK();
    try {
        await sdk.cancelOrder(parentOrderId);
        log$d(`OTO order group canceled successfully: ${parentOrderId}`, { type: 'info' });
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$d(`Failed to cancel OTO order ${parentOrderId}: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Get the status of an OTO order group
 *
 * @param client - AlpacaClient instance
 * @param parentOrderId - The parent order ID from OTOOrderResult
 * @returns The parent order with dependent order information
 *
 * @example
 * const result = await createOTOOrder(client, params);
 * const status = await getOTOOrderStatus(client, result.parentOrderId);
 * console.log('Primary status:', status.status);
 * if (status.legs && status.legs[0]) {
 *   console.log('Dependent status:', status.legs[0].status);
 * }
 */
async function getOTOOrderStatus(client, parentOrderId) {
    log$d(`Getting OTO order status: ${parentOrderId}`, { type: 'debug' });
    const sdk = client.getSDK();
    try {
        const order = await sdk.getOrder(parentOrderId);
        log$d(`OTO order ${parentOrderId} status: ${order.status} | ` +
            `Legs: ${order.legs?.length || 0}`, { type: 'debug' });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$d(`Failed to get OTO order status ${parentOrderId}: ${errorMessage}`, { type: 'error' });
        throw error;
    }
}
/**
 * Create a market buy with automatic stop loss
 * Convenience wrapper for common use case
 *
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param qty - Number of shares
 * @param stopLossPrice - Stop loss trigger price
 * @param stopLimitPrice - Optional limit price for stop-limit
 *
 * @example
 * // Buy AAPL with immediate stop loss protection
 * const result = await buyWithStopLoss(client, 'AAPL', 100, 145.00);
 */
async function buyWithStopLoss(client, symbol, qty, stopLossPrice, stopLimitPrice) {
    return createOTOOrder(client, {
        symbol,
        qty,
        side: 'buy',
        type: 'market',
        dependent: {
            side: 'sell',
            type: stopLimitPrice ? 'stop_limit' : 'stop',
            stopPrice: stopLossPrice,
            limitPrice: stopLimitPrice,
        },
        timeInForce: 'day',
    });
}
/**
 * Create a market buy with automatic trailing stop
 * Convenience wrapper for common use case
 *
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param qty - Number of shares
 * @param trailPercent - Trail percentage (e.g., 5 for 5%)
 *
 * @example
 * // Buy TSLA with 3% trailing stop
 * const result = await buyWithTrailingStop(client, 'TSLA', 50, 3);
 */
async function buyWithTrailingStop(client, symbol, qty, trailPercent) {
    return createOTOOrder(client, {
        symbol,
        qty,
        side: 'buy',
        type: 'market',
        dependent: {
            side: 'sell',
            type: 'trailing_stop',
            trailPercent,
        },
        timeInForce: 'day',
    });
}
/**
 * Create a limit buy with automatic take profit
 * Convenience wrapper for limit entry with profit target
 *
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param qty - Number of shares
 * @param entryPrice - Limit price for entry
 * @param takeProfitPrice - Take profit limit price
 *
 * @example
 * // Buy NVDA at $400 with take profit at $440
 * const result = await limitBuyWithTakeProfit(client, 'NVDA', 25, 400.00, 440.00);
 */
async function limitBuyWithTakeProfit(client, symbol, qty, entryPrice, takeProfitPrice) {
    return createOTOOrder(client, {
        symbol,
        qty,
        side: 'buy',
        type: 'limit',
        limitPrice: entryPrice,
        dependent: {
            side: 'sell',
            type: 'limit',
            limitPrice: takeProfitPrice,
        },
        timeInForce: 'gtc',
    });
}
/**
 * Create a short entry with automatic stop loss
 * Convenience wrapper for short selling with protection
 *
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param qty - Number of shares
 * @param entryPrice - Limit price for short entry
 * @param stopLossPrice - Stop loss trigger price (higher than entry)
 *
 * @example
 * // Short GOOGL at $140 with stop at $145
 * const result = await shortWithStopLoss(client, 'GOOGL', 10, 140.00, 145.00);
 */
async function shortWithStopLoss(client, symbol, qty, entryPrice, stopLossPrice) {
    return createOTOOrder(client, {
        symbol,
        qty,
        side: 'sell',
        type: 'limit',
        limitPrice: entryPrice,
        dependent: {
            side: 'buy',
            type: 'stop',
            stopPrice: stopLossPrice,
        },
        timeInForce: 'gtc',
    });
}
/**
 * Create entry with automatic stop loss using percentage
 * Calculates stop price based on entry price and percentage
 *
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param qty - Number of shares
 * @param entryPrice - Limit price for entry (null for market)
 * @param stopLossPercent - Stop loss percentage (e.g., 5 for 5%)
 * @param side - Order side ('buy' or 'sell')
 *
 * @example
 * // Buy AAPL at $150 with 3% stop loss (stop at $145.50)
 * const result = await entryWithPercentStopLoss(client, 'AAPL', 100, 150.00, 3, 'buy');
 */
async function entryWithPercentStopLoss(client, symbol, qty, entryPrice, stopLossPercent, side = 'buy') {
    if (stopLossPercent <= 0 || stopLossPercent >= 100) {
        throw new Error('stopLossPercent must be between 0 and 100');
    }
    // For market orders without entry price, we cannot calculate stop
    if (entryPrice === null) {
        throw new Error('Entry price required to calculate percentage-based stop loss. Use buyWithStopLoss for market orders.');
    }
    // Calculate stop price based on side
    const stopMultiplier = side === 'buy'
        ? (1 - stopLossPercent / 100) // Below entry for longs
        : (1 + stopLossPercent / 100); // Above entry for shorts
    const stopPrice = roundPriceForAlpaca$1(entryPrice * stopMultiplier);
    const exitSide = side === 'buy' ? 'sell' : 'buy';
    return createOTOOrder(client, {
        symbol,
        qty,
        side,
        type: 'limit',
        limitPrice: entryPrice,
        dependent: {
            side: exitSide,
            type: 'stop',
            stopPrice,
        },
        timeInForce: 'gtc',
    });
}
var otoOrders = {
    createOTOOrder,
    cancelOTOOrder,
    getOTOOrderStatus,
    buyWithStopLoss,
    buyWithTrailingStop,
    limitBuyWithTakeProfit,
    shortWithStopLoss,
    entryWithPercentStopLoss,
};

var otoOrders$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    buyWithStopLoss: buyWithStopLoss,
    buyWithTrailingStop: buyWithTrailingStop,
    cancelOTOOrder: cancelOTOOrder,
    createOTOOrder: createOTOOrder,
    default: otoOrders,
    entryWithPercentStopLoss: entryWithPercentStopLoss,
    getOTOOrderStatus: getOTOOrderStatus,
    limitBuyWithTakeProfit: limitBuyWithTakeProfit,
    shortWithStopLoss: shortWithStopLoss
});

const log$c = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: 'AlpacaQuotes' });
};
/**
 * Error thrown when quote operations fail
 */
class QuoteError extends Error {
    code;
    symbol;
    details;
    constructor(message, code, symbol, details) {
        super(message);
        this.code = code;
        this.symbol = symbol;
        this.details = details;
        this.name = 'QuoteError';
    }
}
/**
 * Get latest quote for a single symbol
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol to get quote for
 * @param feed - Optional data feed (sip, iex, delayed_sip)
 * @returns Latest quote for the symbol
 * @throws QuoteError if the request fails
 */
async function getLatestQuote(client, symbol, feed) {
    const normalizedSymbol = symbol.toUpperCase().trim();
    if (!normalizedSymbol) {
        throw new QuoteError('Symbol is required', 'INVALID_SYMBOL');
    }
    log$c(`Fetching latest quote for ${normalizedSymbol}`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const config = client.getConfig();
        const dataFeed = feed || config.dataFeed || 'iex';
        // Use SDK's getLatestQuote method
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const response = await sdk.getLatestQuote(normalizedSymbol, { feed: dataFeed });
        if (!response) {
            throw new QuoteError(`No quote data returned for ${normalizedSymbol}`, 'NO_DATA', normalizedSymbol);
        }
        log$c(`Successfully fetched quote for ${normalizedSymbol}: bid=${response.BidPrice}, ask=${response.AskPrice}`, { type: 'debug' });
        // Map SDK response to our AlpacaQuote type
        return {
            t: response.Timestamp,
            ap: response.AskPrice,
            as: response.AskSize,
            ax: response.AskExchange,
            bp: response.BidPrice,
            bs: response.BidSize,
            bx: response.BidExchange,
            c: response.Conditions || [],
            z: response.Tape || '',
        };
    }
    catch (error) {
        if (error instanceof QuoteError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$c(`Failed to fetch quote for ${normalizedSymbol}: ${errorMessage}`, { type: 'error' });
        throw new QuoteError(`Failed to fetch quote for ${normalizedSymbol}: ${errorMessage}`, 'FETCH_ERROR', normalizedSymbol, error);
    }
}
/**
 * Get latest quotes for multiple symbols
 * @param client - AlpacaClient instance
 * @param symbols - Array of stock symbols
 * @param feed - Optional data feed (sip, iex, delayed_sip)
 * @returns Object containing quotes for all requested symbols
 * @throws QuoteError if the request fails
 */
async function getLatestQuotes(client, symbols, feed) {
    if (!symbols || symbols.length === 0) {
        throw new QuoteError('At least one symbol is required', 'INVALID_SYMBOLS');
    }
    const normalizedSymbols = symbols.map((s) => s.toUpperCase().trim()).filter(Boolean);
    if (normalizedSymbols.length === 0) {
        throw new QuoteError('No valid symbols provided', 'INVALID_SYMBOLS');
    }
    log$c(`Fetching latest quotes for ${normalizedSymbols.length} symbols`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const config = client.getConfig();
        const dataFeed = feed || config.dataFeed || 'iex';
        // Use SDK's getLatestQuotes method
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const response = await sdk.getLatestQuotes(normalizedSymbols, { feed: dataFeed });
        if (!response) {
            throw new QuoteError('No quote data returned', 'NO_DATA');
        }
        // Map SDK response to our LatestQuotesResponse type
        const quotes = {};
        for (const [symbol, quote] of Object.entries(response)) {
            const q = quote;
            quotes[symbol] = {
                t: q.Timestamp,
                ap: q.AskPrice,
                as: q.AskSize,
                ax: q.AskExchange,
                bp: q.BidPrice,
                bs: q.BidSize,
                bx: q.BidExchange,
                c: q.Conditions || [],
                z: q.Tape || '',
            };
        }
        log$c(`Successfully fetched quotes for ${Object.keys(quotes).length} symbols`, { type: 'debug' });
        return {
            quotes,
            currency: 'USD',
        };
    }
    catch (error) {
        if (error instanceof QuoteError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$c(`Failed to fetch quotes: ${errorMessage}`, { type: 'error' });
        throw new QuoteError(`Failed to fetch quotes: ${errorMessage}`, 'FETCH_ERROR', undefined, error);
    }
}
/**
 * Get bid/ask spread for a symbol
 * Useful for evaluating liquidity and trading costs
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @returns Spread information including bid, ask, spread, and percentage
 * @throws QuoteError if the request fails or if prices are invalid
 */
async function getSpread(client, symbol) {
    const quote = await getLatestQuote(client, symbol);
    const bid = quote.bp;
    const ask = quote.ap;
    if (bid <= 0 || ask <= 0) {
        throw new QuoteError(`Invalid quote prices for ${symbol}: bid=${bid}, ask=${ask}`, 'INVALID_PRICES', symbol);
    }
    if (ask < bid) {
        log$c(`Warning: Ask price (${ask}) is less than bid price (${bid}) for ${symbol}`, { type: 'warn' });
    }
    const spread = ask - bid;
    const midPrice = (bid + ask) / 2;
    const spreadPercent = midPrice > 0 ? (spread / midPrice) * 100 : 0;
    log$c(`Spread for ${symbol}: ${spread.toFixed(4)} (${spreadPercent.toFixed(4)}%)`, { type: 'debug' });
    return {
        bid,
        ask,
        spread,
        spreadPercent,
        midPrice,
        bidSize: quote.bs,
        askSize: quote.as,
    };
}
/**
 * Get multiple spreads for an array of symbols
 * @param client - AlpacaClient instance
 * @param symbols - Array of stock symbols
 * @returns Map of symbol to spread information
 */
async function getSpreads(client, symbols) {
    const quotesResponse = await getLatestQuotes(client, symbols);
    const spreads = new Map();
    for (const [symbol, quote] of Object.entries(quotesResponse.quotes)) {
        const bid = quote.bp;
        const ask = quote.ap;
        if (bid > 0 && ask > 0) {
            const spread = ask - bid;
            const midPrice = (bid + ask) / 2;
            const spreadPercent = midPrice > 0 ? (spread / midPrice) * 100 : 0;
            spreads.set(symbol, {
                bid,
                ask,
                spread,
                spreadPercent,
                midPrice,
                bidSize: quote.bs,
                askSize: quote.as,
            });
        }
    }
    return spreads;
}
/**
 * Check if a symbol has good liquidity based on spread
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param maxSpreadPercent - Maximum acceptable spread percentage (default 1%)
 * @returns true if spread is within acceptable range
 */
async function hasGoodLiquidity$1(client, symbol, maxSpreadPercent = 1.0) {
    try {
        const spreadInfo = await getSpread(client, symbol);
        return spreadInfo.spreadPercent <= maxSpreadPercent;
    }
    catch (error) {
        log$c(`Failed to check liquidity for ${symbol}: ${error.message}`, { type: 'warn' });
        return false;
    }
}
var quotes = {
    getLatestQuote,
    getLatestQuotes,
    getSpread,
    getSpreads,
    hasGoodLiquidity: hasGoodLiquidity$1,
};

var quotes$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    QuoteError: QuoteError,
    default: quotes,
    getLatestQuote: getLatestQuote,
    getLatestQuotes: getLatestQuotes,
    getSpread: getSpread,
    getSpreads: getSpreads,
    hasGoodLiquidity: hasGoodLiquidity$1
});

const log$b = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: 'AlpacaBars' });
};
/**
 * Error thrown when bar operations fail
 */
class BarError extends Error {
    code;
    symbol;
    details;
    constructor(message, code, symbol, details) {
        super(message);
        this.code = code;
        this.symbol = symbol;
        this.details = details;
        this.name = 'BarError';
    }
}
/**
 * Convert date to RFC-3339 format string
 */
function toRFC3339$3(date) {
    if (typeof date === 'string') {
        return date;
    }
    return date.toISOString();
}
/**
 * Get historical bars with automatic pagination
 * @param client - AlpacaClient instance
 * @param params - Parameters for fetching bars
 * @returns Map of symbol to array of bars
 */
async function getBars(client, params) {
    const { symbols, timeframe, start, end, limit, adjustment, feed } = params;
    if (!symbols || symbols.length === 0) {
        throw new BarError('At least one symbol is required', 'INVALID_SYMBOLS');
    }
    const normalizedSymbols = symbols.map((s) => s.toUpperCase().trim()).filter(Boolean);
    if (normalizedSymbols.length === 0) {
        throw new BarError('No valid symbols provided', 'INVALID_SYMBOLS');
    }
    log$b(`Fetching bars for ${normalizedSymbols.length} symbols with timeframe ${timeframe}`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const config = client.getConfig();
        const dataFeed = feed || config.dataFeed || 'iex';
        const options = {
            timeframe,
            feed: dataFeed,
        };
        if (start) {
            options.start = toRFC3339$3(start);
        }
        if (end) {
            options.end = toRFC3339$3(end);
        }
        if (limit) {
            options.limit = limit;
        }
        if (adjustment) {
            options.adjustment = adjustment;
        }
        // Use SDK's getBarsV2 method with pagination
        const result = new Map();
        // Initialize empty arrays for each symbol
        for (const symbol of normalizedSymbols) {
            result.set(symbol, []);
        }
        // Fetch bars - the SDK handles pagination internally via async iterator
        const barsIterator = sdk.getBarsV2(normalizedSymbols.join(','), options);
        for await (const bar of barsIterator) {
            const symbol = bar.Symbol;
            const existingBars = result.get(symbol) || [];
            existingBars.push({
                t: bar.Timestamp,
                o: bar.OpenPrice,
                h: bar.HighPrice,
                l: bar.LowPrice,
                c: bar.ClosePrice,
                v: bar.Volume,
                n: bar.TradeCount,
                vw: bar.VWAP,
            });
            result.set(symbol, existingBars);
        }
        const totalBars = Array.from(result.values()).reduce((sum, bars) => sum + bars.length, 0);
        log$b(`Successfully fetched ${totalBars} bars for ${normalizedSymbols.length} symbols`, { type: 'debug' });
        return result;
    }
    catch (error) {
        if (error instanceof BarError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$b(`Failed to fetch bars: ${errorMessage}`, { type: 'error' });
        throw new BarError(`Failed to fetch bars: ${errorMessage}`, 'FETCH_ERROR', undefined, error);
    }
}
/**
 * Get latest bars for symbols
 * @param client - AlpacaClient instance
 * @param symbols - Array of stock symbols
 * @returns Map of symbol to latest bar
 */
async function getLatestBars(client, symbols) {
    if (!symbols || symbols.length === 0) {
        throw new BarError('At least one symbol is required', 'INVALID_SYMBOLS');
    }
    const normalizedSymbols = symbols.map((s) => s.toUpperCase().trim()).filter(Boolean);
    log$b(`Fetching latest bars for ${normalizedSymbols.length} symbols`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const config = client.getConfig();
        const dataFeed = config.dataFeed || 'iex';
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const response = await sdk.getLatestBars(normalizedSymbols, { feed: dataFeed });
        const result = new Map();
        for (const [symbol, bar] of Object.entries(response)) {
            const b = bar;
            result.set(symbol, {
                t: b.Timestamp,
                o: b.OpenPrice,
                h: b.HighPrice,
                l: b.LowPrice,
                c: b.ClosePrice,
                v: b.Volume,
                n: b.TradeCount,
                vw: b.VWAP,
            });
        }
        log$b(`Successfully fetched latest bars for ${result.size} symbols`, { type: 'debug' });
        return result;
    }
    catch (error) {
        if (error instanceof BarError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$b(`Failed to fetch latest bars: ${errorMessage}`, { type: 'error' });
        throw new BarError(`Failed to fetch latest bars: ${errorMessage}`, 'FETCH_ERROR', undefined, error);
    }
}
/**
 * Get daily prices for a symbol
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param days - Number of days of history to fetch
 * @returns Array of daily bars
 */
async function getDailyPrices(client, symbol, days) {
    const normalizedSymbol = symbol.toUpperCase().trim();
    if (!normalizedSymbol) {
        throw new BarError('Symbol is required', 'INVALID_SYMBOL');
    }
    if (days <= 0) {
        throw new BarError('Days must be a positive number', 'INVALID_DAYS');
    }
    log$b(`Fetching ${days} days of daily prices for ${normalizedSymbol}`, { type: 'debug' });
    // Calculate start date (add buffer for weekends/holidays)
    const bufferDays = Math.ceil(days * 1.5) + 10;
    const start = new Date();
    start.setDate(start.getDate() - bufferDays);
    const result = await getBars(client, {
        symbols: [normalizedSymbol],
        timeframe: '1Day',
        start,
        limit: days,
        adjustment: 'all',
    });
    const bars = result.get(normalizedSymbol) || [];
    // Return only the requested number of days (most recent)
    if (bars.length > days) {
        return bars.slice(-days);
    }
    return bars;
}
/**
 * Get intraday prices for a symbol
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param timeframe - Bar timeframe
 * @param start - Start date/time
 * @param end - Optional end date/time (defaults to now)
 * @returns Array of intraday bars
 */
async function getIntradayPrices(client, symbol, timeframe, start, end) {
    const normalizedSymbol = symbol.toUpperCase().trim();
    if (!normalizedSymbol) {
        throw new BarError('Symbol is required', 'INVALID_SYMBOL');
    }
    log$b(`Fetching intraday prices for ${normalizedSymbol} (${timeframe})`, { type: 'debug' });
    const result = await getBars(client, {
        symbols: [normalizedSymbol],
        timeframe,
        start,
        end: end || new Date(),
    });
    return result.get(normalizedSymbol) || [];
}
/**
 * Get previous close price for a symbol
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @returns Previous close price
 */
async function getPreviousClose(client, symbol) {
    const normalizedSymbol = symbol.toUpperCase().trim();
    if (!normalizedSymbol) {
        throw new BarError('Symbol is required', 'INVALID_SYMBOL');
    }
    log$b(`Fetching previous close for ${normalizedSymbol}`, { type: 'debug' });
    // Get the last 2 daily bars to ensure we have the previous day
    const bars = await getDailyPrices(client, normalizedSymbol, 2);
    if (bars.length === 0) {
        throw new BarError(`No price data available for ${normalizedSymbol}`, 'NO_DATA', normalizedSymbol);
    }
    // If we have 2 bars, the previous close is from the second-to-last bar
    // If we only have 1 bar, use that bar's close
    const previousBar = bars.length >= 2 ? bars[bars.length - 2] : bars[bars.length - 1];
    return previousBar.c;
}
/**
 * Analyze bars and return summary statistics
 * @param bars - Array of bars to analyze
 * @returns Analysis summary with OHLCV stats and price change
 */
function analyzeBars(bars) {
    if (!bars || bars.length === 0) {
        return {
            open: 0,
            high: 0,
            low: 0,
            close: 0,
            volume: 0,
            vwap: 0,
            change: 0,
            changePercent: 0,
            barCount: 0,
            totalTrades: 0,
        };
    }
    const open = bars[0].o;
    const close = bars[bars.length - 1].c;
    let high = -Infinity;
    let low = Infinity;
    let volume = 0;
    let vwapSum = 0;
    let volumeSum = 0;
    let totalTrades = 0;
    for (const bar of bars) {
        if (bar.h > high)
            high = bar.h;
        if (bar.l < low)
            low = bar.l;
        volume += bar.v;
        totalTrades += bar.n;
        // Calculate VWAP using volume-weighted prices
        if (bar.vw > 0 && bar.v > 0) {
            vwapSum += bar.vw * bar.v;
            volumeSum += bar.v;
        }
    }
    const vwap = volumeSum > 0 ? vwapSum / volumeSum : 0;
    const change = close - open;
    const changePercent = open !== 0 ? (change / open) * 100 : 0;
    return {
        open,
        high: high === -Infinity ? 0 : high,
        low: low === Infinity ? 0 : low,
        close,
        volume,
        vwap,
        change,
        changePercent,
        barCount: bars.length,
        totalTrades,
    };
}
/**
 * Get price range statistics for a symbol over a period
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param days - Number of days to analyze
 * @returns Analysis of the price range
 */
async function getPriceRange(client, symbol, days) {
    const bars = await getDailyPrices(client, symbol, days);
    return analyzeBars(bars);
}
/**
 * Calculate average daily volume for a symbol
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param days - Number of days to average (default 20)
 * @returns Average daily volume
 */
async function getAverageDailyVolume(client, symbol, days = 20) {
    const bars = await getDailyPrices(client, symbol, days);
    if (bars.length === 0) {
        return 0;
    }
    const totalVolume = bars.reduce((sum, bar) => sum + bar.v, 0);
    return totalVolume / bars.length;
}
/**
 * Check if a symbol has sufficient trading volume
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param minAvgVolume - Minimum average daily volume required (default 100,000)
 * @param days - Number of days to check (default 20)
 * @returns true if average volume meets minimum requirement
 */
async function hasSufficientVolume(client, symbol, minAvgVolume = 100000, days = 20) {
    try {
        const avgVolume = await getAverageDailyVolume(client, symbol, days);
        return avgVolume >= minAvgVolume;
    }
    catch (error) {
        log$b(`Failed to check volume for ${symbol}: ${error.message}`, { type: 'warn' });
        return false;
    }
}
var bars = {
    getBars,
    getLatestBars,
    getDailyPrices,
    getIntradayPrices,
    getPreviousClose,
    analyzeBars,
    getPriceRange,
    getAverageDailyVolume,
    hasSufficientVolume,
};

var bars$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BarError: BarError,
    analyzeBars: analyzeBars,
    default: bars,
    getAverageDailyVolume: getAverageDailyVolume,
    getBars: getBars,
    getDailyPrices: getDailyPrices,
    getIntradayPrices: getIntradayPrices,
    getLatestBars: getLatestBars,
    getPreviousClose: getPreviousClose,
    getPriceRange: getPriceRange,
    hasSufficientVolume: hasSufficientVolume
});

const log$a = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: 'AlpacaTrades' });
};
/**
 * Error thrown when trade operations fail
 */
class TradeError extends Error {
    code;
    symbol;
    details;
    constructor(message, code, symbol, details) {
        super(message);
        this.code = code;
        this.symbol = symbol;
        this.details = details;
        this.name = 'TradeError';
    }
}
/**
 * Convert date to RFC-3339 format string
 */
function toRFC3339$2(date) {
    if (typeof date === 'string') {
        return date;
    }
    return date.toISOString();
}
/**
 * Get latest trade for a single symbol
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol to get trade for
 * @param feed - Optional data feed (sip, iex, delayed_sip)
 * @returns Latest trade for the symbol
 * @throws TradeError if the request fails
 */
async function getLatestTrade(client, symbol, feed) {
    const normalizedSymbol = symbol.toUpperCase().trim();
    if (!normalizedSymbol) {
        throw new TradeError('Symbol is required', 'INVALID_SYMBOL');
    }
    log$a(`Fetching latest trade for ${normalizedSymbol}`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const config = client.getConfig();
        const dataFeed = feed || config.dataFeed || 'iex';
        // Use SDK's getLatestTrade method
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const response = await sdk.getLatestTrade(normalizedSymbol, { feed: dataFeed });
        if (!response) {
            throw new TradeError(`No trade data returned for ${normalizedSymbol}`, 'NO_DATA', normalizedSymbol);
        }
        log$a(`Successfully fetched trade for ${normalizedSymbol}: price=${response.Price}, size=${response.Size}`, { type: 'debug' });
        // Map SDK response to our AlpacaTrade type
        return {
            t: response.Timestamp,
            p: response.Price,
            s: response.Size,
            x: response.Exchange,
            i: response.ID,
            z: response.Tape || '',
            c: response.Conditions || [],
        };
    }
    catch (error) {
        if (error instanceof TradeError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$a(`Failed to fetch trade for ${normalizedSymbol}: ${errorMessage}`, { type: 'error' });
        throw new TradeError(`Failed to fetch trade for ${normalizedSymbol}: ${errorMessage}`, 'FETCH_ERROR', normalizedSymbol, error);
    }
}
/**
 * Get latest trades for multiple symbols
 * @param client - AlpacaClient instance
 * @param symbols - Array of stock symbols
 * @param feed - Optional data feed (sip, iex, delayed_sip)
 * @returns Object containing trades for all requested symbols
 * @throws TradeError if the request fails
 */
async function getLatestTrades(client, symbols, feed) {
    if (!symbols || symbols.length === 0) {
        throw new TradeError('At least one symbol is required', 'INVALID_SYMBOLS');
    }
    const normalizedSymbols = symbols.map((s) => s.toUpperCase().trim()).filter(Boolean);
    if (normalizedSymbols.length === 0) {
        throw new TradeError('No valid symbols provided', 'INVALID_SYMBOLS');
    }
    log$a(`Fetching latest trades for ${normalizedSymbols.length} symbols`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const config = client.getConfig();
        const dataFeed = feed || config.dataFeed || 'iex';
        // Use SDK's getLatestTrades method
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const response = await sdk.getLatestTrades(normalizedSymbols, { feed: dataFeed });
        if (!response) {
            throw new TradeError('No trade data returned', 'NO_DATA');
        }
        // Map SDK response to our LatestTradesResponse type
        const trades = {};
        for (const [symbol, trade] of Object.entries(response)) {
            const t = trade;
            trades[symbol] = {
                t: t.Timestamp,
                p: t.Price,
                s: t.Size,
                x: t.Exchange,
                i: t.ID,
                z: t.Tape || '',
                c: t.Conditions || [],
            };
        }
        log$a(`Successfully fetched trades for ${Object.keys(trades).length} symbols`, { type: 'debug' });
        return {
            trades,
            currency: 'USD',
        };
    }
    catch (error) {
        if (error instanceof TradeError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$a(`Failed to fetch trades: ${errorMessage}`, { type: 'error' });
        throw new TradeError(`Failed to fetch trades: ${errorMessage}`, 'FETCH_ERROR', undefined, error);
    }
}
/**
 * Get historical trades with automatic pagination
 * @param client - AlpacaClient instance
 * @param params - Parameters for fetching historical trades
 * @returns Array of trades for the symbol
 * @throws TradeError if the request fails
 */
async function getHistoricalTrades(client, params) {
    const { symbol, start, end, limit, feed } = params;
    const normalizedSymbol = symbol.toUpperCase().trim();
    if (!normalizedSymbol) {
        throw new TradeError('Symbol is required', 'INVALID_SYMBOL');
    }
    log$a(`Fetching historical trades for ${normalizedSymbol}`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const config = client.getConfig();
        const dataFeed = feed || config.dataFeed || 'iex';
        const options = {
            start: toRFC3339$2(start),
            feed: dataFeed,
        };
        if (end) {
            options.end = toRFC3339$2(end);
        }
        if (limit) {
            options.limit = limit;
        }
        const trades = [];
        // Use SDK's getTradesV2 method with pagination (async iterator)
        const tradesIterator = sdk.getTradesV2(normalizedSymbol, options);
        for await (const trade of tradesIterator) {
            trades.push({
                t: trade.Timestamp,
                p: trade.Price,
                s: trade.Size,
                x: trade.Exchange,
                i: trade.ID,
                z: trade.Tape || '',
                c: trade.Conditions || [],
            });
            // Respect limit if specified
            if (limit && trades.length >= limit) {
                break;
            }
        }
        log$a(`Successfully fetched ${trades.length} historical trades for ${normalizedSymbol}`, { type: 'debug' });
        return trades;
    }
    catch (error) {
        if (error instanceof TradeError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$a(`Failed to fetch historical trades for ${normalizedSymbol}: ${errorMessage}`, { type: 'error' });
        throw new TradeError(`Failed to fetch historical trades: ${errorMessage}`, 'FETCH_ERROR', normalizedSymbol, error);
    }
}
/**
 * Get current price for a symbol
 * Uses mid-point of latest quote if available, otherwise falls back to last trade price
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param feed - Optional data feed (sip, iex, delayed_sip)
 * @returns Current price for the symbol
 * @throws TradeError if unable to get price
 */
async function getCurrentPrice(client, symbol, feed) {
    const normalizedSymbol = symbol.toUpperCase().trim();
    if (!normalizedSymbol) {
        throw new TradeError('Symbol is required', 'INVALID_SYMBOL');
    }
    log$a(`Fetching current price for ${normalizedSymbol}`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const config = client.getConfig();
        const dataFeed = feed || config.dataFeed || 'iex';
        // Try to get quote first for mid-point price
        try {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const quote = await sdk.getLatestQuote(normalizedSymbol, { feed: dataFeed });
            if (quote && quote.BidPrice > 0 && quote.AskPrice > 0) {
                const midPrice = (quote.BidPrice + quote.AskPrice) / 2;
                log$a(`Current price for ${normalizedSymbol} (mid-point): ${midPrice}`, { type: 'debug' });
                return midPrice;
            }
        }
        catch (quoteError) {
            log$a(`Could not get quote for ${normalizedSymbol}, falling back to trade: ${quoteError.message}`, { type: 'debug' });
        }
        // Fall back to last trade price
        const trade = await getLatestTrade(client, normalizedSymbol, feed);
        if (!trade || trade.p <= 0) {
            throw new TradeError(`No valid price available for ${normalizedSymbol}`, 'NO_PRICE', normalizedSymbol);
        }
        log$a(`Current price for ${normalizedSymbol} (last trade): ${trade.p}`, { type: 'debug' });
        return trade.p;
    }
    catch (error) {
        if (error instanceof TradeError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$a(`Failed to get current price for ${normalizedSymbol}: ${errorMessage}`, { type: 'error' });
        throw new TradeError(`Failed to get current price for ${normalizedSymbol}: ${errorMessage}`, 'FETCH_ERROR', normalizedSymbol, error);
    }
}
/**
 * Get current prices for multiple symbols
 * Uses mid-point of latest quote if available, otherwise falls back to last trade price
 * @param client - AlpacaClient instance
 * @param symbols - Array of stock symbols
 * @param feed - Optional data feed (sip, iex, delayed_sip)
 * @returns Map of symbol to current price
 */
async function getCurrentPrices(client, symbols, feed) {
    if (!symbols || symbols.length === 0) {
        throw new TradeError('At least one symbol is required', 'INVALID_SYMBOLS');
    }
    const normalizedSymbols = symbols.map((s) => s.toUpperCase().trim()).filter(Boolean);
    if (normalizedSymbols.length === 0) {
        throw new TradeError('No valid symbols provided', 'INVALID_SYMBOLS');
    }
    log$a(`Fetching current prices for ${normalizedSymbols.length} symbols`, { type: 'debug' });
    const prices = new Map();
    try {
        const sdk = client.getSDK();
        const config = client.getConfig();
        const dataFeed = feed || config.dataFeed || 'iex';
        // First try to get quotes for mid-point prices
        const symbolsNeedingTrades = [];
        try {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const quotes = await sdk.getLatestQuotes(normalizedSymbols, { feed: dataFeed });
            for (const symbol of normalizedSymbols) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const rawQuote = quotes.get ? quotes.get(symbol) : quotes[symbol];
                const quote = rawQuote;
                if (quote && quote.BidPrice > 0 && quote.AskPrice > 0) {
                    const midPrice = (quote.BidPrice + quote.AskPrice) / 2;
                    prices.set(symbol, midPrice);
                }
                else {
                    symbolsNeedingTrades.push(symbol);
                }
            }
        }
        catch (quoteError) {
            log$a(`Could not get quotes, falling back to trades: ${quoteError.message}`, { type: 'debug' });
            symbolsNeedingTrades.push(...normalizedSymbols.filter((s) => !prices.has(s)));
        }
        // Fall back to trades for symbols without valid quotes
        if (symbolsNeedingTrades.length > 0) {
            try {
                const tradesResponse = await getLatestTrades(client, symbolsNeedingTrades, feed);
                for (const [symbol, trade] of Object.entries(tradesResponse.trades)) {
                    if (trade && trade.p > 0) {
                        prices.set(symbol, trade.p);
                    }
                }
            }
            catch (tradeError) {
                log$a(`Failed to get trades for some symbols: ${tradeError.message}`, { type: 'warn' });
            }
        }
        log$a(`Successfully fetched prices for ${prices.size} of ${normalizedSymbols.length} symbols`, { type: 'debug' });
        return prices;
    }
    catch (error) {
        if (error instanceof TradeError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$a(`Failed to get current prices: ${errorMessage}`, { type: 'error' });
        throw new TradeError(`Failed to get current prices: ${errorMessage}`, 'FETCH_ERROR', undefined, error);
    }
}
/**
 * Get trade volume summary for a symbol over a time period
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param start - Start date/time
 * @param end - End date/time (defaults to now)
 * @returns Total volume and trade count for the period
 */
async function getTradeVolume(client, symbol, start, end) {
    const trades = await getHistoricalTrades(client, {
        symbol,
        start,
        end: end || new Date(),
    });
    if (trades.length === 0) {
        return {
            totalVolume: 0,
            tradeCount: 0,
            avgTradeSize: 0,
        };
    }
    const totalVolume = trades.reduce((sum, trade) => sum + trade.s, 0);
    const tradeCount = trades.length;
    const avgTradeSize = totalVolume / tradeCount;
    log$a(`Trade volume for ${symbol}: ${totalVolume} shares across ${tradeCount} trades`, { type: 'debug' });
    return {
        totalVolume,
        tradeCount,
        avgTradeSize,
    };
}
var trades = {
    getLatestTrade,
    getLatestTrades,
    getHistoricalTrades,
    getCurrentPrice,
    getCurrentPrices,
    getTradeVolume,
};

var trades$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    TradeError: TradeError,
    default: trades,
    getCurrentPrice: getCurrentPrice,
    getCurrentPrices: getCurrentPrices,
    getHistoricalTrades: getHistoricalTrades,
    getLatestTrade: getLatestTrade,
    getLatestTrades: getLatestTrades,
    getTradeVolume: getTradeVolume
});

const log$9 = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: 'AlpacaNews' });
};
/**
 * Error thrown when news operations fail
 */
class NewsError extends Error {
    code;
    symbol;
    details;
    constructor(message, code, symbol, details) {
        super(message);
        this.code = code;
        this.symbol = symbol;
        this.details = details;
        this.name = 'NewsError';
    }
}
/**
 * Strip HTML tags from a string
 */
function stripHtml(html) {
    if (!html) {
        return '';
    }
    // Remove HTML tags
    let text = html.replace(/<[^>]*>/g, ' ');
    // Decode common HTML entities
    text = text
        .replace(/&nbsp;/g, ' ')
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/&apos;/g, "'")
        .replace(/&#x27;/g, "'")
        .replace(/&#x2F;/g, '/')
        .replace(/&mdash;/g, '-')
        .replace(/&ndash;/g, '-')
        .replace(/&hellip;/g, '...')
        .replace(/&ldquo;/g, '"')
        .replace(/&rdquo;/g, '"')
        .replace(/&lsquo;/g, "'")
        .replace(/&rsquo;/g, "'");
    // Decode numeric HTML entities
    text = text.replace(/&#(\d+);/g, (_, code) => String.fromCharCode(parseInt(code, 10)));
    text = text.replace(/&#x([0-9a-fA-F]+);/g, (_, code) => String.fromCharCode(parseInt(code, 16)));
    // Normalize whitespace
    text = text.replace(/\s+/g, ' ').trim();
    return text;
}
/**
 * Convert date to RFC-3339 format string
 */
function toRFC3339$1(date) {
    if (typeof date === 'string') {
        return date;
    }
    return date.toISOString();
}
/**
 * Calculate basic sentiment score from text
 * Returns a value between -1 (negative) and 1 (positive)
 * This is a simple heuristic-based approach
 */
function calculateSentiment(text) {
    if (!text) {
        return 0;
    }
    const lowerText = text.toLowerCase();
    // Positive indicators
    const positiveWords = [
        'surge', 'surges', 'surging', 'soar', 'soars', 'soaring',
        'gain', 'gains', 'gained', 'rise', 'rises', 'rising', 'rose',
        'jump', 'jumps', 'jumped', 'boost', 'boosts', 'boosted',
        'profit', 'profits', 'profitable', 'growth', 'growing', 'grew',
        'beat', 'beats', 'beating', 'exceed', 'exceeds', 'exceeded',
        'outperform', 'outperforms', 'strong', 'stronger', 'strongest',
        'upgrade', 'upgrades', 'upgraded', 'bullish', 'rally', 'rallies',
        'record', 'high', 'highs', 'positive', 'optimistic', 'upbeat',
        'success', 'successful', 'breakthrough', 'innovation', 'innovative',
    ];
    // Negative indicators
    const negativeWords = [
        'drop', 'drops', 'dropped', 'fall', 'falls', 'falling', 'fell',
        'decline', 'declines', 'declined', 'plunge', 'plunges', 'plunged',
        'crash', 'crashes', 'crashed', 'tumble', 'tumbles', 'tumbled',
        'loss', 'losses', 'losing', 'lost', 'miss', 'misses', 'missed',
        'downgrade', 'downgrades', 'downgraded', 'bearish', 'selloff',
        'weak', 'weaker', 'weakest', 'concern', 'concerns', 'worried',
        'warning', 'warns', 'warned', 'risk', 'risks', 'risky',
        'negative', 'pessimistic', 'underperform', 'underperforms',
        'layoff', 'layoffs', 'lawsuit', 'investigation', 'fraud',
        'recession', 'bankruptcy', 'default', 'crisis', 'trouble',
    ];
    let positiveCount = 0;
    let negativeCount = 0;
    for (const word of positiveWords) {
        const regex = new RegExp(`\\b${word}\\b`, 'gi');
        const matches = lowerText.match(regex);
        if (matches) {
            positiveCount += matches.length;
        }
    }
    for (const word of negativeWords) {
        const regex = new RegExp(`\\b${word}\\b`, 'gi');
        const matches = lowerText.match(regex);
        if (matches) {
            negativeCount += matches.length;
        }
    }
    const total = positiveCount + negativeCount;
    if (total === 0) {
        return 0;
    }
    // Calculate sentiment score between -1 and 1
    return (positiveCount - negativeCount) / total;
}
/**
 * Convert Alpaca news article to simplified news format
 */
function toSimpleNews(article, includeContent = false) {
    const cleanSummary = stripHtml(article.summary);
    const cleanContent = includeContent ? stripHtml(article.content) : undefined;
    // Calculate sentiment from headline and summary
    const sentimentText = `${article.headline} ${cleanSummary}`;
    const sentiment = calculateSentiment(sentimentText);
    return {
        symbols: article.symbols,
        title: stripHtml(article.headline),
        summary: cleanSummary,
        content: cleanContent,
        url: article.url,
        source: article.source,
        author: article.author,
        date: article.created_at,
        updatedDate: article.updated_at,
        sentiment,
    };
}
/**
 * Get news articles with optional filtering
 * @param client - AlpacaClient instance
 * @param params - Parameters for fetching news
 * @returns Array of simplified news articles
 * @throws NewsError if the request fails
 */
async function getNews(client, params = {}) {
    const { symbols, start, end, limit = 10, sort = 'desc', includeContent = false } = params;
    log$9(`Fetching news${symbols ? ` for ${symbols.join(', ')}` : ''}`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const options = {
            limit: Math.min(limit, 50), // API max is 50
            sort,
        };
        if (symbols && symbols.length > 0) {
            options.symbols = symbols.map((s) => s.toUpperCase().trim()).filter(Boolean).join(',');
        }
        if (start) {
            options.start = toRFC3339$1(start);
        }
        if (end) {
            options.end = toRFC3339$1(end);
        }
        if (includeContent) {
            options.include_content = true;
        }
        // Use SDK's getNews method
        const response = await sdk.getNews(options);
        if (!response || !Array.isArray(response)) {
            log$9('No news data returned', { type: 'debug' });
            return [];
        }
        // Map SDK response to our SimpleNews type
        // The SDK returns a slightly different structure, so we map the fields
        const articles = response.map((article) => {
            // SDK returns properties in different format
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const sdkArticle = article;
            // Normalize to our expected format
            const normalizedArticle = {
                id: sdkArticle.ID || sdkArticle.id || 0,
                author: sdkArticle.Author || sdkArticle.author || '',
                content: sdkArticle.Content || sdkArticle.content || '',
                created_at: sdkArticle.CreatedAt || sdkArticle.created_at || '',
                updated_at: sdkArticle.UpdatedAt || sdkArticle.updated_at || '',
                headline: sdkArticle.Headline || sdkArticle.headline || '',
                source: sdkArticle.Source || sdkArticle.source || '',
                summary: sdkArticle.Summary || sdkArticle.summary || '',
                url: sdkArticle.URL || sdkArticle.url || '',
                symbols: sdkArticle.Symbols || sdkArticle.symbols || [],
                images: (sdkArticle.Images || sdkArticle.images || []).map((img) => ({
                    size: img.size,
                    url: img.url,
                })),
            };
            return toSimpleNews(normalizedArticle, includeContent);
        });
        log$9(`Successfully fetched ${articles.length} news articles`, { type: 'debug' });
        return articles;
    }
    catch (error) {
        if (error instanceof NewsError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$9(`Failed to fetch news: ${errorMessage}`, { type: 'error' });
        throw new NewsError(`Failed to fetch news: ${errorMessage}`, 'FETCH_ERROR', undefined, error);
    }
}
/**
 * Get latest news for a specific symbol
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol to get news for
 * @param limit - Maximum number of articles (default 10)
 * @returns Array of simplified news articles
 * @throws NewsError if the request fails
 */
async function getLatestNews(client, symbol, limit = 10) {
    const normalizedSymbol = symbol.toUpperCase().trim();
    if (!normalizedSymbol) {
        throw new NewsError('Symbol is required', 'INVALID_SYMBOL');
    }
    log$9(`Fetching latest news for ${normalizedSymbol}`, { type: 'debug' });
    return getNews(client, {
        symbols: [normalizedSymbol],
        limit,
        sort: 'desc',
    });
}
/**
 * Search news by keyword in headlines and summaries
 * Note: This performs client-side filtering since Alpaca API doesn't support keyword search
 * @param client - AlpacaClient instance
 * @param query - Search query (case-insensitive)
 * @param limit - Maximum number of articles (default 10)
 * @returns Array of simplified news articles matching the query
 * @throws NewsError if the request fails
 */
async function searchNews(client, query, limit = 10) {
    if (!query || query.trim().length === 0) {
        throw new NewsError('Search query is required', 'INVALID_QUERY');
    }
    const searchQuery = query.trim().toLowerCase();
    log$9(`Searching news for: ${searchQuery}`, { type: 'debug' });
    try {
        // Fetch more articles than needed to filter client-side
        const fetchLimit = Math.min(limit * 5, 50);
        const articles = await getNews(client, {
            limit: fetchLimit,
            sort: 'desc',
        });
        // Filter articles that match the search query
        const matchingArticles = articles.filter((article) => {
            const title = article.title.toLowerCase();
            const summary = article.summary.toLowerCase();
            const content = article.content?.toLowerCase() || '';
            return (title.includes(searchQuery) ||
                summary.includes(searchQuery) ||
                content.includes(searchQuery));
        });
        // Return only the requested number of articles
        const result = matchingArticles.slice(0, limit);
        log$9(`Found ${result.length} news articles matching "${query}"`, { type: 'debug' });
        return result;
    }
    catch (error) {
        if (error instanceof NewsError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$9(`Failed to search news: ${errorMessage}`, { type: 'error' });
        throw new NewsError(`Failed to search news: ${errorMessage}`, 'SEARCH_ERROR', undefined, error);
    }
}
/**
 * Get news for multiple symbols
 * @param client - AlpacaClient instance
 * @param symbols - Array of stock symbols
 * @param limit - Maximum number of articles per symbol (default 5)
 * @returns Map of symbol to news articles
 */
async function getNewsForSymbols(client, symbols, limit = 5) {
    if (!symbols || symbols.length === 0) {
        throw new NewsError('At least one symbol is required', 'INVALID_SYMBOLS');
    }
    const normalizedSymbols = symbols.map((s) => s.toUpperCase().trim()).filter(Boolean);
    log$9(`Fetching news for ${normalizedSymbols.length} symbols`, { type: 'debug' });
    // Fetch news for all symbols at once
    const allNews = await getNews(client, {
        symbols: normalizedSymbols,
        limit: normalizedSymbols.length * limit,
        sort: 'desc',
    });
    // Group news by symbol
    const newsBySymbol = new Map();
    // Initialize empty arrays for each symbol
    for (const symbol of normalizedSymbols) {
        newsBySymbol.set(symbol, []);
    }
    // Distribute articles to their respective symbols
    for (const article of allNews) {
        const articleSymbols = Array.isArray(article.symbols) ? article.symbols : [article.symbols];
        for (const symbol of articleSymbols) {
            const upperSymbol = symbol.toUpperCase();
            if (normalizedSymbols.includes(upperSymbol)) {
                const symbolNews = newsBySymbol.get(upperSymbol) || [];
                if (symbolNews.length < limit) {
                    symbolNews.push(article);
                    newsBySymbol.set(upperSymbol, symbolNews);
                }
            }
        }
    }
    log$9(`Successfully fetched news for ${newsBySymbol.size} symbols`, { type: 'debug' });
    return newsBySymbol;
}
/**
 * Get average sentiment for a symbol based on recent news
 * @param client - AlpacaClient instance
 * @param symbol - Stock symbol
 * @param limit - Number of articles to analyze (default 10)
 * @returns Average sentiment score between -1 and 1
 */
async function getSymbolSentiment(client, symbol, limit = 10) {
    const news = await getLatestNews(client, symbol, limit);
    if (news.length === 0) {
        return {
            sentiment: 0,
            articleCount: 0,
        };
    }
    const totalSentiment = news.reduce((sum, article) => sum + article.sentiment, 0);
    const avgSentiment = totalSentiment / news.length;
    log$9(`Sentiment for ${symbol}: ${avgSentiment.toFixed(3)} (${news.length} articles)`, { type: 'debug' });
    return {
        sentiment: avgSentiment,
        articleCount: news.length,
    };
}
var news = {
    getNews,
    getLatestNews,
    searchNews,
    getNewsForSymbols,
    getSymbolSentiment,
};

var news$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    NewsError: NewsError,
    default: news,
    getLatestNews: getLatestNews,
    getNews: getNews,
    getNewsForSymbols: getNewsForSymbols,
    getSymbolSentiment: getSymbolSentiment,
    searchNews: searchNews
});

const LOG_SOURCE$6 = 'OptionsContracts';
/**
 * Internal logging helper with consistent source
 */
const log$8 = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: LOG_SOURCE$6 });
};
// ============================================================================
// API Functions
// ============================================================================
/**
 * Get option contracts for an underlying symbol with filters
 *
 * @param client - The AlpacaClient instance
 * @param params - Query parameters for filtering contracts
 * @returns Array of option contracts matching the criteria
 * @throws Error if API request fails
 *
 * @example
 * // Get all AAPL option contracts
 * const contracts = await getOptionContracts(client, {
 *   underlying_symbols: ['AAPL'],
 * });
 *
 * @example
 * // Get AAPL calls expiring in the next 30 days
 * const today = new Date();
 * const thirtyDaysOut = new Date(today.getTime() + 30 * 24 * 60 * 60 * 1000);
 * const contracts = await getOptionContracts(client, {
 *   underlying_symbols: ['AAPL'],
 *   type: 'call',
 *   expiration_date_gte: today.toISOString().split('T')[0],
 *   expiration_date_lte: thirtyDaysOut.toISOString().split('T')[0],
 * });
 */
async function getOptionContracts(client, params) {
    const symbols = params.underlying_symbols.join(', ');
    log$8(`Fetching option contracts for: ${symbols}`, {
        type: 'debug',
        metadata: { params },
    });
    try {
        const allContracts = [];
        let pageToken;
        // Handle pagination
        do {
            const queryParts = [
                `underlying_symbols=${params.underlying_symbols.join(',')}`,
            ];
            if (params.expiration_date_gte)
                queryParts.push(`expiration_date_gte=${params.expiration_date_gte}`);
            if (params.expiration_date_lte)
                queryParts.push(`expiration_date_lte=${params.expiration_date_lte}`);
            if (params.strike_price_gte)
                queryParts.push(`strike_price_gte=${params.strike_price_gte}`);
            if (params.strike_price_lte)
                queryParts.push(`strike_price_lte=${params.strike_price_lte}`);
            if (params.type)
                queryParts.push(`type=${params.type}`);
            if (params.status)
                queryParts.push(`status=${params.status}`);
            if (params.limit)
                queryParts.push(`limit=${params.limit}`);
            if (pageToken)
                queryParts.push(`page_token=${pageToken}`);
            const endpoint = `/options/contracts?${queryParts.join('&')}`;
            const response = await client.makeRequest(endpoint);
            if (response.option_contracts && Array.isArray(response.option_contracts)) {
                allContracts.push(...response.option_contracts);
            }
            pageToken = response.page_token;
            // Break if we have a limit and reached it
            if (params.limit && allContracts.length >= params.limit) {
                break;
            }
        } while (pageToken);
        log$8(`Retrieved ${allContracts.length} option contracts for ${symbols}`, {
            type: 'info',
            metadata: { count: allContracts.length },
        });
        return allContracts;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$8(`Failed to fetch option contracts for ${symbols}: ${errorMessage}`, {
            type: 'error',
            metadata: { params },
        });
        throw new Error(`Failed to fetch option contracts: ${errorMessage}`);
    }
}
/**
 * Get a specific option contract by symbol or ID
 *
 * @param client - The AlpacaClient instance
 * @param symbolOrId - Option contract symbol (e.g., AAPL230120C00150000) or contract ID
 * @returns The option contract details
 * @throws Error if contract not found or API request fails
 *
 * @example
 * // Get contract by OCC symbol
 * const contract = await getOptionContract(client, 'AAPL230120C00150000');
 *
 * @example
 * // Get contract by ID
 * const contract = await getOptionContract(client, 'contract-uuid-here');
 */
async function getOptionContract(client, symbolOrId) {
    log$8(`Fetching option contract: ${symbolOrId}`, { type: 'debug' });
    try {
        const endpoint = `/options/contracts/${encodeURIComponent(symbolOrId)}`;
        const contract = await client.makeRequest(endpoint);
        log$8(`Retrieved option contract: ${contract.symbol}`, {
            type: 'info',
            symbol: contract.underlying_symbol,
            metadata: {
                type: contract.type,
                strike: contract.strike_price,
                expiration: contract.expiration_date,
            },
        });
        return contract;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        if (errorMessage.includes('404') || errorMessage.includes('not found')) {
            log$8(`Option contract not found: ${symbolOrId}`, { type: 'warn' });
            throw new Error(`Option contract not found: ${symbolOrId}`);
        }
        log$8(`Failed to fetch option contract ${symbolOrId}: ${errorMessage}`, { type: 'error' });
        throw new Error(`Failed to fetch option contract: ${errorMessage}`);
    }
}
/**
 * Get option chain for a symbol with optional filters
 *
 * @param client - The AlpacaClient instance
 * @param underlying - The underlying symbol (e.g., 'AAPL')
 * @param params - Optional filter parameters
 * @returns Array of option contracts in the chain
 *
 * @example
 * // Get full option chain for AAPL
 * const chain = await getOptionChain(client, 'AAPL');
 *
 * @example
 * // Get AAPL puts at specific strike range
 * const chain = await getOptionChain(client, 'AAPL', {
 *   type: 'put',
 *   strikePrice: { min: 140, max: 160 },
 * });
 */
async function getOptionChain(client, underlying, params) {
    log$8(`Fetching option chain for ${underlying}`, {
        type: 'debug',
        symbol: underlying,
        metadata: { params },
    });
    const queryParams = {
        underlying_symbols: [underlying],
        status: 'active',
    };
    // Apply filters
    if (params?.expirationDate) {
        queryParams.expiration_date_gte = params.expirationDate;
        queryParams.expiration_date_lte = params.expirationDate;
    }
    if (params?.strikePrice) {
        if (params.strikePrice.min !== undefined) {
            queryParams.strike_price_gte = String(params.strikePrice.min);
        }
        if (params.strikePrice.max !== undefined) {
            queryParams.strike_price_lte = String(params.strikePrice.max);
        }
    }
    if (params?.type) {
        queryParams.type = params.type;
    }
    const contracts = await getOptionContracts(client, queryParams);
    log$8(`Retrieved ${contracts.length} contracts in option chain for ${underlying}`, {
        type: 'info',
        symbol: underlying,
    });
    return contracts;
}
/**
 * Get available expiration dates for an underlying symbol
 *
 * @param client - The AlpacaClient instance
 * @param underlying - The underlying symbol (e.g., 'AAPL')
 * @returns Sorted array of expiration dates (YYYY-MM-DD format)
 *
 * @example
 * const expirations = await getExpirationDates(client, 'AAPL');
 * console.log(`Next expiration: ${expirations[0]}`);
 */
async function getExpirationDates(client, underlying) {
    log$8(`Fetching expiration dates for ${underlying}`, {
        type: 'debug',
        symbol: underlying,
    });
    try {
        // Get all active contracts for the underlying
        const contracts = await getOptionContracts(client, {
            underlying_symbols: [underlying],
            status: 'active',
        });
        // Extract unique expiration dates
        const expirationSet = new Set();
        contracts.forEach((contract) => {
            expirationSet.add(contract.expiration_date);
        });
        // Sort dates chronologically
        const expirations = Array.from(expirationSet).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
        log$8(`Found ${expirations.length} expiration dates for ${underlying}`, {
            type: 'info',
            symbol: underlying,
            metadata: { count: expirations.length, nearest: expirations[0] },
        });
        return expirations;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$8(`Failed to fetch expiration dates for ${underlying}: ${errorMessage}`, {
            type: 'error',
            symbol: underlying,
        });
        throw new Error(`Failed to fetch expiration dates: ${errorMessage}`);
    }
}
/**
 * Get available strike prices for an underlying at a specific expiration
 *
 * @param client - The AlpacaClient instance
 * @param underlying - The underlying symbol
 * @param expirationDate - The expiration date (YYYY-MM-DD format)
 * @returns Sorted array of available strike prices
 *
 * @example
 * const strikes = await getStrikePrices(client, 'AAPL', '2024-01-19');
 */
async function getStrikePrices(client, underlying, expirationDate) {
    log$8(`Fetching strike prices for ${underlying} expiring ${expirationDate}`, {
        type: 'debug',
        symbol: underlying,
    });
    try {
        const contracts = await getOptionChain(client, underlying, { expirationDate });
        // Extract unique strikes
        const strikeSet = new Set();
        contracts.forEach((contract) => {
            const strike = parseFloat(contract.strike_price);
            if (!isNaN(strike)) {
                strikeSet.add(strike);
            }
        });
        // Sort strikes numerically
        const strikes = Array.from(strikeSet).sort((a, b) => a - b);
        log$8(`Found ${strikes.length} strike prices for ${underlying} at ${expirationDate}`, {
            type: 'info',
            symbol: underlying,
            metadata: { count: strikes.length },
        });
        return strikes;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$8(`Failed to fetch strike prices: ${errorMessage}`, {
            type: 'error',
            symbol: underlying,
        });
        throw new Error(`Failed to fetch strike prices: ${errorMessage}`);
    }
}
/**
 * Find ATM (at-the-money) options for an underlying
 * Returns both call and put options at the strike price closest to current price
 *
 * @param client - The AlpacaClient instance
 * @param underlying - The underlying symbol
 * @param expirationDate - The expiration date (YYYY-MM-DD format)
 * @param currentPrice - Current price of the underlying (required to determine ATM)
 * @param type - Optional filter to return only call or put
 * @returns ATM options result with call and/or put contracts
 *
 * @example
 * // Get both ATM call and put
 * const atm = await findATMOptions(client, 'AAPL', '2024-01-19', 175.50);
 * console.log(`ATM Call: ${atm.call?.symbol}`);
 * console.log(`ATM Put: ${atm.put?.symbol}`);
 *
 * @example
 * // Get only ATM call
 * const atm = await findATMOptions(client, 'AAPL', '2024-01-19', 175.50, 'call');
 */
async function findATMOptions(client, underlying, expirationDate, currentPrice, type) {
    log$8(`Finding ATM options for ${underlying} at $${currentPrice.toFixed(2)}`, {
        type: 'debug',
        symbol: underlying,
        metadata: { expirationDate, currentPrice, type },
    });
    try {
        // Get option chain for the expiration
        const contracts = await getOptionChain(client, underlying, {
            expirationDate,
            type,
        });
        if (contracts.length === 0) {
            log$8(`No contracts found for ${underlying} at ${expirationDate}`, {
                type: 'warn',
                symbol: underlying,
            });
            return {
                call: null,
                put: null,
                strikePrice: currentPrice,
                underlyingPrice: currentPrice,
            };
        }
        // Find the strike price closest to current price
        const strikes = new Set();
        contracts.forEach((c) => {
            const strike = parseFloat(c.strike_price);
            if (!isNaN(strike)) {
                strikes.add(strike);
            }
        });
        const sortedStrikes = Array.from(strikes).sort((a, b) => a - b);
        let atmStrike = sortedStrikes[0];
        let minDiff = Math.abs(sortedStrikes[0] - currentPrice);
        for (const strike of sortedStrikes) {
            const diff = Math.abs(strike - currentPrice);
            if (diff < minDiff) {
                minDiff = diff;
                atmStrike = strike;
            }
        }
        // Find call and put at ATM strike
        let call = null;
        let put = null;
        for (const contract of contracts) {
            const strike = parseFloat(contract.strike_price);
            if (strike === atmStrike) {
                if (contract.type === 'call') {
                    call = contract;
                }
                else if (contract.type === 'put') {
                    put = contract;
                }
            }
        }
        log$8(`Found ATM options at strike $${atmStrike.toFixed(2)}`, {
            type: 'info',
            symbol: underlying,
            metadata: {
                atmStrike,
                hasCall: !!call,
                hasPut: !!put,
                priceDiff: (atmStrike - currentPrice).toFixed(2),
            },
        });
        return {
            call,
            put,
            strikePrice: atmStrike,
            underlyingPrice: currentPrice,
        };
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$8(`Failed to find ATM options for ${underlying}: ${errorMessage}`, {
            type: 'error',
            symbol: underlying,
        });
        throw new Error(`Failed to find ATM options: ${errorMessage}`);
    }
}
/**
 * Get grouped option chain organized by expiration and strike
 *
 * @param client - The AlpacaClient instance
 * @param underlying - The underlying symbol
 * @param expirationDates - Optional array of expiration dates to include
 * @returns Grouped option chain structure
 *
 * @example
 * const chain = await getGroupedOptionChain(client, 'AAPL');
 * // Access calls at specific expiration and strike
 * const call = chain.byExpiration['2024-01-19'].calls['175'];
 */
async function getGroupedOptionChain(client, underlying, expirationDates) {
    log$8(`Fetching grouped option chain for ${underlying}`, {
        type: 'debug',
        symbol: underlying,
    });
    try {
        // Get all active contracts
        const contracts = await getOptionContracts(client, {
            underlying_symbols: [underlying],
            status: 'active',
        });
        // Initialize result structure
        const result = {
            underlying,
            byExpiration: {},
            expirations: [],
            strikes: [],
        };
        const expirationSet = new Set();
        const strikeSet = new Set();
        // Group contracts
        for (const contract of contracts) {
            const expiration = contract.expiration_date;
            const strike = parseFloat(contract.strike_price);
            // Filter by expiration if specified
            if (expirationDates && !expirationDates.includes(expiration)) {
                continue;
            }
            // Track unique values
            expirationSet.add(expiration);
            if (!isNaN(strike)) {
                strikeSet.add(strike);
            }
            // Initialize expiration bucket if needed
            if (!result.byExpiration[expiration]) {
                result.byExpiration[expiration] = {
                    calls: {},
                    puts: {},
                };
            }
            // Add to appropriate bucket
            const strikeKey = strike.toString();
            if (contract.type === 'call') {
                result.byExpiration[expiration].calls[strikeKey] = contract;
            }
            else if (contract.type === 'put') {
                result.byExpiration[expiration].puts[strikeKey] = contract;
            }
        }
        // Sort and assign arrays
        result.expirations = Array.from(expirationSet).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
        result.strikes = Array.from(strikeSet).sort((a, b) => a - b);
        log$8(`Grouped ${contracts.length} contracts: ${result.expirations.length} expirations, ${result.strikes.length} strikes`, {
            type: 'info',
            symbol: underlying,
        });
        return result;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$8(`Failed to get grouped option chain for ${underlying}: ${errorMessage}`, {
            type: 'error',
            symbol: underlying,
        });
        throw new Error(`Failed to get grouped option chain: ${errorMessage}`);
    }
}
/**
 * Find options contracts within a delta range (approximated by strike distance from current price)
 *
 * @param client - The AlpacaClient instance
 * @param underlying - The underlying symbol
 * @param expirationDate - The expiration date
 * @param currentPrice - Current price of the underlying
 * @param targetDeltaPercent - Target delta as percentage of current price (e.g., 5 for 5%)
 * @param type - Option type (call or put)
 * @returns Array of contracts within the delta range
 *
 * @example
 * // Find calls approximately 5% OTM
 * const otmCalls = await findOptionsByDelta(client, 'AAPL', '2024-01-19', 175, 5, 'call');
 */
async function findOptionsByDelta(client, underlying, expirationDate, currentPrice, targetDeltaPercent, type) {
    log$8(`Finding ${type} options for ${underlying} at ~${targetDeltaPercent}% OTM`, {
        type: 'debug',
        symbol: underlying,
    });
    try {
        const contracts = await getOptionChain(client, underlying, {
            expirationDate,
            type,
        });
        // Calculate target strike based on delta approximation
        // For calls: OTM is above current price
        // For puts: OTM is below current price
        const deltaOffset = (targetDeltaPercent / 100) * currentPrice;
        const targetStrike = type === 'call'
            ? currentPrice + deltaOffset
            : currentPrice - deltaOffset;
        // Find contracts near the target strike (within 2.5% tolerance)
        const tolerance = currentPrice * 0.025;
        const filtered = contracts.filter((contract) => {
            const strike = parseFloat(contract.strike_price);
            return Math.abs(strike - targetStrike) <= tolerance;
        });
        // Sort by distance from target
        filtered.sort((a, b) => {
            const aDist = Math.abs(parseFloat(a.strike_price) - targetStrike);
            const bDist = Math.abs(parseFloat(b.strike_price) - targetStrike);
            return aDist - bDist;
        });
        log$8(`Found ${filtered.length} ${type} options near target delta`, {
            type: 'info',
            symbol: underlying,
            metadata: { targetStrike: targetStrike.toFixed(2), contracts: filtered.length },
        });
        return filtered;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$8(`Failed to find options by delta: ${errorMessage}`, {
            type: 'error',
            symbol: underlying,
        });
        throw new Error(`Failed to find options by delta: ${errorMessage}`);
    }
}
/**
 * Find the nearest expiration date to a target number of days out
 *
 * @param client - The AlpacaClient instance
 * @param underlying - The underlying symbol
 * @param targetDays - Target number of days to expiration
 * @returns The nearest available expiration date
 *
 * @example
 * // Find expiration closest to 30 days out
 * const expiration = await findNearestExpiration(client, 'AAPL', 30);
 */
async function findNearestExpiration(client, underlying, targetDays) {
    log$8(`Finding expiration nearest to ${targetDays} days for ${underlying}`, {
        type: 'debug',
        symbol: underlying,
    });
    try {
        const expirations = await getExpirationDates(client, underlying);
        if (expirations.length === 0) {
            throw new Error(`No expiration dates available for ${underlying}`);
        }
        const now = new Date();
        const targetDate = new Date(now.getTime() + targetDays * 24 * 60 * 60 * 1000);
        const targetTime = targetDate.getTime();
        let nearestExpiration = expirations[0];
        let minDiff = Math.abs(new Date(expirations[0]).getTime() - targetTime);
        for (const exp of expirations) {
            const expTime = new Date(exp).getTime();
            const diff = Math.abs(expTime - targetTime);
            if (diff < minDiff) {
                minDiff = diff;
                nearestExpiration = exp;
            }
        }
        const actualDays = Math.round((new Date(nearestExpiration).getTime() - now.getTime()) / (24 * 60 * 60 * 1000));
        log$8(`Found nearest expiration: ${nearestExpiration} (${actualDays} days)`, {
            type: 'info',
            symbol: underlying,
            metadata: { targetDays, actualDays, expiration: nearestExpiration },
        });
        return nearestExpiration;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$8(`Failed to find nearest expiration: ${errorMessage}`, {
            type: 'error',
            symbol: underlying,
        });
        throw new Error(`Failed to find nearest expiration: ${errorMessage}`);
    }
}
// ============================================================================
// Utility Functions
// ============================================================================
/**
 * Parse OCC option symbol to extract components
 *
 * @param occSymbol - OCC option symbol (e.g., AAPL230120C00150000)
 * @returns Parsed symbol components
 *
 * @example
 * const parsed = parseOCCSymbol('AAPL230120C00150000');
 * // Returns: { underlying: 'AAPL', expiration: '2023-01-20', type: 'call', strike: 150 }
 */
function parseOCCSymbol(occSymbol) {
    // OCC format: SYMBOL + YYMMDD + C/P + STRIKE (8 digits, strike * 1000)
    // Example: AAPL230120C00150000 = AAPL Jan 20 2023 $150 Call
    // Find where the date portion starts (last 15 characters are date+type+strike)
    if (occSymbol.length < 15) {
        log$8(`Invalid OCC symbol format: ${occSymbol}`, { type: 'warn' });
        return null;
    }
    const suffixStart = occSymbol.length - 15;
    const underlying = occSymbol.substring(0, suffixStart);
    const suffix = occSymbol.substring(suffixStart);
    // Parse date (YYMMDD)
    const year = '20' + suffix.substring(0, 2);
    const month = suffix.substring(2, 4);
    const day = suffix.substring(4, 6);
    const expiration = `${year}-${month}-${day}`;
    // Parse type
    const typeChar = suffix.charAt(6);
    const type = typeChar === 'C' ? 'call' : 'put';
    // Parse strike (8 digits, last 3 are decimal)
    const strikeStr = suffix.substring(7);
    const strike = parseInt(strikeStr, 10) / 1000;
    return { underlying, expiration, type, strike };
}
/**
 * Build OCC option symbol from components
 *
 * @param underlying - The underlying symbol
 * @param expiration - Expiration date (YYYY-MM-DD format)
 * @param type - Option type (call or put)
 * @param strike - Strike price
 * @returns OCC-formatted option symbol
 *
 * @example
 * const symbol = buildOCCSymbol('AAPL', '2023-01-20', 'call', 150);
 * // Returns: 'AAPL230120C00150000'
 */
function buildOCCSymbol(underlying, expiration, type, strike) {
    // Parse date
    const [year, month, day] = expiration.split('-');
    const dateStr = year.slice(2) + month + day;
    // Type character
    const typeChar = type === 'call' ? 'C' : 'P';
    // Strike (multiply by 1000 and pad to 8 digits)
    const strikeInt = Math.round(strike * 1000);
    const strikeStr = strikeInt.toString().padStart(8, '0');
    return `${underlying}${dateStr}${typeChar}${strikeStr}`;
}
/**
 * Check if an option contract is tradable
 *
 * @param contract - The option contract to check
 * @returns True if the contract is active and tradable
 */
function isContractTradable(contract) {
    return contract.status === 'active' && contract.tradable === true;
}
/**
 * Calculate days to expiration for a contract
 *
 * @param contract - The option contract
 * @returns Number of calendar days until expiration
 */
function getDaysToExpiration(contract) {
    const now = new Date();
    const expiration = new Date(contract.expiration_date);
    const diffMs = expiration.getTime() - now.getTime();
    return Math.max(0, Math.ceil(diffMs / (24 * 60 * 60 * 1000)));
}
/**
 * Check if a contract is expiring within N days
 *
 * @param contract - The option contract
 * @param days - Number of days threshold
 * @returns True if contract expires within the specified days
 */
function isExpiringWithin(contract, days) {
    return getDaysToExpiration(contract) <= days;
}
// ============================================================================
// Default Export
// ============================================================================
var contracts = {
    // Core API functions
    getOptionContracts,
    getOptionContract,
    getOptionChain,
    getExpirationDates,
    getStrikePrices,
    findATMOptions,
    getGroupedOptionChain,
    findOptionsByDelta,
    findNearestExpiration,
    // Utility functions
    parseOCCSymbol,
    buildOCCSymbol,
    isContractTradable,
    getDaysToExpiration,
    isExpiringWithin,
};

var optionContracts = /*#__PURE__*/Object.freeze({
    __proto__: null,
    buildOCCSymbol: buildOCCSymbol,
    default: contracts,
    findATMOptions: findATMOptions,
    findNearestExpiration: findNearestExpiration,
    findOptionsByDelta: findOptionsByDelta,
    getDaysToExpiration: getDaysToExpiration,
    getExpirationDates: getExpirationDates,
    getGroupedOptionChain: getGroupedOptionChain,
    getOptionChain: getOptionChain,
    getOptionContract: getOptionContract,
    getOptionContracts: getOptionContracts,
    getStrikePrices: getStrikePrices,
    isContractTradable: isContractTradable,
    isExpiringWithin: isExpiringWithin,
    parseOCCSymbol: parseOCCSymbol
});

const LOG_SOURCE$5 = 'OptionsOrders';
/**
 * Internal logging helper with consistent source
 */
const log$7 = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: LOG_SOURCE$5 });
};
// ============================================================================
// Single-Leg Option Orders
// ============================================================================
/**
 * Create a single-leg option order
 *
 * @param client - The AlpacaClient instance
 * @param params - Order parameters
 * @returns The created order
 * @throws Error if order creation fails
 *
 * @example
 * // Buy to open 5 call contracts
 * const order = await createOptionOrder(client, {
 *   symbol: 'AAPL230120C00150000',
 *   qty: 5,
 *   side: 'buy',
 *   type: 'limit',
 *   limitPrice: 2.50,
 *   positionIntent: 'buy_to_open',
 *   timeInForce: 'day',
 * });
 *
 * @example
 * // Sell to close with market order
 * const order = await createOptionOrder(client, {
 *   symbol: 'AAPL230120C00150000',
 *   qty: 5,
 *   side: 'sell',
 *   type: 'market',
 *   positionIntent: 'sell_to_close',
 * });
 */
async function createOptionOrder(client, params) {
    const { symbol, qty, side, type, limitPrice, positionIntent, timeInForce, clientOrderId } = params;
    log$7(`Creating option order: ${side} ${qty} ${symbol} (${positionIntent})`, {
        type: 'info',
        symbol,
        metadata: { type, limitPrice, positionIntent },
    });
    // Validate parameters
    if (type === 'limit' && limitPrice === undefined) {
        throw new Error('Limit price is required for limit orders');
    }
    if (qty <= 0 || !Number.isInteger(qty)) {
        throw new Error('Quantity must be a positive integer');
    }
    try {
        const sdk = client.getSDK();
        const orderParams = {
            symbol,
            qty: qty.toString(),
            side,
            type,
            time_in_force: timeInForce || 'day',
            position_intent: positionIntent,
        };
        if (type === 'limit' && limitPrice !== undefined) {
            orderParams.limit_price = limitPrice.toString();
        }
        if (clientOrderId) {
            orderParams.client_order_id = clientOrderId;
        }
        const order = await sdk.createOrder(orderParams);
        log$7(`Option order created: ${order.id}`, {
            type: 'info',
            symbol,
            metadata: {
                orderId: order.id,
                status: order.status,
                positionIntent,
                qty: order.qty,
            },
        });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$7(`Failed to create option order for ${symbol}: ${errorMessage}`, {
            type: 'error',
            symbol,
            metadata: { params },
        });
        throw new Error(`Failed to create option order: ${errorMessage}`);
    }
}
/**
 * Buy to open option contracts
 *
 * @param client - The AlpacaClient instance
 * @param symbol - Option contract symbol
 * @param qty - Number of contracts
 * @param limitPrice - Optional limit price (market order if not provided)
 * @param timeInForce - Time in force (default: day)
 * @returns The created order
 *
 * @example
 * const order = await buyToOpen(client, 'AAPL230120C00150000', 5, 2.50);
 */
async function buyToOpen(client, symbol, qty, limitPrice, timeInForce = 'day') {
    return createOptionOrder(client, {
        symbol,
        qty,
        side: 'buy',
        type: limitPrice !== undefined ? 'limit' : 'market',
        limitPrice,
        positionIntent: 'buy_to_open',
        timeInForce,
    });
}
/**
 * Sell to close option contracts
 *
 * @param client - The AlpacaClient instance
 * @param symbol - Option contract symbol
 * @param qty - Number of contracts
 * @param limitPrice - Optional limit price (market order if not provided)
 * @param timeInForce - Time in force (default: day)
 * @returns The created order
 *
 * @example
 * const order = await sellToClose(client, 'AAPL230120C00150000', 5, 3.00);
 */
async function sellToClose(client, symbol, qty, limitPrice, timeInForce = 'day') {
    return createOptionOrder(client, {
        symbol,
        qty,
        side: 'sell',
        type: limitPrice !== undefined ? 'limit' : 'market',
        limitPrice,
        positionIntent: 'sell_to_close',
        timeInForce,
    });
}
/**
 * Sell to open option contracts (short selling options)
 *
 * @param client - The AlpacaClient instance
 * @param symbol - Option contract symbol
 * @param qty - Number of contracts
 * @param limitPrice - Optional limit price (market order if not provided)
 * @param timeInForce - Time in force (default: day)
 * @returns The created order
 *
 * @example
 * const order = await sellToOpen(client, 'AAPL230120P00140000', 5, 1.50);
 */
async function sellToOpen(client, symbol, qty, limitPrice, timeInForce = 'day') {
    return createOptionOrder(client, {
        symbol,
        qty,
        side: 'sell',
        type: limitPrice !== undefined ? 'limit' : 'market',
        limitPrice,
        positionIntent: 'sell_to_open',
        timeInForce,
    });
}
/**
 * Buy to close option contracts (closing short options)
 *
 * @param client - The AlpacaClient instance
 * @param symbol - Option contract symbol
 * @param qty - Number of contracts
 * @param limitPrice - Optional limit price (market order if not provided)
 * @param timeInForce - Time in force (default: day)
 * @returns The created order
 *
 * @example
 * const order = await buyToClose(client, 'AAPL230120P00140000', 5, 0.50);
 */
async function buyToClose(client, symbol, qty, limitPrice, timeInForce = 'day') {
    return createOptionOrder(client, {
        symbol,
        qty,
        side: 'buy',
        type: limitPrice !== undefined ? 'limit' : 'market',
        limitPrice,
        positionIntent: 'buy_to_close',
        timeInForce,
    });
}
// ============================================================================
// Multi-Leg Option Orders
// ============================================================================
/**
 * Validate multi-leg order parameters
 *
 * @param params - Multi-leg order parameters
 * @returns Validation result with errors and warnings
 */
function validateMultiLegOrder(params) {
    const errors = [];
    const warnings = [];
    // Check legs count
    if (!params.legs || params.legs.length < 2) {
        errors.push('Multi-leg orders require at least 2 legs');
    }
    if (params.legs && params.legs.length > 4) {
        errors.push('Multi-leg orders support a maximum of 4 legs');
    }
    // Validate order class
    if (params.order_class !== 'mleg') {
        errors.push("Order class must be 'mleg' for multi-leg orders");
    }
    // Validate quantity
    const qty = parseFloat(params.qty);
    if (isNaN(qty) || qty <= 0) {
        errors.push('Quantity must be a positive number');
    }
    // Validate limit price for limit orders
    if (params.type === 'limit' && !params.limit_price) {
        errors.push('Limit price is required for limit orders');
    }
    // Validate each leg
    if (params.legs) {
        const seenSymbols = new Set();
        for (let i = 0; i < params.legs.length; i++) {
            const leg = params.legs[i];
            if (!leg.symbol) {
                errors.push(`Leg ${i + 1}: Symbol is required`);
            }
            if (!leg.ratio_qty) {
                errors.push(`Leg ${i + 1}: Ratio quantity is required`);
            }
            else {
                const ratioQty = parseFloat(leg.ratio_qty);
                if (isNaN(ratioQty) || ratioQty <= 0) {
                    errors.push(`Leg ${i + 1}: Ratio quantity must be a positive number`);
                }
            }
            if (!['buy', 'sell'].includes(leg.side)) {
                errors.push(`Leg ${i + 1}: Side must be 'buy' or 'sell'`);
            }
            if (!['buy_to_open', 'buy_to_close', 'sell_to_open', 'sell_to_close'].includes(leg.position_intent)) {
                errors.push(`Leg ${i + 1}: Invalid position intent`);
            }
            // Check for duplicate symbols
            if (leg.symbol && seenSymbols.has(leg.symbol)) {
                warnings.push(`Leg ${i + 1}: Duplicate symbol ${leg.symbol} found`);
            }
            if (leg.symbol) {
                seenSymbols.add(leg.symbol);
            }
        }
    }
    return {
        isValid: errors.length === 0,
        errors,
        warnings,
    };
}
/**
 * Create a multi-leg option order (spreads, straddles, etc.)
 *
 * @param client - The AlpacaClient instance
 * @param params - Multi-leg order parameters
 * @returns The created order
 * @throws Error if validation fails or order creation fails
 *
 * @example
 * // Create a vertical call spread
 * const order = await createMultiLegOptionOrder(client, {
 *   order_class: 'mleg',
 *   qty: '1',
 *   type: 'limit',
 *   limit_price: '1.50',
 *   time_in_force: 'day',
 *   legs: [
 *     {
 *       symbol: 'AAPL230120C00150000',
 *       ratio_qty: '1',
 *       side: 'buy',
 *       position_intent: 'buy_to_open',
 *     },
 *     {
 *       symbol: 'AAPL230120C00155000',
 *       ratio_qty: '1',
 *       side: 'sell',
 *       position_intent: 'sell_to_open',
 *     },
 *   ],
 * });
 */
async function createMultiLegOptionOrder(client, params) {
    const legSymbols = params.legs.map((l) => l.symbol).join(', ');
    log$7(`Creating multi-leg option order: ${params.qty}x [${legSymbols}]`, {
        type: 'info',
        metadata: { legsCount: params.legs.length, type: params.type },
    });
    // Validate parameters
    const validation = validateMultiLegOrder(params);
    if (!validation.isValid) {
        const errorMsg = `Multi-leg order validation failed: ${validation.errors.join('; ')}`;
        log$7(errorMsg, { type: 'error', metadata: { errors: validation.errors } });
        throw new Error(errorMsg);
    }
    if (validation.warnings.length > 0) {
        log$7(`Multi-leg order warnings: ${validation.warnings.join('; ')}`, {
            type: 'warn',
            metadata: { warnings: validation.warnings },
        });
    }
    try {
        const sdk = client.getSDK();
        const orderParams = {
            order_class: params.order_class,
            qty: params.qty,
            type: params.type,
            time_in_force: params.time_in_force,
            legs: params.legs,
        };
        if (params.limit_price) {
            orderParams.limit_price = params.limit_price;
        }
        const order = await sdk.createOrder(orderParams);
        log$7(`Multi-leg option order created: ${order.id}`, {
            type: 'info',
            metadata: {
                orderId: order.id,
                status: order.status,
                legsCount: params.legs.length,
            },
        });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$7(`Failed to create multi-leg option order: ${errorMessage}`, {
            type: 'error',
            metadata: { params },
        });
        throw new Error(`Failed to create multi-leg option order: ${errorMessage}`);
    }
}
// ============================================================================
// Spread Order Helpers
// ============================================================================
/**
 * Create a vertical spread (bull call spread or bear put spread)
 *
 * @param client - The AlpacaClient instance
 * @param longSymbol - Symbol of the long leg
 * @param shortSymbol - Symbol of the short leg
 * @param qty - Number of spreads
 * @param limitPrice - Net debit or credit for the spread
 * @param timeInForce - Time in force (default: day)
 * @returns The created order
 *
 * @example
 * // Bull call spread: buy lower strike call, sell higher strike call
 * const order = await createVerticalSpread(
 *   client,
 *   'AAPL230120C00150000', // Long leg
 *   'AAPL230120C00155000', // Short leg
 *   5,
 *   1.50 // Net debit
 * );
 */
async function createVerticalSpread$1(client, longSymbol, shortSymbol, qty, limitPrice, timeInForce = 'day') {
    log$7(`Creating vertical spread: ${qty}x ${longSymbol} / ${shortSymbol}`, {
        type: 'info',
        metadata: { limitPrice },
    });
    const params = {
        order_class: 'mleg',
        qty: qty.toString(),
        type: limitPrice !== undefined ? 'limit' : 'market',
        time_in_force: timeInForce,
        legs: [
            {
                symbol: longSymbol,
                ratio_qty: '1',
                side: 'buy',
                position_intent: 'buy_to_open',
            },
            {
                symbol: shortSymbol,
                ratio_qty: '1',
                side: 'sell',
                position_intent: 'sell_to_open',
            },
        ],
    };
    if (limitPrice !== undefined) {
        params.limit_price = limitPrice.toString();
    }
    return createMultiLegOptionOrder(client, params);
}
/**
 * Create an iron condor spread
 *
 * @param client - The AlpacaClient instance
 * @param putLongSymbol - Lower strike put (buy)
 * @param putShortSymbol - Higher strike put (sell)
 * @param callShortSymbol - Lower strike call (sell)
 * @param callLongSymbol - Higher strike call (buy)
 * @param qty - Number of iron condors
 * @param limitPrice - Net credit for the iron condor
 * @param timeInForce - Time in force (default: day)
 * @returns The created order
 *
 * @example
 * const order = await createIronCondor(
 *   client,
 *   'AAPL230120P00140000', // Buy put
 *   'AAPL230120P00145000', // Sell put
 *   'AAPL230120C00155000', // Sell call
 *   'AAPL230120C00160000', // Buy call
 *   5,
 *   2.00 // Net credit
 * );
 */
async function createIronCondor$1(client, putLongSymbol, putShortSymbol, callShortSymbol, callLongSymbol, qty, limitPrice, timeInForce = 'day') {
    log$7(`Creating iron condor: ${qty}x contracts`, {
        type: 'info',
        metadata: { putLongSymbol, putShortSymbol, callShortSymbol, callLongSymbol, limitPrice },
    });
    const params = {
        order_class: 'mleg',
        qty: qty.toString(),
        type: limitPrice !== undefined ? 'limit' : 'market',
        time_in_force: timeInForce,
        legs: [
            {
                symbol: putLongSymbol,
                ratio_qty: '1',
                side: 'buy',
                position_intent: 'buy_to_open',
            },
            {
                symbol: putShortSymbol,
                ratio_qty: '1',
                side: 'sell',
                position_intent: 'sell_to_open',
            },
            {
                symbol: callShortSymbol,
                ratio_qty: '1',
                side: 'sell',
                position_intent: 'sell_to_open',
            },
            {
                symbol: callLongSymbol,
                ratio_qty: '1',
                side: 'buy',
                position_intent: 'buy_to_open',
            },
        ],
    };
    if (limitPrice !== undefined) {
        params.limit_price = limitPrice.toString();
    }
    return createMultiLegOptionOrder(client, params);
}
/**
 * Create a straddle (buy both call and put at same strike)
 *
 * @param client - The AlpacaClient instance
 * @param callSymbol - Call option symbol
 * @param putSymbol - Put option symbol
 * @param qty - Number of straddles
 * @param limitPrice - Net debit for the straddle
 * @param timeInForce - Time in force (default: day)
 * @returns The created order
 *
 * @example
 * const order = await createStraddle(
 *   client,
 *   'AAPL230120C00150000',
 *   'AAPL230120P00150000',
 *   5,
 *   6.00 // Net debit
 * );
 */
async function createStraddle$1(client, callSymbol, putSymbol, qty, limitPrice, timeInForce = 'day') {
    log$7(`Creating straddle: ${qty}x ${callSymbol} + ${putSymbol}`, {
        type: 'info',
        metadata: { limitPrice },
    });
    const params = {
        order_class: 'mleg',
        qty: qty.toString(),
        type: limitPrice !== undefined ? 'limit' : 'market',
        time_in_force: timeInForce,
        legs: [
            {
                symbol: callSymbol,
                ratio_qty: '1',
                side: 'buy',
                position_intent: 'buy_to_open',
            },
            {
                symbol: putSymbol,
                ratio_qty: '1',
                side: 'buy',
                position_intent: 'buy_to_open',
            },
        ],
    };
    if (limitPrice !== undefined) {
        params.limit_price = limitPrice.toString();
    }
    return createMultiLegOptionOrder(client, params);
}
/**
 * Create a strangle (buy OTM call and OTM put at different strikes)
 *
 * @param client - The AlpacaClient instance
 * @param callSymbol - OTM call option symbol
 * @param putSymbol - OTM put option symbol
 * @param qty - Number of strangles
 * @param limitPrice - Net debit for the strangle
 * @param timeInForce - Time in force (default: day)
 * @returns The created order
 */
async function createStrangle$1(client, callSymbol, putSymbol, qty, limitPrice, timeInForce = 'day') {
    log$7(`Creating strangle: ${qty}x ${callSymbol} + ${putSymbol}`, {
        type: 'info',
        metadata: { limitPrice },
    });
    const params = {
        order_class: 'mleg',
        qty: qty.toString(),
        type: limitPrice !== undefined ? 'limit' : 'market',
        time_in_force: timeInForce,
        legs: [
            {
                symbol: callSymbol,
                ratio_qty: '1',
                side: 'buy',
                position_intent: 'buy_to_open',
            },
            {
                symbol: putSymbol,
                ratio_qty: '1',
                side: 'buy',
                position_intent: 'buy_to_open',
            },
        ],
    };
    if (limitPrice !== undefined) {
        params.limit_price = limitPrice.toString();
    }
    return createMultiLegOptionOrder(client, params);
}
// ============================================================================
// Position Management
// ============================================================================
/**
 * Close an option position
 *
 * @param client - The AlpacaClient instance
 * @param symbol - Option contract symbol
 * @param options - Optional close parameters
 * @returns The close order
 * @throws Error if position not found or close fails
 *
 * @example
 * // Close entire position with market order
 * const order = await closeOptionPosition(client, 'AAPL230120C00150000');
 *
 * @example
 * // Close partial position with limit order
 * const order = await closeOptionPosition(client, 'AAPL230120C00150000', {
 *   qty: 2,
 *   limitPrice: 3.00,
 * });
 */
async function closeOptionPosition(client, symbol, options) {
    log$7(`Closing option position: ${symbol}`, {
        type: 'info',
        symbol,
        metadata: options,
    });
    try {
        const sdk = client.getSDK();
        // First get the current position to determine side and quantity
        let position;
        try {
            position = await sdk.getPosition(symbol);
        }
        catch (error) {
            throw new Error(`No position found for ${symbol}`);
        }
        const positionQty = Math.abs(parseFloat(position.qty));
        const closeQty = options?.qty ?? positionQty;
        if (closeQty > positionQty) {
            throw new Error(`Close quantity (${closeQty}) exceeds position quantity (${positionQty})`);
        }
        // Determine the correct side and intent based on current position
        const isLong = position.side === 'long';
        const side = isLong ? 'sell' : 'buy';
        const positionIntent = isLong ? 'sell_to_close' : 'buy_to_close';
        const order = await createOptionOrder(client, {
            symbol,
            qty: closeQty,
            side,
            type: options?.limitPrice !== undefined ? 'limit' : 'market',
            limitPrice: options?.limitPrice,
            positionIntent,
            timeInForce: options?.timeInForce || 'day',
        });
        log$7(`Option position close order created: ${order.id}`, {
            type: 'info',
            symbol,
            metadata: {
                orderId: order.id,
                closeQty,
                remainingQty: positionQty - closeQty,
            },
        });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$7(`Failed to close option position ${symbol}: ${errorMessage}`, {
            type: 'error',
            symbol,
        });
        throw new Error(`Failed to close option position: ${errorMessage}`);
    }
}
/**
 * Close all option positions
 *
 * @param client - The AlpacaClient instance
 * @returns Result containing orders and any failures
 *
 * @example
 * const result = await closeAllOptionPositions(client);
 * console.log(`Closed ${result.orders.length} positions`);
 * if (result.failed.length > 0) {
 *   console.log(`Failed to close: ${result.failed.map(f => f.symbol).join(', ')}`);
 * }
 */
async function closeAllOptionPositions(client) {
    log$7('Closing all option positions', { type: 'info' });
    const result = {
        orders: [],
        failed: [],
        totalProcessed: 0,
    };
    try {
        const sdk = client.getSDK();
        // Get all positions and filter for options
        const positions = await sdk.getPositions();
        const optionPositions = positions.filter((p) => p.asset_class === 'us_option');
        result.totalProcessed = optionPositions.length;
        if (optionPositions.length === 0) {
            log$7('No option positions to close', { type: 'info' });
            return result;
        }
        log$7(`Found ${optionPositions.length} option positions to close`, {
            type: 'info',
            metadata: { symbols: optionPositions.map((p) => p.symbol) },
        });
        // Close each position
        for (const position of optionPositions) {
            try {
                const order = await closeOptionPosition(client, position.symbol);
                result.orders.push(order);
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                result.failed.push({
                    symbol: position.symbol,
                    error: errorMessage,
                });
                log$7(`Failed to close position ${position.symbol}: ${errorMessage}`, {
                    type: 'warn',
                    symbol: position.symbol,
                });
            }
        }
        log$7(`Closed ${result.orders.length} option positions, ${result.failed.length} failed`, {
            type: 'info',
            metadata: {
                closed: result.orders.length,
                failed: result.failed.length,
            },
        });
        return result;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$7(`Failed to close all option positions: ${errorMessage}`, { type: 'error' });
        throw new Error(`Failed to close all option positions: ${errorMessage}`);
    }
}
/**
 * Exercise an option contract
 * Note: Exercise is only available for American-style options before expiration
 *
 * @param client - The AlpacaClient instance
 * @param symbol - Option contract symbol
 * @param qty - Number of contracts to exercise (defaults to full position)
 * @throws Error if exercise fails
 *
 * @example
 * // Exercise all contracts in position
 * await exerciseOption(client, 'AAPL230120C00150000');
 *
 * @example
 * // Exercise specific quantity
 * await exerciseOption(client, 'AAPL230120C00150000', 5);
 */
async function exerciseOption(client, symbol, qty) {
    log$7(`Exercising option: ${symbol}${qty ? ` (qty: ${qty})` : ''}`, {
        type: 'info',
        symbol,
    });
    try {
        const sdk = client.getSDK();
        // Get current position
        let position;
        try {
            position = await sdk.getPosition(symbol);
        }
        catch (error) {
            throw new Error(`No position found for ${symbol}`);
        }
        // Verify it's a long position (can't exercise short options)
        if (position.side !== 'long') {
            throw new Error('Can only exercise long option positions');
        }
        const positionQty = Math.abs(parseFloat(position.qty));
        const exerciseQty = qty ?? positionQty;
        if (exerciseQty > positionQty) {
            throw new Error(`Exercise quantity (${exerciseQty}) exceeds position quantity (${positionQty})`);
        }
        // Call the exercise endpoint using direct API
        const endpoint = `/positions/${encodeURIComponent(symbol)}/exercise`;
        const body = {};
        if (qty !== undefined) {
            body.qty = qty.toString();
        }
        await client.makeRequest(endpoint, 'POST', Object.keys(body).length > 0 ? body : undefined);
        log$7(`Option exercised: ${symbol} (${exerciseQty} contracts)`, {
            type: 'info',
            symbol,
            metadata: { exerciseQty },
        });
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$7(`Failed to exercise option ${symbol}: ${errorMessage}`, {
            type: 'error',
            symbol,
        });
        throw new Error(`Failed to exercise option: ${errorMessage}`);
    }
}
// ============================================================================
// Order Status Helpers
// ============================================================================
/**
 * Check if an option order is in a terminal state
 *
 * @param status - The order status
 * @returns True if the order is in a terminal state
 */
function isOptionOrderTerminal(status) {
    const terminalStates = ['filled', 'canceled', 'expired', 'rejected'];
    return terminalStates.includes(status);
}
/**
 * Check if an option order can be canceled
 *
 * @param status - The order status
 * @returns True if the order can be canceled
 */
function isOptionOrderCancelable(status) {
    const cancelableStates = ['new', 'partially_filled', 'accepted', 'pending_new'];
    return cancelableStates.includes(status);
}
// ============================================================================
// Default Export
// ============================================================================
var orders$1 = {
    // Single-leg orders
    createOptionOrder,
    buyToOpen,
    sellToClose,
    sellToOpen,
    buyToClose,
    // Multi-leg orders
    validateMultiLegOrder,
    createMultiLegOptionOrder,
    createVerticalSpread: createVerticalSpread$1,
    createIronCondor: createIronCondor$1,
    createStraddle: createStraddle$1,
    createStrangle: createStrangle$1,
    // Position management
    closeOptionPosition,
    closeAllOptionPositions,
    exerciseOption,
    // Order status helpers
    isOptionOrderTerminal,
    isOptionOrderCancelable,
};

var optionOrders = /*#__PURE__*/Object.freeze({
    __proto__: null,
    buyToClose: buyToClose,
    buyToOpen: buyToOpen,
    closeAllOptionPositions: closeAllOptionPositions,
    closeOptionPosition: closeOptionPosition,
    createIronCondor: createIronCondor$1,
    createMultiLegOptionOrder: createMultiLegOptionOrder,
    createOptionOrder: createOptionOrder,
    createStraddle: createStraddle$1,
    createStrangle: createStrangle$1,
    createVerticalSpread: createVerticalSpread$1,
    default: orders$1,
    exerciseOption: exerciseOption,
    isOptionOrderCancelable: isOptionOrderCancelable,
    isOptionOrderTerminal: isOptionOrderTerminal,
    sellToClose: sellToClose,
    sellToOpen: sellToOpen,
    validateMultiLegOrder: validateMultiLegOrder
});

const LOG_SOURCE$4 = 'AlpacaOrders';
/**
 * Internal logging helper with consistent source
 */
const log$6 = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: LOG_SOURCE$4 });
};
/**
 * Creates a new order using the Alpaca SDK.
 * Supports market, limit, stop, and stop_limit order types.
 *
 * @param client - The AlpacaClient instance
 * @param params - Order parameters including symbol, qty, side, type, and time_in_force
 * @returns The created order object
 * @throws Error if order creation fails
 *
 * @example
 * // Create a market order
 * const order = await createOrder(client, {
 *   symbol: 'AAPL',
 *   qty: '10',
 *   side: 'buy',
 *   type: 'market',
 *   time_in_force: 'day',
 * });
 *
 * @example
 * // Create a limit order
 * const order = await createOrder(client, {
 *   symbol: 'AAPL',
 *   qty: '10',
 *   side: 'buy',
 *   type: 'limit',
 *   limit_price: '150.00',
 *   time_in_force: 'gtc',
 * });
 */
async function createOrder(client, params) {
    const { symbol, qty, side, type } = params;
    log$6(`Creating ${type} order: ${side} ${qty || params.notional} ${symbol}`, {
        type: 'info',
        symbol,
    });
    try {
        const sdk = client.getSDK();
        const order = await sdk.createOrder(params);
        log$6(`Order created successfully: ${order.id}`, {
            type: 'info',
            symbol,
            metadata: {
                orderId: order.id,
                status: order.status,
                type: order.type,
                side: order.side,
            },
        });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$6(`Failed to create order for ${symbol}: ${errorMessage}`, {
            type: 'error',
            symbol,
            metadata: { params },
        });
        throw new Error(`Failed to create ${type} order for ${symbol}: ${errorMessage}`);
    }
}
/**
 * Retrieves a specific order by its ID.
 *
 * @param client - The AlpacaClient instance
 * @param orderId - The unique identifier of the order
 * @returns The order object if found
 * @throws Error if order is not found or request fails
 *
 * @example
 * const order = await getOrder(client, 'order-uuid-here');
 * console.log(`Order status: ${order.status}`);
 */
async function getOrder(client, orderId) {
    log$6(`Fetching order: ${orderId}`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const order = await sdk.getOrder(orderId);
        log$6(`Order retrieved: ${orderId} (${order.status})`, {
            type: 'debug',
            symbol: order.symbol,
        });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$6(`Failed to fetch order ${orderId}: ${errorMessage}`, { type: 'error' });
        throw new Error(`Failed to fetch order ${orderId}: ${errorMessage}`);
    }
}
/**
 * Retrieves all orders matching the specified filters.
 *
 * @param client - The AlpacaClient instance
 * @param params - Optional filter parameters
 * @param params.status - Filter by order status: 'open', 'closed', or 'all'
 * @param params.limit - Maximum number of orders to return (default: 50, max: 500)
 * @param params.after - Filter orders created after this timestamp (RFC-3339 format)
 * @param params.until - Filter orders created before this timestamp (RFC-3339 format)
 * @param params.direction - Sort direction: 'asc' or 'desc' (default: 'desc')
 * @param params.nested - Include nested orders (for bracket orders)
 * @param params.symbols - Filter by specific symbols
 * @param params.side - Filter by order side: 'buy' or 'sell'
 * @returns Array of orders matching the filters
 *
 * @example
 * // Get all open orders
 * const openOrders = await getOrders(client, { status: 'open' });
 *
 * @example
 * // Get recent orders for specific symbols
 * const orders = await getOrders(client, {
 *   symbols: ['AAPL', 'GOOGL'],
 *   limit: 100,
 * });
 */
async function getOrders(client, params = {}) {
    const filterDescription = params.status || 'all';
    log$6(`Fetching orders (status: ${filterDescription})`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        // Build query parameters for the SDK
        const queryParams = {};
        if (params.status)
            queryParams.status = params.status;
        if (params.limit)
            queryParams.limit = params.limit;
        if (params.after)
            queryParams.after = params.after;
        if (params.until)
            queryParams.until = params.until;
        if (params.direction)
            queryParams.direction = params.direction;
        if (params.nested !== undefined)
            queryParams.nested = params.nested;
        if (params.symbols && params.symbols.length > 0) {
            queryParams.symbols = params.symbols.join(',');
        }
        if (params.side)
            queryParams.side = params.side;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const orders = await sdk.getOrders(queryParams);
        log$6(`Retrieved ${orders.length} orders`, {
            type: 'debug',
            metadata: { count: orders.length, status: filterDescription },
        });
        return orders;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$6(`Failed to fetch orders: ${errorMessage}`, { type: 'error' });
        throw new Error(`Failed to fetch orders: ${errorMessage}`);
    }
}
/**
 * Cancels a specific order by its ID.
 * Only orders that are 'new', 'partially_filled', or 'accepted' can be canceled.
 *
 * @param client - The AlpacaClient instance
 * @param orderId - The unique identifier of the order to cancel
 * @throws Error if order cannot be canceled (e.g., already filled or canceled)
 *
 * @example
 * await cancelOrder(client, 'order-uuid-here');
 * console.log('Order canceled successfully');
 */
async function cancelOrder(client, orderId) {
    log$6(`Canceling order: ${orderId}`, { type: 'info' });
    try {
        const sdk = client.getSDK();
        await sdk.cancelOrder(orderId);
        log$6(`Order canceled successfully: ${orderId}`, { type: 'info' });
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        // Check for specific error conditions
        if (errorMessage.includes('422') || errorMessage.includes('not cancelable')) {
            log$6(`Order ${orderId} is not cancelable (may already be filled or canceled)`, {
                type: 'warn',
            });
            throw new Error(`Order ${orderId} is not cancelable`);
        }
        if (errorMessage.includes('404') || errorMessage.includes('not found')) {
            log$6(`Order ${orderId} not found`, { type: 'error' });
            throw new Error(`Order ${orderId} not found`);
        }
        log$6(`Failed to cancel order ${orderId}: ${errorMessage}`, { type: 'error' });
        throw new Error(`Failed to cancel order ${orderId}: ${errorMessage}`);
    }
}
/**
 * Cancels all open orders.
 * This operation is atomic - if any cancellation fails, the function continues
 * with remaining orders and returns information about failures.
 *
 * @param client - The AlpacaClient instance
 * @returns Object containing count of canceled orders and any failures
 *
 * @example
 * const result = await cancelAllOrders(client);
 * console.log(`Canceled ${result.canceled} orders`);
 * if (result.failed.length > 0) {
 *   console.log(`Failed to cancel: ${result.failed.join(', ')}`);
 * }
 */
async function cancelAllOrders(client) {
    log$6('Canceling all open orders', { type: 'info' });
    try {
        const sdk = client.getSDK();
        const result = await sdk.cancelAllOrders();
        // The SDK returns an array of canceled order statuses
        const canceled = Array.isArray(result) ? result.length : 0;
        const failed = [];
        // Check for any failures in the response
        if (Array.isArray(result)) {
            result.forEach((item) => {
                if (item.status && item.status >= 400 && item.id) {
                    failed.push(item.id);
                }
            });
        }
        log$6(`Canceled ${canceled} orders${failed.length > 0 ? `, ${failed.length} failed` : ''}`, {
            type: 'info',
            metadata: { canceled, failed: failed.length },
        });
        return { canceled, failed };
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$6(`Failed to cancel all orders: ${errorMessage}`, { type: 'error' });
        throw new Error(`Failed to cancel all orders: ${errorMessage}`);
    }
}
/**
 * Replaces (modifies) an existing order with new parameters.
 * Only pending orders can be replaced. The order must not be filled.
 *
 * Common use cases:
 * - Update the quantity of an order
 * - Change the limit price
 * - Adjust the stop price
 * - Update trailing stop parameters
 *
 * @param client - The AlpacaClient instance
 * @param orderId - The unique identifier of the order to replace
 * @param params - New order parameters (qty, limit_price, stop_price, trail, time_in_force, client_order_id)
 * @returns The new order object that replaces the original
 * @throws Error if order cannot be replaced
 *
 * @example
 * // Update limit price
 * const newOrder = await replaceOrder(client, 'order-id', {
 *   limit_price: '155.00',
 * });
 *
 * @example
 * // Update quantity and price
 * const newOrder = await replaceOrder(client, 'order-id', {
 *   qty: '20',
 *   limit_price: '152.50',
 * });
 */
async function replaceOrder(client, orderId, params) {
    const updateDescription = Object.keys(params).join(', ');
    log$6(`Replacing order ${orderId} (updating: ${updateDescription})`, { type: 'info' });
    try {
        const sdk = client.getSDK();
        const newOrder = await sdk.replaceOrder(orderId, params);
        log$6(`Order replaced successfully: ${orderId} -> ${newOrder.id}`, {
            type: 'info',
            symbol: newOrder.symbol,
            metadata: {
                oldOrderId: orderId,
                newOrderId: newOrder.id,
                status: newOrder.status,
            },
        });
        return newOrder;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        // Check for specific error conditions
        if (errorMessage.includes('422')) {
            log$6(`Order ${orderId} cannot be replaced (may already be filled)`, {
                type: 'error',
            });
            throw new Error(`Order ${orderId} cannot be replaced: order may already be filled or canceled`);
        }
        if (errorMessage.includes('404')) {
            log$6(`Order ${orderId} not found`, { type: 'error' });
            throw new Error(`Order ${orderId} not found`);
        }
        log$6(`Failed to replace order ${orderId}: ${errorMessage}`, { type: 'error' });
        throw new Error(`Failed to replace order ${orderId}: ${errorMessage}`);
    }
}
/**
 * Convenience function to get all open orders.
 *
 * @param client - The AlpacaClient instance
 * @param symbols - Optional array of symbols to filter by
 * @returns Array of open orders
 *
 * @example
 * const openOrders = await getOpenOrders(client);
 * console.log(`Found ${openOrders.length} open orders`);
 */
async function getOpenOrders(client, symbols) {
    return getOrders(client, { status: 'open', symbols });
}
/**
 * Convenience function to check if an order is in a terminal state.
 * Terminal states are: filled, canceled, expired, rejected
 *
 * @param status - The order status to check
 * @returns True if the order is in a terminal state
 *
 * @example
 * const order = await getOrder(client, 'order-id');
 * if (isOrderTerminal(order.status)) {
 *   console.log('Order is complete');
 * }
 */
function isOrderTerminal(status) {
    const terminalStates = ['filled', 'canceled', 'expired', 'rejected'];
    return terminalStates.includes(status);
}
/**
 * Convenience function to check if an order can be canceled.
 * Orders can be canceled if they are: new, partially_filled, accepted, pending_new
 *
 * @param status - The order status to check
 * @returns True if the order can be canceled
 *
 * @example
 * const order = await getOrder(client, 'order-id');
 * if (isOrderCancelable(order.status)) {
 *   await cancelOrder(client, order.id);
 * }
 */
function isOrderCancelable(status) {
    const cancelableStates = ['new', 'partially_filled', 'accepted', 'pending_new'];
    return cancelableStates.includes(status);
}
/**
 * Gets an order by client order ID.
 * Useful when you need to track orders using your own identifiers.
 *
 * @param client - The AlpacaClient instance
 * @param clientOrderId - Your custom order identifier
 * @returns The order if found
 * @throws Error if order is not found
 *
 * @example
 * const order = await getOrderByClientId(client, 'my-custom-order-123');
 */
async function getOrderByClientId(client, clientOrderId) {
    log$6(`Fetching order by client_order_id: ${clientOrderId}`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const order = await sdk.getOrderByClientId(clientOrderId);
        log$6(`Order retrieved by client_order_id: ${clientOrderId} -> ${order.id}`, {
            type: 'debug',
            symbol: order.symbol,
        });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$6(`Failed to fetch order by client_order_id ${clientOrderId}: ${errorMessage}`, {
            type: 'error',
        });
        throw new Error(`Failed to fetch order by client_order_id ${clientOrderId}: ${errorMessage}`);
    }
}

var trading = /*#__PURE__*/Object.freeze({
    __proto__: null,
    cancelAllOrders: cancelAllOrders,
    cancelOrder: cancelOrder,
    createOrder: createOrder,
    getOpenOrders: getOpenOrders,
    getOrder: getOrder,
    getOrderByClientId: getOrderByClientId,
    getOrders: getOrders,
    isOrderCancelable: isOrderCancelable,
    isOrderTerminal: isOrderTerminal,
    replaceOrder: replaceOrder
});

const LOG_SOURCE$3 = 'OptionsStrategies';
/**
 * Internal logging helper with consistent source
 */
const log$5 = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: LOG_SOURCE$3 });
};
/**
 * Error class for option strategy operations
 */
class OptionStrategyError extends Error {
    code;
    strategy;
    details;
    constructor(message, code, strategy, details) {
        super(message);
        this.code = code;
        this.strategy = strategy;
        this.details = details;
        this.name = 'OptionStrategyError';
    }
}
/**
 * Build an OCC-compliant option symbol
 * Format: ROOT + YYMMDD + C/P + Strike (8 digits with 3 decimals)
 */
function buildOptionSymbol(underlying, expirationDate, type, strike) {
    const root = underlying.toUpperCase().padEnd(6, ' ').substring(0, 6).replace(/ /g, '');
    const paddedRoot = root.padEnd(6, ' ');
    // Parse expiration date
    const expDate = new Date(expirationDate);
    const year = expDate.getFullYear().toString().slice(-2);
    const month = (expDate.getMonth() + 1).toString().padStart(2, '0');
    const day = expDate.getDate().toString().padStart(2, '0');
    const dateStr = `${year}${month}${day}`;
    // Type indicator
    const typeChar = type === 'call' ? 'C' : 'P';
    // Strike price: 8 digits, 3 decimal places implied
    // e.g., $150.00 -> 00150000
    const strikeInt = Math.round(strike * 1000);
    const strikeStr = strikeInt.toString().padStart(8, '0');
    return `${paddedRoot}${dateStr}${typeChar}${strikeStr}`;
}
/**
 * Create a vertical spread (call or put spread)
 * - Bull Call Spread: Buy lower strike call, sell higher strike call
 * - Bear Call Spread: Sell lower strike call, buy higher strike call
 * - Bull Put Spread: Sell higher strike put, buy lower strike put
 * - Bear Put Spread: Buy higher strike put, sell lower strike put
 */
async function createVerticalSpread(client, params) {
    const { underlying, expirationDate, type, longStrike, shortStrike, qty, direction, limitPrice, timeInForce = 'day', } = params;
    // Validate strikes
    if (longStrike === shortStrike) {
        throw new OptionStrategyError('Long and short strikes must be different', 'INVALID_STRIKES', 'vertical_spread');
    }
    log$5(`Creating ${direction} ${type} spread on ${underlying}: ${longStrike}/${shortStrike} x${qty}`, {
        type: 'info',
        symbol: underlying,
    });
    // Build option symbols
    const longSymbol = buildOptionSymbol(underlying, expirationDate, type, longStrike);
    const shortSymbol = buildOptionSymbol(underlying, expirationDate, type, shortStrike);
    // Determine position intents based on direction
    const longIntent = direction === 'debit' ? 'buy_to_open' : 'sell_to_close';
    const shortIntent = direction === 'debit' ? 'sell_to_open' : 'buy_to_close';
    // Build multi-leg order
    const legs = [
        {
            symbol: longSymbol,
            ratio_qty: '1',
            side: direction === 'debit' ? 'buy' : 'sell',
            position_intent: longIntent,
        },
        {
            symbol: shortSymbol,
            ratio_qty: '1',
            side: direction === 'debit' ? 'sell' : 'buy',
            position_intent: shortIntent,
        },
    ];
    const orderParams = {
        order_class: 'mleg',
        qty: qty.toString(),
        type: limitPrice !== undefined ? 'limit' : 'market',
        time_in_force: timeInForce,
        legs,
    };
    if (limitPrice !== undefined) {
        orderParams.limit_price = limitPrice.toFixed(2);
    }
    try {
        const sdk = client.getSDK();
        const order = await sdk.createOrder(orderParams);
        log$5(`Vertical spread order created: ${order.id}`, {
            type: 'info',
            symbol: underlying,
            metadata: { orderId: order.id, status: order.status },
        });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$5(`Failed to create vertical spread: ${errorMessage}`, { type: 'error', symbol: underlying });
        throw new OptionStrategyError(`Failed to create vertical spread: ${errorMessage}`, 'ORDER_FAILED', 'vertical_spread', error);
    }
}
/**
 * Create an iron condor
 * Combines a bull put spread and a bear call spread
 * - Buy put at putLongStrike (lowest)
 * - Sell put at putShortStrike
 * - Sell call at callShortStrike
 * - Buy call at callLongStrike (highest)
 */
async function createIronCondor(client, params) {
    const { underlying, expirationDate, putLongStrike, putShortStrike, callShortStrike, callLongStrike, qty, limitPrice, timeInForce = 'day', } = params;
    // Validate strikes are in order
    if (putLongStrike >= putShortStrike ||
        putShortStrike >= callShortStrike ||
        callShortStrike >= callLongStrike) {
        throw new OptionStrategyError('Strikes must be in ascending order: putLong < putShort < callShort < callLong', 'INVALID_STRIKES', 'iron_condor');
    }
    log$5(`Creating iron condor on ${underlying}: ${putLongStrike}/${putShortStrike}/${callShortStrike}/${callLongStrike} x${qty}`, { type: 'info', symbol: underlying });
    // Build option symbols
    const putLongSymbol = buildOptionSymbol(underlying, expirationDate, 'put', putLongStrike);
    const putShortSymbol = buildOptionSymbol(underlying, expirationDate, 'put', putShortStrike);
    const callShortSymbol = buildOptionSymbol(underlying, expirationDate, 'call', callShortStrike);
    const callLongSymbol = buildOptionSymbol(underlying, expirationDate, 'call', callLongStrike);
    // Iron condor legs (selling the inner strikes, buying the outer strikes)
    const legs = [
        {
            symbol: putLongSymbol,
            ratio_qty: '1',
            side: 'buy',
            position_intent: 'buy_to_open',
        },
        {
            symbol: putShortSymbol,
            ratio_qty: '1',
            side: 'sell',
            position_intent: 'sell_to_open',
        },
        {
            symbol: callShortSymbol,
            ratio_qty: '1',
            side: 'sell',
            position_intent: 'sell_to_open',
        },
        {
            symbol: callLongSymbol,
            ratio_qty: '1',
            side: 'buy',
            position_intent: 'buy_to_open',
        },
    ];
    const orderParams = {
        order_class: 'mleg',
        qty: qty.toString(),
        type: limitPrice !== undefined ? 'limit' : 'market',
        time_in_force: timeInForce,
        legs,
    };
    if (limitPrice !== undefined) {
        orderParams.limit_price = limitPrice.toFixed(2);
    }
    try {
        const sdk = client.getSDK();
        const order = await sdk.createOrder(orderParams);
        log$5(`Iron condor order created: ${order.id}`, {
            type: 'info',
            symbol: underlying,
            metadata: { orderId: order.id, status: order.status },
        });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$5(`Failed to create iron condor: ${errorMessage}`, { type: 'error', symbol: underlying });
        throw new OptionStrategyError(`Failed to create iron condor: ${errorMessage}`, 'ORDER_FAILED', 'iron_condor', error);
    }
}
/**
 * Create a straddle (buy/sell both call and put at same strike)
 * - Long straddle: Buy call and put at same strike (expects high volatility)
 * - Short straddle: Sell call and put at same strike (expects low volatility)
 */
async function createStraddle(client, params) {
    const { underlying, expirationDate, strike, qty, direction, limitPrice, timeInForce = 'day', } = params;
    log$5(`Creating ${direction} straddle on ${underlying} at ${strike} x${qty}`, {
        type: 'info',
        symbol: underlying,
    });
    // Build option symbols
    const callSymbol = buildOptionSymbol(underlying, expirationDate, 'call', strike);
    const putSymbol = buildOptionSymbol(underlying, expirationDate, 'put', strike);
    const side = direction === 'long' ? 'buy' : 'sell';
    const intent = direction === 'long' ? 'buy_to_open' : 'sell_to_open';
    const legs = [
        {
            symbol: callSymbol,
            ratio_qty: '1',
            side,
            position_intent: intent,
        },
        {
            symbol: putSymbol,
            ratio_qty: '1',
            side,
            position_intent: intent,
        },
    ];
    const orderParams = {
        order_class: 'mleg',
        qty: qty.toString(),
        type: limitPrice !== undefined ? 'limit' : 'market',
        time_in_force: timeInForce,
        legs,
    };
    if (limitPrice !== undefined) {
        orderParams.limit_price = limitPrice.toFixed(2);
    }
    try {
        const sdk = client.getSDK();
        const order = await sdk.createOrder(orderParams);
        log$5(`Straddle order created: ${order.id}`, {
            type: 'info',
            symbol: underlying,
            metadata: { orderId: order.id, status: order.status },
        });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$5(`Failed to create straddle: ${errorMessage}`, { type: 'error', symbol: underlying });
        throw new OptionStrategyError(`Failed to create straddle: ${errorMessage}`, 'ORDER_FAILED', 'straddle', error);
    }
}
/**
 * Create a covered call
 * - Buy (or already own) 100 shares per contract
 * - Sell call option against the shares
 */
async function createCoveredCall(client, params) {
    const { underlying, expirationDate, strike, qty, limitPrice, timeInForce = 'day', } = params;
    const sharesNeeded = qty * 100;
    log$5(`Creating covered call on ${underlying}: ${sharesNeeded} shares + sell ${strike} call x${qty}`, {
        type: 'info',
        symbol: underlying,
    });
    // First, check current position
    const sdk = client.getSDK();
    let currentPosition = null;
    try {
        currentPosition = await sdk.getPosition(underlying);
    }
    catch {
        // No existing position
        currentPosition = null;
    }
    const existingShares = currentPosition ? parseInt(currentPosition.qty, 10) : 0;
    const additionalSharesNeeded = sharesNeeded - existingShares;
    let stockOrder;
    // Buy shares if needed
    if (additionalSharesNeeded > 0) {
        log$5(`Buying ${additionalSharesNeeded} additional shares of ${underlying}`, {
            type: 'info',
            symbol: underlying,
        });
        stockOrder = await createOrder(client, {
            symbol: underlying,
            qty: additionalSharesNeeded.toString(),
            side: 'buy',
            type: 'market',
            time_in_force: timeInForce,
        });
    }
    else {
        // Already have enough shares - create a placeholder response
        log$5(`Already have ${existingShares} shares of ${underlying}, no stock purchase needed`, {
            type: 'info',
            symbol: underlying,
        });
        // Return a mock order indicating no purchase was needed
        stockOrder = {
            id: 'existing-position',
            client_order_id: 'existing-position',
            created_at: new Date().toISOString(),
            updated_at: null,
            submitted_at: null,
            filled_at: null,
            expired_at: null,
            canceled_at: null,
            failed_at: null,
            replaced_at: null,
            replaced_by: null,
            replaces: null,
            asset_id: '',
            symbol: underlying,
            asset_class: 'us_equity',
            notional: null,
            qty: existingShares.toString(),
            filled_qty: existingShares.toString(),
            filled_avg_price: currentPosition?.avg_entry_price || '0',
            order_class: 'simple',
            type: 'market',
            side: 'buy',
            time_in_force: timeInForce,
            limit_price: null,
            stop_price: null,
            trail_price: null,
            trail_percent: null,
            hwm: null,
            position_intent: null,
            status: 'filled',
            extended_hours: false,
            legs: null,
        };
    }
    // Sell the call option
    const callSymbol = buildOptionSymbol(underlying, expirationDate, 'call', strike);
    try {
        const optionOrderParams = {
            symbol: callSymbol,
            qty: qty.toString(),
            side: 'sell',
            type: limitPrice !== undefined ? 'limit' : 'market',
            time_in_force: timeInForce,
            position_intent: 'sell_to_open',
            limit_price: limitPrice?.toFixed(2),
        };
        const optionOrder = await sdk.createOrder(optionOrderParams);
        log$5(`Covered call option order created: ${optionOrder.id}`, {
            type: 'info',
            symbol: underlying,
            metadata: { orderId: optionOrder.id, status: optionOrder.status },
        });
        return {
            stockOrder,
            optionOrder: optionOrder,
        };
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$5(`Failed to create covered call option: ${errorMessage}`, { type: 'error', symbol: underlying });
        throw new OptionStrategyError(`Failed to create covered call: ${errorMessage}`, 'ORDER_FAILED', 'covered_call', error);
    }
}
/**
 * Roll an option position to a new expiration/strike
 * Closes the current position and opens a new one
 */
async function rollOptionPosition(client, params) {
    const { currentSymbol, newExpirationDate, newStrike, type, limitPrice, timeInForce = 'day', } = params;
    log$5(`Rolling option position from ${currentSymbol} to ${newStrike} exp ${newExpirationDate}`, {
        type: 'info',
        symbol: currentSymbol,
    });
    // Get current position to determine quantity and side
    const sdk = client.getSDK();
    let currentPosition;
    try {
        currentPosition = await sdk.getPosition(currentSymbol);
    }
    catch (error) {
        throw new OptionStrategyError(`No existing position found for ${currentSymbol}`, 'NO_POSITION', 'roll', error);
    }
    const positionQty = Math.abs(parseInt(currentPosition.qty, 10));
    const isLong = parseInt(currentPosition.qty, 10) > 0;
    // Extract underlying from current symbol (first 1-6 chars before the date)
    const underlying = currentSymbol.replace(/\s+/g, '').substring(0, 6).trim();
    // Build new option symbol
    const newSymbol = buildOptionSymbol(underlying, newExpirationDate, type, newStrike);
    // Create legs for the roll
    // Close current position, open new position
    const legs = [
        {
            symbol: currentSymbol,
            ratio_qty: '1',
            side: isLong ? 'sell' : 'buy',
            position_intent: isLong ? 'sell_to_close' : 'buy_to_close',
        },
        {
            symbol: newSymbol,
            ratio_qty: '1',
            side: isLong ? 'buy' : 'sell',
            position_intent: isLong ? 'buy_to_open' : 'sell_to_open',
        },
    ];
    const orderParams = {
        order_class: 'mleg',
        qty: positionQty.toString(),
        type: limitPrice !== undefined ? 'limit' : 'market',
        time_in_force: timeInForce,
        legs,
    };
    if (limitPrice !== undefined) {
        orderParams.limit_price = limitPrice.toFixed(2);
    }
    try {
        const order = await sdk.createOrder(orderParams);
        log$5(`Roll order created: ${order.id}`, {
            type: 'info',
            symbol: underlying,
            metadata: { orderId: order.id, status: order.status, from: currentSymbol, to: newSymbol },
        });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$5(`Failed to roll position: ${errorMessage}`, { type: 'error', symbol: currentSymbol });
        throw new OptionStrategyError(`Failed to roll position: ${errorMessage}`, 'ORDER_FAILED', 'roll', error);
    }
}
/**
 * Create a strangle (buy/sell call and put at different strikes)
 * - Long strangle: Buy OTM call and OTM put (expects high volatility)
 * - Short strangle: Sell OTM call and OTM put (expects low volatility)
 */
async function createStrangle(client, params) {
    const { underlying, expirationDate, putStrike, callStrike, qty, direction, limitPrice, timeInForce = 'day', } = params;
    // Validate strikes
    if (putStrike >= callStrike) {
        throw new OptionStrategyError('Put strike must be less than call strike for a strangle', 'INVALID_STRIKES', 'strangle');
    }
    log$5(`Creating ${direction} strangle on ${underlying}: ${putStrike}P/${callStrike}C x${qty}`, {
        type: 'info',
        symbol: underlying,
    });
    // Build option symbols
    const callSymbol = buildOptionSymbol(underlying, expirationDate, 'call', callStrike);
    const putSymbol = buildOptionSymbol(underlying, expirationDate, 'put', putStrike);
    const side = direction === 'long' ? 'buy' : 'sell';
    const intent = direction === 'long' ? 'buy_to_open' : 'sell_to_open';
    const legs = [
        {
            symbol: callSymbol,
            ratio_qty: '1',
            side,
            position_intent: intent,
        },
        {
            symbol: putSymbol,
            ratio_qty: '1',
            side,
            position_intent: intent,
        },
    ];
    const orderParams = {
        order_class: 'mleg',
        qty: qty.toString(),
        type: limitPrice !== undefined ? 'limit' : 'market',
        time_in_force: timeInForce,
        legs,
    };
    if (limitPrice !== undefined) {
        orderParams.limit_price = limitPrice.toFixed(2);
    }
    try {
        const sdk = client.getSDK();
        const order = await sdk.createOrder(orderParams);
        log$5(`Strangle order created: ${order.id}`, {
            type: 'info',
            symbol: underlying,
            metadata: { orderId: order.id, status: order.status },
        });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$5(`Failed to create strangle: ${errorMessage}`, { type: 'error', symbol: underlying });
        throw new OptionStrategyError(`Failed to create strangle: ${errorMessage}`, 'ORDER_FAILED', 'strangle', error);
    }
}
/**
 * Create a butterfly spread
 * - Long butterfly: Buy 1 lower, sell 2 middle, buy 1 upper
 * - Expects price to stay near middle strike
 */
async function createButterflySpread(client, params) {
    const { underlying, expirationDate, type, lowerStrike, middleStrike, upperStrike, qty, limitPrice, timeInForce = 'day', } = params;
    // Validate strikes are equally spaced
    if (lowerStrike >= middleStrike ||
        middleStrike >= upperStrike) {
        throw new OptionStrategyError('Strikes must be in ascending order: lower < middle < upper', 'INVALID_STRIKES', 'butterfly');
    }
    const lowerWidth = middleStrike - lowerStrike;
    const upperWidth = upperStrike - middleStrike;
    if (Math.abs(lowerWidth - upperWidth) > 0.01) {
        log$5(`Warning: Butterfly spread has unequal wings (${lowerWidth} vs ${upperWidth})`, {
            type: 'warn',
            symbol: underlying,
        });
    }
    log$5(`Creating butterfly spread on ${underlying}: ${lowerStrike}/${middleStrike}/${upperStrike} ${type} x${qty}`, { type: 'info', symbol: underlying });
    // Build option symbols
    const lowerSymbol = buildOptionSymbol(underlying, expirationDate, type, lowerStrike);
    const middleSymbol = buildOptionSymbol(underlying, expirationDate, type, middleStrike);
    const upperSymbol = buildOptionSymbol(underlying, expirationDate, type, upperStrike);
    // Butterfly: Buy 1 lower, Sell 2 middle, Buy 1 upper
    const legs = [
        {
            symbol: lowerSymbol,
            ratio_qty: '1',
            side: 'buy',
            position_intent: 'buy_to_open',
        },
        {
            symbol: middleSymbol,
            ratio_qty: '2',
            side: 'sell',
            position_intent: 'sell_to_open',
        },
        {
            symbol: upperSymbol,
            ratio_qty: '1',
            side: 'buy',
            position_intent: 'buy_to_open',
        },
    ];
    const orderParams = {
        order_class: 'mleg',
        qty: qty.toString(),
        type: limitPrice !== undefined ? 'limit' : 'market',
        time_in_force: timeInForce,
        legs,
    };
    if (limitPrice !== undefined) {
        orderParams.limit_price = limitPrice.toFixed(2);
    }
    try {
        const sdk = client.getSDK();
        const order = await sdk.createOrder(orderParams);
        log$5(`Butterfly spread order created: ${order.id}`, {
            type: 'info',
            symbol: underlying,
            metadata: { orderId: order.id, status: order.status },
        });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$5(`Failed to create butterfly spread: ${errorMessage}`, { type: 'error', symbol: underlying });
        throw new OptionStrategyError(`Failed to create butterfly spread: ${errorMessage}`, 'ORDER_FAILED', 'butterfly', error);
    }
}
var strategies = {
    buildOptionSymbol,
    createVerticalSpread,
    createIronCondor,
    createStraddle,
    createCoveredCall,
    rollOptionPosition,
    createStrangle,
    createButterflySpread,
};

var optionStrategies = /*#__PURE__*/Object.freeze({
    __proto__: null,
    OptionStrategyError: OptionStrategyError,
    buildOptionSymbol: buildOptionSymbol,
    createButterflySpread: createButterflySpread,
    createCoveredCall: createCoveredCall,
    createIronCondor: createIronCondor,
    createStraddle: createStraddle,
    createStrangle: createStrangle,
    createVerticalSpread: createVerticalSpread,
    default: strategies,
    rollOptionPosition: rollOptionPosition
});

const LOG_SOURCE$2 = 'OptionsData';
/**
 * Internal logging helper with consistent source
 */
const log$4 = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: LOG_SOURCE$2 });
};
/**
 * Error class for options data operations
 */
class OptionsDataError extends Error {
    code;
    symbol;
    details;
    constructor(message, code, symbol, details) {
        super(message);
        this.code = code;
        this.symbol = symbol;
        this.details = details;
        this.name = 'OptionsDataError';
    }
}
/**
 * Base URL for Alpaca options market data API
 */
const OPTIONS_DATA_BASE_URL = 'https://data.alpaca.markets/v1beta1/options';
/**
 * Make an authenticated request to the Alpaca options data API
 */
async function makeOptionsDataRequest(client, endpoint, params = {}) {
    const config = client.getConfig();
    const url = new URL(`${OPTIONS_DATA_BASE_URL}${endpoint}`);
    // Add query parameters
    Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined) {
            url.searchParams.append(key, String(value));
        }
    });
    const response = await fetch(url.toString(), {
        method: 'GET',
        headers: {
            'APCA-API-KEY-ID': config.apiKey,
            'APCA-API-SECRET-KEY': config.apiSecret,
            'Content-Type': 'application/json',
        },
    });
    if (!response.ok) {
        const errorText = await response.text();
        throw new OptionsDataError(`Options data request failed: ${response.status} ${response.statusText}`, 'API_ERROR', undefined, { status: response.status, body: errorText });
    }
    return response.json();
}
/**
 * Get options chain with snapshots for an underlying symbol
 * Returns option contracts with their latest quotes, trades, and Greeks
 */
async function getOptionsChain(client, params) {
    const { underlying_symbol, ...queryParams } = params;
    if (!underlying_symbol) {
        throw new OptionsDataError('Underlying symbol is required', 'INVALID_PARAMS');
    }
    log$4(`Fetching options chain for ${underlying_symbol}`, {
        type: 'debug',
        symbol: underlying_symbol,
    });
    try {
        // Build query parameters
        const apiParams = {
            underlying_symbol,
        };
        if (queryParams.feed)
            apiParams.feed = queryParams.feed;
        if (queryParams.limit)
            apiParams.limit = queryParams.limit;
        if (queryParams.updated_since)
            apiParams.updated_since = queryParams.updated_since;
        if (queryParams.page_token)
            apiParams.page_token = queryParams.page_token;
        if (queryParams.type)
            apiParams.type = queryParams.type;
        if (queryParams.strike_price_gte)
            apiParams.strike_price_gte = queryParams.strike_price_gte;
        if (queryParams.strike_price_lte)
            apiParams.strike_price_lte = queryParams.strike_price_lte;
        if (queryParams.expiration_date)
            apiParams.expiration_date = queryParams.expiration_date;
        if (queryParams.expiration_date_gte)
            apiParams.expiration_date_gte = queryParams.expiration_date_gte;
        if (queryParams.expiration_date_lte)
            apiParams.expiration_date_lte = queryParams.expiration_date_lte;
        if (queryParams.root_symbol)
            apiParams.root_symbol = queryParams.root_symbol;
        const response = await makeOptionsDataRequest(client, '/snapshots', apiParams);
        const snapshotCount = Object.keys(response.snapshots || {}).length;
        log$4(`Retrieved options chain for ${underlying_symbol}: ${snapshotCount} contracts`, {
            type: 'debug',
            symbol: underlying_symbol,
            metadata: { count: snapshotCount },
        });
        return response;
    }
    catch (error) {
        if (error instanceof OptionsDataError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$4(`Failed to fetch options chain for ${underlying_symbol}: ${errorMessage}`, {
            type: 'error',
            symbol: underlying_symbol,
        });
        throw new OptionsDataError(`Failed to fetch options chain: ${errorMessage}`, 'FETCH_ERROR', underlying_symbol, error);
    }
}
/**
 * Get latest option quotes for multiple symbols
 */
async function getLatestOptionsQuotes(client, symbols) {
    if (!symbols || symbols.length === 0) {
        throw new OptionsDataError('At least one symbol is required', 'INVALID_PARAMS');
    }
    const normalizedSymbols = symbols.map((s) => s.toUpperCase().trim()).filter(Boolean);
    log$4(`Fetching latest option quotes for ${normalizedSymbols.length} symbols`, { type: 'debug' });
    try {
        const response = await makeOptionsDataRequest(client, '/quotes/latest', { symbols: normalizedSymbols.join(',') });
        const quotes = new Map();
        if (response.quotes) {
            Object.entries(response.quotes).forEach(([symbol, quote]) => {
                quotes.set(symbol, quote);
            });
        }
        log$4(`Retrieved ${quotes.size} option quotes`, {
            type: 'debug',
            metadata: { count: quotes.size },
        });
        return quotes;
    }
    catch (error) {
        if (error instanceof OptionsDataError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$4(`Failed to fetch option quotes: ${errorMessage}`, { type: 'error' });
        throw new OptionsDataError(`Failed to fetch option quotes: ${errorMessage}`, 'FETCH_ERROR', undefined, error);
    }
}
/**
 * Get latest option trades for multiple symbols
 */
async function getLatestOptionsTrades(client, symbols) {
    if (!symbols || symbols.length === 0) {
        throw new OptionsDataError('At least one symbol is required', 'INVALID_PARAMS');
    }
    const normalizedSymbols = symbols.map((s) => s.toUpperCase().trim()).filter(Boolean);
    log$4(`Fetching latest option trades for ${normalizedSymbols.length} symbols`, { type: 'debug' });
    try {
        const response = await makeOptionsDataRequest(client, '/trades/latest', { symbols: normalizedSymbols.join(',') });
        const trades = new Map();
        if (response.trades) {
            Object.entries(response.trades).forEach(([symbol, trade]) => {
                trades.set(symbol, trade);
            });
        }
        log$4(`Retrieved ${trades.size} option trades`, {
            type: 'debug',
            metadata: { count: trades.size },
        });
        return trades;
    }
    catch (error) {
        if (error instanceof OptionsDataError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$4(`Failed to fetch option trades: ${errorMessage}`, { type: 'error' });
        throw new OptionsDataError(`Failed to fetch option trades: ${errorMessage}`, 'FETCH_ERROR', undefined, error);
    }
}
/**
 * Get option snapshots with Greeks for multiple symbols
 */
async function getOptionsSnapshots(client, symbols) {
    if (!symbols || symbols.length === 0) {
        throw new OptionsDataError('At least one symbol is required', 'INVALID_PARAMS');
    }
    const normalizedSymbols = symbols.map((s) => s.toUpperCase().trim()).filter(Boolean);
    log$4(`Fetching option snapshots for ${normalizedSymbols.length} symbols`, { type: 'debug' });
    try {
        const response = await makeOptionsDataRequest(client, '/snapshots', { symbols: normalizedSymbols.join(',') });
        const snapshots = new Map();
        if (response.snapshots) {
            Object.entries(response.snapshots).forEach(([symbol, snapshot]) => {
                snapshots.set(symbol, snapshot);
            });
        }
        log$4(`Retrieved ${snapshots.size} option snapshots`, {
            type: 'debug',
            metadata: { count: snapshots.size },
        });
        return snapshots;
    }
    catch (error) {
        if (error instanceof OptionsDataError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$4(`Failed to fetch option snapshots: ${errorMessage}`, { type: 'error' });
        throw new OptionsDataError(`Failed to fetch option snapshots: ${errorMessage}`, 'FETCH_ERROR', undefined, error);
    }
}
/**
 * Get historical option bars (OHLCV data)
 */
async function getHistoricalOptionsBars(client, params) {
    const { symbols, timeframe, start, end, limit } = params;
    if (!symbols || symbols.length === 0) {
        throw new OptionsDataError('At least one symbol is required', 'INVALID_PARAMS');
    }
    const normalizedSymbols = symbols.map((s) => s.toUpperCase().trim()).filter(Boolean);
    log$4(`Fetching historical option bars for ${normalizedSymbols.length} symbols (${timeframe})`, {
        type: 'debug',
    });
    try {
        const apiParams = {
            symbols: normalizedSymbols.join(','),
            timeframe,
        };
        if (start)
            apiParams.start = start.toISOString();
        if (end)
            apiParams.end = end.toISOString();
        if (limit)
            apiParams.limit = limit;
        const response = await makeOptionsDataRequest(client, '/bars', apiParams);
        const bars = new Map();
        if (response.bars) {
            Object.entries(response.bars).forEach(([symbol, symbolBars]) => {
                bars.set(symbol, symbolBars);
            });
        }
        const totalBars = Array.from(bars.values()).reduce((sum, b) => sum + b.length, 0);
        log$4(`Retrieved ${totalBars} option bars for ${bars.size} symbols`, {
            type: 'debug',
            metadata: { symbolCount: bars.size, barCount: totalBars },
        });
        return bars;
    }
    catch (error) {
        if (error instanceof OptionsDataError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$4(`Failed to fetch historical option bars: ${errorMessage}`, { type: 'error' });
        throw new OptionsDataError(`Failed to fetch historical option bars: ${errorMessage}`, 'FETCH_ERROR', undefined, error);
    }
}
/**
 * Calculate implied volatility from option price (simplified approximation)
 * For production use, consider using a proper Black-Scholes solver
 */
function approximateImpliedVolatility(optionPrice, underlyingPrice, strike, daysToExpiration, riskFreeRate = 0.05, isCall = true) {
    // Simplified IV approximation using Brenner-Subrahmanyam formula
    // IV ~ (optionPrice / underlyingPrice) * sqrt(2 * pi / T)
    const T = daysToExpiration / 365;
    if (T <= 0)
        return 0;
    // Intrinsic value
    const intrinsic = isCall
        ? Math.max(0, underlyingPrice - strike)
        : Math.max(0, strike - underlyingPrice);
    // Time value
    const timeValue = optionPrice - intrinsic;
    if (timeValue <= 0)
        return 0;
    // Simplified approximation
    const iv = (timeValue / underlyingPrice) * Math.sqrt((2 * Math.PI) / T);
    return Math.min(Math.max(iv, 0), 5); // Cap between 0% and 500%
}
/**
 * Calculate option moneyness
 */
function calculateMoneyness(underlyingPrice, strike, isCall) {
    const threshold = 0.02; // 2% threshold for ATM
    const ratio = underlyingPrice / strike;
    if (Math.abs(ratio - 1) <= threshold) {
        return 'ATM';
    }
    if (isCall) {
        return ratio > 1 ? 'ITM' : 'OTM';
    }
    else {
        return ratio < 1 ? 'ITM' : 'OTM';
    }
}
/**
 * Find ATM (at-the-money) strikes from an options chain
 */
function findATMStrikes(snapshots, underlyingPrice) {
    let closestStrike = 0;
    let minDiff = Infinity;
    // Parse all symbols to find closest strike
    for (const symbol of snapshots.keys()) {
        const strikeMatch = symbol.match(/(\d{8})$/);
        if (strikeMatch) {
            const strike = parseInt(strikeMatch[1], 10) / 1000;
            const diff = Math.abs(strike - underlyingPrice);
            if (diff < minDiff) {
                minDiff = diff;
                closestStrike = strike;
            }
        }
    }
    // Find call and put at this strike
    let callSymbol = null;
    let putSymbol = null;
    for (const symbol of snapshots.keys()) {
        const strikeMatch = symbol.match(/(\d{8})$/);
        if (strikeMatch) {
            const strike = parseInt(strikeMatch[1], 10) / 1000;
            if (Math.abs(strike - closestStrike) < 0.01) {
                if (symbol.includes('C')) {
                    callSymbol = symbol;
                }
                else if (symbol.includes('P')) {
                    putSymbol = symbol;
                }
            }
        }
    }
    return { callSymbol, putSymbol, strike: closestStrike };
}
/**
 * Calculate put/call ratio from options chain
 */
function calculatePutCallRatio(snapshots) {
    let callVolume = 0;
    let putVolume = 0;
    let callOI = 0;
    let putOI = 0;
    for (const [symbol, snapshot] of snapshots) {
        const isCall = symbol.includes('C');
        const volume = snapshot.latestTrade?.s || 0;
        const oi = snapshot.openInterest || 0;
        if (isCall) {
            callVolume += volume;
            callOI += oi;
        }
        else {
            putVolume += volume;
            putOI += oi;
        }
    }
    return {
        volumeRatio: callVolume > 0 ? putVolume / callVolume : 0,
        openInterestRatio: callOI > 0 ? putOI / callOI : 0,
    };
}
/**
 * Get option Greeks from a snapshot
 */
function extractGreeks(snapshot) {
    if (!snapshot.greeks) {
        return null;
    }
    return {
        delta: snapshot.greeks.delta,
        gamma: snapshot.greeks.gamma,
        theta: snapshot.greeks.theta,
        vega: snapshot.greeks.vega,
        rho: snapshot.greeks.rho,
    };
}
/**
 * Filter options chain by expiration date range
 */
function filterByExpiration(snapshots, minDays, maxDays) {
    const now = new Date();
    const filtered = new Map();
    for (const [symbol, snapshot] of snapshots) {
        // Extract expiration date from symbol (format: ROOT + YYMMDD + C/P + Strike)
        const dateMatch = symbol.match(/(\d{6})[CP]/);
        if (dateMatch) {
            const dateStr = dateMatch[1];
            const year = 2000 + parseInt(dateStr.substring(0, 2), 10);
            const month = parseInt(dateStr.substring(2, 4), 10) - 1;
            const day = parseInt(dateStr.substring(4, 6), 10);
            const expDate = new Date(year, month, day);
            const daysToExp = Math.ceil((expDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
            if (daysToExp >= minDays && daysToExp <= maxDays) {
                filtered.set(symbol, snapshot);
            }
        }
    }
    return filtered;
}
/**
 * Filter options chain by strike price range
 */
function filterByStrike(snapshots, minStrike, maxStrike) {
    const filtered = new Map();
    for (const [symbol, snapshot] of snapshots) {
        // Extract strike from symbol (last 8 digits, 3 decimal places)
        const strikeMatch = symbol.match(/(\d{8})$/);
        if (strikeMatch) {
            const strike = parseInt(strikeMatch[1], 10) / 1000;
            if (strike >= minStrike && strike <= maxStrike) {
                filtered.set(symbol, snapshot);
            }
        }
    }
    return filtered;
}
/**
 * Filter options chain by option type
 */
function filterByType(snapshots, type) {
    const filtered = new Map();
    const typeChar = type === 'call' ? 'C' : 'P';
    for (const [symbol, snapshot] of snapshots) {
        if (symbol.includes(typeChar)) {
            filtered.set(symbol, snapshot);
        }
    }
    return filtered;
}
/**
 * Get the bid-ask spread for an option
 */
function getOptionSpread(quote) {
    const spread = quote.ap - quote.bp;
    const midPrice = (quote.ap + quote.bp) / 2;
    const spreadPercent = midPrice > 0 ? (spread / midPrice) * 100 : 0;
    return { spread, spreadPercent, midPrice };
}
/**
 * Check if an option has sufficient liquidity
 */
function hasGoodLiquidity(snapshot, maxSpreadPercent = 10, minOpenInterest = 100) {
    // Check open interest
    if ((snapshot.openInterest || 0) < minOpenInterest) {
        return false;
    }
    // Check bid-ask spread
    if (snapshot.latestQuote) {
        const { spreadPercent } = getOptionSpread(snapshot.latestQuote);
        if (spreadPercent > maxSpreadPercent) {
            return false;
        }
    }
    return true;
}
var data$1 = {
    getOptionsChain,
    getLatestOptionsQuotes,
    getLatestOptionsTrades,
    getOptionsSnapshots,
    getHistoricalOptionsBars,
    approximateImpliedVolatility,
    calculateMoneyness,
    findATMStrikes,
    calculatePutCallRatio,
    extractGreeks,
    filterByExpiration,
    filterByStrike,
    filterByType,
    getOptionSpread,
    hasGoodLiquidity,
};

var optionData = /*#__PURE__*/Object.freeze({
    __proto__: null,
    OptionsDataError: OptionsDataError,
    approximateImpliedVolatility: approximateImpliedVolatility,
    calculateMoneyness: calculateMoneyness,
    calculatePutCallRatio: calculatePutCallRatio,
    default: data$1,
    extractGreeks: extractGreeks,
    filterByExpiration: filterByExpiration,
    filterByStrike: filterByStrike,
    filterByType: filterByType,
    findATMStrikes: findATMStrikes,
    getHistoricalOptionsBars: getHistoricalOptionsBars,
    getLatestOptionsQuotes: getLatestOptionsQuotes,
    getLatestOptionsTrades: getLatestOptionsTrades,
    getOptionSpread: getOptionSpread,
    getOptionsChain: getOptionsChain,
    getOptionsSnapshots: getOptionsSnapshots,
    hasGoodLiquidity: hasGoodLiquidity
});

const LOG_SOURCE$1 = 'CryptoOrders';
/**
 * Internal logging helper with consistent source
 */
const log$3 = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: LOG_SOURCE$1 });
};
/**
 * Error thrown when crypto order operations fail
 */
class CryptoOrderError extends Error {
    code;
    symbol;
    details;
    constructor(message, code, symbol, details) {
        super(message);
        this.code = code;
        this.symbol = symbol;
        this.details = details;
        this.name = 'CryptoOrderError';
    }
}
/**
 * Normalize crypto symbol to Alpaca format
 * Ensures proper formatting (e.g., 'BTCUSD' -> 'BTC/USD')
 */
function normalizeCryptoSymbol$1(symbol) {
    // If already in format 'XXX/YYY', return as is
    if (symbol.includes('/')) {
        return symbol.toUpperCase();
    }
    // Handle common formats like 'BTCUSD' -> 'BTC/USD'
    const upperSymbol = symbol.toUpperCase();
    // Check for common quote currencies
    const quoteCurrencies = ['USD', 'USDT', 'USDC', 'BTC'];
    for (const quote of quoteCurrencies) {
        if (upperSymbol.endsWith(quote)) {
            const base = upperSymbol.slice(0, -quote.length);
            if (base.length > 0) {
                return `${base}/${quote}`;
            }
        }
    }
    // Default: assume USD quote
    return `${upperSymbol}/USD`;
}
/**
 * Validate crypto order parameters
 */
function validateCryptoOrderParams(params) {
    if (!params.symbol) {
        throw new CryptoOrderError('Symbol is required', 'MISSING_SYMBOL');
    }
    if (params.qty === undefined && params.notional === undefined) {
        throw new CryptoOrderError('Either qty or notional is required', 'MISSING_QUANTITY', params.symbol);
    }
    if (params.qty !== undefined && params.notional !== undefined) {
        throw new CryptoOrderError('Cannot specify both qty and notional', 'INVALID_QUANTITY', params.symbol);
    }
    if (params.qty !== undefined && params.qty <= 0) {
        throw new CryptoOrderError('Quantity must be positive', 'INVALID_QUANTITY', params.symbol);
    }
    if (params.notional !== undefined && params.notional <= 0) {
        throw new CryptoOrderError('Notional must be positive', 'INVALID_NOTIONAL', params.symbol);
    }
    if ((params.type === 'limit' || params.type === 'stop_limit') && !params.limitPrice) {
        throw new CryptoOrderError('Limit price required for limit orders', 'MISSING_LIMIT_PRICE', params.symbol);
    }
    if ((params.type === 'stop' || params.type === 'stop_limit') && !params.stopPrice) {
        throw new CryptoOrderError('Stop price required for stop orders', 'MISSING_STOP_PRICE', params.symbol);
    }
}
/**
 * Create a crypto order
 * Crypto trading is available 24/7 on Alpaca
 *
 * @param client - The AlpacaClient instance
 * @param params - Crypto order parameters
 * @returns The created order
 * @throws CryptoOrderError if order creation fails
 *
 * @example
 * // Buy 0.5 BTC at market price
 * const order = await createCryptoOrder(client, {
 *   symbol: 'BTC/USD',
 *   qty: 0.5,
 *   side: 'buy',
 *   type: 'market',
 * });
 *
 * @example
 * // Buy $100 worth of ETH
 * const order = await createCryptoOrder(client, {
 *   symbol: 'ETH/USD',
 *   notional: 100,
 *   side: 'buy',
 *   type: 'market',
 * });
 */
async function createCryptoOrder(client, params) {
    validateCryptoOrderParams(params);
    const normalizedSymbol = normalizeCryptoSymbol$1(params.symbol);
    const { qty, notional, side, type, limitPrice, stopPrice, timeInForce, clientOrderId } = params;
    const qtyDescription = qty !== undefined ? `${qty}` : `$${notional}`;
    log$3(`Creating crypto ${type} order: ${side} ${qtyDescription} ${normalizedSymbol}`, {
        type: 'info',
        symbol: normalizedSymbol,
    });
    try {
        const sdk = client.getSDK();
        // Build order request
        const orderRequest = {
            symbol: normalizedSymbol,
            side,
            type,
            time_in_force: timeInForce || 'gtc', // GTC is typical for crypto
        };
        if (qty !== undefined) {
            orderRequest.qty = qty.toString();
        }
        if (notional !== undefined) {
            orderRequest.notional = notional.toString();
        }
        if (limitPrice !== undefined) {
            orderRequest.limit_price = limitPrice.toString();
        }
        if (stopPrice !== undefined) {
            orderRequest.stop_price = stopPrice.toString();
        }
        if (clientOrderId) {
            orderRequest.client_order_id = clientOrderId;
        }
        const order = await sdk.createOrder(orderRequest);
        log$3(`Crypto order created successfully: ${order.id}`, {
            type: 'info',
            symbol: normalizedSymbol,
            metadata: {
                orderId: order.id,
                status: order.status,
                type: order.type,
                side: order.side,
            },
        });
        return order;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$3(`Failed to create crypto order for ${normalizedSymbol}: ${errorMessage}`, {
            type: 'error',
            symbol: normalizedSymbol,
            metadata: { params },
        });
        throw new CryptoOrderError(`Failed to create crypto ${type} order for ${normalizedSymbol}: ${errorMessage}`, 'ORDER_CREATION_FAILED', normalizedSymbol, error);
    }
}
/**
 * Create a crypto market order
 * Executes immediately at the current market price
 *
 * @param client - The AlpacaClient instance
 * @param symbol - Crypto pair symbol (e.g., 'BTC/USD')
 * @param side - Order side: 'buy' or 'sell'
 * @param qty - Quantity to trade
 * @returns The created order
 *
 * @example
 * const order = await createCryptoMarketOrder(client, 'BTC/USD', 'buy', 0.1);
 */
async function createCryptoMarketOrder(client, symbol, side, qty) {
    return createCryptoOrder(client, {
        symbol,
        qty,
        side,
        type: 'market',
    });
}
/**
 * Create a crypto limit order
 * Executes only at the specified price or better
 *
 * @param client - The AlpacaClient instance
 * @param symbol - Crypto pair symbol (e.g., 'BTC/USD')
 * @param side - Order side: 'buy' or 'sell'
 * @param qty - Quantity to trade
 * @param limitPrice - Maximum (buy) or minimum (sell) price
 * @returns The created order
 *
 * @example
 * // Buy 0.5 BTC at $40,000 or lower
 * const order = await createCryptoLimitOrder(client, 'BTC/USD', 'buy', 0.5, 40000);
 */
async function createCryptoLimitOrder(client, symbol, side, qty, limitPrice) {
    return createCryptoOrder(client, {
        symbol,
        qty,
        side,
        type: 'limit',
        limitPrice,
    });
}
/**
 * Create a crypto stop order
 * Becomes a market order when the stop price is reached
 *
 * @param client - The AlpacaClient instance
 * @param symbol - Crypto pair symbol (e.g., 'BTC/USD')
 * @param side - Order side: 'buy' or 'sell'
 * @param qty - Quantity to trade
 * @param stopPrice - Price at which to trigger the order
 * @returns The created order
 *
 * @example
 * // Sell 0.5 BTC if price drops to $35,000
 * const order = await createCryptoStopOrder(client, 'BTC/USD', 'sell', 0.5, 35000);
 */
async function createCryptoStopOrder(client, symbol, side, qty, stopPrice) {
    return createCryptoOrder(client, {
        symbol,
        qty,
        side,
        type: 'stop',
        stopPrice,
    });
}
/**
 * Create a crypto stop-limit order
 * Becomes a limit order when the stop price is reached
 *
 * @param client - The AlpacaClient instance
 * @param symbol - Crypto pair symbol (e.g., 'BTC/USD')
 * @param side - Order side: 'buy' or 'sell'
 * @param qty - Quantity to trade
 * @param stopPrice - Price at which to trigger the limit order
 * @param limitPrice - Limit price for the resulting order
 * @returns The created order
 *
 * @example
 * // Sell 0.5 BTC when price drops to $35,000, but not below $34,500
 * const order = await createCryptoStopLimitOrder(client, 'BTC/USD', 'sell', 0.5, 35000, 34500);
 */
async function createCryptoStopLimitOrder(client, symbol, side, qty, stopPrice, limitPrice) {
    return createCryptoOrder(client, {
        symbol,
        qty,
        side,
        type: 'stop_limit',
        stopPrice,
        limitPrice,
    });
}
/**
 * Buy crypto with a dollar amount (notional order)
 * Allows purchasing crypto with a specific USD amount
 *
 * @param client - The AlpacaClient instance
 * @param symbol - Crypto pair symbol (e.g., 'BTC/USD')
 * @param dollarAmount - Amount in USD to spend
 * @returns The created order
 *
 * @example
 * // Buy $500 worth of Bitcoin
 * const order = await buyCryptoNotional(client, 'BTC/USD', 500);
 */
async function buyCryptoNotional(client, symbol, dollarAmount) {
    if (dollarAmount <= 0) {
        throw new CryptoOrderError('Dollar amount must be positive', 'INVALID_AMOUNT', symbol);
    }
    return createCryptoOrder(client, {
        symbol,
        notional: dollarAmount,
        side: 'buy',
        type: 'market',
    });
}
/**
 * Sell crypto for a dollar amount (notional order)
 * Allows selling crypto for a specific USD amount
 *
 * @param client - The AlpacaClient instance
 * @param symbol - Crypto pair symbol (e.g., 'BTC/USD')
 * @param dollarAmount - Amount in USD to receive
 * @returns The created order
 *
 * @example
 * // Sell $200 worth of Ethereum
 * const order = await sellCryptoNotional(client, 'ETH/USD', 200);
 */
async function sellCryptoNotional(client, symbol, dollarAmount) {
    if (dollarAmount <= 0) {
        throw new CryptoOrderError('Dollar amount must be positive', 'INVALID_AMOUNT', symbol);
    }
    return createCryptoOrder(client, {
        symbol,
        notional: dollarAmount,
        side: 'sell',
        type: 'market',
    });
}
/**
 * Sell all of a crypto position
 * Closes the entire position for the specified crypto pair
 *
 * @param client - The AlpacaClient instance
 * @param symbol - Crypto pair symbol (e.g., 'BTC/USD')
 * @returns The close order
 * @throws CryptoOrderError if no position exists or close fails
 *
 * @example
 * const order = await sellAllCrypto(client, 'BTC/USD');
 */
async function sellAllCrypto(client, symbol) {
    const normalizedSymbol = normalizeCryptoSymbol$1(symbol);
    log$3(`Closing entire crypto position for ${normalizedSymbol}`, {
        type: 'info',
        symbol: normalizedSymbol,
    });
    try {
        const sdk = client.getSDK();
        // Get current position
        const position = await sdk.getPosition(normalizedSymbol);
        if (!position) {
            throw new CryptoOrderError(`No position found for ${normalizedSymbol}`, 'NO_POSITION', normalizedSymbol);
        }
        const qty = Math.abs(parseFloat(position.qty));
        if (qty === 0) {
            throw new CryptoOrderError(`Position for ${normalizedSymbol} has zero quantity`, 'ZERO_POSITION', normalizedSymbol);
        }
        // Determine side based on position
        const side = position.side === 'long' ? 'sell' : 'buy';
        log$3(`Selling ${qty} of ${normalizedSymbol}`, {
            type: 'info',
            symbol: normalizedSymbol,
        });
        // Create market order to close position
        const order = await createCryptoOrder(client, {
            symbol: normalizedSymbol,
            qty,
            side,
            type: 'market',
        });
        log$3(`Crypto position close order created: ${order.id}`, {
            type: 'info',
            symbol: normalizedSymbol,
            metadata: { orderId: order.id },
        });
        return order;
    }
    catch (error) {
        if (error instanceof CryptoOrderError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        // Check for 404 (no position)
        if (errorMessage.includes('404')) {
            throw new CryptoOrderError(`No position found for ${normalizedSymbol}`, 'NO_POSITION', normalizedSymbol);
        }
        log$3(`Failed to close crypto position for ${normalizedSymbol}: ${errorMessage}`, {
            type: 'error',
            symbol: normalizedSymbol,
        });
        throw new CryptoOrderError(`Failed to close crypto position for ${normalizedSymbol}: ${errorMessage}`, 'CLOSE_FAILED', normalizedSymbol, error);
    }
}
/**
 * Get all open crypto orders
 *
 * @param client - The AlpacaClient instance
 * @param symbols - Optional array of crypto symbols to filter by
 * @returns Array of open crypto orders
 *
 * @example
 * const orders = await getOpenCryptoOrders(client);
 * const btcOrders = await getOpenCryptoOrders(client, ['BTC/USD']);
 */
async function getOpenCryptoOrders(client, symbols) {
    log$3('Fetching open crypto orders', { type: 'debug' });
    try {
        const sdk = client.getSDK();
        // Build query params with proper typing
        const queryParams = {
            status: 'open',
            symbols: symbols && symbols.length > 0 ? symbols.map(normalizeCryptoSymbol$1).join(',') : undefined,
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const orders = (await sdk.getOrders(queryParams));
        // Filter to only crypto orders (asset_class === 'crypto')
        const cryptoOrders = orders.filter((order) => order.asset_class === 'crypto');
        log$3(`Found ${cryptoOrders.length} open crypto orders`, {
            type: 'debug',
            metadata: { count: cryptoOrders.length },
        });
        return cryptoOrders;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$3(`Failed to fetch open crypto orders: ${errorMessage}`, { type: 'error' });
        throw new CryptoOrderError(`Failed to fetch open crypto orders: ${errorMessage}`, 'FETCH_ORDERS_FAILED', undefined, error);
    }
}
/**
 * Cancel all open crypto orders
 *
 * @param client - The AlpacaClient instance
 * @param symbol - Optional specific crypto symbol to cancel orders for
 * @returns Number of orders canceled
 *
 * @example
 * // Cancel all crypto orders
 * const canceled = await cancelAllCryptoOrders(client);
 *
 * // Cancel only BTC orders
 * const canceled = await cancelAllCryptoOrders(client, 'BTC/USD');
 */
async function cancelAllCryptoOrders(client, symbol) {
    log$3(`Canceling ${symbol ? `${symbol} ` : ''}crypto orders`, { type: 'info' });
    try {
        const sdk = client.getSDK();
        // Get open crypto orders
        const symbols = symbol ? [symbol] : undefined;
        const orders = await getOpenCryptoOrders(client, symbols);
        if (orders.length === 0) {
            log$3('No open crypto orders to cancel', { type: 'info' });
            return 0;
        }
        // Cancel each order
        let canceledCount = 0;
        for (const order of orders) {
            try {
                await sdk.cancelOrder(order.id);
                canceledCount++;
            }
            catch (cancelError) {
                const msg = cancelError instanceof Error ? cancelError.message : 'Unknown error';
                log$3(`Failed to cancel order ${order.id}: ${msg}`, { type: 'warn' });
            }
        }
        log$3(`Canceled ${canceledCount} crypto orders`, { type: 'info' });
        return canceledCount;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        log$3(`Failed to cancel crypto orders: ${errorMessage}`, { type: 'error' });
        throw new CryptoOrderError(`Failed to cancel crypto orders: ${errorMessage}`, 'CANCEL_FAILED', symbol, error);
    }
}
/**
 * Check if a symbol is a valid crypto pair
 *
 * @param symbol - Symbol to check
 * @returns true if the symbol appears to be a crypto pair
 */
function isCryptoPair(symbol) {
    const normalized = normalizeCryptoSymbol$1(symbol);
    return normalized.includes('/');
}
var orders = {
    createCryptoOrder,
    createCryptoMarketOrder,
    createCryptoLimitOrder,
    createCryptoStopOrder,
    createCryptoStopLimitOrder,
    buyCryptoNotional,
    sellCryptoNotional,
    sellAllCrypto,
    getOpenCryptoOrders,
    cancelAllCryptoOrders,
    isCryptoPair,
};

var cryptoOrders = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CryptoOrderError: CryptoOrderError,
    buyCryptoNotional: buyCryptoNotional,
    cancelAllCryptoOrders: cancelAllCryptoOrders,
    createCryptoLimitOrder: createCryptoLimitOrder,
    createCryptoMarketOrder: createCryptoMarketOrder,
    createCryptoOrder: createCryptoOrder,
    createCryptoStopLimitOrder: createCryptoStopLimitOrder,
    createCryptoStopOrder: createCryptoStopOrder,
    default: orders,
    getOpenCryptoOrders: getOpenCryptoOrders,
    isCryptoPair: isCryptoPair,
    sellAllCrypto: sellAllCrypto,
    sellCryptoNotional: sellCryptoNotional
});

const LOG_SOURCE = 'CryptoData';
/**
 * Internal logging helper with consistent source
 */
const log$2 = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: LOG_SOURCE });
};
/**
 * Error thrown when crypto data operations fail
 */
class CryptoDataError extends Error {
    code;
    symbol;
    details;
    constructor(message, code, symbol, details) {
        super(message);
        this.code = code;
        this.symbol = symbol;
        this.details = details;
        this.name = 'CryptoDataError';
    }
}
/**
 * Normalize crypto symbol to Alpaca format
 */
function normalizeCryptoSymbol(symbol) {
    if (symbol.includes('/')) {
        return symbol.toUpperCase();
    }
    const upperSymbol = symbol.toUpperCase();
    const quoteCurrencies = ['USD', 'USDT', 'USDC', 'BTC'];
    for (const quote of quoteCurrencies) {
        if (upperSymbol.endsWith(quote)) {
            const base = upperSymbol.slice(0, -quote.length);
            if (base.length > 0) {
                return `${base}/${quote}`;
            }
        }
    }
    return `${upperSymbol}/USD`;
}
/**
 * Convert date to RFC-3339 format string
 */
function toRFC3339(date) {
    if (typeof date === 'string') {
        return date;
    }
    return date.toISOString();
}
/**
 * Get crypto bars (OHLCV data)
 *
 * @param client - AlpacaClient instance
 * @param params - Parameters for fetching bars
 * @returns Map of symbol to array of bars
 *
 * @example
 * const bars = await getCryptoBars(client, {
 *   symbols: ['BTC/USD', 'ETH/USD'],
 *   timeframe: '1Hour',
 *   start: new Date('2024-01-01'),
 *   limit: 100,
 * });
 */
async function getCryptoBars(client, params) {
    const { symbols, timeframe, start, end, limit, sort } = params;
    if (!symbols || symbols.length === 0) {
        throw new CryptoDataError('At least one symbol is required', 'INVALID_SYMBOLS');
    }
    const normalizedSymbols = symbols.map(normalizeCryptoSymbol);
    log$2(`Fetching crypto bars for ${normalizedSymbols.length} symbols with timeframe ${timeframe}`, {
        type: 'debug',
    });
    try {
        const sdk = client.getSDK();
        const options = {
            timeframe,
        };
        if (start) {
            options.start = toRFC3339(start);
        }
        if (end) {
            options.end = toRFC3339(end);
        }
        if (limit) {
            options.limit = limit;
        }
        if (sort) {
            options.sort = sort;
        }
        const result = new Map();
        // Initialize empty arrays for each symbol
        for (const symbol of normalizedSymbols) {
            result.set(symbol, []);
        }
        // Use SDK's getCryptoBars method
        // The SDK returns an async iterator, but TypeScript may not recognize it properly
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const barsResponse = sdk.getCryptoBars(normalizedSymbols, options);
        // Handle both async iterator and direct response formats
        if (barsResponse && typeof barsResponse[Symbol.asyncIterator] === 'function') {
            for await (const bar of barsResponse) {
                const symbol = bar.Symbol;
                const existingBars = result.get(symbol) || [];
                existingBars.push({
                    t: new Date(bar.Timestamp),
                    o: bar.Open,
                    h: bar.High,
                    l: bar.Low,
                    c: bar.Close,
                    v: bar.Volume,
                    n: bar.TradeCount || 0,
                    vw: bar.VWAP || 0,
                });
                result.set(symbol, existingBars);
            }
        }
        else if (barsResponse && barsResponse.then) {
            // Handle Promise response
            const response = await barsResponse;
            if (response && response.bars) {
                for (const [symbol, bars] of Object.entries(response.bars)) {
                    const barArray = bars;
                    result.set(symbol, barArray.map((bar) => ({
                        t: new Date(bar.Timestamp),
                        o: bar.Open,
                        h: bar.High,
                        l: bar.Low,
                        c: bar.Close,
                        v: bar.Volume,
                        n: bar.TradeCount || 0,
                        vw: bar.VWAP || 0,
                    })));
                }
            }
        }
        const totalBars = Array.from(result.values()).reduce((sum, bars) => sum + bars.length, 0);
        log$2(`Successfully fetched ${totalBars} crypto bars for ${normalizedSymbols.length} symbols`, {
            type: 'debug',
        });
        return result;
    }
    catch (error) {
        if (error instanceof CryptoDataError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$2(`Failed to fetch crypto bars: ${errorMessage}`, { type: 'error' });
        throw new CryptoDataError(`Failed to fetch crypto bars: ${errorMessage}`, 'FETCH_ERROR', undefined, error);
    }
}
/**
 * Get latest crypto trades
 *
 * @param client - AlpacaClient instance
 * @param symbols - Array of crypto symbols
 * @returns Map of symbol to latest trade data
 *
 * @example
 * const trades = await getLatestCryptoTrades(client, ['BTC/USD', 'ETH/USD']);
 * const btcTrade = trades.get('BTC/USD');
 * console.log(`BTC last trade: $${btcTrade?.price}`);
 */
async function getLatestCryptoTrades(client, symbols) {
    if (!symbols || symbols.length === 0) {
        throw new CryptoDataError('At least one symbol is required', 'INVALID_SYMBOLS');
    }
    const normalizedSymbols = symbols.map(normalizeCryptoSymbol);
    log$2(`Fetching latest crypto trades for ${normalizedSymbols.length} symbols`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const response = await sdk.getLatestCryptoTrades(normalizedSymbols);
        const result = new Map();
        for (const [symbol, trade] of Object.entries(response)) {
            const t = trade;
            result.set(symbol, {
                price: t.Price,
                size: t.Size,
                timestamp: new Date(t.Timestamp),
                id: t.ID,
                takerSide: t.TakerSide,
            });
        }
        log$2(`Successfully fetched latest trades for ${result.size} crypto symbols`, { type: 'debug' });
        return result;
    }
    catch (error) {
        if (error instanceof CryptoDataError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$2(`Failed to fetch latest crypto trades: ${errorMessage}`, { type: 'error' });
        throw new CryptoDataError(`Failed to fetch latest crypto trades: ${errorMessage}`, 'FETCH_ERROR', undefined, error);
    }
}
/**
 * Get latest crypto quotes
 *
 * @param client - AlpacaClient instance
 * @param symbols - Array of crypto symbols
 * @returns Map of symbol to latest quote data
 *
 * @example
 * const quotes = await getLatestCryptoQuotes(client, ['BTC/USD']);
 * const btcQuote = quotes.get('BTC/USD');
 * console.log(`BTC bid/ask: $${btcQuote?.bid}/$${btcQuote?.ask}`);
 */
async function getLatestCryptoQuotes(client, symbols) {
    if (!symbols || symbols.length === 0) {
        throw new CryptoDataError('At least one symbol is required', 'INVALID_SYMBOLS');
    }
    const normalizedSymbols = symbols.map(normalizeCryptoSymbol);
    log$2(`Fetching latest crypto quotes for ${normalizedSymbols.length} symbols`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const response = await sdk.getLatestCryptoQuotes(normalizedSymbols);
        const result = new Map();
        for (const [symbol, quote] of Object.entries(response)) {
            const q = quote;
            result.set(symbol, {
                bid: q.BidPrice,
                bidSize: q.BidSize,
                ask: q.AskPrice,
                askSize: q.AskSize,
                timestamp: new Date(q.Timestamp),
            });
        }
        log$2(`Successfully fetched latest quotes for ${result.size} crypto symbols`, { type: 'debug' });
        return result;
    }
    catch (error) {
        if (error instanceof CryptoDataError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$2(`Failed to fetch latest crypto quotes: ${errorMessage}`, { type: 'error' });
        throw new CryptoDataError(`Failed to fetch latest crypto quotes: ${errorMessage}`, 'FETCH_ERROR', undefined, error);
    }
}
/**
 * Get the current price for a crypto symbol
 * Uses the latest trade price
 *
 * @param client - AlpacaClient instance
 * @param symbol - Crypto symbol (e.g., 'BTC/USD')
 * @returns Current price
 *
 * @example
 * const btcPrice = await getCryptoPrice(client, 'BTC/USD');
 * console.log(`Bitcoin is currently $${btcPrice.toFixed(2)}`);
 */
async function getCryptoPrice(client, symbol) {
    const normalizedSymbol = normalizeCryptoSymbol(symbol);
    log$2(`Fetching price for ${normalizedSymbol}`, { type: 'debug', symbol: normalizedSymbol });
    const trades = await getLatestCryptoTrades(client, [normalizedSymbol]);
    const trade = trades.get(normalizedSymbol);
    if (!trade) {
        throw new CryptoDataError(`No price data available for ${normalizedSymbol}`, 'NO_DATA', normalizedSymbol);
    }
    return trade.price;
}
/**
 * Get the bid-ask spread for a crypto symbol
 *
 * @param client - AlpacaClient instance
 * @param symbol - Crypto symbol (e.g., 'BTC/USD')
 * @returns Object with bid, ask, spread, and spreadPercent
 *
 * @example
 * const spread = await getCryptoSpread(client, 'BTC/USD');
 * console.log(`BTC spread: $${spread.spread.toFixed(2)} (${spread.spreadPercent.toFixed(4)}%)`);
 */
async function getCryptoSpread(client, symbol) {
    const normalizedSymbol = normalizeCryptoSymbol(symbol);
    log$2(`Fetching spread for ${normalizedSymbol}`, { type: 'debug', symbol: normalizedSymbol });
    const quotes = await getLatestCryptoQuotes(client, [normalizedSymbol]);
    const quote = quotes.get(normalizedSymbol);
    if (!quote) {
        throw new CryptoDataError(`No quote data available for ${normalizedSymbol}`, 'NO_DATA', normalizedSymbol);
    }
    const spread = quote.ask - quote.bid;
    const midPrice = (quote.ask + quote.bid) / 2;
    const spreadPercent = midPrice > 0 ? (spread / midPrice) * 100 : 0;
    return {
        bid: quote.bid,
        ask: quote.ask,
        spread,
        spreadPercent,
    };
}
/**
 * Get crypto snapshots with latest trade, quote, and bar data
 *
 * @param client - AlpacaClient instance
 * @param symbols - Array of crypto symbols
 * @returns Map of symbol to snapshot data
 *
 * @example
 * const snapshots = await getCryptoSnapshots(client, ['BTC/USD', 'ETH/USD']);
 */
async function getCryptoSnapshots(client, symbols) {
    if (!symbols || symbols.length === 0) {
        throw new CryptoDataError('At least one symbol is required', 'INVALID_SYMBOLS');
    }
    const normalizedSymbols = symbols.map(normalizeCryptoSymbol);
    log$2(`Fetching crypto snapshots for ${normalizedSymbols.length} symbols`, { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const response = await sdk.getCryptoSnapshots(normalizedSymbols);
        const result = new Map();
        for (const [symbol, snapshot] of Object.entries(response)) {
            const s = snapshot;
            const cryptoSnapshot = {
                symbol,
            };
            if (s.latestTrade) {
                cryptoSnapshot.latestTrade = {
                    price: s.latestTrade.Price,
                    size: s.latestTrade.Size,
                    timestamp: new Date(s.latestTrade.Timestamp),
                    id: s.latestTrade.ID,
                    takerSide: s.latestTrade.TakerSide,
                };
            }
            if (s.latestQuote) {
                cryptoSnapshot.latestQuote = {
                    bid: s.latestQuote.BidPrice,
                    bidSize: s.latestQuote.BidSize,
                    ask: s.latestQuote.AskPrice,
                    askSize: s.latestQuote.AskSize,
                    timestamp: new Date(s.latestQuote.Timestamp),
                };
            }
            if (s.dailyBar) {
                cryptoSnapshot.dailyBar = {
                    t: new Date(s.dailyBar.Timestamp),
                    o: s.dailyBar.Open,
                    h: s.dailyBar.High,
                    l: s.dailyBar.Low,
                    c: s.dailyBar.Close,
                    v: s.dailyBar.Volume,
                    n: s.dailyBar.TradeCount || 0,
                    vw: s.dailyBar.VWAP || 0,
                };
            }
            if (s.prevDailyBar) {
                cryptoSnapshot.prevDailyBar = {
                    t: new Date(s.prevDailyBar.Timestamp),
                    o: s.prevDailyBar.Open,
                    h: s.prevDailyBar.High,
                    l: s.prevDailyBar.Low,
                    c: s.prevDailyBar.Close,
                    v: s.prevDailyBar.Volume,
                    n: s.prevDailyBar.TradeCount || 0,
                    vw: s.prevDailyBar.VWAP || 0,
                };
            }
            if (s.minuteBar) {
                cryptoSnapshot.minuteBar = {
                    t: new Date(s.minuteBar.Timestamp),
                    o: s.minuteBar.Open,
                    h: s.minuteBar.High,
                    l: s.minuteBar.Low,
                    c: s.minuteBar.Close,
                    v: s.minuteBar.Volume,
                    n: s.minuteBar.TradeCount || 0,
                    vw: s.minuteBar.VWAP || 0,
                };
            }
            result.set(symbol, cryptoSnapshot);
        }
        log$2(`Successfully fetched snapshots for ${result.size} crypto symbols`, { type: 'debug' });
        return result;
    }
    catch (error) {
        if (error instanceof CryptoDataError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$2(`Failed to fetch crypto snapshots: ${errorMessage}`, { type: 'error' });
        throw new CryptoDataError(`Failed to fetch crypto snapshots: ${errorMessage}`, 'FETCH_ERROR', undefined, error);
    }
}
/**
 * Get historical crypto trades
 *
 * @param client - AlpacaClient instance
 * @param symbol - Crypto symbol
 * @param start - Start date/time
 * @param end - Optional end date/time
 * @param limit - Maximum number of trades
 * @returns Array of trades
 *
 * @example
 * const trades = await getCryptoTrades(client, 'BTC/USD', new Date('2024-01-01'), undefined, 100);
 */
async function getCryptoTrades(client, symbol, start, end, limit) {
    const normalizedSymbol = normalizeCryptoSymbol(symbol);
    log$2(`Fetching crypto trades for ${normalizedSymbol}`, { type: 'debug', symbol: normalizedSymbol });
    try {
        const sdk = client.getSDK();
        const options = {
            start: toRFC3339(start),
        };
        if (end) {
            options.end = toRFC3339(end);
        }
        if (limit) {
            options.limit = limit;
        }
        const trades = [];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const tradesResponse = sdk.getCryptoTrades(normalizedSymbol, options);
        // Handle both async iterator and direct response formats
        if (tradesResponse && typeof tradesResponse[Symbol.asyncIterator] === 'function') {
            for await (const trade of tradesResponse) {
                trades.push({
                    price: trade.Price,
                    size: trade.Size,
                    timestamp: new Date(trade.Timestamp),
                    id: trade.ID,
                    takerSide: trade.TakerSide,
                });
                // Respect limit
                if (limit && trades.length >= limit) {
                    break;
                }
            }
        }
        else if (tradesResponse && tradesResponse.then) {
            // Handle Promise response
            const response = await tradesResponse;
            if (response && response.trades) {
                const tradeArray = response.trades;
                for (const trade of tradeArray) {
                    trades.push({
                        price: trade.Price,
                        size: trade.Size,
                        timestamp: new Date(trade.Timestamp),
                        id: trade.ID,
                        takerSide: trade.TakerSide,
                    });
                    // Respect limit
                    if (limit && trades.length >= limit) {
                        break;
                    }
                }
            }
        }
        log$2(`Successfully fetched ${trades.length} crypto trades for ${normalizedSymbol}`, {
            type: 'debug',
            symbol: normalizedSymbol,
        });
        return trades;
    }
    catch (error) {
        if (error instanceof CryptoDataError) {
            throw error;
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        log$2(`Failed to fetch crypto trades: ${errorMessage}`, { type: 'error' });
        throw new CryptoDataError(`Failed to fetch crypto trades: ${errorMessage}`, 'FETCH_ERROR', normalizedSymbol, error);
    }
}
/**
 * Get daily prices for a crypto symbol
 *
 * @param client - AlpacaClient instance
 * @param symbol - Crypto symbol
 * @param days - Number of days of history
 * @returns Array of daily bars
 *
 * @example
 * const dailyBars = await getCryptoDailyPrices(client, 'BTC/USD', 30);
 */
async function getCryptoDailyPrices(client, symbol, days) {
    const normalizedSymbol = normalizeCryptoSymbol(symbol);
    if (days <= 0) {
        throw new CryptoDataError('Days must be a positive number', 'INVALID_DAYS', normalizedSymbol);
    }
    log$2(`Fetching ${days} days of daily prices for ${normalizedSymbol}`, {
        type: 'debug',
        symbol: normalizedSymbol,
    });
    // Calculate start date with buffer
    const start = new Date();
    start.setDate(start.getDate() - Math.ceil(days * 1.5));
    const result = await getCryptoBars(client, {
        symbols: [normalizedSymbol],
        timeframe: '1Day',
        start,
        limit: days,
    });
    const bars = result.get(normalizedSymbol) || [];
    // Return only the requested number of days (most recent)
    if (bars.length > days) {
        return bars.slice(-days);
    }
    return bars;
}
/**
 * Calculate 24-hour price change for a crypto symbol
 *
 * @param client - AlpacaClient instance
 * @param symbol - Crypto symbol
 * @returns Object with current price, previous price, change, and change percent
 *
 * @example
 * const change = await getCrypto24HourChange(client, 'BTC/USD');
 * console.log(`BTC 24h change: ${change.changePercent.toFixed(2)}%`);
 */
async function getCrypto24HourChange(client, symbol) {
    const normalizedSymbol = normalizeCryptoSymbol(symbol);
    log$2(`Calculating 24h change for ${normalizedSymbol}`, {
        type: 'debug',
        symbol: normalizedSymbol,
    });
    const snapshots = await getCryptoSnapshots(client, [normalizedSymbol]);
    const snapshot = snapshots.get(normalizedSymbol);
    if (!snapshot?.latestTrade) {
        throw new CryptoDataError(`No price data available for ${normalizedSymbol}`, 'NO_DATA', normalizedSymbol);
    }
    const currentPrice = snapshot.latestTrade.price;
    let previousPrice = currentPrice;
    // Use previous daily bar close if available
    if (snapshot.prevDailyBar) {
        previousPrice = snapshot.prevDailyBar.c;
    }
    else if (snapshot.dailyBar) {
        previousPrice = snapshot.dailyBar.o; // Use daily open as fallback
    }
    const change = currentPrice - previousPrice;
    const changePercent = previousPrice !== 0 ? (change / previousPrice) * 100 : 0;
    return {
        currentPrice,
        previousPrice,
        change,
        changePercent,
    };
}
// ============================================================================
// Supported Crypto Pairs
// ============================================================================
/**
 * All supported BTC trading pairs
 */
const BTC_PAIRS = ['BCH/BTC', 'ETH/BTC', 'LTC/BTC', 'UNI/BTC'];
/**
 * All supported USDT trading pairs
 */
const USDT_PAIRS = [
    'AAVE/USDT',
    'BCH/USDT',
    'BTC/USDT',
    'DOGE/USDT',
    'ETH/USDT',
    'LINK/USDT',
    'LTC/USDT',
    'SUSHI/USDT',
    'UNI/USDT',
    'YFI/USDT',
];
/**
 * All supported USDC trading pairs
 */
const USDC_PAIRS = [
    'AAVE/USDC',
    'AVAX/USDC',
    'BAT/USDC',
    'BCH/USDC',
    'BTC/USDC',
    'CRV/USDC',
    'DOGE/USDC',
    'DOT/USDC',
    'ETH/USDC',
    'GRT/USDC',
    'LINK/USDC',
    'LTC/USDC',
    'MKR/USDC',
    'SHIB/USDC',
    'SUSHI/USDC',
    'UNI/USDC',
    'XTZ/USDC',
    'YFI/USDC',
];
/**
 * All supported USD trading pairs
 */
const USD_PAIRS = [
    'AAVE/USD',
    'AVAX/USD',
    'BAT/USD',
    'BCH/USD',
    'BTC/USD',
    'CRV/USD',
    'DOGE/USD',
    'DOT/USD',
    'ETH/USD',
    'GRT/USD',
    'LINK/USD',
    'LTC/USD',
    'MKR/USD',
    'SHIB/USD',
    'SUSHI/USD',
    'UNI/USD',
    'USDC/USD',
    'USDT/USD',
    'XTZ/USD',
    'YFI/USD',
];
/**
 * Get all supported crypto pairs
 *
 * @returns Array of all supported crypto trading pairs
 *
 * @example
 * const pairs = getSupportedCryptoPairs();
 * console.log(`${pairs.length} crypto pairs available`);
 */
function getSupportedCryptoPairs() {
    return [...BTC_PAIRS, ...USDT_PAIRS, ...USDC_PAIRS, ...USD_PAIRS];
}
/**
 * Get supported crypto pairs by quote currency
 *
 * @param quoteCurrency - Quote currency ('USD', 'USDC', 'USDT', 'BTC')
 * @returns Array of supported pairs for that quote currency
 *
 * @example
 * const usdPairs = getCryptoPairsByQuote('USD');
 */
function getCryptoPairsByQuote(quoteCurrency) {
    switch (quoteCurrency) {
        case 'USD':
            return USD_PAIRS;
        case 'USDC':
            return USDC_PAIRS;
        case 'USDT':
            return USDT_PAIRS;
        case 'BTC':
            return BTC_PAIRS;
        default:
            return [];
    }
}
/**
 * Check if a crypto pair is supported
 *
 * @param symbol - Crypto pair to check
 * @returns true if the pair is supported
 *
 * @example
 * if (isSupportedCryptoPair('BTC/USD')) {
 *   // Trade BTC
 * }
 */
function isSupportedCryptoPair(symbol) {
    const normalized = normalizeCryptoSymbol(symbol);
    const allPairs = getSupportedCryptoPairs();
    return allPairs.includes(normalized);
}
/**
 * Get popular crypto pairs (most commonly traded)
 *
 * @returns Array of popular crypto trading pairs
 */
function getPopularCryptoPairs() {
    return [
        'BTC/USD',
        'ETH/USD',
        'DOGE/USD',
        'LINK/USD',
        'AVAX/USD',
        'SHIB/USD',
        'LTC/USD',
        'UNI/USD',
    ];
}
var data = {
    getCryptoBars,
    getLatestCryptoTrades,
    getLatestCryptoQuotes,
    getCryptoPrice,
    getCryptoSpread,
    getCryptoSnapshots,
    getCryptoTrades,
    getCryptoDailyPrices,
    getCrypto24HourChange,
    getSupportedCryptoPairs,
    getCryptoPairsByQuote,
    isSupportedCryptoPair,
    getPopularCryptoPairs,
    BTC_PAIRS,
    USDT_PAIRS,
    USDC_PAIRS,
    USD_PAIRS,
};

var cryptoData = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BTC_PAIRS: BTC_PAIRS,
    CryptoDataError: CryptoDataError,
    USDC_PAIRS: USDC_PAIRS,
    USDT_PAIRS: USDT_PAIRS,
    USD_PAIRS: USD_PAIRS,
    default: data,
    getCrypto24HourChange: getCrypto24HourChange,
    getCryptoBars: getCryptoBars,
    getCryptoDailyPrices: getCryptoDailyPrices,
    getCryptoPairsByQuote: getCryptoPairsByQuote,
    getCryptoPrice: getCryptoPrice,
    getCryptoSnapshots: getCryptoSnapshots,
    getCryptoSpread: getCryptoSpread,
    getCryptoTrades: getCryptoTrades,
    getLatestCryptoQuotes: getLatestCryptoQuotes,
    getLatestCryptoTrades: getLatestCryptoTrades,
    getPopularCryptoPairs: getPopularCryptoPairs,
    getSupportedCryptoPairs: getSupportedCryptoPairs,
    isSupportedCryptoPair: isSupportedCryptoPair
});

/**
 * Alpaca WebSocket Streams Module
 * Real-time market data and trade update streams
 *
 * NOTE: This is a placeholder module. Full streaming support requires
 * additional implementation for WebSocket connection management.
 *
 * @module @adaptic/utils/alpaca/streams
 */
/**
 * Create a stream manager for real-time data
 *
 * NOTE: This is a placeholder implementation. Full streaming support
 * requires WebSocket connection management which is available through
 * the Alpaca SDK's built-in streaming capabilities.
 *
 * @param config - Stream manager configuration
 * @returns A stream manager instance
 *
 * @example
 * ```typescript
 * const client = createAlpacaClient({ ... });
 * const streamManager = createStreamManager({
 *   client,
 *   onTrade: (trade) => console.log('Trade:', trade),
 *   onQuote: (quote) => console.log('Quote:', quote),
 *   onError: (error) => console.error('Stream error:', error),
 * });
 *
 * await streamManager.connectDataStream();
 * streamManager.subscribeToTrades(['AAPL', 'GOOGL']);
 * ```
 */
function createStreamManager(_config) {
    // Placeholder implementation
    // The actual implementation would use the Alpaca SDK's WebSocket capabilities
    return {
        connectTradingStream: async () => {
            throw new Error('Stream manager not yet implemented. Use Alpaca SDK streaming directly.');
        },
        connectDataStream: async () => {
            throw new Error('Stream manager not yet implemented. Use Alpaca SDK streaming directly.');
        },
        disconnect: () => {
            // No-op placeholder
        },
        subscribeToTrades: (_symbols) => {
            throw new Error('Stream manager not yet implemented. Use Alpaca SDK streaming directly.');
        },
        subscribeToQuotes: (_symbols) => {
            throw new Error('Stream manager not yet implemented. Use Alpaca SDK streaming directly.');
        },
        subscribeToBars: (_symbols) => {
            throw new Error('Stream manager not yet implemented. Use Alpaca SDK streaming directly.');
        },
        unsubscribe: (_symbols) => {
            // No-op placeholder
        },
    };
}
var streams = {
    createStreamManager,
};

var streams$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createStreamManager: createStreamManager,
    default: streams
});

const log$1 = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: 'SmartOrders' });
};
/**
 * Analyze parameters and determine the best order type
 *
 * Decision logic:
 * - Bracket: Entry + Take Profit + Stop Loss
 * - OCO: Take Profit + Stop Loss (no entry - for existing position)
 * - OTO: Entry + single exit (either TP or SL, not both)
 * - Trailing Stop: Only trailing stop specified
 * - Simple: None of the above
 *
 * @param params - Smart order parameters
 * @returns The recommended order type
 *
 * @example
 * ```typescript
 * const orderType = determineOrderType({
 *   symbol: 'AAPL',
 *   qty: 100,
 *   side: 'buy',
 *   entry: { type: 'limit', limitPrice: 150 },
 *   takeProfit: { limitPrice: 160 },
 *   stopLoss: { stopPrice: 145 },
 * });
 * // Returns: 'bracket'
 * ```
 */
function determineOrderType(params) {
    const hasEntry = !!params.entry;
    const hasTakeProfit = !!params.takeProfit;
    const hasStopLoss = !!params.stopLoss;
    const hasTrailingStop = !!params.trailingStop;
    // Bracket: Entry + Take Profit + Stop Loss
    if (hasEntry && hasTakeProfit && hasStopLoss) {
        return 'bracket';
    }
    // OCO: Take Profit + Stop Loss (no entry - for existing position)
    if (!hasEntry && hasTakeProfit && hasStopLoss) {
        return 'oco';
    }
    // OTO: Entry + single exit (either TP or SL)
    if (hasEntry && (hasTakeProfit !== hasStopLoss)) {
        return 'oto';
    }
    // Trailing Stop
    if (hasTrailingStop) {
        return 'trailing_stop';
    }
    return 'simple';
}
/**
 * Create an executor adapter for bracket orders from AlpacaClient
 */
function createExecutorFromClient(client) {
    const sdk = client.getSDK();
    return {
        createOrder: async (params) => {
            return sdk.createOrder(params);
        },
    };
}
/**
 * Create a smart order based on parameters
 * Automatically selects the appropriate order type based on provided configuration
 *
 * @param client - AlpacaClient instance
 * @param params - Smart order parameters
 * @returns The created order(s) based on the determined order type
 * @throws Error if parameters result in 'simple' order type (use createOrder directly)
 *
 * @example
 * ```typescript
 * // Full bracket order with entry, take profit, and stop loss
 * const result = await createSmartOrder(client, {
 *   symbol: 'AAPL',
 *   qty: 100,
 *   side: 'buy',
 *   entry: { type: 'limit', limitPrice: 150 },
 *   takeProfit: { limitPrice: 160 },
 *   stopLoss: { stopPrice: 145 },
 *   timeInForce: 'gtc',
 * });
 *
 * // OCO for existing position (no entry)
 * const result = await createSmartOrder(client, {
 *   symbol: 'AAPL',
 *   qty: 100,
 *   side: 'sell',
 *   takeProfit: { limitPrice: 160 },
 *   stopLoss: { stopPrice: 145 },
 * });
 *
 * // OTO with entry and stop loss only
 * const result = await createSmartOrder(client, {
 *   symbol: 'AAPL',
 *   qty: 100,
 *   side: 'buy',
 *   entry: { type: 'limit', limitPrice: 150 },
 *   stopLoss: { stopPrice: 145 },
 * });
 *
 * // Trailing stop
 * const result = await createSmartOrder(client, {
 *   symbol: 'AAPL',
 *   qty: 100,
 *   side: 'sell',
 *   trailingStop: { trailPercent: 5 },
 * });
 * ```
 */
async function createSmartOrder(client, params) {
    const orderType = determineOrderType(params);
    log$1(`Creating smart order: ${orderType} for ${params.symbol}`, { type: 'info' });
    log$1(`  Side: ${params.side}, Qty: ${params.qty}`, { type: 'debug' });
    switch (orderType) {
        case 'bracket': {
            const executor = createExecutorFromClient(client);
            return createBracketOrder(executor, {
                symbol: params.symbol,
                qty: params.qty,
                side: params.side,
                type: params.entry.type,
                limitPrice: params.entry.limitPrice,
                takeProfit: params.takeProfit,
                stopLoss: params.stopLoss,
                timeInForce: params.timeInForce,
                extendedHours: params.extendedHours,
            });
        }
        case 'oco': {
            return createOCOOrder(client, {
                symbol: params.symbol,
                qty: params.qty,
                side: params.side,
                takeProfit: params.takeProfit,
                stopLoss: params.stopLoss,
                timeInForce: params.timeInForce,
            });
        }
        case 'oto': {
            // Determine exit side (opposite of entry)
            const exitSide = params.side === 'buy' ? 'sell' : 'buy';
            // Build dependent order based on what's provided (TP or SL)
            const dependent = params.takeProfit
                ? {
                    side: exitSide,
                    type: 'limit',
                    limitPrice: params.takeProfit.limitPrice,
                }
                : {
                    side: exitSide,
                    type: 'stop',
                    stopPrice: params.stopLoss.stopPrice,
                    limitPrice: params.stopLoss.limitPrice,
                };
            return createOTOOrder(client, {
                symbol: params.symbol,
                qty: params.qty,
                side: params.side,
                type: params.entry.type,
                limitPrice: params.entry.limitPrice,
                dependent,
                timeInForce: params.timeInForce,
                extendedHours: params.extendedHours,
            });
        }
        case 'trailing_stop': {
            return createTrailingStop(client, {
                symbol: params.symbol,
                qty: params.qty,
                side: params.side,
                trailPercent: params.trailingStop.trailPercent,
                trailPrice: params.trailingStop.trailPrice,
                timeInForce: params.timeInForce,
                extendedHours: params.extendedHours,
            });
        }
        default:
            throw new Error('Simple orders should use createOrder directly. ' +
                'Smart orders require at least one of: entry+takeProfit+stopLoss (bracket), ' +
                'takeProfit+stopLoss (OCO), entry+takeProfit/stopLoss (OTO), or trailingStop.');
    }
}
/**
 * Quick bracket order with percentage-based take profit and stop loss
 * Calculates TP and SL prices based on percentages from entry price
 *
 * For buy orders:
 * - Take profit is entryPrice + takeProfitPercent
 * - Stop loss is entryPrice - stopLossPercent
 *
 * For sell (short) orders:
 * - Take profit is entryPrice - takeProfitPercent
 * - Stop loss is entryPrice + stopLossPercent
 *
 * @param client - AlpacaClient instance
 * @param params - Percentage bracket parameters
 * @returns The created bracket order result
 *
 * @example
 * ```typescript
 * // Buy AAPL at $150 with 5% take profit ($157.50) and 2% stop loss ($147)
 * const result = await createPercentageBracket(client, {
 *   symbol: 'AAPL',
 *   qty: 100,
 *   side: 'buy',
 *   entryPrice: 150.00,
 *   takeProfitPercent: 5,  // Take profit at $157.50
 *   stopLossPercent: 2,    // Stop loss at $147.00
 *   timeInForce: 'gtc',
 * });
 * ```
 */
async function createPercentageBracket(client, params) {
    const { symbol, qty, side, entryPrice, takeProfitPercent, stopLossPercent, timeInForce = 'gtc', } = params;
    // Multiplier: +1 for buy (profit above, stop below), -1 for sell (profit below, stop above)
    const multiplier = side === 'buy' ? 1 : -1;
    const takeProfitPrice = entryPrice * (1 + (multiplier * takeProfitPercent / 100));
    const stopLossPrice = entryPrice * (1 - (multiplier * stopLossPercent / 100));
    // Round to 2 decimal places for prices >= $1, 4 decimal places for prices < $1
    const roundPrice = (price) => {
        return price >= 1 ? Math.round(price * 100) / 100 : Math.round(price * 10000) / 10000;
    };
    log$1(`Creating percentage bracket for ${symbol}: ` +
        `${side} ${qty} @ $${entryPrice} | ` +
        `TP: ${takeProfitPercent}% ($${roundPrice(takeProfitPrice).toFixed(2)}) | ` +
        `SL: ${stopLossPercent}% ($${roundPrice(stopLossPrice).toFixed(2)})`, { symbol, type: 'info' });
    const executor = createExecutorFromClient(client);
    return createBracketOrder(executor, {
        symbol,
        qty,
        side,
        type: 'limit',
        limitPrice: entryPrice,
        takeProfit: { limitPrice: roundPrice(takeProfitPrice) },
        stopLoss: { stopPrice: roundPrice(stopLossPrice) },
        timeInForce,
    });
}
/**
 * Create a risk-managed position
 * Calculates position size based on risk amount and stop distance
 *
 * Position size formula: riskAmount / abs(entryPrice - stopPrice)
 *
 * @param client - AlpacaClient instance
 * @param params - Risk-managed position parameters
 * @returns The created bracket or OTO order result
 * @throws Error if risk amount is too small for the stop distance
 *
 * @example
 * ```typescript
 * // Risk $500 on AAPL trade with entry at $150 and stop at $145
 * // Position size = $500 / ($150 - $145) = 100 shares
 * const result = await createRiskManagedPosition(client, {
 *   symbol: 'AAPL',
 *   side: 'buy',
 *   entryPrice: 150.00,
 *   stopPrice: 145.00,
 *   riskAmount: 500,
 *   takeProfitPrice: 160.00, // Optional
 *   timeInForce: 'gtc',
 * });
 *
 * // Actual risk: 100 shares * $5 stop distance = $500
 * ```
 */
async function createRiskManagedPosition(client, params) {
    const { symbol, side, entryPrice, stopPrice, riskAmount, takeProfitPrice, timeInForce = 'gtc', } = params;
    const stopDistance = Math.abs(entryPrice - stopPrice);
    const qty = Math.floor(riskAmount / stopDistance);
    if (qty < 1) {
        throw new Error(`Risk amount $${riskAmount.toFixed(2)} is too small for stop distance $${stopDistance.toFixed(2)}. ` +
            `Minimum position size would be 1 share, requiring risk of at least $${stopDistance.toFixed(2)}.`);
    }
    const actualRisk = qty * stopDistance;
    log$1(`Creating risk-managed position for ${symbol}: ` +
        `${side} ${qty} shares @ $${entryPrice} | ` +
        `Stop: $${stopPrice} | ` +
        `Risking: $${actualRisk.toFixed(2)} (target: $${riskAmount.toFixed(2)})`, { symbol, type: 'info' });
    const executor = createExecutorFromClient(client);
    if (takeProfitPrice) {
        // Create full bracket order with TP and SL
        return createBracketOrder(executor, {
            symbol,
            qty,
            side,
            type: 'limit',
            limitPrice: entryPrice,
            takeProfit: { limitPrice: takeProfitPrice },
            stopLoss: { stopPrice },
            timeInForce,
        });
    }
    else {
        // Create OTO order with just stop loss
        const exitSide = side === 'buy' ? 'sell' : 'buy';
        return createOTOOrder(client, {
            symbol,
            qty,
            side,
            type: 'limit',
            limitPrice: entryPrice,
            dependent: {
                side: exitSide,
                type: 'stop',
                stopPrice,
            },
            timeInForce,
        });
    }
}
/**
 * Calculate reward-to-risk ratio for a trade setup
 *
 * @param entryPrice - Entry price
 * @param takeProfitPrice - Take profit price
 * @param stopLossPrice - Stop loss price
 * @param side - Order side ('buy' or 'sell')
 * @returns Reward-to-risk ratio (e.g., 2.5 means 2.5:1 reward:risk)
 *
 * @example
 * ```typescript
 * // Buy at $150, TP at $160, SL at $145
 * const rr = calculateRewardRiskRatio(150, 160, 145, 'buy');
 * // Returns: 2.0 (reward: $10 / risk: $5 = 2:1)
 * ```
 */
function calculateRewardRiskRatio(entryPrice, takeProfitPrice, stopLossPrice, side) {
    let reward;
    let risk;
    if (side === 'buy') {
        reward = takeProfitPrice - entryPrice;
        risk = entryPrice - stopLossPrice;
    }
    else {
        reward = entryPrice - takeProfitPrice;
        risk = stopLossPrice - entryPrice;
    }
    if (risk <= 0) {
        throw new Error('Risk must be positive. Check stop loss placement.');
    }
    if (reward <= 0) {
        throw new Error('Reward must be positive. Check take profit placement.');
    }
    return reward / risk;
}
/**
 * Calculate position size based on account risk percentage
 *
 * @param accountValue - Total account value
 * @param riskPercent - Percentage of account to risk (e.g., 1 = 1%)
 * @param entryPrice - Entry price
 * @param stopPrice - Stop loss price
 * @returns Recommended position size in shares
 *
 * @example
 * ```typescript
 * // $100,000 account, risk 1%, entry at $150, stop at $145
 * const shares = calculatePositionSize(100000, 1, 150, 145);
 * // Returns: 200 (risk $1,000 / $5 per share = 200 shares)
 * ```
 */
function calculatePositionSize(accountValue, riskPercent, entryPrice, stopPrice) {
    const riskAmount = accountValue * (riskPercent / 100);
    const stopDistance = Math.abs(entryPrice - stopPrice);
    if (stopDistance <= 0) {
        throw new Error('Stop distance must be positive');
    }
    return Math.floor(riskAmount / stopDistance);
}
/**
 * Default export with all smart order functions
 */
var smartOrders = {
    // Core functions
    createSmartOrder,
    determineOrderType,
    // Convenience functions
    createPercentageBracket,
    createRiskManagedPosition,
    // Utility functions
    calculateRewardRiskRatio,
    calculatePositionSize,
    // Re-exported from sub-modules
    createBracketOrder,
    createProtectiveBracket,
    createExecutorFromTradingAPI,
    createOCOOrder,
    createOTOOrder,
    createTrailingStop,
    updateTrailingStop,
};

var smartOrders$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    TrailingStopValidationError: TrailingStopValidationError,
    buyWithStopLoss: buyWithStopLoss,
    buyWithTrailingStop: buyWithTrailingStop,
    calculatePositionSize: calculatePositionSize,
    calculateRewardRiskRatio: calculateRewardRiskRatio,
    cancelOCOOrder: cancelOCOOrder,
    cancelOTOOrder: cancelOTOOrder,
    cancelTrailingStop: cancelTrailingStop,
    cancelTrailingStopsForSymbol: cancelTrailingStopsForSymbol,
    createBracketOrder: createBracketOrder,
    createExecutorFromTradingAPI: createExecutorFromTradingAPI,
    createOCOOrder: createOCOOrder,
    createOTOOrder: createOTOOrder,
    createPercentageBracket: createPercentageBracket,
    createPortfolioTrailingStops: createPortfolioTrailingStops,
    createProtectiveBracket: createProtectiveBracket,
    createRiskManagedPosition: createRiskManagedPosition,
    createSmartOrder: createSmartOrder,
    createTrailingStop: createTrailingStop,
    default: smartOrders,
    determineOrderType: determineOrderType,
    entryWithPercentStopLoss: entryWithPercentStopLoss,
    getOCOOrderStatus: getOCOOrderStatus,
    getOTOOrderStatus: getOTOOrderStatus,
    getOpenTrailingStops: getOpenTrailingStops,
    getTrailingStopHWM: getTrailingStopHWM,
    hasActiveTrailingStop: hasActiveTrailingStop,
    limitBuyWithTakeProfit: limitBuyWithTakeProfit,
    protectLongPosition: protectLongPosition,
    protectShortPosition: protectShortPosition,
    shortWithStopLoss: shortWithStopLoss,
    updateTrailingStop: updateTrailingStop
});

const log = (message, options = { type: 'info' }) => {
    log$l(message, { ...options, source: 'Positions' });
};
// ============================================================================
// Helper Functions
// ============================================================================
/**
 * Round a price to the appropriate decimal places for Alpaca
 * Prices >= $1 are rounded to 2 decimal places
 * Prices < $1 are rounded to 4 decimal places
 *
 * @param price - The price to round
 * @returns The rounded price
 *
 * @example
 * roundPriceForAlpaca(123.456) // Returns 123.46
 * roundPriceForAlpaca(0.12345) // Returns 0.1235
 */
function roundPriceForAlpaca(price) {
    return price >= 1 ? Math.round(price * 100) / 100 : Math.round(price * 10000) / 10000;
}
/**
 * Parse numeric string to number, handling null/undefined
 *
 * @param value - The string value to parse
 * @param defaultValue - Default value if parsing fails (default: 0)
 * @returns The parsed number or default value
 */
function parseNumericString(value, defaultValue = 0) {
    if (value === null || value === undefined) {
        return defaultValue;
    }
    const parsed = parseFloat(value);
    return isNaN(parsed) ? defaultValue : parsed;
}
// ============================================================================
// Position Query Functions
// ============================================================================
/**
 * Get all open positions for the account
 *
 * @param client - The Alpaca client instance
 * @returns Array of all open positions
 *
 * @example
 * const client = createAlpacaClient(config);
 * const positions = await getPositions(client);
 * console.log(`Found ${positions.length} open positions`);
 */
async function getPositions(client) {
    log('Fetching all open positions', { type: 'debug' });
    try {
        const sdk = client.getSDK();
        const positions = await sdk.getPositions();
        log(`Retrieved ${positions.length} positions`, { type: 'info' });
        return positions;
    }
    catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        log(`Failed to fetch positions: ${message}`, { type: 'error' });
        throw error;
    }
}
/**
 * Get positions filtered by asset class
 *
 * @param client - The Alpaca client instance
 * @param assetClass - The asset class to filter by ('us_equity', 'us_option', 'crypto')
 * @returns Array of positions matching the asset class
 *
 * @example
 * const equityPositions = await getPositionsByAssetClass(client, 'us_equity');
 * const optionPositions = await getPositionsByAssetClass(client, 'us_option');
 */
async function getPositionsByAssetClass(client, assetClass) {
    log(`Fetching positions for asset class: ${assetClass}`, { type: 'debug' });
    try {
        const positions = await getPositions(client);
        const filtered = positions.filter((position) => position.asset_class === assetClass);
        log(`Found ${filtered.length} ${assetClass} positions`, { type: 'info' });
        return filtered;
    }
    catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        log(`Failed to fetch ${assetClass} positions: ${message}`, { type: 'error' });
        throw error;
    }
}
/**
 * Get a specific position by symbol
 *
 * @param client - The Alpaca client instance
 * @param symbol - The trading symbol to look up
 * @returns The position if found, null otherwise
 *
 * @example
 * const applePosition = await getPosition(client, 'AAPL');
 * if (applePosition) {
 *   console.log(`Holding ${applePosition.qty} shares of AAPL`);
 * }
 */
async function getPosition(client, symbol) {
    log(`Fetching position for symbol: ${symbol}`, { type: 'debug', symbol });
    try {
        const sdk = client.getSDK();
        const position = await sdk.getPosition(symbol);
        log(`Found position for ${symbol}: ${position.qty} shares`, { type: 'info', symbol });
        return position;
    }
    catch (error) {
        // Alpaca returns 404 if no position exists
        if (error instanceof Error && error.message.includes('404')) {
            log(`No position found for ${symbol}`, { type: 'debug', symbol });
            return null;
        }
        const message = error instanceof Error ? error.message : 'Unknown error';
        log(`Failed to fetch position for ${symbol}: ${message}`, { type: 'error', symbol });
        throw error;
    }
}
/**
 * Check if a position exists for a given symbol
 *
 * @param client - The Alpaca client instance
 * @param symbol - The trading symbol to check
 * @returns True if a position exists, false otherwise
 *
 * @example
 * if (await hasPosition(client, 'AAPL')) {
 *   console.log('Already have AAPL position');
 * }
 */
async function hasPosition(client, symbol) {
    const position = await getPosition(client, symbol);
    return position !== null;
}
/**
 * Get the quantity of shares held for a symbol
 *
 * @param client - The Alpaca client instance
 * @param symbol - The trading symbol
 * @returns The quantity held (positive for long, negative for short), 0 if no position
 *
 * @example
 * const qty = await getPositionQty(client, 'AAPL');
 * console.log(`Holding ${qty} shares of AAPL`);
 */
async function getPositionQty(client, symbol) {
    const position = await getPosition(client, symbol);
    if (!position) {
        return 0;
    }
    const qty = parseNumericString(position.qty);
    return position.side === 'short' ? -Math.abs(qty) : qty;
}
/**
 * Get the market value of a position
 *
 * @param client - The Alpaca client instance
 * @param symbol - The trading symbol
 * @returns The market value in dollars, 0 if no position
 *
 * @example
 * const value = await getPositionValue(client, 'AAPL');
 * console.log(`AAPL position worth $${value.toFixed(2)}`);
 */
async function getPositionValue(client, symbol) {
    const position = await getPosition(client, symbol);
    if (!position) {
        return 0;
    }
    return parseNumericString(position.market_value);
}
/**
 * Get the side of a position (long or short)
 *
 * @param client - The Alpaca client instance
 * @param symbol - The trading symbol
 * @returns 'long', 'short', or null if no position
 *
 * @example
 * const side = await getPositionSide(client, 'AAPL');
 * if (side === 'long') {
 *   console.log('Long position in AAPL');
 * }
 */
async function getPositionSide(client, symbol) {
    const position = await getPosition(client, symbol);
    return position?.side ?? null;
}
// ============================================================================
// Position Close Functions
// ============================================================================
/**
 * Close a specific position
 *
 * @param client - The Alpaca client instance
 * @param symbol - The trading symbol to close
 * @param options - Optional parameters for partial closes
 * @returns The resulting close order
 * @throws Error if no position exists or close fails
 *
 * @example
 * // Close entire position
 * const order = await closePosition(client, 'AAPL');
 *
 * // Close 50% of position
 * const order = await closePosition(client, 'AAPL', { percentage: 50 });
 *
 * // Close specific quantity
 * const order = await closePosition(client, 'AAPL', { qty: 10 });
 */
async function closePosition(client, symbol, options) {
    log(`Closing position for ${symbol}`, { type: 'info', symbol });
    try {
        const sdk = client.getSDK();
        // Build query params for partial closes
        const queryParams = {};
        if (options?.qty !== undefined) {
            queryParams.qty = options.qty.toString();
            log(`Closing ${options.qty} shares of ${symbol}`, { type: 'info', symbol });
        }
        else if (options?.percentage !== undefined) {
            queryParams.percentage = options.percentage.toString();
            log(`Closing ${options.percentage}% of ${symbol} position`, { type: 'info', symbol });
        }
        else {
            log(`Closing entire position for ${symbol}`, { type: 'info', symbol });
        }
        // Use sendRequest for parameterized close, closePosition for full close
        let order;
        if (Object.keys(queryParams).length > 0) {
            // SDK doesn't support params, use sendRequest directly
            order = await sdk.sendRequest(`/positions/${encodeURIComponent(symbol)}`, queryParams, null, 'DELETE');
        }
        else {
            order = await sdk.closePosition(symbol);
        }
        log(`Position close order created for ${symbol}: ${order.id}`, { type: 'info', symbol });
        return order;
    }
    catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        log(`Failed to close position for ${symbol}: ${message}`, { type: 'error', symbol });
        throw error;
    }
}
/**
 * Close all open positions
 *
 * @param client - The Alpaca client instance
 * @param options - Optional parameters
 * @returns Array of close orders
 *
 * @example
 * // Close all positions and cancel orders
 * const orders = await closeAllPositions(client, { cancelOrders: true });
 *
 * // Close all positions without canceling orders
 * const orders = await closeAllPositions(client, { cancelOrders: false });
 */
async function closeAllPositions(client, options) {
    const cancelOrders = options?.cancelOrders ?? true;
    log(`Closing all positions${cancelOrders ? ' and canceling open orders' : ''}`, { type: 'info' });
    try {
        const sdk = client.getSDK();
        // Build query params for cancel_orders option
        const queryParams = {
            cancel_orders: cancelOrders.toString(),
        };
        // Use sendRequest to pass the cancel_orders parameter
        const response = await sdk.sendRequest('/positions', queryParams, null, 'DELETE');
        // The SDK returns an array of objects with order info
        const orders = Array.isArray(response) ? response : [];
        log(`Closed ${orders.length} positions`, { type: 'info' });
        return orders;
    }
    catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        log(`Failed to close all positions: ${message}`, { type: 'error' });
        throw error;
    }
}
/**
 * Close all positions with limit orders (for after-hours trading)
 * Sets limit price slightly below current price for sells, above for buys
 *
 * @param client - The Alpaca client instance
 * @param options - Optional parameters
 * @returns Array of limit orders created
 *
 * @example
 * // Close positions after hours with 0.5% price offset
 * const orders = await closeAllPositionsAfterHours(client, { limitPriceOffset: 0.5 });
 */
async function closeAllPositionsAfterHours(client, options) {
    const limitPriceOffset = options?.limitPriceOffset ?? 0.5;
    log(`Closing all positions with limit orders (${limitPriceOffset}% offset) for after-hours`, { type: 'info' });
    try {
        const sdk = client.getSDK();
        const positions = await getPositions(client);
        if (positions.length === 0) {
            log('No positions to close', { type: 'info' });
            return [];
        }
        // First cancel all open orders
        await sdk.cancelAllOrders();
        log('Cancelled all open orders', { type: 'info' });
        const orders = [];
        const offsetMultiplier = limitPriceOffset / 100;
        for (const position of positions) {
            const qty = Math.abs(parseNumericString(position.qty));
            const currentPrice = parseNumericString(position.current_price);
            const side = position.side === 'long' ? 'sell' : 'buy';
            if (qty === 0 || currentPrice === 0) {
                log(`Skipping ${position.symbol}: invalid qty or price`, { type: 'warn', symbol: position.symbol });
                continue;
            }
            // Calculate limit price with offset
            const limitPrice = side === 'sell'
                ? roundPriceForAlpaca(currentPrice * (1 - offsetMultiplier))
                : roundPriceForAlpaca(currentPrice * (1 + offsetMultiplier));
            log(`Creating limit order to close ${position.symbol}: ${side} ${qty} shares at $${limitPrice.toFixed(2)}`, { type: 'info', symbol: position.symbol });
            try {
                const order = await sdk.createOrder({
                    symbol: position.symbol,
                    qty: qty,
                    side: side,
                    type: 'limit',
                    time_in_force: 'day',
                    limit_price: limitPrice,
                    extended_hours: true,
                });
                orders.push(order);
            }
            catch (orderError) {
                const message = orderError instanceof Error ? orderError.message : 'Unknown error';
                log(`Failed to create close order for ${position.symbol}: ${message}`, { type: 'error', symbol: position.symbol });
            }
        }
        log(`Created ${orders.length} limit orders to close positions`, { type: 'info' });
        return orders;
    }
    catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        log(`Failed to close positions after hours: ${message}`, { type: 'error' });
        throw error;
    }
}
// ============================================================================
// P&L Functions
// ============================================================================
/**
 * Get P&L summary for a specific position
 *
 * @param client - The Alpaca client instance
 * @param symbol - The trading symbol
 * @returns P&L summary for the position, null if no position exists
 *
 * @example
 * const pnl = await getPositionPnL(client, 'AAPL');
 * if (pnl) {
 *   console.log(`AAPL unrealized P&L: $${pnl.unrealizedPL.toFixed(2)} (${pnl.unrealizedPLPercent.toFixed(2)}%)`);
 * }
 */
async function getPositionPnL(client, symbol) {
    log(`Calculating P&L for ${symbol}`, { type: 'debug', symbol });
    const position = await getPosition(client, symbol);
    if (!position) {
        log(`No position found for ${symbol}`, { type: 'debug', symbol });
        return null;
    }
    const qty = parseNumericString(position.qty);
    const avgEntryPrice = parseNumericString(position.avg_entry_price);
    const currentPrice = parseNumericString(position.current_price);
    const marketValue = parseNumericString(position.market_value);
    const costBasis = parseNumericString(position.cost_basis);
    const unrealizedPL = parseNumericString(position.unrealized_pl);
    const unrealizedPLPercent = parseNumericString(position.unrealized_plpc) * 100;
    const todayPL = parseNumericString(position.unrealized_intraday_pl);
    const todayPLPercent = parseNumericString(position.unrealized_intraday_plpc) * 100;
    const summary = {
        symbol: position.symbol,
        qty,
        avgEntryPrice,
        currentPrice,
        marketValue,
        costBasis,
        unrealizedPL,
        unrealizedPLPercent,
        todayPL,
        todayPLPercent,
    };
    log(`${symbol} P&L: $${unrealizedPL.toFixed(2)} (${unrealizedPLPercent.toFixed(2)}%)`, { type: 'info', symbol });
    return summary;
}
/**
 * Get total portfolio P&L summary
 *
 * @param client - The Alpaca client instance
 * @returns Portfolio-level P&L summary including all positions
 *
 * @example
 * const portfolio = await getPortfolioPnL(client);
 * console.log(`Total unrealized P&L: $${portfolio.totalUnrealizedPL.toFixed(2)}`);
 * console.log(`Today's P&L: $${portfolio.todayPL.toFixed(2)}`);
 */
async function getPortfolioPnL(client) {
    log('Calculating portfolio P&L', { type: 'debug' });
    const positions = await getPositions(client);
    const positionSummaries = positions.map((position) => {
        const qty = parseNumericString(position.qty);
        const avgEntryPrice = parseNumericString(position.avg_entry_price);
        const currentPrice = parseNumericString(position.current_price);
        const marketValue = parseNumericString(position.market_value);
        const costBasis = parseNumericString(position.cost_basis);
        const unrealizedPL = parseNumericString(position.unrealized_pl);
        const unrealizedPLPercent = parseNumericString(position.unrealized_plpc) * 100;
        const todayPL = parseNumericString(position.unrealized_intraday_pl);
        const todayPLPercent = parseNumericString(position.unrealized_intraday_plpc) * 100;
        return {
            symbol: position.symbol,
            qty,
            avgEntryPrice,
            currentPrice,
            marketValue,
            costBasis,
            unrealizedPL,
            unrealizedPLPercent,
            todayPL,
            todayPLPercent,
        };
    });
    // Calculate totals
    const totalMarketValue = positionSummaries.reduce((sum, p) => sum + p.marketValue, 0);
    const totalCostBasis = positionSummaries.reduce((sum, p) => sum + p.costBasis, 0);
    const totalUnrealizedPL = positionSummaries.reduce((sum, p) => sum + p.unrealizedPL, 0);
    const todayPL = positionSummaries.reduce((sum, p) => sum + p.todayPL, 0);
    // Calculate percentage returns
    const totalUnrealizedPLPercent = totalCostBasis !== 0
        ? (totalUnrealizedPL / totalCostBasis) * 100
        : 0;
    // Today's P&L percent is calculated based on previous day's market value
    const previousDayValue = totalMarketValue - todayPL;
    const todayPLPercent = previousDayValue !== 0
        ? (todayPL / previousDayValue) * 100
        : 0;
    const summary = {
        totalMarketValue,
        totalCostBasis,
        totalUnrealizedPL,
        totalUnrealizedPLPercent,
        todayPL,
        todayPLPercent,
        positions: positionSummaries,
    };
    log(`Portfolio P&L: $${totalUnrealizedPL.toFixed(2)} (${totalUnrealizedPLPercent.toFixed(2)}%), ` +
        `Today: $${todayPL.toFixed(2)} (${todayPLPercent.toFixed(2)}%)`, { type: 'info' });
    return summary;
}
// ============================================================================
// Utility Functions
// ============================================================================
/**
 * Get all equity positions (us_equity asset class)
 *
 * @param client - The Alpaca client instance
 * @returns Array of equity positions
 *
 * @example
 * const equities = await getEquityPositions(client);
 */
async function getEquityPositions(client) {
    return getPositionsByAssetClass(client, 'us_equity');
}
/**
 * Get all option positions (us_option asset class)
 *
 * @param client - The Alpaca client instance
 * @returns Array of option positions
 *
 * @example
 * const options = await getOptionPositions(client);
 */
async function getOptionPositions(client) {
    return getPositionsByAssetClass(client, 'us_option');
}
/**
 * Get all crypto positions
 *
 * @param client - The Alpaca client instance
 * @returns Array of crypto positions
 *
 * @example
 * const crypto = await getCryptoPositions(client);
 */
async function getCryptoPositions(client) {
    return getPositionsByAssetClass(client, 'crypto');
}
/**
 * Get count of open positions
 *
 * @param client - The Alpaca client instance
 * @param assetClass - Optional asset class filter
 * @returns Number of open positions
 *
 * @example
 * const totalPositions = await getPositionCount(client);
 * const equityPositions = await getPositionCount(client, 'us_equity');
 */
async function getPositionCount(client, assetClass) {
    const positions = assetClass
        ? await getPositionsByAssetClass(client, assetClass)
        : await getPositions(client);
    return positions.length;
}
/**
 * Get symbols of all open positions
 *
 * @param client - The Alpaca client instance
 * @param assetClass - Optional asset class filter
 * @returns Array of position symbols
 *
 * @example
 * const symbols = await getPositionSymbols(client);
 * console.log(`Holding positions in: ${symbols.join(', ')}`);
 */
async function getPositionSymbols(client, assetClass) {
    const positions = assetClass
        ? await getPositionsByAssetClass(client, assetClass)
        : await getPositions(client);
    return positions.map((p) => p.symbol);
}
/**
 * Get total market value of all positions
 *
 * @param client - The Alpaca client instance
 * @param assetClass - Optional asset class filter
 * @returns Total market value in dollars
 *
 * @example
 * const totalValue = await getTotalMarketValue(client);
 * const equityValue = await getTotalMarketValue(client, 'us_equity');
 */
async function getTotalMarketValue(client, assetClass) {
    const positions = assetClass
        ? await getPositionsByAssetClass(client, assetClass)
        : await getPositions(client);
    return positions.reduce((total, p) => total + parseNumericString(p.market_value), 0);
}
/**
 * Check if there are any open positions
 *
 * @param client - The Alpaca client instance
 * @param assetClass - Optional asset class filter
 * @returns True if there are open positions
 *
 * @example
 * if (await hasAnyPositions(client)) {
 *   console.log('Portfolio has open positions');
 * }
 */
async function hasAnyPositions(client, assetClass) {
    const count = await getPositionCount(client, assetClass);
    return count > 0;
}
/**
 * Get positions sorted by market value (descending)
 *
 * @param client - The Alpaca client instance
 * @param assetClass - Optional asset class filter
 * @returns Positions sorted by market value (largest first)
 *
 * @example
 * const sortedPositions = await getPositionsByValue(client);
 * console.log(`Largest position: ${sortedPositions[0]?.symbol}`);
 */
async function getPositionsByValue(client, assetClass) {
    const positions = assetClass
        ? await getPositionsByAssetClass(client, assetClass)
        : await getPositions(client);
    return positions.sort((a, b) => {
        const aValue = Math.abs(parseNumericString(a.market_value));
        const bValue = Math.abs(parseNumericString(b.market_value));
        return bValue - aValue;
    });
}
/**
 * Get positions sorted by unrealized P&L (descending - best performers first)
 *
 * @param client - The Alpaca client instance
 * @param assetClass - Optional asset class filter
 * @returns Positions sorted by unrealized P&L
 *
 * @example
 * const sortedPositions = await getPositionsByPnL(client);
 * const winners = sortedPositions.filter(p => parseFloat(p.unrealized_pl) > 0);
 * const losers = sortedPositions.filter(p => parseFloat(p.unrealized_pl) < 0);
 */
async function getPositionsByPnL(client, assetClass) {
    const positions = assetClass
        ? await getPositionsByAssetClass(client, assetClass)
        : await getPositions(client);
    return positions.sort((a, b) => {
        const aPnL = parseNumericString(a.unrealized_pl);
        const bPnL = parseNumericString(b.unrealized_pl);
        return bPnL - aPnL;
    });
}
/**
 * Get winning positions (positive unrealized P&L)
 *
 * @param client - The Alpaca client instance
 * @param assetClass - Optional asset class filter
 * @returns Positions with positive unrealized P&L
 *
 * @example
 * const winners = await getWinningPositions(client);
 */
async function getWinningPositions(client, assetClass) {
    const positions = assetClass
        ? await getPositionsByAssetClass(client, assetClass)
        : await getPositions(client);
    return positions.filter((p) => parseNumericString(p.unrealized_pl) > 0);
}
/**
 * Get losing positions (negative unrealized P&L)
 *
 * @param client - The Alpaca client instance
 * @param assetClass - Optional asset class filter
 * @returns Positions with negative unrealized P&L
 *
 * @example
 * const losers = await getLosingPositions(client);
 */
async function getLosingPositions(client, assetClass) {
    const positions = assetClass
        ? await getPositionsByAssetClass(client, assetClass)
        : await getPositions(client);
    return positions.filter((p) => parseNumericString(p.unrealized_pl) < 0);
}
// ============================================================================
// Export Default
// ============================================================================
var positions = {
    // Query functions
    getPositions,
    getPositionsByAssetClass,
    getPosition,
    hasPosition,
    getPositionQty,
    getPositionValue,
    getPositionSide,
    // Close functions
    closePosition,
    closeAllPositions,
    closeAllPositionsAfterHours,
    // P&L functions
    getPositionPnL,
    getPortfolioPnL,
    // Utility functions
    getEquityPositions,
    getOptionPositions,
    getCryptoPositions,
    getPositionCount,
    getPositionSymbols,
    getTotalMarketValue,
    hasAnyPositions,
    getPositionsByValue,
    getPositionsByPnL,
    getWinningPositions,
    getLosingPositions,
};

var positions$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    closeAllPositions: closeAllPositions,
    closeAllPositionsAfterHours: closeAllPositionsAfterHours,
    closePosition: closePosition,
    default: positions,
    getCryptoPositions: getCryptoPositions,
    getEquityPositions: getEquityPositions,
    getLosingPositions: getLosingPositions,
    getOptionPositions: getOptionPositions,
    getPortfolioPnL: getPortfolioPnL,
    getPosition: getPosition,
    getPositionCount: getPositionCount,
    getPositionPnL: getPositionPnL,
    getPositionQty: getPositionQty,
    getPositionSide: getPositionSide,
    getPositionSymbols: getPositionSymbols,
    getPositionValue: getPositionValue,
    getPositions: getPositions,
    getPositionsByAssetClass: getPositionsByAssetClass,
    getPositionsByPnL: getPositionsByPnL,
    getPositionsByValue: getPositionsByValue,
    getTotalMarketValue: getTotalMarketValue,
    getWinningPositions: getWinningPositions,
    hasAnyPositions: hasAnyPositions,
    hasPosition: hasPosition
});

/**
 * Alpaca Module
 * Unified export of all Alpaca functionality using official SDK
 *
 * @module @adaptic/utils/alpaca
 */
// Core client
/**
 * Alpaca namespace for convenient access to all functionality
 *
 * @example
 * ```typescript
 * import { alpaca } from '@adaptic/utils';
 *
 * // Create client
 * const client = alpaca.createClient({
 *   apiKey: 'your-api-key',
 *   apiSecret: 'your-api-secret',
 *   accountType: 'PAPER',
 * });
 *
 * // Use trading functions
 * const order = await alpaca.orders.createOrder(client, { ... });
 *
 * // Use market data functions
 * const quote = await alpaca.quotes.getLatestQuote(client, 'AAPL');
 *
 * // Use smart orders
 * const bracket = await alpaca.smartOrders.createSmartOrder(client, { ... });
 * ```
 */
const alpaca = {
    // Client factory
    createClient: createAlpacaClient,
    createClientFromEnv,
    clearClientCache,
    // Trading - Orders
    orders: {
        ...trading,
        ...orderUtils$1,
    },
    // Trading - Smart Orders (brackets, OCO, OTO, trailing stops)
    smartOrders: {
        ...smartOrders$1,
        bracket: bracketOrders$1,
        oco: ocoOrders$1,
        oto: otoOrders$1,
        trailingStops: trailingStops$1,
    },
    // Trading - Positions
    positions: positions$1,
    // Trading - Account
    account: account$1,
    // Market Data
    quotes: quotes$1,
    bars: bars$1,
    trades: trades$1,
    news: news$1,
    // Options
    options: {
        contracts: optionContracts,
        orders: optionOrders,
        strategies: optionStrategies,
        data: optionData,
    },
    // Crypto
    crypto: {
        orders: cryptoOrders,
        data: cryptoData,
    },
    // Streams
    streams: streams$1,
};

/**
 * @module LRUCache
 */
const defaultPerf = (typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function') ?
    performance
    : Date;
const warned = new Set();
/* c8 ignore start */
const PROCESS = (typeof process === 'object' && !!process ?
    process
    : {});
/* c8 ignore start */
const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function' ?
        PROCESS.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn = (code) => !warned.has(code);
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max) => !isPosInt(max) ? null
    : max <= Math.pow(2, 8) ? Uint8Array
        : max <= Math.pow(2, 16) ? Uint16Array
            : max <= Math.pow(2, 32) ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER ? ZeroArray
                    : null;
/* c8 ignore stop */
class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
            return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */
class LRUCache {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #onInsert;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    #perf;
    /**
     * {@link LRUCache.OptionsBase.perf}
     */
    get perf() {
        return this.#perf;
    }
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #autopurgeTimers;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    #hasOnInsert;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            autopurgeTimers: c.#autopurgeTimers,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    get memoMethod() {
        return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.onInsert} (read-only)
     */
    get onInsert() {
        return this.#onInsert;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, perf, } = options;
        if (perf !== undefined) {
            if (typeof perf?.now !== 'function') {
                throw new TypeError('perf option must have a now() method if specified');
            }
        }
        this.#perf = perf ?? defaultPerf;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined && typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof onInsert === 'function') {
            this.#onInsert = onInsert;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasOnInsert = !!this.#onInsert;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        const purgeTimers = this.ttlAutopurge ?
            new Array(this.#max)
            : undefined;
        this.#autopurgeTimers = purgeTimers;
        this.#setItemTTL = (index, ttl, start = this.#perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            // clear out the purge timer if we're setting TTL to 0, and
            // previously had a ttl purge timer running, so it doesn't
            // fire unnecessarily.
            if (purgeTimers?.[index]) {
                clearTimeout(purgeTimers[index]);
                purgeTimers[index] = undefined;
            }
            if (ttl !== 0 && purgeTimers) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.#delete(this.#keyList[index], 'expire');
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
                purgeTimers[index] = t;
            }
        };
        this.#updateItemAge = index => {
            starts[index] = ttls[index] !== 0 ? this.#perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */
                if (!ttl || !start)
                    return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = () => {
            const n = this.#perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
            return n;
        };
        this.getRemainingTTL = key => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = index => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => { };
    #statusTTL = () => { };
    #setItemTTL = () => { };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = index => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                }
                else {
                    throw new TypeError('invalid size value (must be positive integer). ' +
                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
                        'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while (this.#calculatedSize > maxSize) {
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = _i => { };
    #addItemSize = (_i, _s, _st) => { };
    #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#tail; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                }
                else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#head; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                }
                else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return (index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index);
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
        for (const i of this.#indexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
        for (const i of this.#rindexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
        for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
        for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag] = 'LRUCache';
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined)
                continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
                this.#delete(this.#keyList[i], 'expire');
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined)
            return undefined;
        const v = this.#valList[i];
        /* c8 ignore start - this isn't tested for the info function,
         * but it's the same logic as found in other places. */
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
            return undefined;
        /* c8 ignore end */
        const entry = { value };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (this.#perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined || key === undefined)
                continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = this.#perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = this.#perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.#delete(k, 'set');
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = (this.#size === 0 ? this.#tail
                : this.#free.length !== 0 ? this.#free.pop()
                    : this.#size === this.#max ? this.#evict(false)
                        : this.#size);
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
                status.set = 'add';
            noUpdateTTL = false;
            if (this.#hasOnInsert) {
                this.#onInsert?.(v, k, 'add');
            }
        }
        else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([s, k, 'set']);
                        }
                    }
                }
                else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([oldVal, k, 'set']);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ?
                        oldVal.__staleWhileFetching
                        : oldVal;
                    if (oldValue !== undefined)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = 'update';
            }
            if (this.#hasOnInsert) {
                this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace');
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status)
                this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (this.#size) {
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                }
                else if (val !== undefined) {
                    return val;
                }
            }
        }
        finally {
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while ((task = dt?.shift())) {
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        }
        else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, 'evict']);
            }
        }
        this.#removeItemSize(head);
        if (this.#autopurgeTimers?.[head]) {
            clearTimeout(this.#autopurgeTimers[head]);
            this.#autopurgeTimers[head] = undefined;
        }
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        }
        else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) &&
                v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            }
            else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        }
        else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined || (!allowStale && this.#isStale(index))) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
            signal: ac.signal,
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context,
        };
        const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort)
                        options.status.fetchAbortIgnored = true;
                }
                else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            // if nothing else has been written there but we're set to update the
            // cache and ignore the abort, or if it's still pending on this specific
            // background request, then write it to the cache.
            const vl = this.#valList[index];
            if (vl === p || (ignoreAbort && updateCache && vl === undefined)) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching !== undefined) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    }
                    else {
                        this.#delete(k, 'fetch');
                    }
                }
                else {
                    if (options.status)
                        options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er) => {
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.#delete(k, 'fetch');
                }
                else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            }
            else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then(v => res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', () => {
                if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = v => cb(v, true);
                    }
                }
            });
        };
        if (options.status)
            options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
        }
        else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
            return false;
        const b = p;
        return (!!b &&
            b instanceof Promise &&
            b.hasOwnProperty('__staleWhileFetching') &&
            b.__abortController instanceof AC);
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status)
                status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status,
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status)
                status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
        }
        else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status)
                    this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
        }
    }
    async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === undefined)
            throw new Error('fetch() returned undefined');
        return v;
    }
    memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
            throw new Error('no memoMethod provided to constructor');
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== undefined)
            return v;
        const vv = memoMethod(k, v, {
            options,
            context,
        });
        this.set(k, vv, options);
        return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
                this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status)
                    status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.#delete(k, 'expire');
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : undefined;
                }
                else {
                    if (status &&
                        allowStale &&
                        value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            }
            else {
                if (status)
                    status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            }
            else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        return this.#delete(k, 'delete');
    }
    #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                if (this.#autopurgeTimers?.[index]) {
                    clearTimeout(this.#autopurgeTimers?.[index]);
                    this.#autopurgeTimers[index] = undefined;
                }
                deleted = true;
                if (this.#size === 1) {
                    this.#clear(reason);
                }
                else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    }
                    else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, reason);
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([v, k, reason]);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    }
                    else if (index === this.#head) {
                        this.#head = this.#next[index];
                    }
                    else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        return this.#clear('delete');
    }
    #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            }
            else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, reason]);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
            for (const t of this.#autopurgeTimers ?? []) {
                if (t !== undefined)
                    clearTimeout(t);
            }
            this.#autopurgeTimers?.fill(undefined);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
    }
}

/**
 * StampedeProtectedCache provides three-layer protection against cache stampedes
 *
 * @description High-performance caching system implementing multiple stampede prevention
 * strategies to protect downstream services (market data APIs, position services) from
 * request bursts during synchronized cache expiration events.
 *
 * @rationale In algorithmic trading, cache stampedes can:
 * - Overwhelm market data APIs (Alpaca, Polygon) causing rate limiting (200 req/min limits)
 * - Introduce latency spikes during critical trading windows (market open/close)
 * - Trigger cascading failures when position data becomes unavailable
 * - Cause missed trading opportunities due to stale or unavailable data
 *
 * Three-layer protection:
 * 1. Request coalescing - Multiple concurrent requests for the same key share a single promise
 * 2. Stale-while-revalidate - Serve stale data while refreshing in background
 * 3. Probabilistic early expiration - Add jitter to prevent synchronized expiration
 *
 * @template T - Type of cached data (e.g., AlpacaPosition[], MarketQuote, AccountInfo)
 *
 * @example
 * ```typescript
 * // Initialize cache for position data
 * const positionCache = new StampedeProtectedCache<AlpacaPosition[]>({
 *   maxSize: 1000,
 *   defaultTtl: 30000, // 30 seconds
 *   staleWhileRevalidateTtl: 60000, // 60 seconds grace
 *   minJitter: 0.9,
 *   maxJitter: 1.1,
 *   enableBackgroundRefresh: true,
 *   logger: pinoLogger
 * });
 *
 * // Fetch with automatic caching and stampede protection
 * const positions = await positionCache.get(
 *   accountId,
 *   async (key) => await alpacaApi.getPositions(key)
 * );
 * ```
 *
 * @businessLogic
 * 1. On cache.get(), check for existing entry
 * 2. If found and fresh (< TTL with jitter): return cached value (HIT)
 * 3. If found but stale (< staleWhileRevalidateTtl): return stale value, trigger background refresh (STALE HIT)
 * 4. If not found or expired beyond grace period: fetch from source (MISS)
 * 5. During fetch, coalesce duplicate concurrent requests to single API call
 * 6. After successful fetch, cache result with jittered TTL to prevent synchronized expiration
 *
 * @auditTrail
 * - All cache operations logged with timestamps and metadata
 * - Statistics tracked: hits, misses, stale hits, coalesced requests, refresh errors
 * - Performance metrics exposed via getStats() for monitoring dashboards
 */
class StampedeProtectedCache {
    cache;
    options;
    pendingRefreshes = new Map();
    stats = {
        totalGets: 0,
        hits: 0,
        misses: 0,
        staleHits: 0,
        coalescedRequests: 0,
        backgroundRefreshes: 0,
        refreshErrors: 0,
    };
    constructor(options) {
        this.options = {
            ...options,
            staleWhileRevalidateTtl: options.staleWhileRevalidateTtl ?? options.defaultTtl * 2,
            minJitter: options.minJitter ?? 0.9,
            maxJitter: options.maxJitter ?? 1.1,
            enableBackgroundRefresh: options.enableBackgroundRefresh ?? true,
            logger: options.logger ?? {
                debug: () => { },
                info: () => { },
                warn: () => { },
                error: () => { },
            },
        };
        this.cache = new LRUCache({
            max: this.options.maxSize,
            ttl: undefined, // We manage TTL ourselves
            allowStale: true,
            updateAgeOnGet: false,
            updateAgeOnHas: false,
        });
        this.options.logger.info('StampedeProtectedCache initialized', {
            maxSize: this.options.maxSize,
            defaultTtl: this.options.defaultTtl,
            staleWhileRevalidateTtl: this.options.staleWhileRevalidateTtl,
            jitterRange: [this.options.minJitter, this.options.maxJitter],
        });
    }
    /**
     * Get a value from the cache, loading it if necessary
     *
     * @description Primary cache access method implementing three-layer stampede protection.
     * Returns cached data if fresh, serves stale data while refreshing if within grace period,
     * or fetches fresh data with request coalescing if expired.
     *
     * @param key - Unique cache key (e.g., accountId, symbol, "positions:ACCT123")
     * @param loader - Async function to load data on cache miss
     * @param ttl - Optional TTL override in milliseconds. If not provided, uses defaultTtl from config
     *
     * @returns Promise resolving to cached or freshly loaded data
     *
     * @throws Error if loader function fails and no stale data is available
     *
     * @example
     * ```typescript
     * // Get positions with default TTL
     * const positions = await cache.get(
     *   accountId,
     *   async (key) => await alpacaApi.getPositions(key)
     * );
     *
     * // Get market quote with custom TTL (5 seconds for real-time data)
     * const quote = await cache.get(
     *   `quote:${symbol}`,
     *   async (key) => await polygonApi.getQuote(symbol),
     *   5000
     * );
     * ```
     *
     * @businessLogic
     * 1. Increment totalGets counter for statistics
     * 2. Calculate effective TTL (custom or default)
     * 3. Attempt cache lookup by key
     * 4. If entry exists:
     *    a. Increment access count and update lastAccessedAt
     *    b. Apply probabilistic jitter to expiration time
     *    c. If still fresh (now < jitteredExpiresAt): return cached value (HIT)
     *    d. If stale but within grace period (now < staleExpiresAt) and not already refreshing:
     *       - Serve stale value immediately
     *       - Trigger background refresh if enabled
     *       - Return stale value (STALE HIT)
     * 5. If entry not found or expired beyond grace: load fresh data with coalescing (MISS)
     */
    async get(key, loader, ttl) {
        this.stats.totalGets++;
        const effectiveTtl = ttl ?? this.options.defaultTtl;
        const now = Date.now();
        // Check if we have a cached entry
        const cached = this.cache.get(key);
        if (cached) {
            cached.accessCount++;
            cached.lastAccessedAt = now;
            // Check if entry is still fresh (considering probabilistic expiration)
            const jitteredExpiresAt = this.applyJitter(cached.expiresAt);
            if (now < jitteredExpiresAt) {
                // Fresh hit
                this.stats.hits++;
                this.options.logger.debug('Cache hit (fresh)', { key, age: now - cached.createdAt });
                return cached.value;
            }
            // Check if we can serve stale while revalidating
            const staleExpiresAt = cached.createdAt + this.options.staleWhileRevalidateTtl;
            if (now < staleExpiresAt && !cached.isRefreshing) {
                // Serve stale and trigger background refresh
                this.stats.staleHits++;
                this.options.logger.debug('Cache hit (stale-while-revalidate)', {
                    key,
                    age: now - cached.createdAt,
                    staleAge: now - cached.expiresAt
                });
                if (this.options.enableBackgroundRefresh) {
                    this.refreshInBackground(key, loader, effectiveTtl);
                }
                return cached.value;
            }
        }
        // Cache miss or expired - need to load
        this.stats.misses++;
        this.options.logger.debug('Cache miss', { key, hadCached: !!cached });
        return this.loadWithCoalescing(key, loader, effectiveTtl);
    }
    /**
     * Set a value in the cache
     *
     * @description Manually store a value in the cache with optional custom TTL.
     * Useful for pre-warming cache or storing computed results.
     *
     * @param key - Unique cache key
     * @param value - Data to cache
     * @param ttl - Optional TTL in milliseconds. If not provided, uses defaultTtl
     *
     * @returns void
     *
     * @example
     * ```typescript
     * // Pre-warm cache with known data
     * cache.set('positions:ACCT123', positions, 30000);
     *
     * // Cache computed result
     * const aggregatedData = computeAggregation(positions);
     * cache.set('aggregated:ACCT123', aggregatedData, 60000);
     * ```
     */
    set(key, value, ttl) {
        const effectiveTtl = ttl ?? this.options.defaultTtl;
        const now = Date.now();
        const entry = {
            value,
            createdAt: now,
            ttl: effectiveTtl,
            expiresAt: now + effectiveTtl,
            accessCount: 0,
            lastAccessedAt: now,
            isRefreshing: false,
        };
        this.cache.set(key, entry);
        this.options.logger.debug('Cache set', { key, ttl: effectiveTtl });
    }
    /**
     * Check if a key exists in the cache (regardless of expiration)
     *
     * @description Checks for cache entry existence without considering TTL or freshness.
     * Does not update access statistics or timestamps.
     *
     * @param key - Cache key to check
     *
     * @returns true if entry exists (fresh or stale), false otherwise
     *
     * @example
     * ```typescript
     * if (cache.has(accountId)) {
     *   // Entry exists, may be fresh or stale
     * }
     * ```
     */
    has(key) {
        return this.cache.has(key);
    }
    /**
     * Delete a specific key from the cache
     *
     * @description Immediately removes cache entry and any pending refreshes for the key.
     * Useful for cache invalidation when source data changes.
     *
     * @param key - Cache key to delete
     *
     * @returns true if entry was deleted, false if key did not exist
     *
     * @example
     * ```typescript
     * // Invalidate after position update
     * await alpacaApi.submitOrder(order);
     * cache.delete(`positions:${accountId}`);
     * ```
     */
    delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
            this.options.logger.debug('Cache entry deleted', { key });
        }
        return deleted;
    }
    /**
     * Invalidate a key (alias for delete)
     *
     * @description Semantic alias for delete() method. Use for clarity when invalidating
     * cache after data mutations.
     *
     * @param key - Cache key to invalidate
     *
     * @returns true if entry was invalidated, false if key did not exist
     *
     * @example
     * ```typescript
     * // Invalidate after trade execution
     * cache.invalidate(`positions:${accountId}`);
     * ```
     */
    invalidate(key) {
        return this.delete(key);
    }
    /**
     * Clear all entries from the cache
     *
     * @description Removes all cached entries and pending refreshes. Use during system
     * resets or configuration changes requiring fresh data.
     *
     * @returns void
     *
     * @example
     * ```typescript
     * // Clear cache during market hours transition
     * if (marketJustOpened) {
     *   cache.clear();
     * }
     * ```
     */
    clear() {
        const sizeBefore = this.cache.size;
        this.cache.clear();
        this.pendingRefreshes.clear();
        this.options.logger.info('Cache cleared', { entriesRemoved: sizeBefore });
    }
    /**
     * Get cache statistics
     *
     * @description Returns comprehensive performance metrics for monitoring and analysis.
     * Statistics include hit/miss ratios, active refreshes, coalesced requests, and errors.
     *
     * @returns CacheStats object with current performance metrics
     *
     * @example
     * ```typescript
     * const stats = cache.getStats();
     * logger.info('Cache performance', {
     *   hitRatio: stats.hitRatio,
     *   size: stats.size,
     *   activeRefreshes: stats.activeRefreshes
     * });
     *
     * // Alert on poor performance
     * if (stats.hitRatio < 0.7) {
     *   alerting.send('Low cache hit ratio', stats);
     * }
     * ```
     */
    getStats() {
        return {
            totalGets: this.stats.totalGets,
            hits: this.stats.hits,
            misses: this.stats.misses,
            staleHits: this.stats.staleHits,
            hitRatio: this.stats.totalGets > 0 ? this.stats.hits / this.stats.totalGets : 0,
            size: this.cache.size,
            maxSize: this.options.maxSize,
            activeRefreshes: this.pendingRefreshes.size,
            coalescedRequests: this.stats.coalescedRequests,
            backgroundRefreshes: this.stats.backgroundRefreshes,
            refreshErrors: this.stats.refreshErrors,
        };
    }
    /**
     * Get all cached keys
     *
     * @description Returns array of all cache keys currently stored, regardless of freshness.
     * Useful for debugging and cache inspection.
     *
     * @returns Array of cache keys
     *
     * @example
     * ```typescript
     * const keys = cache.keys();
     * console.log('Cached accounts:', keys);
     * // ['positions:ACCT123', 'positions:ACCT456', 'quote:AAPL']
     * ```
     */
    keys() {
        return Array.from(this.cache.keys());
    }
    /**
     * Get the size of the cache
     *
     * @description Returns current number of entries in cache. Compare to maxSize to
     * monitor capacity utilization.
     *
     * @returns Number of cached entries
     *
     * @example
     * ```typescript
     * const utilizationPct = (cache.size / cache.getStats().maxSize) * 100;
     * if (utilizationPct > 90) {
     *   logger.warn('Cache near capacity', { size: cache.size });
     * }
     * ```
     */
    get size() {
        return this.cache.size;
    }
    /**
     * Load data with request coalescing to prevent duplicate requests
     */
    async loadWithCoalescing(key, loader, ttl) {
        // Check if there's already a pending refresh for this key
        const existingPromise = this.pendingRefreshes.get(key);
        if (existingPromise) {
            this.stats.coalescedRequests++;
            this.options.logger.debug('Request coalesced', { key });
            return existingPromise;
        }
        // Create new promise and store it
        const promise = this.loadAndCache(key, loader, ttl);
        this.pendingRefreshes.set(key, promise);
        try {
            const result = await promise;
            return result;
        }
        finally {
            // Clean up the pending promise
            this.pendingRefreshes.delete(key);
        }
    }
    /**
     * Load data and cache it
     */
    async loadAndCache(key, loader, ttl) {
        const startTime = Date.now();
        try {
            this.options.logger.debug('Loading data', { key });
            const value = await loader(key);
            // Cache the loaded value
            this.set(key, value, ttl);
            const loadTime = Date.now() - startTime;
            this.options.logger.debug('Data loaded and cached', { key, loadTime });
            return value;
        }
        catch (error) {
            this.stats.refreshErrors++;
            const loadTime = Date.now() - startTime;
            this.options.logger.error('Failed to load data', { key, error, loadTime });
            // Update cached entry with error if it exists
            const cached = this.cache.get(key);
            if (cached) {
                cached.lastError = error;
                cached.isRefreshing = false;
            }
            throw error;
        }
    }
    /**
     * Refresh data in the background
     */
    refreshInBackground(key, loader, ttl) {
        // Mark the entry as refreshing
        const cached = this.cache.get(key);
        if (cached) {
            cached.isRefreshing = true;
        }
        // Don't wait for the refresh to complete
        this.loadWithCoalescing(key, loader, ttl)
            .then(() => {
            this.stats.backgroundRefreshes++;
            this.options.logger.debug('Background refresh completed', { key });
        })
            .catch((error) => {
            this.options.logger.warn('Background refresh failed', { key, error });
        })
            .finally(() => {
            // Mark as no longer refreshing
            const entry = this.cache.get(key);
            if (entry) {
                entry.isRefreshing = false;
            }
        });
    }
    /**
     * Apply probabilistic jitter to expiration time
     */
    applyJitter(originalExpiresAt) {
        const range = this.options.maxJitter - this.options.minJitter;
        const jitter = this.options.minJitter + (Math.random() * range);
        const createdAt = originalExpiresAt - this.options.defaultTtl;
        const jitteredTtl = this.options.defaultTtl * jitter;
        return createdAt + jitteredTtl;
    }
    /**
     * Reset statistics (useful for testing)
     *
     * @description Clears all performance counters to zero. Use for testing or when starting
     * fresh metrics collection period.
     *
     * @returns void
     *
     * @example
     * ```typescript
     * // Reset stats at start of trading day
     * cache.resetStats();
     * ```
     */
    resetStats() {
        this.stats.totalGets = 0;
        this.stats.hits = 0;
        this.stats.misses = 0;
        this.stats.staleHits = 0;
        this.stats.coalescedRequests = 0;
        this.stats.backgroundRefreshes = 0;
        this.stats.refreshErrors = 0;
    }
}
/**
 * Factory function to create a new StampedeProtectedCache instance
 *
 * @description Convenience factory for creating cache instances with type inference.
 * Alternative to using 'new StampedeProtectedCache<T>()'.
 *
 * @template T - Type of cached data
 * @param options - Cache configuration options
 *
 * @returns New StampedeProtectedCache instance
 *
 * @example
 * ```typescript
 * // Type is automatically inferred
 * const cache = createStampedeProtectedCache<AlpacaPosition[]>({
 *   maxSize: 1000,
 *   defaultTtl: 30000
 * });
 * ```
 */
function createStampedeProtectedCache(options) {
    return new StampedeProtectedCache(options);
}
/**
 * Default cache options for common use cases
 *
 * @description Production-tested default configuration suitable for most trading applications.
 * Provides balanced performance for position and market data caching.
 *
 * @rationale These defaults are optimized for:
 * - Position data refresh frequency (30-60s acceptable staleness)
 * - API rate limit protection (Alpaca: 200 req/min)
 * - Memory efficiency (1000 entries  10MB for typical position data)
 * - Stampede prevention (10% jitter prevents synchronized expiration)
 *
 * @example
 * ```typescript
 * // Use defaults for quick setup
 * const cache = new StampedeProtectedCache({
 *   ...DEFAULT_CACHE_OPTIONS,
 *   logger: customLogger
 * });
 *
 * // Override specific settings
 * const realtimeCache = new StampedeProtectedCache({
 *   ...DEFAULT_CACHE_OPTIONS,
 *   defaultTtl: 5000, // 5s for real-time quotes
 *   maxSize: 10000
 * });
 * ```
 */
const DEFAULT_CACHE_OPTIONS = {
    maxSize: 1000,
    defaultTtl: 60000, // 1 minute
    staleWhileRevalidateTtl: 120000, // 2 minutes
    minJitter: 0.9, // 90%
    maxJitter: 1.1, // 110%
    enableBackgroundRefresh: true,
};

/**
 * Intelligent Asset Allocation Algorithm
 *
 * Determines optimal asset allocation across multiple asset classes based on:
 * - User risk profile
 * - Market conditions
 * - Account size
 * - User preferences
 * - Modern Portfolio Theory principles
 * - Risk-adjusted returns
 * - Diversification optimization
 */
/**
 * Asset Allocation Engine
 *
 * Implements sophisticated portfolio optimization using:
 * - Mean-variance optimization
 * - Risk parity approach
 * - Black-Litterman model influences
 * - Correlation-based diversification
 * - Dynamic risk adjustment
 */
class AssetAllocationEngine {
    config;
    defaultConfig = {
        objective: 'MAX_SHARPE',
        riskFreeRate: 0.04, // 4% risk-free rate
        rebalancingThreshold: 5, // 5% drift threshold
        transactionCostModel: 'PERCENTAGE',
        timeHorizon: 5, // 5 year horizon
        allowLeverage: false,
        includeAlternatives: true
    };
    /**
     * Default risk profiles with typical asset class allocations
     */
    defaultRiskProfiles = new Map([
        [
            'CONSERVATIVE',
            {
                profile: 'CONSERVATIVE',
                description: 'Capital preservation focused with minimal volatility',
                baseAllocations: new Map([
                    ['EQUITIES', 0.20],
                    ['OPTIONS', 0.05],
                    ['FUTURES', 0.00],
                    ['ETF', 0.50],
                    ['FOREX', 0.10],
                    ['CRYPTO', 0.00]
                ]),
                maxVolatility: 8,
                maxDrawdown: 10,
                targetReturn: 5,
                riskScore: 20
            }
        ],
        [
            'MODERATE_CONSERVATIVE',
            {
                profile: 'MODERATE_CONSERVATIVE',
                description: 'Income focused with moderate growth potential',
                baseAllocations: new Map([
                    ['EQUITIES', 0.30],
                    ['OPTIONS', 0.10],
                    ['FUTURES', 0.05],
                    ['ETF', 0.40],
                    ['FOREX', 0.10],
                    ['CRYPTO', 0.05]
                ]),
                maxVolatility: 12,
                maxDrawdown: 15,
                targetReturn: 7,
                riskScore: 35
            }
        ],
        [
            'MODERATE',
            {
                profile: 'MODERATE',
                description: 'Balanced growth and income with managed volatility',
                baseAllocations: new Map([
                    ['EQUITIES', 0.40],
                    ['OPTIONS', 0.15],
                    ['FUTURES', 0.10],
                    ['ETF', 0.25],
                    ['FOREX', 0.05],
                    ['CRYPTO', 0.05]
                ]),
                maxVolatility: 15,
                maxDrawdown: 20,
                targetReturn: 10,
                riskScore: 50
            }
        ],
        [
            'MODERATE_AGGRESSIVE',
            {
                profile: 'MODERATE_AGGRESSIVE',
                description: 'Growth focused with higher volatility tolerance',
                baseAllocations: new Map([
                    ['EQUITIES', 0.50],
                    ['OPTIONS', 0.20],
                    ['FUTURES', 0.10],
                    ['ETF', 0.10],
                    ['FOREX', 0.05],
                    ['CRYPTO', 0.05]
                ]),
                maxVolatility: 20,
                maxDrawdown: 25,
                targetReturn: 13,
                riskScore: 70
            }
        ],
        [
            'AGGRESSIVE',
            {
                profile: 'AGGRESSIVE',
                description: 'Maximum growth with high volatility acceptance',
                baseAllocations: new Map([
                    ['EQUITIES', 0.45],
                    ['OPTIONS', 0.25],
                    ['FUTURES', 0.15],
                    ['ETF', 0.05],
                    ['FOREX', 0.05],
                    ['CRYPTO', 0.05]
                ]),
                maxVolatility: 30,
                maxDrawdown: 35,
                targetReturn: 18,
                riskScore: 85
            }
        ]
    ]);
    constructor(config = {}) {
        this.config = config;
        this.config = { ...this.defaultConfig, ...config };
    }
    /**
     * Generate optimal asset allocation recommendation
     */
    async generateAllocation(input) {
        // Step 1: Determine risk profile if not provided
        const riskProfile = input.riskProfile || this.inferRiskProfile(input);
        // Step 2: Assess market conditions
        const marketCondition = this.assessMarketCondition(input.marketConditions);
        // Step 3: Get base allocations from risk profile
        const baseAllocations = this.getBaseAllocations(riskProfile);
        // Step 4: Adjust allocations based on market conditions
        const marketAdjustedAllocations = this.adjustForMarketConditions(baseAllocations, marketCondition, input.marketConditions);
        // Step 5: Apply user preferences and constraints
        const constrainedAllocations = this.applyConstraints(marketAdjustedAllocations, input.preferences, input.constraints, input.assetCharacteristics);
        // Step 6: Optimize allocations using selected objective
        const optimizedAllocations = this.optimizeAllocations(constrainedAllocations, input.assetCharacteristics, input.accountSize, riskProfile);
        // Step 7: Calculate portfolio metrics
        const portfolioMetrics = this.calculatePortfolioMetrics(optimizedAllocations, input.assetCharacteristics);
        // Step 8: Perform risk analysis
        const riskAnalysis = this.performRiskAnalysis(optimizedAllocations, input.assetCharacteristics, riskProfile);
        // Step 9: Calculate diversification metrics
        const diversification = this.calculateDiversification(optimizedAllocations, input.assetCharacteristics);
        // Step 10: Generate rebalancing recommendations if current positions exist
        const rebalancing = input.currentPositions
            ? this.generateRebalancingActions(input.currentPositions, optimizedAllocations, input.accountSize)
            : undefined;
        // Step 11: Build allocation recommendation
        const recommendation = {
            id: this.generateRecommendationId(),
            allocations: this.buildAssetAllocations(optimizedAllocations, input.accountSize, input.assetCharacteristics, portfolioMetrics, riskProfile),
            portfolioMetrics,
            riskAnalysis,
            diversification,
            rebalancing,
            timestamp: new Date(),
            nextRebalancingDate: this.calculateNextRebalancingDate(input.preferences?.rebalancingFrequency),
            methodology: this.getMethodologyDescription(this.config.objective, riskProfile),
            warnings: this.generateWarnings(optimizedAllocations, riskAnalysis, input)
        };
        return recommendation;
    }
    /**
     * Infer risk profile from account characteristics
     */
    inferRiskProfile(input) {
        let riskScore = 50; // Start at moderate
        // Adjust based on account size
        if (input.accountSize < 10000) {
            riskScore -= 10; // Smaller accounts tend to be more conservative
        }
        else if (input.accountSize > 100000) {
            riskScore += 10; // Larger accounts can take more risk
        }
        // Adjust based on preferences
        if (input.preferences?.maxDrawdown) {
            if (input.preferences.maxDrawdown < 15)
                riskScore -= 15;
            else if (input.preferences.maxDrawdown > 25)
                riskScore += 15;
        }
        if (input.preferences?.targetReturn) {
            if (input.preferences.targetReturn < 6)
                riskScore -= 10;
            else if (input.preferences.targetReturn > 12)
                riskScore += 10;
        }
        // Adjust based on excluded asset classes (conservative if many excluded)
        if (input.preferences?.excludedAssetClasses) {
            riskScore -= input.preferences.excludedAssetClasses.length * 5;
        }
        // Map score to profile
        if (riskScore < 30)
            return 'CONSERVATIVE';
        if (riskScore < 45)
            return 'MODERATE_CONSERVATIVE';
        if (riskScore < 60)
            return 'MODERATE';
        if (riskScore < 75)
            return 'MODERATE_AGGRESSIVE';
        return 'AGGRESSIVE';
    }
    /**
     * Assess current market condition
     */
    assessMarketCondition(metrics) {
        // High volatility check
        if (metrics.volatilityIndex > 30) {
            return 'HIGH_VOLATILITY';
        }
        // Low volatility check
        if (metrics.volatilityIndex < 12) {
            return 'LOW_VOLATILITY';
        }
        // Crisis detection
        if (metrics.volatilityIndex > 40 ||
            metrics.sentimentScore < 20 ||
            metrics.creditSpread > 500) {
            return 'CRISIS';
        }
        // Bull market
        if (metrics.trendDirection === 'UP' &&
            metrics.marketStrength > 60 &&
            metrics.sentimentScore > 60) {
            return 'BULL';
        }
        // Bear market
        if (metrics.trendDirection === 'DOWN' &&
            metrics.marketStrength < 40 &&
            metrics.sentimentScore < 40) {
            return 'BEAR';
        }
        // Default to sideways
        return 'SIDEWAYS';
    }
    /**
     * Get base allocations from risk profile
     */
    getBaseAllocations(riskProfile) {
        const profile = this.defaultRiskProfiles.get(riskProfile);
        if (!profile) {
            throw new Error(`Unknown risk profile: ${riskProfile}`);
        }
        return new Map(profile.baseAllocations);
    }
    /**
     * Adjust allocations based on market conditions
     */
    adjustForMarketConditions(baseAllocations, condition, metrics) {
        const adjusted = new Map(baseAllocations);
        switch (condition) {
            case 'CRISIS':
                // Shift to defensive assets
                this.scaleAllocation(adjusted, 'EQUITIES', 0.5);
                this.scaleAllocation(adjusted, 'OPTIONS', 0.3);
                this.scaleAllocation(adjusted, 'FUTURES', 0.2);
                this.scaleAllocation(adjusted, 'ETF', 1.5);
                this.scaleAllocation(adjusted, 'CRYPTO', 0.1);
                break;
            case 'HIGH_VOLATILITY':
                // Reduce volatile assets
                this.scaleAllocation(adjusted, 'OPTIONS', 0.7);
                this.scaleAllocation(adjusted, 'FUTURES', 0.7);
                this.scaleAllocation(adjusted, 'CRYPTO', 0.5);
                this.scaleAllocation(adjusted, 'ETF', 1.2);
                break;
            case 'LOW_VOLATILITY':
                // Can take more risk
                this.scaleAllocation(adjusted, 'EQUITIES', 1.1);
                this.scaleAllocation(adjusted, 'OPTIONS', 1.2);
                this.scaleAllocation(adjusted, 'CRYPTO', 1.3);
                break;
            case 'BULL':
                // Increase growth assets
                this.scaleAllocation(adjusted, 'EQUITIES', 1.2);
                this.scaleAllocation(adjusted, 'OPTIONS', 1.1);
                this.scaleAllocation(adjusted, 'CRYPTO', 1.2);
                this.scaleAllocation(adjusted, 'ETF', 0.9);
                break;
            case 'BEAR':
                // Defensive positioning
                this.scaleAllocation(adjusted, 'EQUITIES', 0.7);
                this.scaleAllocation(adjusted, 'OPTIONS', 0.8);
                this.scaleAllocation(adjusted, 'CRYPTO', 0.6);
                this.scaleAllocation(adjusted, 'ETF', 1.3);
                this.scaleAllocation(adjusted, 'FOREX', 1.2);
                break;
            case 'SIDEWAYS':
                // Favor income and options strategies
                this.scaleAllocation(adjusted, 'OPTIONS', 1.2);
                this.scaleAllocation(adjusted, 'EQUITIES', 0.95);
                break;
        }
        // Additional adjustments based on specific metrics
        if (metrics.inflationRate > 4) {
            // High inflation - favor real assets
            this.scaleAllocation(adjusted, 'CRYPTO', 1.1);
            this.scaleAllocation(adjusted, 'ETF', 0.9);
        }
        if (metrics.interestRateLevel === 'HIGH') {
            // High rates - favor fixed income and reduce growth
            this.scaleAllocation(adjusted, 'EQUITIES', 0.9);
            this.scaleAllocation(adjusted, 'ETF', 1.1);
        }
        // Normalize to sum to 1.0
        return this.normalizeAllocations(adjusted);
    }
    /**
     * Scale allocation for a specific asset class
     */
    scaleAllocation(allocations, assetClass, scaleFactor) {
        const current = allocations.get(assetClass) || 0;
        allocations.set(assetClass, current * scaleFactor);
    }
    /**
     * Normalize allocations to sum to 1.0
     */
    normalizeAllocations(allocations) {
        const total = Array.from(allocations.values()).reduce((sum, val) => sum + val, 0);
        if (total === 0) {
            // Equal weight if all zeros
            const assetCount = allocations.size;
            allocations.forEach((_, key) => allocations.set(key, 1 / assetCount));
            return allocations;
        }
        const normalized = new Map();
        allocations.forEach((value, key) => {
            normalized.set(key, value / total);
        });
        return normalized;
    }
    /**
     * Apply user constraints and preferences
     */
    applyConstraints(allocations, preferences, constraints, characteristics) {
        const constrained = new Map(allocations);
        // Apply exclusions
        if (preferences?.excludedAssetClasses) {
            preferences.excludedAssetClasses.forEach(asset => {
                constrained.set(asset, 0);
            });
        }
        // Apply preferred asset classes
        if (preferences?.preferredAssetClasses && preferences.preferredAssetClasses.length > 0) {
            // Zero out non-preferred assets
            constrained.forEach((_, asset) => {
                if (!preferences.preferredAssetClasses.includes(asset)) {
                    constrained.set(asset, 0);
                }
            });
        }
        // Apply min/max per class
        if (preferences?.minAllocationPerClass !== undefined) {
            constrained.forEach((value, asset) => {
                if (value > 0 && value < preferences.minAllocationPerClass) {
                    constrained.set(asset, preferences.minAllocationPerClass);
                }
            });
        }
        if (preferences?.maxAllocationPerClass !== undefined) {
            constrained.forEach((value, asset) => {
                if (value > preferences.maxAllocationPerClass) {
                    constrained.set(asset, preferences.maxAllocationPerClass);
                }
            });
        }
        // Apply specific constraints
        if (constraints) {
            constraints.forEach(constraint => {
                if (constraint.assetClass) {
                    const current = constrained.get(constraint.assetClass) || 0;
                    switch (constraint.type) {
                        case 'MIN_ALLOCATION':
                            if (current < constraint.value && constraint.hard) {
                                constrained.set(constraint.assetClass, constraint.value);
                            }
                            break;
                        case 'MAX_ALLOCATION':
                            if (current > constraint.value) {
                                constrained.set(constraint.assetClass, constraint.value);
                            }
                            break;
                    }
                }
            });
        }
        // Re-normalize after constraint application
        return this.normalizeAllocations(constrained);
    }
    /**
     * Optimize allocations using specified objective
     */
    optimizeAllocations(allocations, characteristics, accountSize, riskProfile) {
        const charMap = new Map(characteristics.map(c => [c.assetClass, c]));
        switch (this.config.objective) {
            case 'MAX_SHARPE':
                return this.maximizeSharpeRatio(allocations, charMap);
            case 'MIN_RISK':
                return this.minimizeRisk(allocations, charMap);
            case 'MAX_RETURN':
                return this.maximizeReturn(allocations, charMap, riskProfile);
            case 'RISK_PARITY':
                return this.riskParityAllocation(allocations, charMap);
            case 'MAX_DIVERSIFICATION':
                return this.maximizeDiversification(allocations, charMap);
            default:
                return allocations;
        }
    }
    /**
     * Maximize Sharpe ratio allocation
     */
    maximizeSharpeRatio(allocations, characteristics) {
        const optimized = new Map();
        // Calculate excess returns (return - risk-free rate)
        const excessReturns = new Map();
        allocations.forEach((_, asset) => {
            const char = characteristics.get(asset);
            if (char) {
                const excessReturn = char.expectedReturn - this.config.riskFreeRate * 100;
                excessReturns.set(asset, excessReturn);
            }
        });
        // Weight by Sharpe ratio (simplified)
        let totalSharpe = 0;
        const sharpeRatios = new Map();
        allocations.forEach((_, asset) => {
            const char = characteristics.get(asset);
            if (char && char.volatility > 0) {
                const sharpe = (excessReturns.get(asset) || 0) / char.volatility;
                sharpeRatios.set(asset, Math.max(0, sharpe)); // Only positive sharpe
                totalSharpe += Math.max(0, sharpe);
            }
        });
        // Allocate proportional to Sharpe ratio
        if (totalSharpe > 0) {
            sharpeRatios.forEach((sharpe, asset) => {
                optimized.set(asset, sharpe / totalSharpe);
            });
        }
        else {
            // Fall back to equal weight
            const count = allocations.size;
            allocations.forEach((_, asset) => {
                optimized.set(asset, 1 / count);
            });
        }
        // Blend with original allocations (50/50 blend)
        const blended = new Map();
        allocations.forEach((originalWeight, asset) => {
            const optimizedWeight = optimized.get(asset) || 0;
            blended.set(asset, 0.5 * originalWeight + 0.5 * optimizedWeight);
        });
        return this.normalizeAllocations(blended);
    }
    /**
     * Minimize portfolio risk
     */
    minimizeRisk(allocations, characteristics) {
        const optimized = new Map();
        // Weight inversely to volatility
        let totalInvVol = 0;
        const invVolatilities = new Map();
        allocations.forEach((_, asset) => {
            const char = characteristics.get(asset);
            if (char && char.volatility > 0) {
                const invVol = 1 / char.volatility;
                invVolatilities.set(asset, invVol);
                totalInvVol += invVol;
            }
        });
        // Allocate proportional to inverse volatility
        if (totalInvVol > 0) {
            invVolatilities.forEach((invVol, asset) => {
                optimized.set(asset, invVol / totalInvVol);
            });
        }
        else {
            const count = allocations.size;
            allocations.forEach((_, asset) => {
                optimized.set(asset, 1 / count);
            });
        }
        // Blend with original
        const blended = new Map();
        allocations.forEach((originalWeight, asset) => {
            const optimizedWeight = optimized.get(asset) || 0;
            blended.set(asset, 0.6 * optimizedWeight + 0.4 * originalWeight);
        });
        return this.normalizeAllocations(blended);
    }
    /**
     * Maximize expected return
     */
    maximizeReturn(allocations, characteristics, riskProfile) {
        const profile = this.defaultRiskProfiles.get(riskProfile);
        if (!profile)
            return allocations;
        const optimized = new Map();
        // Weight by expected return, but cap by volatility constraint
        let totalAdjustedReturn = 0;
        const adjustedReturns = new Map();
        allocations.forEach((_, asset) => {
            const char = characteristics.get(asset);
            if (char) {
                // Penalize high volatility assets
                const volatilityPenalty = char.volatility > profile.maxVolatility
                    ? 0.5
                    : 1.0;
                const adjustedReturn = char.expectedReturn * volatilityPenalty;
                adjustedReturns.set(asset, Math.max(0, adjustedReturn));
                totalAdjustedReturn += Math.max(0, adjustedReturn);
            }
        });
        // Allocate proportional to adjusted returns
        if (totalAdjustedReturn > 0) {
            adjustedReturns.forEach((adjReturn, asset) => {
                optimized.set(asset, adjReturn / totalAdjustedReturn);
            });
        }
        else {
            const count = allocations.size;
            allocations.forEach((_, asset) => {
                optimized.set(asset, 1 / count);
            });
        }
        // Blend with original
        const blended = new Map();
        allocations.forEach((originalWeight, asset) => {
            const optimizedWeight = optimized.get(asset) || 0;
            blended.set(asset, 0.5 * optimizedWeight + 0.5 * originalWeight);
        });
        return this.normalizeAllocations(blended);
    }
    /**
     * Risk parity allocation (equal risk contribution)
     */
    riskParityAllocation(allocations, characteristics) {
        // Simplified risk parity: weight inversely to volatility
        return this.minimizeRisk(allocations, characteristics);
    }
    /**
     * Maximize diversification
     */
    maximizeDiversification(allocations, characteristics) {
        const optimized = new Map();
        // Calculate average correlation for each asset
        const avgCorrelations = new Map();
        allocations.forEach((_, asset) => {
            const char = characteristics.get(asset);
            if (char && char.correlations) {
                let sumCorr = 0;
                let count = 0;
                char.correlations.forEach((corr, _) => {
                    sumCorr += Math.abs(corr);
                    count++;
                });
                const avgCorr = count > 0 ? sumCorr / count : 0.5;
                avgCorrelations.set(asset, avgCorr);
            }
        });
        // Weight inversely to average correlation
        let totalInvCorr = 0;
        const invCorrelations = new Map();
        avgCorrelations.forEach((avgCorr, asset) => {
            const invCorr = 1 / (0.1 + avgCorr); // Add small constant to avoid division by zero
            invCorrelations.set(asset, invCorr);
            totalInvCorr += invCorr;
        });
        // Allocate proportional to inverse correlation
        if (totalInvCorr > 0) {
            invCorrelations.forEach((invCorr, asset) => {
                optimized.set(asset, invCorr / totalInvCorr);
            });
        }
        else {
            const count = allocations.size;
            allocations.forEach((_, asset) => {
                optimized.set(asset, 1 / count);
            });
        }
        // Blend with original
        const blended = new Map();
        allocations.forEach((originalWeight, asset) => {
            const optimizedWeight = optimized.get(asset) || 0;
            blended.set(asset, 0.5 * optimizedWeight + 0.5 * originalWeight);
        });
        return this.normalizeAllocations(blended);
    }
    /**
     * Calculate comprehensive portfolio metrics
     */
    calculatePortfolioMetrics(allocations, characteristics) {
        const charMap = new Map(characteristics.map(c => [c.assetClass, c]));
        let expectedReturn = 0;
        let portfolioVariance = 0;
        // Calculate expected return
        allocations.forEach((weight, asset) => {
            const char = charMap.get(asset);
            if (char) {
                expectedReturn += weight * char.expectedReturn;
            }
        });
        // Calculate portfolio variance (simplified - assumes correlations)
        const assetList = Array.from(allocations.keys());
        for (let i = 0; i < assetList.length; i++) {
            for (let j = 0; j < assetList.length; j++) {
                const asset1 = assetList[i];
                const asset2 = assetList[j];
                const w1 = allocations.get(asset1) || 0;
                const w2 = allocations.get(asset2) || 0;
                const char1 = charMap.get(asset1);
                const char2 = charMap.get(asset2);
                if (char1 && char2) {
                    const vol1 = char1.volatility / 100; // Convert from percentage
                    const vol2 = char2.volatility / 100;
                    let correlation = 1.0;
                    if (i !== j) {
                        correlation = char1.correlations?.get(asset2) ?? 0.3; // Default correlation
                    }
                    portfolioVariance += w1 * w2 * vol1 * vol2 * correlation;
                }
            }
        }
        const expectedVolatility = Math.sqrt(portfolioVariance) * 100; // Convert to percentage
        // Calculate Sharpe ratio
        const excessReturn = expectedReturn - this.config.riskFreeRate * 100;
        const sharpeRatio = expectedVolatility > 0 ? excessReturn / expectedVolatility : 0;
        // Calculate Sortino ratio (simplified - using volatility as proxy)
        const downsideDeviation = expectedVolatility * 0.7; // Rough approximation
        const sortinoRatio = downsideDeviation > 0 ? excessReturn / downsideDeviation : 0;
        // Estimate maximum drawdown (rough approximation)
        const maxDrawdown = expectedVolatility * 1.5;
        // VaR and CVaR (parametric approach, 95% confidence)
        const valueAtRisk95 = 1.645 * expectedVolatility;
        const conditionalVaR = 2.063 * expectedVolatility; // 95% CVaR
        // Beta and Alpha (simplified)
        const beta = 1.0; // Assume market beta for now
        const alpha = expectedReturn - (this.config.riskFreeRate * 100 + beta * 6); // Assume 6% market risk premium
        // Information ratio
        const trackingError = expectedVolatility * 0.5;
        const informationRatio = trackingError > 0 ? alpha / trackingError : 0;
        return {
            expectedReturn,
            expectedVolatility,
            sharpeRatio,
            sortinoRatio,
            maxDrawdown,
            valueAtRisk95,
            conditionalVaR,
            beta,
            alpha,
            informationRatio
        };
    }
    /**
     * Perform comprehensive risk analysis
     */
    performRiskAnalysis(allocations, characteristics, riskProfile) {
        const charMap = new Map(characteristics.map(c => [c.assetClass, c]));
        const profile = this.defaultRiskProfiles.get(riskProfile);
        // Calculate portfolio volatility
        let totalVolatility = 0;
        allocations.forEach((weight, asset) => {
            const char = charMap.get(asset);
            if (char) {
                totalVolatility += weight * char.volatility;
            }
        });
        // Risk score (0-100)
        const riskScore = Math.min(100, (totalVolatility / profile.maxVolatility) * 100);
        // Risk level
        let riskLevel;
        if (riskScore < 40)
            riskLevel = 'LOW';
        else if (riskScore < 60)
            riskLevel = 'MEDIUM';
        else if (riskScore < 80)
            riskLevel = 'HIGH';
        else
            riskLevel = 'EXTREME';
        // Systematic vs idiosyncratic risk (simplified)
        const systematicRisk = totalVolatility * 0.7; // 70% systematic
        const idiosyncraticRisk = totalVolatility * 0.3; // 30% idiosyncratic
        // Tail risk (simplified - higher volatility = higher tail risk)
        const tailRisk = totalVolatility * 1.2;
        // Liquidity risk
        let liquidityRisk = 0;
        allocations.forEach((weight, asset) => {
            const char = charMap.get(asset);
            if (char) {
                liquidityRisk += weight * (100 - char.liquidityScore);
            }
        });
        // Concentration risk (HHI)
        let hhi = 0;
        allocations.forEach(weight => {
            hhi += weight * weight;
        });
        const concentrationRisk = hhi * 100;
        // Currency risk (simplified)
        const forexWeight = allocations.get('FOREX') || 0;
        const cryptoWeight = allocations.get('CRYPTO') || 0;
        const currencyRisk = (forexWeight + cryptoWeight) * 50;
        // Risk decomposition by asset class
        const riskDecomposition = new Map();
        let totalRiskContribution = 0;
        allocations.forEach((weight, asset) => {
            const char = charMap.get(asset);
            if (char) {
                const riskContribution = weight * char.volatility;
                riskDecomposition.set(asset, riskContribution);
                totalRiskContribution += riskContribution;
            }
        });
        // Normalize risk contributions
        if (totalRiskContribution > 0) {
            riskDecomposition.forEach((contrib, asset) => {
                riskDecomposition.set(asset, (contrib / totalRiskContribution) * 100);
            });
        }
        return {
            riskScore,
            riskLevel,
            systematicRisk,
            idiosyncraticRisk,
            tailRisk,
            liquidityRisk,
            concentrationRisk,
            currencyRisk,
            riskDecomposition
        };
    }
    /**
     * Calculate diversification metrics
     */
    calculateDiversification(allocations, characteristics) {
        const charMap = new Map(characteristics.map(c => [c.assetClass, c]));
        // Herfindahl-Hirschman Index (concentration measure)
        let hhi = 0;
        allocations.forEach(weight => {
            hhi += weight * weight;
        });
        // Effective number of assets
        const effectiveNumberOfAssets = hhi > 0 ? 1 / hhi : allocations.size;
        // Average correlation
        let sumCorrelations = 0;
        let correlationCount = 0;
        let maxCorr = 0;
        const assetList = Array.from(allocations.keys());
        for (let i = 0; i < assetList.length; i++) {
            for (let j = i + 1; j < assetList.length; j++) {
                const asset1 = assetList[i];
                const asset2 = assetList[j];
                const char1 = charMap.get(asset1);
                if (char1?.correlations) {
                    const corr = Math.abs(char1.correlations.get(asset2) ?? 0.3);
                    sumCorrelations += corr;
                    correlationCount++;
                    maxCorr = Math.max(maxCorr, corr);
                }
            }
        }
        const averageCorrelation = correlationCount > 0 ? sumCorrelations / correlationCount : 0;
        // Diversification ratio (weighted average vol / portfolio vol)
        let weightedAvgVol = 0;
        let portfolioVar = 0;
        allocations.forEach((weight, asset) => {
            const char = charMap.get(asset);
            if (char) {
                weightedAvgVol += weight * char.volatility;
            }
        });
        // Calculate portfolio variance
        for (let i = 0; i < assetList.length; i++) {
            for (let j = 0; j < assetList.length; j++) {
                const asset1 = assetList[i];
                const asset2 = assetList[j];
                const w1 = allocations.get(asset1) || 0;
                const w2 = allocations.get(asset2) || 0;
                const char1 = charMap.get(asset1);
                const char2 = charMap.get(asset2);
                if (char1 && char2) {
                    const vol1 = char1.volatility / 100;
                    const vol2 = char2.volatility / 100;
                    const corr = i === j ? 1.0 : (char1.correlations?.get(asset2) ?? 0.3);
                    portfolioVar += w1 * w2 * vol1 * vol2 * corr;
                }
            }
        }
        const portfolioVol = Math.sqrt(portfolioVar) * 100;
        const diversificationRatio = portfolioVol > 0 ? weightedAvgVol / portfolioVol : 1;
        // Asset class diversity score (based on number of asset classes used)
        const nonZeroAllocations = Array.from(allocations.values()).filter(w => w > 0.01).length;
        const totalAssetClasses = allocations.size;
        const assetClassDiversity = (nonZeroAllocations / totalAssetClasses) * 100;
        // Build correlation matrix
        const correlationMatrix = [];
        for (let i = 0; i < assetList.length; i++) {
            correlationMatrix[i] = [];
            for (let j = 0; j < assetList.length; j++) {
                if (i === j) {
                    correlationMatrix[i][j] = 1.0;
                }
                else {
                    const char1 = charMap.get(assetList[i]);
                    const corr = char1?.correlations?.get(assetList[j]) ?? 0.3;
                    correlationMatrix[i][j] = corr;
                }
            }
        }
        return {
            diversificationRatio,
            herfindahlIndex: hhi,
            effectiveNumberOfAssets,
            averageCorrelation,
            maxPairwiseCorrelation: maxCorr,
            correlationMatrix,
            assetClassDiversity
        };
    }
    /**
     * Generate rebalancing actions
     */
    generateRebalancingActions(currentPositions, targetAllocations, accountSize) {
        const actions = [];
        // Calculate current total value
        let currentTotal = 0;
        currentPositions.forEach(amount => {
            currentTotal += amount;
        });
        // Generate actions for each asset class
        targetAllocations.forEach((targetWeight, asset) => {
            const currentAmount = currentPositions.get(asset) || 0;
            const currentWeight = currentTotal > 0 ? currentAmount / currentTotal : 0;
            const targetAmount = accountSize * targetWeight;
            const drift = Math.abs(currentWeight - targetWeight);
            // Only rebalance if drift exceeds threshold
            if (drift > this.config.rebalancingThreshold / 100) {
                const tradeDelta = targetAmount - currentAmount;
                actions.push({
                    assetClass: asset,
                    currentAllocation: currentWeight,
                    targetAllocation: targetWeight,
                    action: tradeDelta > 0 ? 'BUY' : 'SELL',
                    tradeAmount: Math.abs(tradeDelta),
                    priority: drift > 0.15 ? 1 : drift > 0.10 ? 2 : 3,
                    estimatedCost: Math.abs(tradeDelta) * 0.001, // 0.1% transaction cost
                    reason: `Drift of ${(drift * 100).toFixed(2)}% exceeds threshold`
                });
            }
        });
        // Sort by priority
        actions.sort((a, b) => a.priority - b.priority);
        return actions;
    }
    /**
     * Build detailed asset allocations
     */
    buildAssetAllocations(allocations, accountSize, characteristics, portfolioMetrics, riskProfile) {
        const charMap = new Map(characteristics.map(c => [c.assetClass, c]));
        const assetAllocations = [];
        allocations.forEach((weight, asset) => {
            if (weight > 0.001) { // Only include meaningful allocations
                const char = charMap.get(asset);
                const amount = accountSize * weight;
                // Calculate risk contribution
                const assetVol = char?.volatility || 0;
                const portfolioVol = portfolioMetrics.expectedVolatility;
                const riskContribution = portfolioVol > 0 ? (weight * assetVol) / portfolioVol : 0;
                // Calculate return contribution
                const assetReturn = char?.expectedReturn || 0;
                const returnContribution = weight * assetReturn;
                // Generate rationale
                const rationale = this.generateAllocationRationale(asset, weight, char, riskProfile);
                // Calculate confidence (based on data quality and market conditions)
                const confidence = char ? Math.min(0.95, 0.7 + (char.liquidityScore / 200)) : 0.5;
                assetAllocations.push({
                    assetClass: asset,
                    allocation: weight,
                    amount,
                    riskContribution,
                    returnContribution,
                    rationale,
                    confidence
                });
            }
        });
        // Sort by allocation size
        assetAllocations.sort((a, b) => b.allocation - a.allocation);
        return assetAllocations;
    }
    /**
     * Generate rationale for asset allocation
     */
    generateAllocationRationale(asset, weight, characteristics, riskProfile) {
        if (!characteristics) {
            return `${(weight * 100).toFixed(1)}% allocated to ${asset}`;
        }
        const reasons = [];
        // Add size description
        if (weight > 0.3) {
            reasons.push('Core holding');
        }
        else if (weight > 0.15) {
            reasons.push('Significant position');
        }
        else if (weight > 0.05) {
            reasons.push('Moderate allocation');
        }
        else {
            reasons.push('Tactical allocation');
        }
        // Add characteristic-based reasoning
        if (characteristics.sharpeRatio > 1.5) {
            reasons.push('strong risk-adjusted returns');
        }
        if (characteristics.volatility < 15) {
            reasons.push('low volatility');
        }
        else if (characteristics.volatility > 25) {
            reasons.push('high growth potential');
        }
        if (characteristics.liquidityScore > 80) {
            reasons.push('high liquidity');
        }
        // Add risk profile context
        if (riskProfile === 'CONSERVATIVE' && asset === 'ETF') {
            reasons.push('diversification and stability');
        }
        else if (riskProfile === 'AGGRESSIVE' && asset === 'OPTIONS') {
            reasons.push('leveraged growth opportunities');
        }
        return `${(weight * 100).toFixed(1)}% allocation - ${reasons.join(', ')}`;
    }
    /**
     * Calculate next rebalancing date
     */
    calculateNextRebalancingDate(frequencyDays) {
        const days = frequencyDays || 90; // Default to quarterly
        const nextDate = new Date();
        nextDate.setDate(nextDate.getDate() + days);
        return nextDate;
    }
    /**
     * Get methodology description
     */
    getMethodologyDescription(objective, riskProfile) {
        const descriptions = {
            MAX_SHARPE: 'Sharpe ratio maximization with risk-adjusted return optimization',
            MIN_RISK: 'Minimum variance optimization prioritizing capital preservation',
            MAX_RETURN: 'Return maximization within risk tolerance constraints',
            RISK_PARITY: 'Equal risk contribution across asset classes',
            MAX_DIVERSIFICATION: 'Correlation-based diversification maximization',
            TARGET_RETURN: 'Target return achievement with minimum required risk',
            TARGET_RISK: 'Target risk level with maximum potential return'
        };
        return `${descriptions[objective]} tailored for ${riskProfile} risk profile`;
    }
    /**
     * Generate warnings based on allocation
     */
    generateWarnings(allocations, riskAnalysis, input) {
        const warnings = [];
        // High risk warning
        if (riskAnalysis.riskLevel === 'HIGH' || riskAnalysis.riskLevel === 'EXTREME') {
            warnings.push(`Portfolio risk level is ${riskAnalysis.riskLevel}. Consider reducing exposure to volatile assets.`);
        }
        // Concentration warning
        if (riskAnalysis.concentrationRisk > 40) {
            warnings.push('High concentration detected. Portfolio may benefit from additional diversification.');
        }
        // Liquidity warning
        if (riskAnalysis.liquidityRisk > 30) {
            warnings.push('Some positions may have limited liquidity. Consider exit strategies in advance.');
        }
        // Small account warning
        if (input.accountSize < 5000) {
            warnings.push('Small account size may limit diversification. Consider focusing on ETFs for broader exposure.');
        }
        // High volatility market warning
        if (input.marketConditions.volatilityIndex > 25) {
            warnings.push('Market volatility is elevated. Consider maintaining higher cash reserves.');
        }
        // Crypto allocation warning
        const cryptoAlloc = allocations.get('CRYPTO') || 0;
        if (cryptoAlloc > 0.15) {
            warnings.push('Cryptocurrency allocation exceeds 15%. Be aware of high volatility and regulatory risks.');
        }
        // Options allocation warning
        const optionsAlloc = allocations.get('OPTIONS') || 0;
        if (optionsAlloc > 0.25) {
            warnings.push('Options allocation is significant. Ensure adequate knowledge and risk management.');
        }
        return warnings;
    }
    /**
     * Generate unique recommendation ID
     */
    generateRecommendationId() {
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(2, 9);
        return `alloc_${timestamp}_${random}`;
    }
}
/**
 * Convenience function to generate allocation with default settings
 */
async function generateOptimalAllocation(input, config) {
    const engine = new AssetAllocationEngine(config);
    return engine.generateAllocation(input);
}
/**
 * Convenience function to get default risk profile characteristics
 */
function getDefaultRiskProfile(profile) {
    const engine = new AssetAllocationEngine();
    return engine.defaultRiskProfiles.get(profile);
}

// Export factory functions for easier instantiation
const createAlpacaTradingAPI = (credentials) => {
    return new AlpacaTradingAPI(credentials);
};
const createAlpacaMarketDataAPI = () => {
    return AlpacaMarketDataAPI.getInstance();
};
const adaptic = {
    types: Types,
    backend: {
        fetchAssetOverview: fetchAssetOverview,
        getApolloClient: getSharedApolloClient,
        configureAuth: configureAuth,
        isAuthConfigured: isAuthConfigured,
    },
    alpaca: {
        // New SDK-based client factory (RECOMMENDED)
        createClient: alpaca.createClient,
        createClientFromEnv: alpaca.createClientFromEnv,
        clearClientCache: alpaca.clearClientCache,
        // New SDK-based modules (RECOMMENDED)
        /** @description Smart orders: brackets, OCO, OTO, trailing stops */
        smartOrders: alpaca.smartOrders,
        /** @description Standard order operations */
        orders: alpaca.orders,
        /** @description Position management */
        positions: alpaca.positions,
        /** @description Account information and configuration */
        account: alpaca.account,
        /** @description Real-time and historical quotes */
        quotes: alpaca.quotes,
        /** @description Historical price bars (OHLCV) */
        bars: alpaca.bars,
        /** @description Trade data */
        trades: alpaca.trades,
        /** @description Market news */
        news: alpaca.news,
        /** @description Options trading and data */
        options: alpaca.options,
        /** @description Cryptocurrency trading and data */
        crypto: alpaca.crypto,
        /** @description Real-time WebSocket streams */
        streams: alpaca.streams,
        // =========================================================================
        // DEPRECATED: Legacy API (maintained for backward compatibility)
        // Prefer using the new SDK-based modules above
        // =========================================================================
        /** @deprecated Use new createClient() instead */
        TradingAPI: AlpacaTradingAPI,
        /** @deprecated Use new createClient() instead */
        MarketDataAPI: AlpacaMarketDataAPI,
        /** @deprecated Use new SDK modules instead */
        makeRequest: makeRequest,
        /** @deprecated Use account.getAccountDetails() instead */
        accountDetails: fetchAccountDetails,
        /** @deprecated Use positions.getPositions() instead */
        legacyPositions: fetchAllPositions,
        /** @deprecated Use the new positions module instead */
        position: {
            /** @deprecated Use positions.getPosition() instead */
            fetch: fetchPosition,
            /** @deprecated Use positions.closePosition() instead */
            close: closePosition$1,
            /** @deprecated Use positions.getPositions() instead */
            fetchAll: fetchAllPositions,
            /** @deprecated Use positions.closeAllPositions() instead */
            closeAll: closeAllPositions$1,
            /** @deprecated Use positions.closeAllPositionsAfterHours() instead */
            closeAllAfterHours: closeAllPositionsAfterHours$1,
        },
        /** @deprecated Use account.getPortfolioHistory() instead */
        portfolioHistory: fetchPortfolioHistory,
        /** @deprecated Use account.getAccountConfiguration() instead */
        getConfig: getConfiguration,
        /** @deprecated Use account.updateAccountConfiguration() instead */
        updateConfig: updateConfiguration,
        /** @deprecated Use news.getNews() instead */
        legacyNews: fetchNews$1,
        /** @deprecated Use the new orders module instead */
        legacyOrders: {
            /** @deprecated Use orders.createOrder() instead */
            create: createOrder$1,
            /** @deprecated Use orders.createOrder() with type='limit' instead */
            createLimitOrder: createLimitOrder,
            /** @deprecated Use orders.getOrder() instead */
            get: getOrder$1,
            /** @deprecated Use orders.getOrders() instead */
            getAll: getOrders$1,
            /** @deprecated Use orders.replaceOrder() instead */
            replace: replaceOrder$1,
            /** @deprecated Use orders.cancelOrder() instead */
            cancel: cancelOrder$1,
            /** @deprecated Use orders.cancelAllOrders() instead */
            cancelAll: cancelAllOrders$1,
        },
        /** @deprecated Use SDK asset functions instead */
        asset: {
            get: getAsset,
        },
        /** @deprecated Use quotes.getLatestQuotes() instead */
        quote: {
            getLatest: getLatestQuotes$1,
        },
    },
    av: {
        fetchQuote: fetchQuote,
        fetchTickerNews: fetchTickerNews,
        convertDateToYYYYMMDDTHHMM: convertDateToYYYYMMDDTHHMM,
        convertYYYYMMDDTHHMMSSToDate: convertYYYYMMDDTHHMMSSToDate,
    },
    crypto: {
        fetchBars: fetchBars,
        fetchNews: fetchNews,
        fetchLatestTrades: fetchLatestTrades,
        fetchLatestQuotes: fetchLatestQuotes,
    },
    format: {
        capitalize: capitalize,
        enum: formatEnum,
        currency: formatCurrency,
        number: formatNumber,
        percentage: formatPercentage,
        date: formatDate,
        dateToString: formatDateToString,
        dateTimeForGS: dateTimeForGS,
    },
    metrics: {
        trade: fetchTradeMetrics,
        alphaAndBeta: calculateAlphaAndBeta$1,
        maxDrawdown: calculateMaxDrawdown$1,
        dailyReturns: calculateDailyReturns$1,
        returnsByDate: alignReturnsByDate,
        beta: calculateBetaFromReturns$1,
        infoRatio: calculateInformationRatio$1,
        allpm: fetchPerformanceMetrics,
    },
    polygon: {
        fetchTickerInfo: fetchTickerInfo,
        fetchGroupedDaily: fetchGroupedDaily,
        fetchLastTrade: fetchLastTrade,
        fetchTrades: fetchTrades,
        fetchPrices: fetchPrices,
        analysePolygonPriceData: analysePolygonPriceData,
        formatPriceData: formatPriceData,
        fetchDailyOpenClose: fetchDailyOpenClose,
        getPreviousClose: getPreviousClose$1,
    },
    indices: {
        fetchAggregates: fetchIndicesAggregates,
        fetchPreviousClose: fetchIndicesPreviousClose,
        fetchDailyOpenClose: fetchIndicesDailyOpenClose,
        fetchSnapshot: fetchIndicesSnapshot,
        fetchUniversalSnapshot: fetchUniversalSnapshot,
        formatBarData: formatIndicesBarData,
    },
    price: {
        roundUp: roundStockPrice,
        equityValues: getEquityValues,
        totalFees: computeTotalFees,
    },
    ta: {
        calculateEMA: calculateEMA,
        calculateMACD: calculateMACD,
        calculateRSI: calculateRSI,
        calculateStochasticOscillator: calculateStochasticOscillator,
        calculateBollingerBands: calculateBollingerBands,
        calculateSupportAndResistance: calculateSupportAndResistance,
        calculateFibonacciLevels: calculateFibonacciLevels,
    },
    time: {
        toUnixTimestamp: toUnixTimestamp,
        getTimeAgo: getTimeAgo,
        timeAgo: timeAgo,
        normalizeDate: normalizeDate,
        getDateInNY: getDateInNY,
        createMarketTimeUtil: createMarketTimeUtil,
        getStartAndEndTimestamps: getStartAndEndTimestamps,
        getStartAndEndDates: getStartAndEndDates,
        getMarketOpenClose: getMarketOpenClose,
        calculateTimeRange: calculateTimeRange,
        calculateDaysLeft: calculateDaysLeft,
        formatDate: formatDate /* move to format, keeping here for compatibility  */,
        currentTimeET: currentTimeET,
        MarketTimeUtil: MarketTimeUtil,
        MARKET_TIMES: MARKET_TIMES,
        getLastTradingDateYYYYMMDD: getLastTradingDateYYYYMMDD,
        getLastFullTradingDate: getLastFullTradingDate,
        getNextMarketDay: getNextMarketDay,
        parseETDateFromAV: parseETDateFromAV,
        formatToUSEastern: formatToUSEastern,
        unixTimetoUSEastern: unixTimetoUSEastern,
        getMarketStatus: getMarketStatus,
        timeDiffString: timeDiffString,
        getNYTimeZone: getNYTimeZone,
        getTradingDate: getTradingDate,
    },
    utils: {
        logIfDebug: logIfDebug,
        fetchWithRetry: fetchWithRetry,
        validatePolygonApiKey: validatePolygonApiKey,
    },
};
const adptc = adaptic;

export { AlpacaClient, AlpacaMarketDataAPI, AlpacaTradingAPI, AssetAllocationEngine, BTC_PAIRS, BarError, CryptoDataError, CryptoOrderError, DEFAULT_CACHE_OPTIONS, NewsError, OptionStrategyError, OptionsDataError, QuoteError, StampedeProtectedCache, TradeError, TrailingStopValidationError, USDC_PAIRS, USDT_PAIRS, USD_PAIRS, account, adaptic, adptc, alpaca, analyzeBars, approximateImpliedVolatility, bracketOrders, buildOCCSymbol, buildOptionSymbol, buyCryptoNotional, buyToClose, buyToOpen, buyWithStopLoss, buyWithTrailingStop, calculateMoneyness, calculateOrderValue, calculatePeriodPerformance, calculatePutCallRatio, calculateTotalFilledValue, cancelAllCryptoOrders, cancelOCOOrder, cancelOTOOrder, cancelTrailingStop, cancelTrailingStopsForSymbol, checkTradingEligibility, clearClientCache, closeAllOptionPositions, closeOptionPosition, createAlpacaClient, createAlpacaMarketDataAPI, createAlpacaTradingAPI, createBracketOrder, createButterflySpread, createClientFromEnv, createCoveredCall, createCryptoLimitOrder, createCryptoMarketOrder, createCryptoOrder, createCryptoStopLimitOrder, createCryptoStopOrder, createExecutorFromTradingAPI, createIronCondor$1 as createIronCondor, createIronCondor as createIronCondorAdvanced, createMultiLegOptionOrder, createOCOOrder, createOTOOrder, createOptionOrder, createPortfolioTrailingStops, createProtectiveBracket, createStampedeProtectedCache, createStraddle$1 as createStraddle, createStraddle as createStraddleAdvanced, createStrangle$1 as createStrangle, createStrangle as createStrangleAdvanced, createStreamManager, createTrailingStop, createVerticalSpread$1 as createVerticalSpread, createVerticalSpread as createVerticalSpreadAdvanced, entryWithPercentStopLoss, exerciseOption, extractGreeks, filterByExpiration, filterByStrike, filterByType, filterOrdersByDateRange, findATMOptions, findATMStrikes, findNearestExpiration, findOptionsByDelta, formatOrderForLog, formatOrderSummary, generateOptimalAllocation, getAccountConfiguration, getAccountDetails, getAccountSummary, getAllOrders, getAverageDailyVolume, getBars, getBuyingPower, getCrypto24HourChange, getCryptoBars, getCryptoDailyPrices, getCryptoPairsByQuote, getCryptoPrice, getCryptoSnapshots, getCryptoSpread, getCryptoTrades, getCurrentPrice, getCurrentPrices, getDailyPrices, getDailyReturns, getDaysToExpiration, getDefaultRiskProfile, getEquityCurve, getExpirationDates, getFilledOrders, getGroupedOptionChain, getHistoricalOptionsBars, getHistoricalTrades, getIntradayPrices, getLatestBars, getLatestCryptoQuotes, getLatestCryptoTrades, getLatestNews, getLatestOptionsQuotes, getLatestOptionsTrades, getLatestQuote, getLatestQuotes, getLatestTrade, getLatestTrades, getMarginInfo, getNews, getNewsForSymbols, getOCOOrderStatus, getOTOOrderStatus, getOpenCryptoOrders, getOpenOrders$1 as getOpenOrdersQuery, getOpenTrailingStops, getOptionChain, getOptionContract, getOptionContracts, getOptionSpread, getOptionsChain, getOptionsSnapshots, getOptionsTradingLevel, getOrderHistory, getOrdersBySymbol, getPDTStatus, getPopularCryptoPairs, getPortfolioHistory, getPreviousClose, getPriceRange, getSpread, getSpreads, getStrikePrices, getSupportedCryptoPairs, getSymbolSentiment, getTradeVolume, getTrailingStopHWM, groupOrdersByStatus, groupOrdersBySymbol, hasActiveTrailingStop, hasGoodLiquidity as hasOptionLiquidity, hasGoodLiquidity$1 as hasStockLiquidity, hasSufficientVolume, isContractTradable, isCryptoPair, isExpiringWithin, isMarginAccount, isOptionOrderCancelable, isOptionOrderTerminal, isOrderFillable, isOrderFilled, isOrderOpen, isOrderTerminal$1 as isOrderTerminalStatus, isSupportedCryptoPair, limitBuyWithTakeProfit, ocoOrders, orderUtils, otoOrders, parseOCCSymbol, protectLongPosition, protectShortPosition, rollOptionPosition, roundPriceForAlpaca$3 as roundPriceForAlpaca, roundPriceForAlpacaNumber, searchNews, sellAllCrypto, sellCryptoNotional, sellToClose, sellToOpen, shortWithStopLoss, sortOrdersByDate, trailingStops, updateAccountConfiguration, updateTrailingStop, validateMultiLegOrder, waitForOrderFill };
//# sourceMappingURL=index.mjs.map
